Basic resolution 1
Simplest possible resolution
CODE
====

type t
type u = t
    
BEFORE
======
type (root Root).t
type (root Root).u = resolved[global((root Root).t)]

AFTER 
===== 
type (root Root).t
type (root Root).u = resolved[global((root Root).t)]

Basic resolution 2
Environment lookup
CODE
====

module M : sig
    type t
end
type u = M.t
    
BEFORE
======
module (root Root).M : sig
  type (root Root).M.t
  end
type (root Root).u = resolved[global((root Root).M)].t

AFTER 
===== 
module (root Root).M : sig
  type (root Root).M.t
  end
type (root Root).u = resolved[global((root Root).M).t]

Basic resolution 3
Module type
CODE
====

module type M = sig
    type t
end
module N : M
type u = N.t
    
BEFORE
======
module type (root Root).M = sig
  type (root Root).M.t
  end
module (root Root).N : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).N)].t

AFTER 
===== 
module type (root Root).M = sig
  type (root Root).M.t
  end
module (root Root).N : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).N).t]

Basic resolution 4
Module type
CODE
====

module type M = sig
    module N : sig
        type t
    end
end
module A : M
type u = A.N.t
    
BEFORE
======
module type (root Root).M = sig
  module (root Root).M.N : sig
    type (root Root).M.N.t
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].N.t

AFTER 
===== 
module type (root Root).M = sig
  module (root Root).M.N : sig
    type (root Root).M.N.t
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A).N.t]

Basic resolution 4
Module type
CODE
====

module type M = sig
    module type N = sig
        type t
    end
    module B : N
end
module A : M
type u = A.B.t
    
BEFORE
======
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.B : resolved[global((root Root).M.N)]
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].B.t

AFTER 
===== 
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.B : resolved[global((root Root).M.N)]
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A).B.t]

Basic resolution 4
Module type
CODE
====

module type M = sig
    module type N = sig
        type t
    end
    module X : sig
        module B : N
    end
end
module A : M
type u = A.X.B.t
    
BEFORE
======
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.X : sig
    module (root Root).M.X.B : resolved[global((root Root).M.N)]
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].X.B.t

AFTER 
===== 
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.X : sig
    module (root Root).M.X.B : resolved[global((root Root).M.N)]
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A).X.B.t]

Module substitution
Ensure a substitution is taken into account during resolution
CODE
====

module type A = sig
module M : sig module type S end
module N : M.S
end

module B : sig module type S = sig type t end end

module C : A with module M = B

type t = C.N.t
    
BEFORE
======
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M)].S
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [*.M = = resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C)].N.t

AFTER 
===== 
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[opaquemoduletype(global((root Root).A.M).S)]
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [root_module_type(global((root Root).A)).M = = resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C).N.t]

Module substitution2
Ensure a destructive substitution is taken into account during resolution
CODE
====

module type A = sig
module M : sig module type S end
module N : M.S
end

module B : sig module type S = sig type t end end

module C : A with module M := B

type t = C.N.t
    
BEFORE
======
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M)].S
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [*.M := resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C)].N.t

AFTER 
===== 
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[opaquemoduletype(global((root Root).A.M).S)]
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [root_module_type(global((root Root).A)).M := resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C).N.t]

Module alias
Resolve a module alias
CODE
====

module A : sig
    type t
end
module B = A
type t = B.t

BEFORE
======
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
type (root Root).t = resolved[global((root Root).B)].t

AFTER 
===== 
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
type (root Root).t = resolved[(global((root Root).A) -> global((root Root).B)).t]

Module alias
Resolve a module alias
CODE
====

module A : sig
    type t
end
module B = A
module C = B
type t = C.t

BEFORE
======
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
module (root Root).C = resolved[global((root Root).B)]
type (root Root).t = resolved[global((root Root).C)].t

AFTER 
===== 
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
module (root Root).C = resolved[(global((root Root).A) -> global((root Root).B))]
type (root Root).t = resolved[((global((root Root).A) -> global((root Root).B)) -> global((root Root).C)).t]

Functor
Resolve a functor
CODE
====

module type S = sig
  type t
end

module F ( X : S ) ( Y : S ) : sig
  type x_t = X.t
  type y_t = Y.t
  type f_t = x_t
end

BEFORE
======
module type (root Root).S = sig
  type (root Root).S.t
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).S)]) -> ((param (root Root).F.result Y) : resolved[global((root Root).S)]) -> sig
  type (root Root).F.result.result.x_t = resolved[global((param (root Root).F X))].t
  type (root Root).F.result.result.y_t = resolved[global((param (root Root).F.result Y))].t
  type (root Root).F.result.result.f_t = resolved[global((root Root).F.result.result.x_t)]
  end

AFTER 
===== 
module type (root Root).S = sig
  type (root Root).S.t
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).S)]) -> ((param (root Root).F.result Y) : resolved[global((root Root).S)]) -> sig
  type (root Root).F.result.result.x_t = resolved[global((param (root Root).F X)).t]
  type (root Root).F.result.result.y_t = resolved[global((param (root Root).F.result Y)).t]
  type (root Root).F.result.result.f_t = resolved[global((root Root).F.result.result.x_t)]
  end

Functor
Resolve a functor
CODE
====

module type S =
sig
  type t
end

module type S1 = functor (_ : S) -> S

module F1 : functor (Arg : S) -> S

module F2 : functor (Arg : S) -> (S with type t = Arg.t)

module F3 : functor (Arg : S) ->
sig
  type t = Arg.t
end

module F4 (Arg : S) : S

module F5 (Arg1 : S) (Arg2 : S) (Arg3 : S) : sig
        type t = Arg1.t
        type u = Arg2.t
        type v = Arg3.t
        type z = t
end

module F6 : S1

module type F7 = functor (Arg : S) -> sig
  type t = Arg.t
  type u = t
end
BEFORE
======
module type (root Root).S = sig
  type (root Root).S.t
  end
module type (root Root).S1 = ((param (root Root).S1 _) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F1 : ((param (root Root).F1 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F2 : ((param (root Root).F2 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)] with [*.t = resolved[global((param (root Root).F2 Arg))].t]
module (root Root).F3 : ((param (root Root).F3 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F3.result.t = resolved[global((param (root Root).F3 Arg))].t
  end
module (root Root).F4 : ((param (root Root).F4 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F5 : ((param (root Root).F5 Arg1) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result Arg2) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result.result Arg3) : resolved[global((root Root).S)]) -> sig
  type (root Root).F5.result.result.result.t = resolved[global((param (root Root).F5 Arg1))].t
  type (root Root).F5.result.result.result.u = resolved[global((param (root Root).F5.result Arg2))].t
  type (root Root).F5.result.result.result.v = resolved[global((param (root Root).F5.result.result Arg3))].t
  type (root Root).F5.result.result.result.z = resolved[global((root Root).F5.result.result.result.t)]
  end
module (root Root).F6 : resolved[global((root Root).S1)]
module type (root Root).F7 = ((param (root Root).F7 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F7.result.t = resolved[global((param (root Root).F7 Arg))].t
  type (root Root).F7.result.u = resolved[global((root Root).F7.result.t)]
  end

AFTER 
===== 
module type (root Root).S = sig
  type (root Root).S.t
  end
module type (root Root).S1 = ((param (root Root).S1 _) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F1 : ((param (root Root).F1 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F2 : ((param (root Root).F2 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)] with [root_module_type(global((root Root).S)).t = resolved[global((param (root Root).F2 Arg)).t]]
module (root Root).F3 : ((param (root Root).F3 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F3.result.t = resolved[global((param (root Root).F3 Arg)).t]
  end
module (root Root).F4 : ((param (root Root).F4 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F5 : ((param (root Root).F5 Arg1) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result Arg2) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result.result Arg3) : resolved[global((root Root).S)]) -> sig
  type (root Root).F5.result.result.result.t = resolved[global((param (root Root).F5 Arg1)).t]
  type (root Root).F5.result.result.result.u = resolved[global((param (root Root).F5.result Arg2)).t]
  type (root Root).F5.result.result.result.v = resolved[global((param (root Root).F5.result.result Arg3)).t]
  type (root Root).F5.result.result.result.z = resolved[global((root Root).F5.result.result.result.t)]
  end
module (root Root).F6 : resolved[global((root Root).S1)]
module type (root Root).F7 = ((param (root Root).F7 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F7.result.t = resolved[global((param (root Root).F7 Arg)).t]
  type (root Root).F7.result.u = resolved[global((root Root).F7.result.t)]
  end

