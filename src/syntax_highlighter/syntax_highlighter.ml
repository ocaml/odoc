type token = Parser.token

let tag_of_token (tok : Parser.token) =
  match tok with
  | Parser.WITH -> "WITH"
  | Parser.WHILE -> "WHILE"
  | Parser.WHEN -> "WHEN"
  | Parser.VIRTUAL -> "VIRTUAL"
  | Parser.VAL -> "VAL"
  | Parser.UNDERSCORE -> "UNDERSCORE"
  | Parser.UIDENT i -> "UIDENT." ^ i
  | Parser.TYPE -> "TYPE"
  | Parser.TRY -> "TRY"
  | Parser.TRUE -> "TRUE"
  | Parser.TO -> "TO"
  | Parser.TILDE -> "TILDE"
  | Parser.THEN -> "THEN"
  | Parser.STRUCT -> "STRUCT"
  | Parser.STRING _ -> "STRING"
  | Parser.STAR -> "STAR"
  | Parser.SIG -> "SIG"
  | Parser.SEMISEMI -> "SEMISEMI"
  | Parser.SEMI -> "SEMI"
  | Parser.RPAREN -> "RPAREN"
  | Parser.REC -> "REC"
  | Parser.RBRACKET -> "RBRACKET"
  | Parser.RBRACE -> "RBRACE"
  | Parser.QUOTED_STRING_ITEM _ -> "QUOTED_STRING_ITEM"
  | Parser.QUOTED_STRING_EXPR _ -> "QUOTED_STRING_EXPR"
  | Parser.QUOTE -> "QUOTE"
  | Parser.QUESTION -> "QUESTION"
  | Parser.PRIVATE -> "PRIVATE"
  | Parser.PREFIXOP _ -> "PREFIXOP"
  | Parser.PLUSEQ -> "PLUSEQ"
  | Parser.PLUSDOT -> "PLUSDOT"
  | Parser.PLUS -> "PLUS"
  | Parser.PERCENT -> "PERCENT"
  | Parser.OR -> "OR"
  | Parser.OPTLABEL _ -> "OPTLABEL"
  | Parser.OPEN -> "OPEN"
  | Parser.OF -> "OF"
  | Parser.OBJECT -> "OBJECT"
  | Parser.NONREC -> "NONREC"
  | Parser.NEW -> "NEW"
  | Parser.MUTABLE -> "MUTABLE"
  | Parser.MODULE -> "MODULE"
  | Parser.MINUSGREATER -> "MINUSGREATER"
  | Parser.MINUSDOT -> "MINUSDOT"
  | Parser.MINUS -> "MINUS"
  | Parser.METHOD -> "METHOD"
  | Parser.MATCH -> "MATCH"
  | Parser.LPAREN -> "LPAREN"
  | Parser.LIDENT s -> "LIDENT" ^ s
  | Parser.LETOP _ -> "LETOP"
  | Parser.LET -> "LET"
  | Parser.LESSMINUS -> "LESSMINUS"
  | Parser.LESS -> "LESS"
  | Parser.LBRACKETPERCENTPERCENT -> "LBRACKETPERCENTPERCENT"
  | Parser.LBRACKETPERCENT -> "LBRACKETPERCENT"
  | Parser.LBRACKETLESS -> "LBRACKETLESS"
  | Parser.LBRACKETGREATER -> "LBRACKETGREATER"
  | Parser.LBRACKETBAR -> "LBRACKETBAR"
  | Parser.LBRACKETATATAT -> "LBRACKETATATAT"
  | Parser.LBRACKETATAT -> "LBRACKETATAT"
  | Parser.LBRACKETAT -> "LBRACKETAT"
  | Parser.LBRACKET -> "LBRACKET"
  | Parser.LBRACELESS -> "LBRACELESS"
  | Parser.LBRACE -> "LBRACE"
  | Parser.LAZY -> "LAZY"
  | Parser.LABEL s -> "LABEL" ^ s
  | Parser.INT _ -> "INT"
  | Parser.INITIALIZER -> "INITIALIZER"
  | Parser.INHERIT -> "INHERIT"
  | Parser.INFIXOP4 _ -> "INFIXOP4"
  | Parser.INFIXOP3 _ -> "INFIXOP3"
  | Parser.INFIXOP2 _ -> "INFIXOP2"
  | Parser.INFIXOP1 _ -> "INFIXOP1"
  | Parser.INFIXOP0 _ -> "INFIXOP0"
  | Parser.INCLUDE -> "INCLUDE"
  | Parser.IN -> "IN"
  | Parser.IF -> "IF"
  | Parser.HASHOP _ -> "HASHOP"
  | Parser.HASH -> "HASH"
  | Parser.GREATERRBRACKET -> "GREATERRBRACKET"
  | Parser.GREATERRBRACE -> "GREATERRBRACE"
  | Parser.GREATER -> "GREATER"
  | Parser.FUNCTOR -> "FUNCTOR"
  | Parser.FUNCTION -> "FUNCTION"
  | Parser.FUN -> "FUN"
  | Parser.FOR -> "FOR"
  | Parser.FLOAT _ -> "FLOAT"
  | Parser.FALSE -> "FALSE"
  | Parser.EXTERNAL -> "EXTERNAL"
  | Parser.EXCEPTION -> "EXCEPTION"
  | Parser.EQUAL -> "EQUAL"
  | Parser.EOL -> "EOL"
  | Parser.EOF -> "EOF"
  | Parser.END -> "END"
  | Parser.ELSE -> "ELSE"
  | Parser.DOWNTO -> "DOWNTO"
  | Parser.DOTOP _ -> "DOTOP"
  | Parser.DOTDOT -> "DOTDOT"
  | Parser.DOT -> "DOT"
  | Parser.DONE -> "DONE"
  | Parser.DOCSTRING _ -> "DOCSTRING"
  | Parser.DO -> "DO"
  | Parser.CONSTRAINT -> "CONSTRAINT"
  | Parser.COMMENT _ -> "COMMENT"
  | Parser.COMMA -> "COMMA"
  | Parser.COLONGREATER -> "COLONGREATER"
  | Parser.COLONEQUAL -> "COLONEQUAL"
  | Parser.COLONCOLON -> "COLONCOLON"
  | Parser.COLON -> "COLON"
  | Parser.CLASS -> "CLASS"
  | Parser.CHAR _ -> "CHAR"
  | Parser.BEGIN -> "BEGIN"
  | Parser.BARRBRACKET -> "BARRBRACKET"
  | Parser.BARBAR -> "BARBAR"
  | Parser.BAR -> "BAR"
  | Parser.BANG -> "BANG"
  | Parser.BACKQUOTE -> "BACKQUOTE"
  | Parser.ASSERT -> "ASSERT"
  | Parser.AS -> "AS"
  | Parser.ANDOP _ -> "ANDOP"
  | Parser.AND -> "AND"
  | Parser.AMPERSAND -> "AMPERSAND"
  | Parser.AMPERAMPER -> "AMPERAMPER"

let syntax_highlighting_locs src =
  let lexbuf = Lexing.from_string ~with_positions:true src in
  let rec collect lexbuf =
    let tok = Lexer.token_with_comments lexbuf in
    let loc_start, loc_end = (lexbuf.lex_start_p, lexbuf.lex_curr_p) in
    match tok with
    | Parser.EOF -> []
    | Parser.COMMENT (_, loc) as tok ->
        (tok, (loc.loc_start.pos_cnum, loc.loc_end.pos_cnum)) :: collect lexbuf
    | tok -> (tok, (loc_start.pos_cnum, loc_end.pos_cnum)) :: collect lexbuf
  in
  collect lexbuf
