<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>good-practices (ppxlib.good-practices)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html"><code>ppxlib</code>'s user manual</a> &#x00BB; Good Practices</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><p> <div style="display: flex; justify-content:space-between"><div><a href="ast-traversal.html" title="ast-traversal">&lt; Traversing the AST</a> </div><div><a href="examples.html" title="examples">Examples &gt;</a> </div></div></p><h1 id="good-practices"><a href="#good-practices" class="anchor"></a>Good Practices</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#resp_loc">Respecting Locations</a><ul><li><a href="#the-invariants">The Invariants</a></li><li><a href="#guidelines-for-writing-well-behaved-ppxs">Guidelines for Writing Well-Behaved PPXs</a></li></ul></li><li><a href="#handling_errors">Handling Errors</a><ul><li><a href="#embedding-the-errors-in-the-ast">Embedding the Errors in the AST</a></li><li><a href="#a-documented-example">A Documented Example</a></li></ul></li><li><a href="#quoting">Quoting</a></li><li><a href="#testing-your-ppx">Testing Your PPX</a></li><li><a href="#migrate-from-other-preprocessing-systems">Migrate From Other Preprocessing Systems</a></li><li><a href="#other-good-practices">Other good practices</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html"><code>ppxlib</code>'s user manual</a><ul><li><a href="ast-traversal.html">AST Traversals</a></li><li><a href="driver.html">How It Works</a></li><li><a href="examples.html">Examples</a></li><li><a href="generating-code.html">Generating AST Nodes</a></li><li><a href="#" class="current_unit">Good Practices</a></li><li><a href="matching-code.html">Destructing AST Nodes</a></li><li><a href="quick_intro.html">Introduction</a></li><li><a href="writing-ppxs.html">Writing a Transformation</a></li><li>Library <code>ppxlib</code><ul><li><a href="ppxlib/Ppxlib/index.html">Ppxlib</a></li></ul></li><li>Library <code>ppxlib.ast</code><ul><li><a href="ppxlib.ast/Ppxlib_ast/index.html">Ppxlib_ast</a></li></ul></li><li>Library <code>ppxlib.astlib</code><ul><li><a href="ppxlib.astlib/Astlib/index.html">Astlib</a></li></ul></li><li>Library <code>ppxlib.metaquot</code><ul><li><a href="ppxlib.metaquot/Ppxlib_metaquot/index.html">Ppxlib_metaquot</a></li></ul></li><li>Library <code>ppxlib.metaquot_lifters</code><ul><li><a href="ppxlib.metaquot_lifters/Ppxlib_metaquot_lifters/index.html">Ppxlib_metaquot_lifters</a></li></ul></li><li>Library <code>ppxlib.print_diff</code><ul><li><a href="ppxlib.print_diff/Ppxlib_print_diff/index.html">Ppxlib_print_diff</a></li></ul></li><li>Library <code>ppxlib.runner</code><ul><li><a href="ppxlib.runner/Ppxlib_runner/index.html">Ppxlib_runner</a></li></ul></li><li>Library <code>ppxlib.runner_as_ppx</code><ul><li><a href="ppxlib.runner_as_ppx/Ppxlib_runner_as_ppx/index.html">Ppxlib_runner_as_ppx</a></li></ul></li><li>Library <code>ppxlib.stdppx</code><ul><li><a href="ppxlib.stdppx/Stdppx/index.html">Stdppx</a></li></ul></li><li>Library <code>ppxlib.traverse</code><ul><li><a href="ppxlib.traverse/Ppxlib_traverse/index.html">Ppxlib_traverse</a></li></ul></li><li>Library <code>ppxlib.traverse_builtins</code><ul><li><a href="ppxlib.traverse_builtins/Ppxlib_traverse_builtins/index.html">Ppxlib_traverse_builtins</a></li></ul></li><li><a href="src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="resp_loc"><a href="#resp_loc" class="anchor"></a>Respecting Locations</h2><p>Correctly dealing with location is essential to correctly generate OCaml code. They are necessary for error reporting by the compiler, but more generally for Merlin's features to work, such as displaying occurrences and jumping to definition. When called, the driver is called with the <code>-check</code> and <code>-check-locations</code> flags, <code>ppxlib</code> makes it is a requirement that locations follow some rules in order to accept the rewriting, as it will check that some invariants are respected.</p><h3 id="the-invariants"><a href="#the-invariants" class="anchor"></a>The Invariants</h3><p>The invariants are as follows:</p><ul><li>AST nodes are requested to be well-nested WRT locations</li><li>the locations of &quot;sibling&quot; AST nodes should not overlap</li></ul><p>This is required for Merlin to behave properly.</p><p>Indeed, for almost any query directed at Merlin, it will need to inspect the context around the user's cursor to give an answer that makes sense. And the only input it has to do that is the cursor‚Äôs position in the buffer. The handling of most queries starts by traversing the AST, using the locations of nodes to select the right branch. (1) is necessary to avoid discarding subtrees too early, (2) is used to avoid Merlin making arbitrary choices (if you ask for the type under the cursor, and there seems to be two things under the cursor, Merlin will need to pick one).</p><h3 id="guidelines-for-writing-well-behaved-ppxs"><a href="#guidelines-for-writing-well-behaved-ppxs" class="anchor"></a>Guidelines for Writing Well-Behaved PPXs</h3><p>It's obviously not always (indeed rarely) possible to mint new locations when manipulating the AST.</p><p>The intended way to deal with locations is this:</p><ul><li>AST nodes that exist in the source should keep their original location</li><li>new nodes should be given a &quot;ghost&quot; location (i.e., <code>{ some_loc with loc_ghost = true }</code>) to indicate that the node doesn't exist in the sources.</li></ul><p>In particular, <a href="ppxlib/Ppxlib/Location/index.html#val-none" title="Ppxlib.Location.none"><code>Location.none</code></a> is never meant to be used by PPX authors, where some location is always available (for instance, derivers and extenders at least know the locations of their relevant node).</p><p>Both the new check and Merlin will happily traverse the ghost nodes as if they didn't exist. Note: this comes into play when deciding which nodes are &quot;siblings,&quot; for instance, if your AST is:</p><pre>  A (B1(C, D),
     B2(X, Y))</pre><p>but <code>B2</code> has a ghost location, then <code>B1</code>, <code>X</code> and <code>Y</code> are considered siblings.</p><p>Additionally, there is an attribute <code>[@merlin.hide]</code> that you can add on nodes to tell Merlin (and the check) to ignore this node and all of its children. Some helpers for this are provided in <a href="ppxlib/Ppxlib/Merlin_helpers/index.html" title="Ppxlib.Merlin_helpers"><code>Merlin_helpers</code></a>.</p><h2 id="handling_errors"><a href="#handling_errors" class="anchor"></a>Handling Errors</h2><p>In order to give a nice user experience when using a PPX, it is necessary that the resulting parsetree is as complete as possible. Most IDE tools, such as Merlin, rely on the AST for their features, such as displaying type, jumping to definition, or showing the list of errors.</p><p>In order to achieve this, errors that happen during rewriting should be handled in a way that do not prevent a meaningful AST to be passed to Merlin.</p><p>There are mainly two ways to report errors when writing a PPX.</p><ul><li>By embedding special extensions nodes, called &quot;error nodes&quot;, inside the generated code.</li><li>By raising a sepcific exception, letting the ppxlib driver <a href="driver.html#exception_handling" title="exception_handling">handle the error</a>.</li></ul><p>Let us emphasize that, while exceptions can be practical to quickly fail with an error, the embedding mechanism has many advantages. For instance, embedding allows to report multiple errors, and to output the part of the code that could be generated successfully.</p><h3 id="embedding-the-errors-in-the-ast"><a href="#embedding-the-errors-in-the-ast" class="anchor"></a>Embedding the Errors in the AST</h3><p>It is better to always return a valid AST, as complete as possible, but with &quot;error extension nodes&quot; at every place where successful code generation was impossible. Error extension nodes are special extension nodes <code>[%ocaml.error &quot;error_message&quot;]</code> that can be embedded into a valid AST and are interpreted later as errors, e.g., by the compiler or Merlin. As all extension nodes, they can be put <a href="https://ocaml.org/manual/extensionnodes.html">at many places in the AST</a> to replace structure items, expressions, or patterns, for example.</p><p>So whenever you're in doubt whether to throw an exception or if to embed the error as an error extension node when writing a PPX rewriter, embed the error is the way to go! And whenever you're in doubt about where exactly to embed the error inside the AST, a good ground rule is: as deep in the AST as possible.</p><p>For instance, suppose a rewriter is supposed to define a new record type, but there is an error in one field‚Äôs type generation. In order to have the most complete AST as output, the rewriter can still define the type and all of its fields, putting an extension node in place of the type of the faulty field:</p><pre class="language-ocaml"><code>type long_record = {
  field_1: int;
  field_2: [%ocaml.error &quot;field_2 could not be implemented due to foo&quot;];
}</code></pre><p><code>ppxlib</code> provides a function in its API to create error extension nodes: <a href="ppxlib/Ppxlib/Location/index.html#val-error_extensionf" title="Ppxlib.Location.error_extensionf"><code>error_extensionf</code></a>. This function creates an extension node, which then must be transformed in the right kind of node using functions such as <a href="ppxlib/Ppxlib/Ast_builder/Default/index.html#val-pexp_extension" title="Ppxlib.Ast_builder.Default.pexp_extension"><code>pexp_extension</code></a>.</p><h3 id="a-documented-example"><a href="#a-documented-example" class="anchor"></a>A Documented Example</h3><p>Let us give an example. We will define a deriver on types records, which constructs a default value from a given type. For instance, the derivation on the type <code>type t = { x:int; y: float; z: string}</code> would yield <code>let default_t = {x= 0; y= 0.; z= &quot;&quot;}</code>. This deriver has two limitations:</p><ol><li>It does not work on other types than records,</li><li>It only works for records containing fields of type <code>string</code>, <code>int</code>, or <code>float</code>.</li></ol><p>The rewriter should warn the user about these limitations with a good error reporting. Let‚Äôs first look at the second point. Here is the function mapping the fields from the type definition to a default expression.</p><pre class="language-ocaml"><code>let create_record ~loc fields =
  let declaration_to_instantiation (ld : label_declaration) =
    let loc = ld.pld_loc in
    let { pld_type; pld_name; _ } = ld in
    let e =
      match pld_type with
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;string&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_string (&quot;&quot;, loc, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;int&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_integer (&quot;0&quot;, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;float&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_float (&quot;0.&quot;, None))
      | _ -&gt;
          pexp_extension ~loc
          @@ Location.error_extensionf ~loc
               &quot;Default value can only be derived for int, float, and string.&quot;
    in
    ({ txt = Lident pld_name.txt; loc }, e)
  in
  let l = List.map fields ~f:declaration_to_instantiation in
  pexp_record ~loc l None</code></pre><p>When the record definition contains several fields with types other than <code>int</code>, <code>float</code>, or <code>string</code>, several error nodes are added in the AST. Moreover, the location of the error nodes corresponds to the field record's definition. This allows tools such as Merlin to report all errors at once, at the right location, resulting in a better workflow than having to recompile every time an error is corrected to see the next one.</p><p>The first limitation is that the deriver cannot work on non-record types. However, we decided here to derive a default value, even in the case of non-record types, so that it does not appear as undefined in the remaining of the file. This impossible value consists of an error extension node.</p><pre class="language-ocaml"><code>let generate_impl ~ctxt (_rec_flag, type_declarations) =
  let loc = Expansion_context.Deriver.derived_item_loc ctxt in
  List.map type_declarations ~f:(fun (td : type_declaration) -&gt;
      let e, name =
        match td with
        | { ptype_kind = Ptype_record fields; ptype_name; ptype_loc; _ } -&gt;
            (create_record ~loc:ptype_loc fields, ptype_name)
        | { ptype_name; ptype_loc; _ } -&gt;
            ( pexp_extension ~loc
              @@ Location.error_extensionf ~loc:ptype_loc
                   &quot;Cannot derive accessors for non record type %s&quot;
                   ptype_name.txt,
              ptype_name )
      in
      [
        pstr_value ~loc Nonrecursive
          [
            {
              pvb_pat = ppat_var ~loc { txt = &quot;default_&quot; ^ name.txt; loc };
              pvb_expr = e;
              pvb_attributes = [];
              pvb_loc = loc;
            };
          ];
      ])
  |&gt; List.concat</code></pre><h2 id="quoting"><a href="#quoting" class="anchor"></a>Quoting</h2><p>Quoting is part of producing <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a> code. But before talking about the solution, let's introduce the problem.</p><p>Say you are writing an extension rewriter, which takes an expression as payload, and would replace all identifiers <code>id</code> in the expression with a similar expression, but with a printing debug:</p><pre class="language-ocaml"><code>let x = 0 in
let y = 2 in
[%debug x + 1, y + 2 ]</code></pre><p>would generate the following code:</p><pre class="language-ocaml"><code>let x = 0 in
let y = 2 in
let debug = Printf.printf &quot;%s = %d; &quot; in
(debug &quot;x&quot; x ; x) + 1,
(debug &quot;y&quot; y ; y) + 2</code></pre><p>When executed, the code would print <code>x = 0; y = 2; </code>. So far, so good. However, suppose now that instead of <code>x</code>, the variable is named <code>debug</code>. The following seemingly equivalent code:</p><pre class="language-ocaml"><code>let debug = 0 in
let y = 2 in
[%debug debug + 1, y + 2 ]</code></pre><p>would generate:</p><pre class="language-ocaml"><code>let debug = 0 in
let y = 2 in
let debug = Printf.printf &quot;%s = %d; &quot; in
(debug &quot;debug&quot; debug ; debug) + 1,
(debug &quot;y&quot; y ; y) + 2</code></pre><p>which does not even type-check! The problem is that the payload is expected to be evaluated in some environment where <code>debug</code> has some value and type, but the rewriting modifies this environment and shadows the <code>debug</code> name.</p><p>&quot;Quoting&quot; is a mechanism to prevent this problem from happenning. In <code>ppxlib</code>, it is done through the <a href="ppxlib/Ppxlib/Expansion_helpers/Quoter/index.html" title="Ppxlib.Expansion_helpers.Quoter"><code>Expansion_helpers.Quoter</code></a> module in several steps:</p><ul><li>First, create a quoter using the <a href="ppxlib/Ppxlib/Expansion_helpers/Quoter/index.html#val-create" title="Ppxlib.Expansion_helpers.Quoter.create"><code>create</code></a> function:</li></ul><pre class="language-ocaml"><code># open Expansion_helper ;;
#s let quoter = Quoter.create () ;;
val quoter : Quoter.t = &lt;abstr&gt;</code></pre><ul><li>Then, use <a href="ppxlib/Ppxlib/Expansion_helpers/Quoter/index.html#val-quote" title="Ppxlib.Expansion_helpers.Quoter.quote"><code>Expansion_helpers.Quoter.quote</code></a> to quote all the expressions that are given from the user, might rely on a context, and that you want &quot;intact.&quot;</li></ul><pre class="language-ocaml"><code># let quoted_part = Quoter.quote quoter part_to_quote ;;
val quoted_payload : expression =</code></pre><ul><li>Finally, call <a href="ppxlib/Ppxlib/Expansion_helpers/Quoter/index.html#val-sanitize" title="Ppxlib.Expansion_helpers.Quoter.sanitize"><code>Expansion_helpers.Quoter.sanitize</code></a> on the whole expression (with quoted parts).</li></ul><pre class="language-ocaml"><code># let result = Expansion_helpers.Quoter.sanitize ~quoter rewritten_expression ;;
val result : expression =
...</code></pre><p>If the <code>debug</code> rewriter had been written using this method, the quoting would have ensured that the payload is evaluated in the same context as the extension node!</p><p>Here is an example on how to write a <code>debug</code> rewriter (with the limitation that the payload should not contain variable binding, but the code was left simple to illustrate quoting):</p><pre class="language-ocaml"><code># let rewrite expr =
    (* Create a quoter *)
    let quoter = Quoter.create () in
    (* An AST mapper to log and replace variables with quoted ones *)
    let replace_var =
      object
        (* See the chapter on AST traverse *)
        inherit Ast_traverse.map as super
  
        (* in case of expression *)
        method! expression expr =
          match expr.pexp_desc with
          (* in case of identifier (not &quot;+&quot;) *)
          | Pexp_ident { txt = Lident var_name; loc }
            when not (String.equal &quot;+&quot; var_name) -&gt;
              (* quote the var *)
              let quoted_var = Quoter.quote quoter expr in
              let name = Ast_builder.Default.estring ~loc var_name in
              (* and rewrite the expression *)
              [%expr
                debug [%e name] [%e quoted_var];
                [%e quoted_var]]
          (* otherwise, continue inside recursively *)
          | _ -&gt; super#expression expr
      end
    in
    let quoted_rewrite = replace_var#expression expr in
    let loc = expr.pexp_loc in
    (* Sanitize the whole thing *)
    Quoter.sanitize quoter
      [%expr
        let debug = Printf.printf &quot;%s = %d; &quot; in
        [%e quoted_rewrite]] ;;
  val rewrite : expression -&gt; expression = &lt;fun&gt;</code></pre><p>With <a href="ppxlib/Ppxlib/index.html"><code>Ppxlib</code></a>'s current quoting mechanism, the code given in that example would look like:</p><pre class="language-ocaml"><code># Format.printf &quot;%a\n&quot; Pprintast.expression @@ rewrite [%expr debug + 1, y + 2] ;;
let rec __1 = y
and __0 = debug in
let debug = Printf.printf &quot;%s = %d; &quot; in
(((debug &quot;debug&quot; __0; __0) + 1), ((debug &quot;y&quot; __1; __1) + 2))
- : unit = ()</code></pre><h2 id="testing-your-ppx"><a href="#testing-your-ppx" class="anchor"></a>Testing Your PPX</h2><p>This section is not yet written. You can refer to <a href="https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem#testing-your-ppx">this blog post</a> (notice that that blog post was written before `dune` introduced its cram test feature), or contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><h2 id="migrate-from-other-preprocessing-systems"><a href="#migrate-from-other-preprocessing-systems" class="anchor"></a>Migrate From Other Preprocessing Systems</h2><p>This section is not yet written. You can contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><h2 id="other-good-practices"><a href="#other-good-practices" class="anchor"></a>Other good practices</h2><p>There are many good practices or other way to use <code>ppxlib</code> that are not mentioned in this manual. For instance, (in very short), you should always try to fully qualify variable names that are generated into the code via a PPX.</p><p>if you want to add a section to this &quot;good practices&quot; manual, you can contribute to the <code>ppxlib</code> documentation by opening a pull request in the <a href="https://github.com/ocaml-ppx/ppxlib/">repository</a>.</p><p> <div style="display: flex; justify-content:space-between"><div><a href="ast-traversal.html" title="ast-traversal">&lt; Traversing the AST</a> </div><div><a href="examples.html" title="examples">Examples &gt;</a> </div></div></p></div></body></html>
