<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Re (re.re.Re)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../sherlodoc_db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">re</a> &#x00BB; Library <code>re</code> &#x00BB; Re</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Re</span></code><a href="../../src/re/re.ml.html" class="source_link">Source</a></h1><p>Module <code>Re</code>: code for creating and using regular expressions, independently of regular expression syntax.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#compilation-and-execution-of-a-regular-expression">Compilation and execution of a regular expression</a></li><li><a href="#high-level-operations">High Level Operations</a></li><li><a href="#string-expressions-(literal-match)">String expressions (literal match)</a></li><li><a href="#basic-operations-on-regular-expressions">Basic operations on regular expressions</a></li><li><a href="#string,-line,-word">String, line, word</a></li><li><a href="#match-semantics">Match semantics</a></li><li><a href="#groups-(or-submatches)">Groups (or submatches)</a></li><li><a href="#character-sets">Character sets</a></li><li><a href="#predefined-character-sets">Predefined character sets</a></li><li><a href="#case-modifiers">Case modifiers</a></li><li><a href="#internal-debugging">Internal debugging</a></li><li><a href="#experimental-functions">Experimental functions</a></li><li><a href="#deprecated-functions">Deprecated functions</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../index.html">re</a><ul><li>Library <code>re</code><ul><li><a href="#" class="current_unit">Re</a><ul><li><a href="Group/index.html">Group</a></li><li><a href="Mark/index.html">Mark</a></li><li><a href="Seq/index.html">Seq</a></li><li><a href="View/index.html">View</a></li><li><a href="Emacs/index.html">Emacs</a></li><li><a href="Glob/index.html">Glob</a></li><li><a href="Perl/index.html">Perl</a></li><li><a href="Pcre/index.html">Pcre</a></li><li><a href="Posix/index.html">Posix</a></li><li><a href="Str/index.html">Str</a></li></ul></li></ul></li><li>Library <code>re.emacs</code><ul><li><a href="../../re.emacs/Re_emacs/index.html">Re_emacs</a></li></ul></li><li>Library <code>re.glob</code><ul><li><a href="../../re.glob/Re_glob/index.html">Re_glob</a></li></ul></li><li>Library <code>re.pcre</code><ul><li><a href="../../re.pcre/Re_pcre/index.html">Re_pcre</a></li></ul></li><li>Library <code>re.perl</code><ul><li><a href="../../re.perl/Re_perl/index.html">Re_perl</a></li></ul></li><li>Library <code>re.posix</code><ul><li><a href="../../re.posix/Re_posix/index.html">Re_posix</a></li></ul></li><li>Library <code>re.str</code><ul><li><a href="../../re.str/Re_str/index.html">Re_str</a></li></ul></li><li><a href="../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.type-t" class="source_link">Source</a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Regular expression</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-re"><a href="#type-re" class="anchor"></a><a href="../../src/re/core.ml.html#def_105" class="source_link">Source</a><code><span><span class="keyword">type</span> re</span></code></div><div class="spec-doc"><p>Compiled regular expression</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Group"><a href="#module-Group" class="anchor"></a><a href="../../src/re/group.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Group/index.html">Group</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Manipulate matching groups.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-groups"><a href="#type-groups" class="anchor"></a><a href="../../src/re/core.ml.html#type-groups" class="source_link">Source</a><code><span><span class="keyword">type</span> groups</span><span> = <a href="Group/index.html#type-t">Group.t</a></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.t</li></ul></div></div><h3 id="compilation-and-execution-of-a-regular-expression"><a href="#compilation-and-execution-of-a-regular-expression" class="anchor"></a>Compilation and execution of a regular expression</h3><div class="odoc-spec"><div class="spec value anchored" id="val-compile"><a href="#val-compile" class="anchor"></a><a href="../../src/re/core.ml.html#local_compile_100" class="source_link">Source</a><code><span><span class="keyword">val</span> compile : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-re">re</a></span></code></div><div class="spec-doc"><p>Compile a regular expression into an executable version that can be used to match strings, e.g. with <a href="#val-exec"><code>exec</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-group_count"><a href="#val-group_count" class="anchor"></a><a href="../../src/re/core.ml.html#local_group_count_104" class="source_link">Source</a><code><span><span class="keyword">val</span> group_count : <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of capture groups (including the one corresponding to the entire regexp).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-group_names"><a href="#val-group_names" class="anchor"></a><a href="../../src/re/core.ml.html#local_group_names_103" class="source_link">Source</a><code><span><span class="keyword">val</span> group_names : <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(string * int)</span> list</span></span></code></div><div class="spec-doc"><p>Return named capture groups with their index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec"><a href="#val-exec" class="anchor"></a><a href="../../src/re/core.ml.html#val-exec" class="source_link">Source</a><code><span><span class="keyword">val</span> exec : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="Group/index.html#type-t">Group.t</a></span></code></div><div class="spec-doc"><p><code>exec re str</code> searches <code>str</code> for a match of the compiled expression <code>re</code>, and returns the matched groups if any.</p><p>More specifically, when a match exists, <code>exec</code> returns a match that starts at the earliest position possible. If multiple such matches are possible, the one specified by the match semantics described below is returned.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [str &quot;//&quot;; rep print ]);;
val regex : re = &lt;abstr&gt;

# Re.exec regex &quot;// a C comment&quot;;;
- : Re.Group.t = &lt;abstr&gt;

# Re.exec regex &quot;# a C comment?&quot;;;
Exception: Not_found

# Re.exec ~pos:1 regex &quot;// a C comment&quot;;;
Exception: Not_found</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pos</span> <p>optional beginning of the string (default 0)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">len</span> <p>length of the substring of <code>str</code> that can be matched (default <code>-1</code>, meaning to the end of the string)</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#exception-Not_found"><code>Not_found</code></a> <p>if the regular expression can't be found in <code>str</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec_opt"><a href="#val-exec_opt" class="anchor"></a><a href="../../src/re/core.ml.html#val-exec_opt" class="source_link">Source</a><code><span><span class="keyword">val</span> exec_opt : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Group/index.html#type-t">Group.t</a> option</span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-exec"><code>exec</code></a>, but returns an option instead of using an exception.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [str &quot;//&quot;; rep print ]);;
val regex : re = &lt;abstr&gt;

# Re.exec_opt regex &quot;// a C comment&quot;;;
- : Re.Group.t option = Some &lt;abstr&gt;

# Re.exec_opt regex &quot;# a C comment?&quot;;;
- : Re.Group.t option = None

# Re.exec_opt ~pos:1 regex &quot;// a C comment&quot;;;
- : Re.Group.t option = None</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-execp"><a href="#val-execp" class="anchor"></a><a href="../../src/re/core.ml.html#val-execp" class="source_link">Source</a><code><span><span class="keyword">val</span> execp : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Similar to <a href="#val-exec"><code>exec</code></a>, but returns <code>true</code> if the expression matches, and <code>false</code> if it doesn't. This function is more efficient than calling <a href="#val-exec"><code>exec</code></a> or <a href="#val-exec_opt"><code>exec_opt</code></a> and ignoring the returned group.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [str &quot;//&quot;; rep print ]);;
val regex : re = &lt;abstr&gt;

# Re.execp regex &quot;// a C comment&quot;;;
- : bool = true

# Re.execp ~pos:1 regex &quot;// a C comment&quot;;;
- : bool = false</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec_partial"><a href="#val-exec_partial" class="anchor"></a><a href="../../src/re/core.ml.html#val-exec_partial" class="source_link">Source</a><code><span><span class="keyword">val</span> exec_partial : 
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>[ `Full <span>| `Partial</span> <span>| `Mismatch</span> ]</span></span></code></div><div class="spec-doc"><p>More detailed version of <a href="#val-execp"><code>execp</code></a>. <code>`Full</code> is equivalent to <code>true</code>, while <code>`Mismatch</code> and <code>`Partial</code> are equivalent to <code>false</code>, but <code>`Partial</code> indicates the input string could be extended to create a match.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [bos; str &quot;// a C comment&quot;]);;
val regex : re = &lt;abstr&gt;

# Re.exec_partial regex &quot;// a C comment here.&quot;;;
- : [ `Full | `Mismatch | `Partial ] = `Full

# Re.exec_partial regex &quot;// a C comment&quot;;;
- : [ `Full | `Mismatch | `Partial ] = `Partial

# Re.exec_partial regex &quot;//&quot;;;
- : [ `Full | `Mismatch | `Partial ] = `Partial

# Re.exec_partial regex &quot;# a C comment?&quot;;;
- : [ `Full | `Mismatch | `Partial ] = `Mismatch</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exec_partial_detailed"><a href="#val-exec_partial_detailed" class="anchor"></a><a href="../../src/re/core.ml.html#val-exec_partial_detailed" class="source_link">Source</a><code><span><span class="keyword">val</span> exec_partial_detailed : 
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>[ <span>`Full of <a href="Group/index.html#type-t">Group.t</a></span> <span><span>| `Partial</span> of int</span> <span>| `Mismatch</span> ]</span></span></code></div><div class="spec-doc"><p>More detailed version of <a href="#val-exec_opt"><code>exec_opt</code></a>. <code>`Full group</code> is equivalent to <code>Some group</code>, while <code>`Mismatch</code> and <code>`Partial _</code> are equivalent to <code>None</code>, but <code>`Partial position</code> indicates that the input string could be extended to create a match, and no match could start in the input string before the given position. This could be used to not have to search the entirety of the input if more becomes available, and use the given position as the <code>?pos</code> argument.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Mark"><a href="#module-Mark" class="anchor"></a><a href="../../src/re/core.ml.html#module-Mark" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Mark/index.html">Mark</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Marks</p></div></div><h3 id="high-level-operations"><a href="#high-level-operations" class="anchor"></a>High Level Operations</h3><div class="odoc-spec"><div class="spec type anchored" id="type-split_token"><a href="#type-split_token" class="anchor"></a><a href="../../src/re/core.ml.html#type-split_token" class="source_link">Source</a><code><span><span class="keyword">type</span> split_token</span><span> = </span><span>[ </span></code><ol><li id="type-split_token.Text" class="def variant constructor anchored"><a href="#type-split_token.Text" class="anchor"></a><code><span>| </span><span>`Text <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Text between delimiters</p><span class="comment-delim">*)</span></div></li><li id="type-split_token.Delim" class="def variant constructor anchored"><a href="#type-split_token.Delim" class="anchor"></a><code><span>| </span><span>`Delim <span class="keyword">of</span> <a href="Group/index.html#type-t">Group.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Delimiter</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><a href="../../src/re/core.ml.html#module-List.val-all" class="source_link">Source</a><code><span><span class="keyword">val</span> all : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Group/index.html#type-t">Group.t</a> list</span></span></code></div><div class="spec-doc"><p>Repeatedly calls <a href="#val-exec"><code>exec</code></a> on the given string, starting at given position and length.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [str &quot;my&quot;; blank; word(rep alpha)]);;
val regex : re = &lt;abstr&gt;

# Re.all regex &quot;my head, my shoulders, my knees, my toes ...&quot;;;
- : Re.Group.t list = [&lt;abstr&gt;; &lt;abstr&gt;; &lt;abstr&gt;; &lt;abstr&gt;]

# Re.all regex &quot;My head, My shoulders, My knees, My toes ...&quot;;;
- : Re.Group.t list = []</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-gen"><a href="#type-gen" class="anchor"></a><a href="../../src/re/core.ml.html#type-gen" class="source_link">Source</a><code><span><span class="keyword">type</span> <span>'a gen</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all_gen"><a href="#val-all_gen" class="anchor"></a><a href="../../src/re/core.ml.html#val-all_gen" class="source_link">Source</a><code><span><span class="keyword">val</span> all_gen : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Group/index.html#type-t">Group.t</a> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-all"><code>Seq.all</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all_seq"><a href="#val-all_seq" class="anchor"></a><a href="../../src/re/core.ml.html#val-all_seq" class="source_link">Source</a><code><span><span class="keyword">val</span> all_seq : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="Group/index.html#type-t">Group.t</a> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-all"><code>Seq.all</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matches"><a href="#val-matches" class="anchor"></a><a href="../../src/re/core.ml.html#module-List.val-matches" class="source_link">Source</a><code><span><span class="keyword">val</span> matches : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-all"><code>all</code></a>, but extracts the matched substring rather than returning the whole group. This basically iterates over matched strings.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile Re.(seq [str &quot;my&quot;; blank; word(rep alpha)]);;
val regex : re = &lt;abstr&gt;

# Re.matches regex &quot;my head, my shoulders, my knees, my toes ...&quot;;;
- : string list = [&quot;my head&quot;; &quot;my shoulders&quot;; &quot;my knees&quot;; &quot;my toes&quot;]

# Re.matches regex &quot;My head, My shoulders, My knees, My toes ...&quot;;;
- : string list = []

# Re.matches regex &quot;my my my my head my 1 toe my ...&quot;;;
- : string list = [&quot;my my&quot;; &quot;my my&quot;]

# Re.matches ~pos:2 regex &quot;my my my my head my +1 toe my ...&quot;;;
- : string list = [&quot;my my&quot;; &quot;my head&quot;]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matches_gen"><a href="#val-matches_gen" class="anchor"></a><a href="../../src/re/core.ml.html#val-matches_gen" class="source_link">Source</a><code><span><span class="keyword">val</span> matches_gen : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-matches"><code>Seq.matches</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matches_seq"><a href="#val-matches_seq" class="anchor"></a><a href="../../src/re/core.ml.html#val-matches_seq" class="source_link">Source</a><code><span><span class="keyword">val</span> matches_seq : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-matches"><code>Seq.matches</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><a href="../../src/re/core.ml.html#module-List.val-split" class="source_link">Source</a><code><span><span class="keyword">val</span> split : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>split re s</code> splits <code>s</code> into chunks separated by <code>re</code>. It yields the chunks themselves, not the separator. An occurence of the separator at the beginning or the end of the string is ignoring.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile (Re.char ',');;
val regex : re = &lt;abstr&gt;

# Re.split regex &quot;Re,Ocaml,Jerome Vouillon&quot;;;
- : string list = [&quot;Re&quot;; &quot;Ocaml&quot;; &quot;Jerome Vouillon&quot;]

# Re.split regex &quot;No commas in this sentence.&quot;;;
- : string list = [&quot;No commas in this sentence.&quot;]

# Re.split regex &quot;,1,2,&quot;;;
- : string list = [&quot;1&quot;; &quot;2&quot;]

# Re.split ~pos:3 regex &quot;1,2,3,4. Commas go brrr.&quot;;;
- : string list = [&quot;3&quot;; &quot;4. Commas go brrr.&quot;]</code></pre><p>Zero-length patterns:</p><p>Be careful when using <code>split</code> with zero-length patterns like <code>eol</code>, <code>bow</code>, and <code>eow</code>. Because they don't have any width, they will still be present in the result. (Note the position of the <code>\n</code> and space characters in the output.)</p><pre class="language-ocaml"><code># Re.split (Re.compile Re.eol) &quot;a\nb&quot;;;
- : string list = [&quot;a&quot;; &quot;\nb&quot;]

# Re.split (Re.compile Re.bow) &quot;a b&quot;;;
- : string list = [&quot;a &quot;; &quot;b&quot;]

# Re.split (Re.compile Re.eow) &quot;a b&quot;;;
- : string list = [&quot;a&quot;; &quot; b&quot;]</code></pre><p>Compare this to the behavior of splitting on the char itself. (Note that the delimiters are not present in the output.)</p><pre class="language-ocaml"><code># Re.split (Re.compile (Re.char '\n')) &quot;a\nb&quot;;;
- : string list = [&quot;a&quot;; &quot;b&quot;]

# Re.split (Re.compile (Re.char ' ')) &quot;a b&quot;;;
- : string list = [&quot;a&quot;; &quot;b&quot;]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_delim"><a href="#val-split_delim" class="anchor"></a><a href="../../src/re/core.ml.html#module-List.val-split_delim" class="source_link">Source</a><code><span><span class="keyword">val</span> split_delim : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>split_delim re s</code> splits <code>s</code> into chunks separated by <code>re</code>. It yields the chunks themselves, not the separator. Occurences of the separator at the beginning or the end of the string will produce empty chunks.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile (Re.char ',');;
val regex : re = &lt;abstr&gt;

# Re.split regex &quot;Re,Ocaml,Jerome Vouillon&quot;;;
- : string list = [&quot;Re&quot;; &quot;Ocaml&quot;; &quot;Jerome Vouillon&quot;]

# Re.split regex &quot;No commas in this sentence.&quot;;;
- : string list = [&quot;No commas in this sentence.&quot;]

# Re.split regex &quot;,1,2,&quot;;;
- : string list = [&quot;&quot;; &quot;1&quot;; &quot;2&quot;; &quot;&quot;]

# Re.split ~pos:3 regex &quot;1,2,3,4. Commas go brrr.&quot;;;
- : string list = [&quot;3&quot;; &quot;4. Commas go brrr.&quot;]</code></pre><p>Zero-length patterns:</p><p>Be careful when using <code>split_delim</code> with zero-length patterns like <code>eol</code>, <code>bow</code>, and <code>eow</code>. Because they don't have any width, they will still be present in the result. (Note the position of the <code>\n</code> and space characters in the output.)</p><pre class="language-ocaml"><code># Re.split_delim (Re.compile Re.eol) &quot;a\nb&quot;;;
- : string list = [&quot;a&quot;; &quot;\nb&quot;; &quot;&quot;]

# Re.split_delim (Re.compile Re.bow) &quot;a b&quot;;;
- : string list = [&quot;&quot;; &quot;a &quot;; &quot;b&quot;]

# Re.split_delim (Re.compile Re.eow) &quot;a b&quot;;;
- : string list = [&quot;a&quot;; &quot; b&quot;; &quot;&quot;]</code></pre><p>Compare this to the behavior of splitting on the char itself. (Note that the delimiters are not present in the output.)</p><pre class="language-ocaml"><code># Re.split_delim (Re.compile (Re.char '\n')) &quot;a\nb&quot;;;
- : string list = [&quot;a&quot;; &quot;b&quot;]

# Re.split_delim (Re.compile (Re.char ' ')) &quot;a b&quot;;;
- : string list = [&quot;a&quot;; &quot;b&quot;]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_gen"><a href="#val-split_gen" class="anchor"></a><a href="../../src/re/core.ml.html#val-split_gen" class="source_link">Source</a><code><span><span class="keyword">val</span> split_gen : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-split"><code>Seq.split</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_seq"><a href="#val-split_seq" class="anchor"></a><a href="../../src/re/core.ml.html#val-split_seq" class="source_link">Source</a><code><span><span class="keyword">val</span> split_seq : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-split"><code>Seq.split</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_full"><a href="#val-split_full" class="anchor"></a><a href="../../src/re/core.ml.html#module-List.val-split_full" class="source_link">Source</a><code><span><span class="keyword">val</span> split_full : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-split_token">split_token</a> list</span></span></code></div><div class="spec-doc"><p><code>split re s</code> splits <code>s</code> into chunks separated by <code>re</code>. It yields the chunks along with the separators. For instance this can be used with a whitespace-matching re such as <code>&quot;[\t ]+&quot;</code>.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile (Re.char ',');;
val regex : re = &lt;abstr&gt;

# Re.split_full regex &quot;Re,Ocaml,Jerome Vouillon&quot;;;
- : Re.split_token list =
  [`Text &quot;Re&quot;; `Delim &lt;abstr&gt;; `Text &quot;Ocaml&quot;; `Delim &lt;abstr&gt;;
  `Text &quot;Jerome Vouillon&quot;]

# Re.split_full regex &quot;No commas in this sentence.&quot;;;
- : Re.split_token list = [`Text &quot;No commas in this sentence.&quot;]

# Re.split_full ~pos:3 regex &quot;1,2,3,4. Commas go brrr.&quot;;;
- : Re.split_token list =
  [`Delim &lt;abstr&gt;; `Text &quot;3&quot;; `Delim &lt;abstr&gt;; `Text &quot;4. Commas go brrr.&quot;]</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_full_gen"><a href="#val-split_full_gen" class="anchor"></a><a href="../../src/re/core.ml.html#val-split_full_gen" class="source_link">Source</a><code><span><span class="keyword">val</span> split_full_gen : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-split_token">split_token</a> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-split_full"><code>Seq.split_full</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_full_seq"><a href="#val-split_full_seq" class="anchor"></a><a href="../../src/re/core.ml.html#val-split_full_seq" class="source_link">Source</a><code><span><span class="keyword">val</span> split_full_seq : <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-split_token">split_token</a> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>Use <a href="Seq/index.html#val-split_full"><code>Seq.split_full</code></a> instead.</p></li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Seq"><a href="#module-Seq" class="anchor"></a><a href="../../src/re/search.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Seq/index.html">Seq</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="string-expressions-(literal-match)"><a href="#string-expressions-(literal-match)" class="anchor"></a>String expressions (literal match)</h3><div class="odoc-spec"><div class="spec value anchored" id="val-str"><a href="#val-str" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-str" class="source_link">Source</a><code><span><span class="keyword">val</span> str : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-char"><a href="#val-char" class="anchor"></a><a href="../../src/re/core.ml.html#local_char_2" class="source_link">Source</a><code><span><span class="keyword">val</span> char : <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><h3 id="basic-operations-on-regular-expressions"><a href="#basic-operations-on-regular-expressions" class="anchor"></a>Basic operations on regular expressions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-alt"><a href="#val-alt" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-alt" class="source_link">Source</a><code><span><span class="keyword">val</span> alt : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Alternative.</p><p><code>alt []</code> is equivalent to <a href="#val-empty"><code>empty</code></a>.</p><p>By default, the leftmost match is preferred (see match semantics below).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq"><a href="#val-seq" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-seq" class="source_link">Source</a><code><span><span class="keyword">val</span> seq : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Sequence</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-empty" class="source_link">Source</a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Match nothing</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-epsilon"><a href="#val-epsilon" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-epsilon" class="source_link">Source</a><code><span><span class="keyword">val</span> epsilon : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Empty word</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rep"><a href="#val-rep" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-rep" class="source_link">Source</a><code><span><span class="keyword">val</span> rep : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>0 or more matches</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rep1"><a href="#val-rep1" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-rep1" class="source_link">Source</a><code><span><span class="keyword">val</span> rep1 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>1 or more matches</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-repn"><a href="#val-repn" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-repn" class="source_link">Source</a><code><span><span class="keyword">val</span> repn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>repn re i j</code> matches <code>re</code> at least <code>i</code> times and at most <code>j</code> times, bounds included. <code>j = None</code> means no upper bound.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opt"><a href="#val-opt" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-opt" class="source_link">Source</a><code><span><span class="keyword">val</span> opt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>0 or 1 matches</p></div></div><h3 id="string,-line,-word"><a href="#string,-line,-word" class="anchor"></a>String, line, word</h3><p>We define a word as a sequence of latin1 letters, digits and underscore.</p><div class="odoc-spec"><div class="spec value anchored" id="val-bol"><a href="#val-bol" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-bol" class="source_link">Source</a><code><span><span class="keyword">val</span> bol : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Beginning of line</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eol"><a href="#val-eol" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-eol" class="source_link">Source</a><code><span><span class="keyword">val</span> eol : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>End of line</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bow"><a href="#val-bow" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-bow" class="source_link">Source</a><code><span><span class="keyword">val</span> bow : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Beginning of word</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eow"><a href="#val-eow" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-eow" class="source_link">Source</a><code><span><span class="keyword">val</span> eow : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>End of word</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bos"><a href="#val-bos" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-bos" class="source_link">Source</a><code><span><span class="keyword">val</span> bos : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Beginning of string. This differs from <a href="#val-start"><code>start</code></a> because it matches the beginning of the input string even when using <code>~pos</code> arguments:</p><pre class="language-ocaml"><code>let b = execp (compile (seq [ bos; str &quot;a&quot; ])) &quot;aa&quot; ~pos:1 in
assert (not b)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eos"><a href="#val-eos" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-eos" class="source_link">Source</a><code><span><span class="keyword">val</span> eos : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>End of string. This is different from <a href="#val-stop"><code>stop</code></a> in the way described in <a href="#val-bos"><code>bos</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leol"><a href="#val-leol" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-leol" class="source_link">Source</a><code><span><span class="keyword">val</span> leol : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Last end of line or end of string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-start"><a href="#val-start" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-start" class="source_link">Source</a><code><span><span class="keyword">val</span> start : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Initial position. This differs from <a href="#val-bos"><code>bos</code></a> because it takes into account the <code>~pos</code> arguments:</p><pre class="language-ocaml"><code>let b = execp (compile (seq [ start; str &quot;a&quot; ])) &quot;aa&quot; ~pos:1 in
assert b</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stop"><a href="#val-stop" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-stop" class="source_link">Source</a><code><span><span class="keyword">val</span> stop : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Final position. This is different from <a href="#val-eos"><code>eos</code></a> in the way described in <a href="#val-start"><code>start</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-word"><a href="#val-word" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-word" class="source_link">Source</a><code><span><span class="keyword">val</span> word : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Word</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-not_boundary"><a href="#val-not_boundary" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-not_boundary" class="source_link">Source</a><code><span><span class="keyword">val</span> not_boundary : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Not at a word boundary</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-whole_string"><a href="#val-whole_string" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-whole_string" class="source_link">Source</a><code><span><span class="keyword">val</span> whole_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Only matches the whole string, i.e. <code>fun t -&gt; seq [ bos; t; eos ]</code>.</p></div></div><h3 id="match-semantics"><a href="#match-semantics" class="anchor"></a>Match semantics</h3><p>A regular expression frequently matches a string in multiple ways. For instance <code>exec (compile (opt (str &quot;a&quot;))) &quot;ab&quot;</code> can match &quot;&quot; or &quot;a&quot;. Match semantic can be modified with the functions below, allowing one to choose which of these is preferable.</p><p>By default, the leftmost branch of alternations is preferred, and repetitions are greedy.</p><p>Note that the existence of matches cannot be changed by specifying match semantics. <code>seq [ bos; str &quot;a&quot;; non_greedy (opt (str &quot;b&quot;)); eos ]</code> will match when applied to &quot;ab&quot;. However if <code>seq [ bos; str &quot;a&quot;; non_greedy (opt (str &quot;b&quot;)) ]</code> is applied to &quot;ab&quot;, it will match &quot;a&quot; rather than &quot;ab&quot;.</p><p>Also note that multiple match semantics can conflict. In this case, the one executed earlier takes precedence. For instance, any match of <code>shortest (seq [ bos; group (rep (str &quot;a&quot;)); group (rep (str &quot;a&quot;)); eos ])</code> will always have an empty first group. Conversely, if we use <code>longest</code> instead of <code>shortest</code>, the second group will always be empty.</p><div class="odoc-spec"><div class="spec value anchored" id="val-longest"><a href="#val-longest" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-longest" class="source_link">Source</a><code><span><span class="keyword">val</span> longest : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Longest match semantics. That is, matches will match as many bytes as possible. If multiple choices match the maximum amount of bytes, the one respecting the inner match semantics is preferred.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shortest"><a href="#val-shortest" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-shortest" class="source_link">Source</a><code><span><span class="keyword">val</span> shortest : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-longest"><code>longest</code></a>, but matching the least number of bytes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first"><a href="#val-first" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-first" class="source_link">Source</a><code><span><span class="keyword">val</span> first : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>First match semantics for alternations (not repetitions). That is, matches will prefer the leftmost branch of the alternation that matches the text.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-greedy"><a href="#val-greedy" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-greedy" class="source_link">Source</a><code><span><span class="keyword">val</span> greedy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Greedy matches for repetitions (<a href="#val-opt"><code>opt</code></a>, <a href="#val-rep"><code>rep</code></a>, <a href="#val-rep1"><code>rep1</code></a>, <a href="#val-repn"><code>repn</code></a>): they will match as many times as possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-non_greedy"><a href="#val-non_greedy" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-non_greedy" class="source_link">Source</a><code><span><span class="keyword">val</span> non_greedy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Non-greedy matches for repetitions (<a href="#val-opt"><code>opt</code></a>, <a href="#val-rep"><code>rep</code></a>, <a href="#val-rep1"><code>rep1</code></a>, <a href="#val-repn"><code>repn</code></a>): they will match as few times as possible.</p></div></div><h3 id="groups-(or-submatches)"><a href="#groups-(or-submatches)" class="anchor"></a>Groups (or submatches)</h3><div class="odoc-spec"><div class="spec value anchored" id="val-group"><a href="#val-group" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-group" class="source_link">Source</a><code><span><span class="keyword">val</span> group : <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Delimit a group. The group is considered as matching if it is used at least once (it may be used multiple times if is nested inside <a href="#val-rep"><code>rep</code></a> for instance). If it is used multiple times, the last match is what gets captured.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_group"><a href="#val-no_group" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-no_group" class="source_link">Source</a><code><span><span class="keyword">val</span> no_group : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Remove all groups</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nest"><a href="#val-nest" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-nest" class="source_link">Source</a><code><span><span class="keyword">val</span> nest : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>When matching against <code>nest e</code>, only the group matching in the last match of e will be considered as matching.</p><p>For instance:</p><pre class="language-ocaml"><code>let re = compile (rep1 (nest (alt [ group (str &quot;a&quot;); str &quot;b&quot; ]))) in
let group = Re.exec re &quot;ab&quot; in
assert (Group.get_opt group 1 = None);
(* same thing but without [nest] *)
let re = compile (rep1 (alt [ group (str &quot;a&quot;); str &quot;b&quot; ])) in
let group = Re.exec re &quot;ab&quot; in
assert (Group.get_opt group 1 = Some &quot;a&quot;)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mark"><a href="#val-mark" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-mark" class="source_link">Source</a><code><span><span class="keyword">val</span> mark : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Mark/index.html#type-t">Mark.t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Mark a regexp. the markid can then be used to know if this regexp was used.</p></div></div><h3 id="character-sets"><a href="#character-sets" class="anchor"></a>Character sets</h3><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-set" class="source_link">Source</a><code><span><span class="keyword">val</span> set : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Any character of the string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rg"><a href="#val-rg" class="anchor"></a><a href="../../src/re/core.ml.html#local_rg_4" class="source_link">Source</a><code><span><span class="keyword">val</span> rg : <span>char <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Character ranges</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inter"><a href="#val-inter" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-inter" class="source_link">Source</a><code><span><span class="keyword">val</span> inter : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Intersection of character sets</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-diff"><a href="#val-diff" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-diff" class="source_link">Source</a><code><span><span class="keyword">val</span> diff : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Difference of character sets</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compl"><a href="#val-compl" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-compl" class="source_link">Source</a><code><span><span class="keyword">val</span> compl : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Complement of union</p></div></div><h3 id="predefined-character-sets"><a href="#predefined-character-sets" class="anchor"></a>Predefined character sets</h3><div class="odoc-spec"><div class="spec value anchored" id="val-any"><a href="#val-any" class="anchor"></a><a href="../../src/re/core.ml.html#local_any_7" class="source_link">Source</a><code><span><span class="keyword">val</span> any : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Any character</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-notnl"><a href="#val-notnl" class="anchor"></a><a href="../../src/re/core.ml.html#local_notnl_8" class="source_link">Source</a><code><span><span class="keyword">val</span> notnl : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Any character but a newline</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alnum"><a href="#val-alnum" class="anchor"></a><a href="../../src/re/core.ml.html#local_alnum_13" class="source_link">Source</a><code><span><span class="keyword">val</span> alnum : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wordc"><a href="#val-wordc" class="anchor"></a><a href="../../src/re/core.ml.html#local_wordc_14" class="source_link">Source</a><code><span><span class="keyword">val</span> wordc : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alpha"><a href="#val-alpha" class="anchor"></a><a href="../../src/re/core.ml.html#local_alpha_11" class="source_link">Source</a><code><span><span class="keyword">val</span> alpha : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ascii"><a href="#val-ascii" class="anchor"></a><a href="../../src/re/core.ml.html#local_ascii_15" class="source_link">Source</a><code><span><span class="keyword">val</span> ascii : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blank"><a href="#val-blank" class="anchor"></a><a href="../../src/re/core.ml.html#local_blank_16" class="source_link">Source</a><code><span><span class="keyword">val</span> blank : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cntrl"><a href="#val-cntrl" class="anchor"></a><a href="../../src/re/core.ml.html#local_cntrl_17" class="source_link">Source</a><code><span><span class="keyword">val</span> cntrl : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-digit"><a href="#val-digit" class="anchor"></a><a href="../../src/re/core.ml.html#local_digit_12" class="source_link">Source</a><code><span><span class="keyword">val</span> digit : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-graph"><a href="#val-graph" class="anchor"></a><a href="../../src/re/core.ml.html#local_graph_18" class="source_link">Source</a><code><span><span class="keyword">val</span> graph : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lower"><a href="#val-lower" class="anchor"></a><a href="../../src/re/core.ml.html#local_lower_9" class="source_link">Source</a><code><span><span class="keyword">val</span> lower : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><a href="../../src/re/core.ml.html#local_print_19" class="source_link">Source</a><code><span><span class="keyword">val</span> print : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-punct"><a href="#val-punct" class="anchor"></a><a href="../../src/re/core.ml.html#local_punct_20" class="source_link">Source</a><code><span><span class="keyword">val</span> punct : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-space"><a href="#val-space" class="anchor"></a><a href="../../src/re/core.ml.html#local_space_21" class="source_link">Source</a><code><span><span class="keyword">val</span> space : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-upper"><a href="#val-upper" class="anchor"></a><a href="../../src/re/core.ml.html#local_upper_10" class="source_link">Source</a><code><span><span class="keyword">val</span> upper : <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xdigit"><a href="#val-xdigit" class="anchor"></a><a href="../../src/re/core.ml.html#local_xdigit_22" class="source_link">Source</a><code><span><span class="keyword">val</span> xdigit : <a href="#type-t">t</a></span></code></div></div><h3 id="case-modifiers"><a href="#case-modifiers" class="anchor"></a>Case modifiers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-case"><a href="#val-case" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-case" class="source_link">Source</a><code><span><span class="keyword">val</span> case : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Case sensitive matching. Note that this works on latin1, not ascii and not utf8.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_case"><a href="#val-no_case" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-no_case" class="source_link">Source</a><code><span><span class="keyword">val</span> no_case : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Case insensitive matching. Note that this works on latin1, not ascii and not utf8.</p></div></div><h3 id="internal-debugging"><a href="#internal-debugging" class="anchor"></a>Internal debugging</h3><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-pp" class="source_link">Source</a><code><span><span class="keyword">val</span> pp : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_re"><a href="#val-pp_re" class="anchor"></a><a href="../../src/re/core.ml.html#local_pp_re_101" class="source_link">Source</a><code><span><span class="keyword">val</span> pp_re : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_re"><a href="#val-print_re" class="anchor"></a><a href="../../src/re/core.ml.html#local_print_re_102" class="source_link">Source</a><code><span><span class="keyword">val</span> print_re : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-re">re</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Alias for <a href="#val-pp_re"><code>pp_re</code></a>. Deprecated</p></div></div><h3 id="experimental-functions"><a href="#experimental-functions" class="anchor"></a>Experimental functions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-witness"><a href="#val-witness" class="anchor"></a><a href="../../src/re/ast.ml.html#module-Export.val-witness" class="source_link">Source</a><code><span><span class="keyword">val</span> witness : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>witness r</code> generates a string <code>s</code> such that <code>execp (compile r) s</code> is true.</p><p>Be warned that this function is buggy because it ignores zero-width assertions like beginning of words. As a result it can generate incorrect results.</p></div></div><h3 id="deprecated-functions"><a href="#deprecated-functions" class="anchor"></a>Deprecated functions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-substrings"><a href="#type-substrings" class="anchor"></a><a href="../../src/re/core.ml.html#type-substrings" class="source_link">Source</a><code><span><span class="keyword">type</span> substrings</span><span> = <a href="Group/index.html#type-t">Group.t</a></span></code></div><div class="spec-doc"><p>Alias for <a href="Group/index.html#type-t"><code>Group.t</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.t</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><a href="../../src/re/core.ml.html#val-get" class="source_link">Source</a><code><span><span class="keyword">val</span> get : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Same as <a href="Group/index.html#val-get"><code>Group.get</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.get</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_ofs"><a href="#val-get_ofs" class="anchor"></a><a href="../../src/re/core.ml.html#val-get_ofs" class="source_link">Source</a><code><span><span class="keyword">val</span> get_ofs : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p>Same as <a href="Group/index.html#val-offset"><code>Group.offset</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.offset</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_all"><a href="#val-get_all" class="anchor"></a><a href="../../src/re/core.ml.html#val-get_all" class="source_link">Source</a><code><span><span class="keyword">val</span> get_all : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span>string array</span></span></code></div><div class="spec-doc"><p>Same as <a href="Group/index.html#val-all"><code>Group.all</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.all</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_all_ofs"><a href="#val-get_all_ofs" class="anchor"></a><a href="../../src/re/core.ml.html#val-get_all_ofs" class="source_link">Source</a><code><span><span class="keyword">val</span> get_all_ofs : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * int)</span> array</span></span></code></div><div class="spec-doc"><p>Same as <a href="Group/index.html#val-all_offset"><code>Group.all_offset</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.all_offset</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-test"><a href="#val-test" class="anchor"></a><a href="../../src/re/core.ml.html#val-test" class="source_link">Source</a><code><span><span class="keyword">val</span> test : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="Group/index.html#val-test"><code>Group.test</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Group.test</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-markid"><a href="#type-markid" class="anchor"></a><a href="../../src/re/core.ml.html#type-markid" class="source_link">Source</a><code><span><span class="keyword">type</span> markid</span><span> = <a href="Mark/index.html#type-t">Mark.t</a></span></code></div><div class="spec-doc"><p>Alias for <a href="Mark/index.html#type-t"><code>Mark.t</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Mark.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-marked"><a href="#val-marked" class="anchor"></a><a href="../../src/re/core.ml.html#val-marked" class="source_link">Source</a><code><span><span class="keyword">val</span> marked : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Mark/index.html#type-t">Mark.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="Mark/index.html#val-test"><code>Mark.test</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Mark.test</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mark_set"><a href="#val-mark_set" class="anchor"></a><a href="../../src/re/core.ml.html#val-mark_set" class="source_link">Source</a><code><span><span class="keyword">val</span> mark_set : <span><a href="Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Mark/Set/index.html#type-t">Mark.Set.t</a></span></code></div><div class="spec-doc"><p>Same as <a href="Mark/index.html#val-all"><code>Mark.all</code></a>. Deprecated</p><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Mark.all</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace"><a href="#val-replace" class="anchor"></a><a href="../../src/re/replace.ml.html#val-replace" class="source_link">Source</a><code><span><span class="keyword">val</span> replace : 
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?all</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Re__.Compile.re</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">f</span>:<span>(<span><a href="../Re__/Core/Group/index.html#type-t">Group.t</a> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>replace ~all re ~f s</code> iterates on <code>s</code>, and replaces every occurrence of <code>re</code> with <code>f substring</code> where <code>substring</code> is the current match. If <code>all = false</code>, then only the first occurrence of <code>re</code> is replaced.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-replace_string"><a href="#val-replace_string" class="anchor"></a><a href="../../src/re/replace.ml.html#val-replace_string" class="source_link">Source</a><code><span><span class="keyword">val</span> replace_string : 
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?all</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Re__.Compile.re</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">by</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>replace_string ~all re ~by s</code> iterates on <code>s</code>, and replaces every occurrence of <code>re</code> with <code>by</code>. If <code>all = false</code>, then only the first occurrence of <code>re</code> is replaced.</p><p>Examples:</p><pre class="language-ocaml"><code># let regex = Re.compile (Re.char ',');;
val regex : re = &lt;abstr&gt;

# Re.replace_string regex ~by:&quot;;&quot; &quot;[1,2,3,4,5,6,7]&quot;;;
- : string = &quot;[1;2;3;4;5;6;7]&quot;

# Re.replace_string regex ~all:false ~by:&quot;;&quot; &quot;[1,2,3,4,5,6,7]&quot;;;
- : string = &quot;[1;2,3,4,5,6,7]&quot;</code></pre></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-View"><a href="#module-View" class="anchor"></a><a href="../../src/re/view.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="View/index.html">View</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Emacs"><a href="#module-Emacs" class="anchor"></a><a href="../../src/re/emacs.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Emacs/index.html">Emacs</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Emacs-style regular expressions</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Glob"><a href="#module-Glob" class="anchor"></a><a href="../../src/re/glob.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Glob/index.html">Glob</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Shell-style regular expressions</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Perl"><a href="#module-Perl" class="anchor"></a><a href="../../src/re/perl.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Perl/index.html">Perl</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Perl-style regular expressions</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Pcre"><a href="#module-Pcre" class="anchor"></a><a href="../../src/re/pcre.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Pcre/index.html">Pcre</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Posix"><a href="#module-Posix" class="anchor"></a><a href="../../src/re/posix.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Posix/index.html">Posix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>References:</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Str"><a href="#module-Str" class="anchor"></a><a href="../../src/re/str.ml.html" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Str/index.html">Str</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module <code>Str</code>: regular expressions and high-level string processing</p></div></div></div></body></html>
