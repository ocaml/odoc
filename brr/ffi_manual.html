<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ffi_manual (brr.ffi_manual)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html">Brr  <span class="version">v0.0.7</span></a> &#x00BB; Brr FFI manual</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="brr-ffi-manual"><a href="#brr-ffi-manual" class="anchor"></a>Brr FFI manual</h1><p>This manual describes how OCaml and JavaScript values are represented by <code>js_of_ocaml</code> and Brr. The companion <a href="ffi_cookbook.html" title="ffi_cookbook">FFI cookbook</a> has a few tips and off-the-shelf design answers for common JavaScript bindings scenarios.</p><p>An OCaml value compiled by <code>js_of_ocaml</code> is encoded as a JavaScript value (see <a href="http://doi.org/10.1002/spe.2187">this paper</a> for outdated yet interesting details). JavaScript does not understand this encoding, conversly OCaml does not understand JavaScript values directly. The <em>foreign function interface</em> (FFI) reconciles these views.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#foreword">Foreword</a></li><li><a href="#js_values">JavaScript values</a></li><li><a href="#equality">Equality</a></li><li><a href="#null_undefined">Null and undefined</a></li><li><a href="#bools">Booleans</a></li><li><a href="#nums">numbers</a></li><li><a href="#strings">Strings</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#objs">Objects</a><ul><li><a href="#global">The <code>global</code> object</a></li><li><a href="#props">Properties</a></li><li><a href="#uprop">Unicode property names</a></li><li><a href="#create_obj">Creating</a></li><li><a href="#create">Creating with constructors</a></li><li><a href="#method">Calling methods</a></li></ul></li><li><a href="#funcs">Functions</a></li><li><a href="#errors">Errors and exceptions</a></li><li><a href="#promises">Promises</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html">Brr  <span class="version">v0.0.7</span></a><ul><li><a href="ffi_cookbook.html">Brr FFI cookbook</a></li><li><a href="#" class="current_unit">Brr FFI manual</a></li><li><a href="ocaml_console.html">OCaml console</a></li><li><a href="web_page_howto.html">Web page howto</a></li><li>Library <code>brr</code><ul><li><a href="brr/Brr/index.html">Brr</a></li><li><a href="brr/Brr_canvas/index.html">Brr_canvas</a></li><li><a href="brr/Brr_io/index.html">Brr_io</a></li><li><a href="brr/Brr_webaudio/index.html">Brr_webaudio</a></li><li><a href="brr/Brr_webcrypto/index.html">Brr_webcrypto</a></li><li><a href="brr/Brr_webgpu/index.html">Brr_webgpu</a></li><li><a href="brr/Brr_webmidi/index.html">Brr_webmidi</a></li><li><a href="brr/Brr_webworkers/index.html">Brr_webworkers</a></li><li><a href="brr/Fut/index.html">Fut</a></li><li><a href="brr/Jstr/index.html">Jstr</a></li><li><a href="brr/Jv/index.html">Jv</a></li></ul></li><li>Library <code>brr.ocaml_poke</code><ul><li><a href="brr.ocaml_poke/Brr_ocaml_poke/index.html">Brr_ocaml_poke</a></li></ul></li><li>Library <code>brr.ocaml_poke_ui</code><ul><li><a href="brr.ocaml_poke_ui/Brr_ocaml_poke_ui/index.html">Brr_ocaml_poke_ui</a></li></ul></li><li>Library <code>brr.poke</code><ul><li><a href="brr.poke/Brr_poke/index.html">Brr_poke</a></li></ul></li><li>Library <code>brr.poked</code><ul><li><a href="brr.poked/Brr_poked/index.html">Brr_poked</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="foreword"><a href="#foreword" class="anchor"></a>Foreword</h2><p>The official <code>js_of_ocaml</code> JavaScript foreign function interface encodes and structurally types JavaScript objects as OCaml object phantom types. This is a very neat trick and topped with the custom syntax offered by <code>js_of_ocaml-ppx</code> this means that you can write perfectly typed and idiomatic JavaScript code in OCaml with unscrutable type error messages.</p><p>We are not keen to program in JavaCamlScript. We are not keen to have to use the round corner of the OCaml language. We are not keen to use an ad-hoc syntax powered by the horrific and brittle <code>ppx</code> system. We want to tap into the browser APIs for the functionality they provide, not for the programming idioms they propose.</p><p>In particular we are not attached to the JavaScript object system and do not feel the need to model it into OCaml types. In Brr we simply hide JavaScript objects behind abstract OCaml types which are acted upon using regular OCaml functions. JavaScript being quite sane about its object-orientation, the occasional mixin or inheritance relationship can be handled with explicit coercions functions.</p><p>This approach exposes the browser APIs in a simple way for both newcomers and working OCaml programmers who can harness the power of the excellent work that went into the <code>js_of_ocaml</code> compiler and its runtime without the need to submit to <code>ppx</code> and less travelled parts of the language.</p><h2 id="js_values"><a href="#js_values" class="anchor"></a>JavaScript values</h2><p>JavaScript values are represented in OCaml programs by the <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> type. A value of this type represents any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_and_Structure_types">JavaScript value</a>: <code>null</code>, <code>undefined</code>, a boolean, a number, a string, an array, an object, a function, etc.</p><p>Except for JavaScript strings which are represented by values of type <a href="brr/Jstr/index.html#type-t"><code>Jstr.t</code></a> nothing is done to type JavaScript values beyond this universal type. JavaScript bindings glue is in charge of manipulating <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values of specific object types and expose them as type safe interfaces by using OCaml abstract types.</p><p>The <a href="brr/Jv/index.html#val-repr"><code>Jv.repr</code></a> function returns the JavaScript representation of any OCaml value, it is the moral equivalent of <code>Obj.repr</code> for the JavaScript encoding of OCaml values made by <code>js_of_ocaml</code> compilation.</p><h2 id="equality"><a href="#equality" class="anchor"></a>Equality</h2><p>The <a href="brr/Jv/index.html"><code>Jv</code></a> module provides access to JavaScript equality operators on <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values:</p><ul><li><a href="brr/Jv/index.html#val-equal"><code>Jv.equal</code></a> is JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code></a>, which tries to convert operands of different types to assess equality.</li><li><a href="brr/Jv/index.html#val-strict_equal"><code>Jv.strict_equal</code></a> is JavaScript's strict equality <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality"><code>===</code></a> which always considers operands of different types to be different</li></ul><p>The OCaml <code>( = )</code> structural equality is implemented as per OCaml semantics on OCaml values. What it does on JavaScript values does not seem to be properly documented (get in touch if you know any better) ‚Äì you will have to make sense of <a href="https://github.com/ocsigen/js_of_ocaml/blob/master/runtime/compare.js">the source</a>.</p><p>The OCaml <code>( == )</code> physical equality is compiled to JavaScript's strict equality <code>===</code>.</p><p>To sum up we have:</p><pre>OCaml             Compiled JavaScript
---------------------------------------
Jv.equal          ==
Jv.strict_equal   ===
( = )             caml_equal
( == )            ===</pre><h2 id="null_undefined"><a href="#null_undefined" class="anchor"></a>Null and undefined</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can <em>always</em> be <code>null</code> or <code>undefined</code>. In what follows we call <em>safe</em> a value that is guaranteed not be <code>null</code> or <code>undefined</code> and <em>unsafe</em> one that may be.</p><p>OCaml got rid of null pointer errors so don't let these values go back haunt your stack traces. Make sure to always handle them immediately in the context where they occur ‚Äì otherwise they will propagate and blow up in your face at unrelated points in your code.</p><p><code>null</code> is represented by <a href="brr/Jv/index.html#val-null"><code>Jv.null</code></a> and <code>undefined</code> by <a href="brr/Jv/index.html#val-undefined"><code>Jv.undefined</code></a>. You can test for them with the <a href="brr/Jv/index.html#val-is_null"><code>Jv.is_null</code></a> and <a href="brr/Jv/index.html#val-is_undefined"><code>Jv.is_undefined</code></a> predicates which make sure to use the correct JavaScript equality function.</p><pre class="language-ocaml"><code>let is_null = Jv.is_null jv            (* true iff [jv] is null *)
let is_undefined = Jv.is_undefined jv  (* true iff [jv] is undefined *)</code></pre><p>In general it's a good idea to defensively test for both; the functions <a href="brr/Jv/index.html#val-is_none"><code>Jv.is_none</code></a> and <a href="brr/Jv/index.html#val-is_some"><code>Jv.is_some</code></a> do that directly.</p><pre class="language-ocaml"><code>let is_none = Jv.is_none jv  (* true iff null or undefined *)
let is_some = Jv.is_some jv  (* false iff null or undefined *)</code></pre><p>For APIs that use these values to denote absence of values, use the <a href="brr/Jv/index.html#val-to_option"><code>Jv.to_option</code></a> function when you convert <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values to OCaml types. It handles <code>null</code> and <code>undefined</code> by mapping them to <code>None</code>.</p><pre class="language-ocaml"><code>let safe_int : int option = Jv.to_option Jv.to_int jv
let safe_jv : Jv.t option = Jv.to_option Fun.id jv</code></pre><p>If you are on the way from OCaml to JavaScript you have to choose to map <code>None</code> values to one of <code>null</code>, <code>undefined</code> or something else. The <code>none</code> argument of <a href="brr/Jv/index.html#val-of_option"><code>Jv.of_option</code></a> specifies this:</p><pre class="language-ocaml"><code>let jv = Jv.of_option ~none:Jv.null Fun.id v         (* None is null *)
let jv = Jv.of_option ~none:Jv.undefined Fun.id v    (* None is undefined *)
let jv = Jv.of_option ~none:Jstr.empty Jv.of_jstr v  (* None is empty *)</code></pre><h2 id="bools"><a href="#bools" class="anchor"></a>Booleans</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript booleans.</p><p><a href="brr/Jv/index.html#val-of_bool"><code>Jv.of_bool</code></a> and <a href="brr/Jv/index.html#val-to_bool"><code>Jv.to_bool</code></a> convert them with OCaml <code>bool</code>s. <a href="brr/Jv/index.html#val-to_bool"><code>Jv.to_bool</code></a> is unsafe, it does not check for <code>null</code> or <code>undefined</code>. If needed combine with <a href="brr/Jv/index.html#val-is_none"><code>Jv.is_none</code></a>:</p><pre class="language-ocaml"><code>let safe_bool : bool = if Jv.is_none jv then false else Jv.to_bool jv</code></pre><p>OCaml <code>bool</code> values are not represented by JavaScript booleans. Make sure not to directly give a JavaScript boolean to an OCaml function expecting a <code>bool</code> value and vice-versa; always go through the conversion functions.</p><h2 id="nums"><a href="#nums" class="anchor"></a>numbers</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript numbers.</p><p><a href="brr/Jv/index.html#val-of_int"><code>Jv.of_int</code></a> and <a href="brr/Jv/index.html#val-to_int"><code>Jv.to_int</code></a> convert them with OCaml <code>int</code>s. <a href="brr/Jv/index.html#val-of_float"><code>Jv.of_float</code></a> and <a href="brr/Jv/index.html#val-to_float"><code>Jv.to_float</code></a> convert them with OCaml <code>float</code>s. Both <a href="brr/Jv/index.html#val-to_int"><code>Jv.to_int</code></a> and <a href="brr/Jv/index.html#val-to_float"><code>Jv.to_float</code></a> are unsafe, they do not check for <code>null</code> or <code>undefined</code>. If needed combine them with <a href="brr/Jv/index.html#val-of_option"><code>Jv.of_option</code></a>:</p><pre class="language-ocaml"><code>let i : int option = Jv.to_option Jv.to_int jv</code></pre><p>The conversions are lossless, except if you convert a non-integral JavaScript number with <a href="brr/Jv/index.html#val-to_int"><code>Jv.to_int</code></a>.</p><p>OCaml <code>int</code> and <code>float</code> values are directly represented by JavaScript numbers. This means the conversion are nops. Nevertheless use the conversion functions to insulate yourself of changes <code>js_of_ocaml</code> might make in the future.</p><h2 id="strings"><a href="#strings" class="anchor"></a>Strings</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript strings.</p><p>JavaScript strings are immutable sequences of UTF-16 encoded Unicode text. OCaml <code>string</code>s are immutable sequences of bytes and nowadays assumed to be UTF-8 encoded text <em>when interpreted as textual content</em>.</p><p>Because of this difference we use a dedicated data type <a href="brr/Jstr/index.html#type-t"><code>Jstr.t</code></a> for JavaScript strings. Values of this type directly represent a JavaScript <code>String</code> object. Use <a href="brr/Jstr/index.html#type-t"><code>Jstr.t</code></a> values to represent the strings returned to you by JavaScript APIs, not OCaml <code>string</code>s. This avoids constantly converting representations between UTF-16 and UTF-8.</p><p>The <a href="brr/Jstr/index.html#val-v"><code>Jstr.v</code></a> function takes an UTF-8 encoded OCaml string and translates it to an UTF-16 encoded JavaScript string. By UTF-8 encoding OCaml sources this almosts gives us a literal notation for JavaScript strings:</p><pre class="language-ocaml"><code>let s : Jstr.t = Jstr.v &quot;A JavaScript string&quot;</code></pre><p>If the OCaml string is only made of US-ASCII characters like above the <code>js_of_ocaml</code> compiler compiles the call and OCaml string literal <em>directly</em> to a JavaScript string literal. However if the literal has non US-ASCII Unicode characters, a runtime conversion occurs for now (see <a href="https://github.com/ocsigen/js_of_ocaml/issues/1034">this issue</a>):</p><pre class="language-ocaml"><code>let s : Jstr.t = Jstr.v &quot;üê´&quot; (* UTF-8 to UTF-16 conversion at runtime *)</code></pre><p>To convert a JavaScript string to an UTF-8 encoded OCaml string use <a href="brr/Jstr/index.html#val-to_string"><code>Jstr.to_string</code></a>.</p><p>Conversion between <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values and <a href="brr/Jstr/index.html#type-t"><code>Jstr.t</code></a> are nops, but do use the <a href="brr/Jv/index.html#val-of_jstr"><code>Jv.of_jstr</code></a> and <a href="brr/Jv/index.html#val-to_jstr"><code>Jv.to_jstr</code></a> functions.</p><h2 id="arrays"><a href="#arrays" class="anchor"></a>Arrays</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript arrays.</p><p>The <a href="brr/Jv/Jarray/index.html"><code>Jv.Jarray</code></a> module provides functions to directly manipulate them. In general you will want to convert them to OCaml arrays or lists, the functions <a href="brr/Jv/index.html#val-to_array"><code>Jv.to_array</code></a>, <a href="brr/Jv/index.html#val-of_array"><code>Jv.of_array</code></a>, <a href="brr/Jv/index.html#val-to_list"><code>Jv.to_list</code></a>, <a href="brr/Jv/index.html#val-of_list"><code>Jv.of_list</code></a> do this aswell as a few <a href="brr/Jv/index.html#array_special" title="array_special">specialized</a> conversion functions.</p><p>JavaScript arrays and OCaml <code>list</code>s and <code>array</code>s are represented differently, these conversions are not free.</p><h2 id="objs"><a href="#objs" class="anchor"></a>Objects</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript objects.</p><h3 id="global"><a href="#global" class="anchor"></a>The <code>global</code> object</h3><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis">global object</a> is represented by the <a href="brr/Jv/index.html#val-global"><code>Jv.global</code></a> value. This object is used to access the global scope in window and non-window contexts. For example to look for functions, object constructors or global values.</p><h3 id="props"><a href="#props" class="anchor"></a>Properties</h3><p>Functions <a href="brr/Jv/index.html#val-find"><code>Jv.find</code></a>, <a href="brr/Jv/index.html#val-get"><code>Jv.get</code></a>, <a href="brr/Jv/index.html#val-set"><code>Jv.set</code></a> and <a href="brr/Jv/index.html#val-delete"><code>Jv.delete</code></a> operate on object properties of <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values. <a href="brr/Jv/index.html#val-get"><code>Jv.get</code></a> returns <code>undefined</code> if the property is undefined and <code>null</code> if it is defined but <code>null</code>; use <a href="brr/Jv/index.html#val-find"><code>Jv.find</code></a> to safely map these cases to <code>None</code>.</p><pre class="language-ocaml"><code>let get_prop o = Jv.get o &quot;prop&quot;
let set_prop o v = Jv.set o &quot;prop&quot; v
let delete_prop o = Jv.delete o &quot;prop&quot;
let find_prop o = Jv.find o &quot;prop&quot; (* handles [null] and [undefined] *)</code></pre><p>These property functions return and take <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values. In practice you have to further convert these values to the types they represent. For example for an <code>int</code> property:</p><pre class="language-ocaml"><code>let length o = Jv.to_int (Jv.get o &quot;length&quot;)
let set_length o l = Jv.set o &quot;length&quot; (Jv.of_int l)</code></pre><p>To make these conversions more streamlined for basic types, <a href="brr/Jv/index.html"><code>Jv</code></a> provides the <a href="brr/Jv/Bool/index.html"><code>Jv.Bool</code></a>, <a href="brr/Jv/Int/index.html"><code>Jv.Int</code></a>, <a href="brr/Jv/Float/index.html"><code>Jv.Float</code></a> and <a href="brr/Jv/Jstr/index.html"><code>Jv.Jstr</code></a> submodules which have property functions converting directly with the corresponding OCaml types. Using <a href="brr/Jv/Int/index.html"><code>Jv.Int</code></a> the example above rewrites to:</p><pre class="language-ocaml"><code>let length o = Jv.Int.get o &quot;length&quot;
let set_length l = Jv.Int.set o &quot;length&quot; l</code></pre><p>An few other example:</p><pre class="language-ocaml"><code>let name o = Jv.Jstr.get o &quot;name&quot;
let set_name o s = Jv.Jstr.set o &quot;name&quot; s
let pi = Jv.Float.get (Jv.get Jv.global &quot;Math&quot;) &quot;PI&quot;</code></pre><h3 id="uprop"><a href="#uprop" class="anchor"></a>Unicode property names</h3><p>Most object property names in APIs are made only of US-ASCII characters. For these properties the functions seen so far work perfectly.</p><p>However if you do hit property names that have arbitrary Unicode characters you <em>cannot</em> use these. You need to use these primed primitives: <a href="brr/Jv/index.html#val-get'"><code>Jv.get'</code></a>, <a href="brr/Jv/index.html#val-set'"><code>Jv.set'</code></a> and <a href="brr/Jv/index.html#val-delete'"><code>Jv.delete'</code></a>. These functions take a <a href="brr/Jstr/index.html#type-t"><code>Jstr.t</code></a> for the property name:</p><pre class="language-ocaml"><code>let pi2_prop = Jstr.v &quot;œÄ¬≤&quot; (* make sure we don't convert on each call *)
let pi2 o = Jv.to_float (Jv.get' o pi2_prop)</code></pre><h3 id="create_obj"><a href="#create_obj" class="anchor"></a>Creating</h3><p>A new object can be created via <a href="brr/Jv/index.html#val-obj"><code>Jv.obj</code></a> which simply takes an array of name/value pairs:</p><pre class="language-ocaml"><code>let o = Jv.obj Jv.[| &quot;length&quot;, of_int 3; &quot;name&quot;, of_jstr (Jstr.v &quot;Ha!&quot;) |]</code></pre><p>If you need to handle full Unicode names use <a href="brr/Jv/index.html#val-obj'"><code>Jv.obj'</code></a>:</p><pre class="language-ocaml"><code>let pi2_prop = Jstr.v &quot;œÄ¬≤&quot; (* make sure we don't convert on each call *)
let o = Jv.obj' Jv.[| pi2_prop, of_float (pi *. pi) |]</code></pre><h3 id="create"><a href="#create" class="anchor"></a>Creating with constructors</h3><p>A new object is created with a constructor by first looking the constructor function in the global object and then call it with <a href="brr/Jv/index.html#val-new'"><code>Jv.new'</code></a>:</p><pre class="language-ocaml"><code>let date = Jv.get Jv.global &quot;Date&quot;
let date_of_ptime_ms ms = Jv.new' date [| Jv.of_float ms |]</code></pre><h3 id="method"><a href="#method" class="anchor"></a>Calling methods</h3><p>To call a method on a object, construct an OCaml array of <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values representing the method arguments and use <a href="brr/Jv/index.html#val-call"><code>Jv.call</code></a> on the object</p><pre class="language-ocaml"><code>let to_jstr o = Jv.to_jstr (Jv.call o &quot;toString&quot; [||])</code></pre><h2 id="funcs"><a href="#funcs" class="anchor"></a>Functions</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript functions and closures.</p><p>To call a function, look it up in the global object, construct an OCaml array of <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> values representing the arguments and invoke <a href="brr/Jv/index.html#val-apply"><code>Jv.apply</code></a>.</p><pre class="language-ocaml"><code>let atob = Jv.get Jv.global &quot;atob&quot;
let base64 s = Jv.to_jstr @@ Jv.apply atob Jv.[| of_jstr s |]</code></pre><p>For information about calling back from JavaScript to OCaml see the <a href="ffi_cookbook.html#callback" title="callback">cookbook</a>.</p><h2 id="errors"><a href="#errors" class="anchor"></a>Errors and exceptions</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript <code>Error</code> objects.</p><p>The <a href="brr/Jv/Error/index.html"><code>Jv.Error</code></a> module has a dedicated type and functions to handle them. Use the <a href="brr/Jv/index.html#val-of_error"><code>Jv.of_error</code></a> and <a href="brr/Jv/index.html#val-to_error"><code>Jv.to_error</code></a> functions to convert them with <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> objects.</p><p>JavaScript exceptions are thrown in your face as the OCaml <a href="brr/Jv/index.html#exception-Error"><code>Jv.Error</code></a> which holds a <a href="brr/Jv/Error/index.html#type-t"><code>Jv.Error.t</code></a> value. So handling JavaScript exceptions is just a matter of catching that exception:</p><pre class="language-ocaml"><code>let result_of_raising f v = match f v with
| exception (Jv.Error e) -&gt; Error (Jv.Error.message e)
| v -&gt; Ok v</code></pre><p>If you want to throw a JavaScript exception yourself from OCaml code use <a href="brr/Jv/index.html#val-throw"><code>Jv.throw</code></a>.</p><h2 id="promises"><a href="#promises" class="anchor"></a>Promises</h2><p>Values of type <a href="brr/Jv/index.html#type-t"><code>Jv.t</code></a> can represent JavaScript promise objects.</p><p>The <a href="brr/Jv/Promise/index.html"><code>Jv.Promise</code></a> module has a type and few functions to handle them directly. However <a href="brr/Brr/index.html"><code>Brr</code></a> uses <a href="brr/Fut/index.html"><code>Fut</code></a> values to safely type them. This is the module you should use to interact with JavaScript promises, see the <a href="ffi_cookbook.html#promises" title="promises">cookbook</a> for explanations.</p></div></body></html>
