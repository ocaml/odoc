<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>driver (odoc.driver)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html">The odoc documentation generator</a> &#x00BB; How to Drive <code>odoc</code></nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="how-to-drive-odoc"><a href="#how-to-drive-odoc" class="anchor"></a>How to Drive <code>odoc</code></h1><p><code>odoc</code> is a CLI tool to create API and documentation for OCaml projects. However, it operates at a rather low level, taking individual files through several distinct phases until the HTML output is generated.</p><p>For this reason, just like for building any multifiles OCaml project, <code>odoc</code> needs to be driven by a higher level tool. The driver will take care of calling the <code>odoc</code> command with the right arguments throughout the different phases. The <a href="../odoc-driver/index.html" title="index">odoc-driver</a> package contains a &quot;reference driver&quot;, that is kept up-to-date with the latest development of <code>odoc</code>,</p><p>Several drivers for <code>odoc</code> exist, such as: <a href="https://dune.readthedocs.io/en/stable/documentation.html">dune</a> and <a href="../odig/index.html" title="index">odig</a>.</p><p>This document explains how to drive <code>odoc</code>, as of version 3. It is not needed to know any of this to <em>use</em> <code>odoc</code>, it is targeted at driver authors, tools that interact with <code>odoc</code>, or any curious passerby. This includes several subjects:</p><ul><li>A big picture view of the doc generation model,</li><li>A unified explanation for the various command line flags,</li><li>An explanation of the <code>odoc</code> pipeline,</li><li>A convention for building docs for <code>opam</code>-installed packages.</li></ul><p>In addition to the documentation, the reference driver is a good tool to understand how to build <code>odoc</code> projects. It can be useful to look at the implementation code, but it can also help to simply look at all invocations of <code>odoc</code> during a run of the driver.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#units">Trees of documentation</a></li><li><a href="#the-doc-generation-pipeline">The doc generation pipeline</a><ul><li><a href="#the-compile-phase">The compile phase</a><ul><li><a href="#compiling-interfaces">Compiling interfaces</a></li><li><a href="#compiling-implementations">Compiling implementations</a></li><li><a href="#compiling-assets">Compiling assets</a></li></ul></li><li><a href="#the-link-phase">The link phase</a></li><li><a href="#the-indexing-phase">The indexing phase</a><ul><li><a href="#counting-occurrences">Counting occurrences</a></li><li><a href="#indexing-entries">Indexing entries</a></li></ul></li><li><a href="#the-generation-phase">The generation phase</a><ul><li><a href="#a-javascript-file-for-search-requests">A JavaScript file for search requests</a></li><li><a href="#interfaces-and-pages">Interfaces and pages</a></li><li><a href="#source-code">Source code</a></li><li><a href="#generating-docs-for-assets">Generating docs for assets</a></li></ul></li></ul></li><li><a href="#conv">Convention for installed packages</a><ul><li><a href="#the--p-and--l-trees,-and-their-root-ids">The <code>-P</code> and <code>-L</code> trees, and their root ids</a></li><li><a href="#link-time-dependencies">Link-time dependencies</a></li><li><a href="#the-units">The units</a></li><li><a href="#the---parent-id-arguments">The <code>--parent-id</code> arguments</a></li><li><a href="#the---source-id-arguments">The <code>--source-id</code> arguments</a></li><li><a href="#ordering-the-generated-pages">Ordering the generated pages</a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html">The odoc documentation generator</a><ul><li><a href="odoc_for_authors.html"><code>odoc</code> for Authors</a></li><li><a href="cheatsheet.html">Cheatsheet</a></li><li><a href="dune.html">Dune and odoc</a></li><li><a href="features.html">Language Features</a></li><li><a href="ocamldoc_differences.html">Markup Differences From OCamldoc</a></li><li><a href="interface.html"><code>odoc</code> Interface Guarantees</a></li><li><a href="#" class="current_unit">How to Drive <code>odoc</code></a></li><li><a href="json.html">JSON output</a></li><li><a href="deprecated/index.html">Deprecated features</a></li><li>Library <code>odoc.document</code><ul><li><a href="odoc.document/Odoc_document/index.html">Odoc_document</a></li></ul></li><li>Library <code>odoc.examples</code><ul><li><a href="odoc.examples/Odoc_examples/index.html">Odoc_examples</a></li></ul></li><li>Library <code>odoc.html</code><ul><li><a href="odoc.html/Odoc_html/index.html">Odoc_html</a></li></ul></li><li>Library <code>odoc.html_support_files</code><ul><li><a href="odoc.html_support_files/Odoc_html_support_files/index.html">Odoc_html_support_files</a></li></ul></li><li>Library <code>odoc.index</code><ul><li><a href="odoc.index/Odoc_index/index.html">Odoc_index</a></li></ul></li><li>Library <code>odoc.json_index</code><ul><li><a href="odoc.json_index/Odoc_json_index/index.html">Odoc_json_index</a></li></ul></li><li>Library <code>odoc.latex</code><ul><li><a href="odoc.latex/Odoc_latex/index.html">Odoc_latex</a></li></ul></li><li>Library <code>odoc.loader</code><ul><li><a href="odoc.loader/Odoc_loader/index.html">Odoc_loader</a></li></ul></li><li>Library <code>odoc.manpage</code><ul><li><a href="odoc.manpage/Odoc_manpage/index.html">Odoc_manpage</a></li></ul></li><li>Library <code>odoc.model</code><ul><li><a href="odoc.model/Odoc_model/index.html">Odoc_model</a></li></ul></li><li>Library <code>odoc.model_desc</code><ul><li><a href="odoc.model_desc/Odoc_model_desc/index.html">Odoc_model_desc</a></li></ul></li><li>Library <code>odoc.ocamlary</code><ul><li><a href="odoc.ocamlary/Ocamlary/index.html">Ocamlary</a></li></ul></li><li>Library <code>odoc.occurrences</code><ul><li><a href="odoc.occurrences/Odoc_occurrences/index.html">Odoc_occurrences</a></li></ul></li><li>Library <code>odoc.odoc</code><ul><li><a href="odoc.odoc/Odoc_odoc/index.html">Odoc_odoc</a></li></ul></li><li>Library <code>odoc.odoc_utils</code><ul><li><a href="odoc.odoc_utils/Odoc_utils/index.html">Odoc_utils</a></li></ul></li><li>Library <code>odoc.search</code><ul><li><a href="odoc.search/Odoc_search/index.html">Odoc_search</a></li></ul></li><li>Library <code>odoc.search_html_frontend</code><ul><li><a href="odoc.search_html_frontend/Odoc_html_frontend/index.html">Odoc_html_frontend</a></li></ul></li><li>Library <code>odoc.syntax_highlighter</code><ul><li><a href="odoc.syntax_highlighter/Syntax_highlighter/index.html">Syntax_highlighter</a></li></ul></li><li>Library <code>odoc.xref2</code><ul><li><a href="odoc.xref2/Odoc_xref2/index.html">Odoc_xref2</a></li></ul></li><li>Library <code>odoc.xref_test</code><ul><li><a href="odoc.xref_test/Odoc_xref_test/index.html">Odoc_xref_test</a></li></ul></li><li><a href="src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="units"><a href="#units" class="anchor"></a>Trees of documentation</h2><p>In its third major version, <code>odoc</code> has been improved so that the same documentation can work on multiple scenarios, from local switches to big monorepos, or the <a href="https://ocaml.org/packages">ocaml.org</a> hub of documentation for all packages, without anything breaking, especially references.</p><p>The idea is that we have named groups of documentation, that we'll call <em>trees</em> here. We have two kinds of trees: page trees, and modules trees. Inside the trees, the hierarchy is managed by <code>odoc</code>. The driver is free to &quot;root&quot; them however they like in the overall hierarchy. So <code>odoc</code> is responsible for the hierarchy below the trees root, and the driver is responsible for the one outside of the trees. In order to reference another tree, a documentation author can use the name of the tree in the reference.</p><p>Different situations will give different meanings to the trees. In the case of <code>opam</code> packages, though, there is a natural meaning to give to those trees (you'll find more details in the <a href="#conv" title="conv">convention for opam-installed packages</a>). Any opam package will have an associated &quot;documentation tree&quot;, named with the name of the package. Any of its libraries will have an associated &quot;module tree&quot;, named with the name of the library. Another package can thus refer to the doc using the package name, or to any of its library using the library name, no matter where the package is located in the hierarchy.</p><h2 id="the-doc-generation-pipeline"><a href="#the-doc-generation-pipeline" class="anchor"></a>The doc generation pipeline</h2><p>Just like when compiling OCaml modules, generating docs for these modules need to be run in a specific order, as some information for generating docs for a file might reside in another one. However, <code>odoc</code> actually allows a particular file to reference a module that depends on it, seemingly creating a circular dependency.</p><p>This circular dependency problem is one of the reasons we have several phases in <code>odoc</code>. Let's review them:</p><ul><li>The <code>compile</code> phase, which is used to create the <code>.odoc</code> artifacts from <code>.cm{i;t;ti}</code> and <code>.mld</code> files. This is where <code>odoc</code> does similar work to that of the OCaml compiler, computing expansions for each module types. The dependencies between are the same as the ones for the <code>.cm{i;t;ti}</code> input.</li></ul><ul><li>The <code>link</code> phase transforms the <code>.odoc</code> artifacts to <code>.odocl</code>. The main result of this phase is to resolve odoc references, which also has an effect on canonical modules.</li></ul><ul><li>The <code>indexing</code> phase generates <code>.odoc-index</code> files from sets of <code>.odocl</code> files. These index files will be used both for generating a global sidebar, and for generating a search index.</li></ul><ul><li>The <code>generation</code> phase takes the <code>.odocl</code> and <code>.odoc-index</code> files and turns them into either HTML, man pages or Latex files.</li></ul><h3 id="the-compile-phase"><a href="#the-compile-phase" class="anchor"></a>The compile phase</h3><p>The compile phase takes as input a set of <code>.cm{i;t;ti}</code> as well as <code>.mld</code> files, and builds a directory hierarchy of <code>.odoc</code> files.</p><p>There are distinct commands for this phase: <code>odoc compile</code> for interfaces and pages, <code>odoc compile-impl</code> for implementations, and <code>odoc compile-asset</code> for assets.</p><h4 id="compiling-interfaces"><a href="#compiling-interfaces" class="anchor"></a>Compiling interfaces</h4><p>Let's have a look at a generic invocation of <code>odoc</code> during the compile phase:</p><pre class="language-shell"><code>$ odoc compile --output-dir &lt;od&gt; --parent-id &lt;pid&gt; -I &lt;dir1&gt; -I &lt;dir2&gt; &lt;input-file&gt;.&lt;ext&gt;</code></pre><ul><li><code>&lt;input-file&gt;.&lt;ext&gt;</code> is the input file, either a <code>.cm{i;t;ti}</code> file or an <code>.mld</code> file. Prefer <code>.cmti</code> files over the other formats!</li></ul><ul><li><code>--output-dir &lt;od&gt;</code> allows to specify the directory that will contain all the <code>.odoc</code> files. This directory has to be fully managed by <code>odoc</code> and should not be modified by another tool! The output file depends on the <code>--parent-id</code> option.</li></ul><ul><li><code>--parent-id &lt;pid&gt;</code> allows to place the output <code>.odoc</code> file in the documentation hierarchy. This consists in a <code>/</code> separated sequence of non empty strings (used as directory name). This &quot;path&quot; determines where the <code>.odoc</code> file will be located below the <code>&lt;od&gt;</code> output dir. The name of the output file is <code>&lt;input-file&gt;.odoc</code> for modules, and <code>page-&lt;input-file&gt;.odoc</code> for pages. Documentation artifacts that will be in the same <a href="#units" title="units">unit of documentation</a> need to hare a common root in their parent id.</li></ul><ul><li><code>-I &lt;dir&gt;</code> corresponds to the search path for other <code>.odoc</code> files. Multiple directory can be added to the search path, so every required <code>.odoc</code> file is in the search path. The required <code>.odoc</code> files are the one generated from a <code>.cm{i;t;ti}</code> file listed when calling <code>odoc compile-deps</code> on the input file.</li></ul><p>A concrete example for such command would be:</p><pre class="language-shell"><code>$ odoc compile
     ~/.opam/5.2.0/lib/ppxlib/ppxlib__Extension.cmti
     --output-dir _odoc/
     -I _odoc/ocaml-base-compiler/compiler-libs.common
     -I _odoc/ocaml-base-compiler/stdlib
     -I _odoc/ocaml-compiler-libs/ocaml-compiler-libs.common
     -I _odoc/ppxlib/ppxlib
     -I _odoc/ppxlib/ppxlib.ast
     -I _odoc/ppxlib/ppxlib.astlib
     -I _odoc/ppxlib/ppxlib.stdppx
     -I _odoc/ppxlib/ppxlib.traverse_builtins
     -I _odoc/sexplib0/sexplib0
     --parent-id ppxlib/ppxlib</code></pre><h4 id="compiling-implementations"><a href="#compiling-implementations" class="anchor"></a>Compiling implementations</h4><p>A <code>compile-impl</code> command is pretty similar:</p><pre class="language-shell"><code>$ odoc compile-impl --output-dir &lt;od&gt; --source-id &lt;sid&gt; --parent-id &lt;pid&gt; -I &lt;dir1&gt; -I &lt;dir2&gt; &lt;input-file&gt;.&lt;ext&gt;</code></pre><ul><li><code>&lt;input-file&gt;.cmt</code> is the input file, it has to be a <code>.cmt</code> file.</li></ul><ul><li><code>--output-dir &lt;od&gt;</code> has the same meaning as for <code>odoc compile</code>.</li></ul><ul><li><code>--parent-id &lt;pid&gt;</code> also has the same meaning as for <code>odoc compile</code>. However, the name of the output file is <code>impl-&lt;input-file&gt;.odoc</code>. Implementations need to be available through the <code>-I</code> search path, so it is very likely that one wants the implementation and interface <code>.odoc</code> files to share the same parent id.</li></ul><ul><li><code>-I &lt;dir&gt;</code> also corresponds to the search path for other <code>.odoc</code> files.</li></ul><ul><li><code>source-id &lt;sid&gt;</code> is a new argument specific to <code>compile-impl</code>. This corresponds to the location of the rendering of the source, which is required to generate links to it.</li></ul><p>A concrete example for such command would be:</p><pre class="language-shell"><code>$ odoc compile-impl
      ~/.opam/5.2.0/lib/ppxlib/ppxlib__Spellcheck.cmt
      --output-dir _odoc/
      -I _odoc/ocaml-base-compiler/compiler-libs.common
      -I _odoc/ocaml-base-compiler/stdlib
      -I _odoc/ocaml-compiler-libs/ocaml-compiler-libs.common
      -I _odoc/ppxlib/ppxlib
      -I _odoc/ppxlib/ppxlib.ast
      -I _odoc/ppxlib/ppxlib.astlib
      -I _odoc/ppxlib/ppxlib.stdppx
      -I _odoc/sexplib0/sexplib0
      --enable-missing-root-warning
      --parent-id ppxlib/ppxlib
      --source-id ppxlib/src/ppxlib/spellcheck.ml</code></pre><h4 id="compiling-assets"><a href="#compiling-assets" class="anchor"></a>Compiling assets</h4><p>Assets are given during the generation phase. But we still need to create an <code>.odoc</code> file, for <code>odoc</code>'s resolution mechanism.</p><pre class="language-shell"><code>$ odoc compile-asset --output-dir &lt;od&gt; --parent-id &lt;pid&gt; --name &lt;assetname&gt;</code></pre><ul><li><code>--output-dir</code> and <code>--parent-id</code> are identical to the <code>compile</code> and <code>compile-impl</code> commands,</li></ul><ul><li><code>--name &lt;assetname&gt;</code> gives the asset name.</li></ul><ul><li>The output file name is computed from the previous values as <code>&lt;output-dir&gt;/&lt;parent-id&gt;/asset-&lt;assetname&gt;.odoc</code>.</li></ul><h3 id="the-link-phase"><a href="#the-link-phase" class="anchor"></a>The link phase</h3><p>The link phase requires the directory of the <code>compile</code> phase to generate its set of <code>.odocl</code> files. This phase resolves references and canonicals.</p><p>A generic link command is:</p><pre class="language-shell"><code>$ odoc link
    -I &lt;dir1&gt; -I &lt;dir2&gt;
    -P &lt;pname1&gt;:&lt;pdir1&gt; -P &lt;pname2&gt;:&lt;pdir2&gt;
    -L &lt;lname1&gt;:&lt;ldir1&gt; -L &lt;lname2&gt;:&lt;ldir2&gt;
    &lt;path/to/file.odoc&gt;</code></pre><ul><li><code>&lt;path/to/file.odoc</code> is the input <code>.odoc</code> file. The result of this command is <code>path/to/file.odocl</code>. This path was determined by <code>--output-dir</code> and <code>--parent-id</code> from the link phase, and it is important for the indexing phase that it stays in the same location.</li></ul><ul><li><code>-P &lt;name&gt;:&lt;dir&gt;</code> are used to list the &quot;page trees&quot;, used to resolve references such as <code>{!/ocamlfind/index}</code>.</li></ul><ul><li><code>-L &lt;name&gt;:&lt;dir&gt;</code> are used to list the &quot;module trees&quot;, used to resolve references such as <code>{!/findlib.dynload/Fl_dynload}</code>. This also adds <code>&lt;dir&gt;</code> to the search path.</li></ul><ul><li><code>-I &lt;dir&gt;</code> adds <code>&lt;dir&gt;</code> to the search path. The search path is used to resolve references that do not use the &quot;named tree&quot; mechanism, such as <code>{!Module}</code> and <code>{!page-pagename}</code>.</li></ul><h3 id="the-indexing-phase"><a href="#the-indexing-phase" class="anchor"></a>The indexing phase</h3><p>The indexing phase refers to the &quot;crunching&quot; of information split in several <code>.odocl</code> files. Currently, there are two use-cases for this phase:</p><ul><li>Generating a search index. This requires all information from linked interfaces and pages, but also form linked implementations in order to sort results (by number of occurrences).</li></ul><ul><li>Generating a global sidebar.</li></ul><h4 id="counting-occurrences"><a href="#counting-occurrences" class="anchor"></a>Counting occurrences</h4><p>This step counts the number of occurrences of each value/type/... in the implementation, and stores them in a table. A generic invocation is:</p><pre class="language-shell"><code>$ odoc count-occurrences &lt;dir1&gt; &lt;dir2&gt; -o &lt;path/to/name.odoc-occurrences&gt;</code></pre><p>An example of such command:</p><pre class="language-shell"><code>$ odoc count-occurrences _odoc/ -o _odoc/occurrences-all.odoc-occurrences</code></pre><h4 id="indexing-entries"><a href="#indexing-entries" class="anchor"></a>Indexing entries</h4><p>The <code>odoc compile-index</code> produces an <code>.odoc-index</code> file, from <code>.odocl</code> files, other <code>.odoc-index</code> files, and possibly some <code>.odoc-occurrences</code> files.</p><p>To create an index for the page and documentation units, we use the <code>-P</code> and <code>-L</code> arguments.</p><pre class="language-shell"><code>$ odoc compile-index
    -o path/to/&lt;indexname&gt;.odoc-index
    -P &lt;pname1&gt;:&lt;ppath1&gt;
    -P &lt;pname2&gt;:&lt;ppath2&gt;
    -L &lt;lname1&gt;:&lt;lpath1&gt;
    -L &lt;lname2&gt;:&lt;lpath2&gt;
    --occurrences &lt;path/to/name.odoc-occurrences&gt;</code></pre><p>An example of such command:</p><pre class="language-shell"><code>$ odoc compile-index
    -o _odoc/ppxlib/index.odoc-index
    -P ppxlib:_odoc/ppxlib
    -L ppxlib:_odoc/ppxlib/ppxlib
    -L ppxlib.ast:_odoc/ppxlib/ppxlib.ast
    -L ppxlib.astlib:_odoc/ppxlib/ppxlib.astlib
    -L ppxlib.metaquot:_odoc/ppxlib/ppxlib.metaquot
    -L ppxlib.metaquot_lifters:_odoc/ppxlib/ppxlib.metaquot_lifters
    -L ppxlib.print_diff:_odoc/ppxlib/ppxlib.print_diff
    -L ppxlib.runner:_odoc/ppxlib/ppxlib.runner
    -L ppxlib.runner_as_ppx:_odoc/ppxlib/ppxlib.runner_as_ppx
    -L ppxlib.stdppx:_odoc/ppxlib/ppxlib.stdppx
    -L ppxlib.traverse:_odoc/ppxlib/ppxlib.traverse
    -L ppxlib.traverse_builtins:_odoc/ppxlib/ppxlib.traverse_builtins
    --occurrences _odoc/occurrences-all.odoc-occurrences</code></pre><h3 id="the-generation-phase"><a href="#the-generation-phase" class="anchor"></a>The generation phase</h3><p>The generation phase is the phase that takes all information computed in previous files, and actually generates the documentation. It can take the form of HTML, Latex and manpages, although currently HTML is the <code>odoc</code> backend that supports the most functionalities (such as images, videos, ...).</p><p>In this manual, we describe the HTML generation usecase. Usually, generating for other backend boils down to replacing <code>html-generate</code> by <code>latex-generate</code> or <code>man-generate</code>, refer to the manpage to see the diverging options.</p><p>Given an <code>.odocl</code> file, <code>odoc</code> might generate a single <code>.html</code> file, or a complete directory of <code>.html</code> files. The <code>--output-dir</code> option specifies the root for generating those outputs.</p><h4 id="a-javascript-file-for-search-requests"><a href="#a-javascript-file-for-search-requests" class="anchor"></a>A JavaScript file for search requests</h4><p><code>odoc</code> provides a way to plugin a JavaScript file, containing the code to answer user's queries. In order to never block the UI, this file will be loaded in a web worker to perform searches:</p><ul><li>The search query will be sent as a plain string to the web worker, using the standard mechanism of message passing.</li></ul><ul><li>The web worker has to send back the result as a message to the main thread, containing the results. The format for the result message is a string that can be parsed as a list of JSON objects. Each object contain two keys-value pairs: a key <code>&quot;url&quot;</code> which contains a relative URL from <code>--ouput-dir</code>; and a key <code>&quot;html&quot;</code> which contain the html showing the search entry.</li></ul><ul><li>The JavaScript file must be manually put in the <code>--output-dir</code> values, the driver can decide where.</li></ul><h4 id="interfaces-and-pages"><a href="#interfaces-and-pages" class="anchor"></a>Interfaces and pages</h4><p>A generic <code>html-generate</code> command for interfaces has the following form:</p><pre class="language-shell"><code>$ odoc html-generate
  --output-dir &lt;odir&gt;
  --index &lt;path/to/file.odoc-index&gt;
  --search-uri &lt;relative/to/output-dir/file.js&gt;
  --search-uri &lt;relative/to/output-dir/file2.js&gt;
  &lt;path/to/file.odocl&gt;</code></pre><ul><li><code>--output-dir &lt;odir&gt;</code> is used to specify the root output for the generated <code>.html</code>.</li></ul><ul><li><code>--index &lt;path/to/file.odoc-index&gt;</code> is given to <code>odoc</code> for sidebar generation.</li></ul><ul><li><code>--search-uri &lt;relative/to/output-dir/file.js&gt;</code> tells <code>odoc</code> which file(s) to load in a web worker.</li></ul><p>The output directory or file can be computed from this command's <code>--output-dir</code>, the initial <code>--parent-id</code> given when creating the <code>.odoc</code> file, as well as the unit name. In the case of a module, the output is a directory named with the name of the module. In the case of a page, the output is a file with the name of the page and the <code>.html</code> extension.</p><p>An example of such command is:</p><pre class="language-shell"><code>$ odoc html-generate
    _odoc/ppxlib/page-index.odocl
    --index _odoc/ppxlib/index.odoc-index
    --search-uri ppxlib/sherlodoc_db.js
    --search-uri sherlodoc.js
    -o _html/</code></pre><h4 id="source-code"><a href="#source-code" class="anchor"></a>Source code</h4><pre class="language-shell"><code>$ odoc html-generate-source --output-dir &lt;odir&gt; --impl &lt;path/to/impl-file.odocl&gt; &lt;path/to/source/file.ml&gt;</code></pre><ul><li><code>--output-dir &lt;odir&gt;</code> has been covered already</li></ul><ul><li><code>--impl &lt;path/to/impl-file.odocl&gt;</code> allows to give the implementation file.</li></ul><ul><li><code>&lt;path/to/source/file.ml&gt;</code> is the source file.</li></ul><p>The output file can be computed from this command's <code>--output-dir</code>, and the initial <code>--source-id</code> and <code>--name</code> given when creating the <code>impl-*.odoc</code> file.</p><p>An example of such command is:</p><pre class="language-shell"><code>$ odoc html-generate-source
    --impl _odoc/ppxlib/ppxlib/impl-ppxlib__Reconcile.odocl
    /home/panglesd/.opam/5.2.0/lib/ppxlib/reconcile.ml
    -o _html/</code></pre><h4 id="generating-docs-for-assets"><a href="#generating-docs-for-assets" class="anchor"></a>Generating docs for assets</h4><p>This is the phase where we pass the actual asset. We pass it as a positional argument, and give the asset unit using <code>--asset-unit</code>.</p><pre class="language-shell"><code>$ odoc html-generate-asset --output-dir &lt;odir&gt; --asset-unit &lt;path/to/asset-file.odocl&gt; &lt;path/to/asset/file.ext&gt;</code></pre><h2 id="conv"><a href="#conv" class="anchor"></a>Convention for installed packages</h2><p>In order to build the documentation for installed packages, the driver needs to give a meaning to the various concepts above. In particular, it needs to define the pages and libraries trees, know where to find the pages and assets, what id to give them, when linking it needs to know to which trees the artifact may be linking...</p><p>So that the different drivers and installed packages play well together, we define here a convention for building installed packages. If both the package and the driver follow it, building the docs should go well!</p><h3 id="the--p-and--l-trees,-and-their-root-ids"><a href="#the--p-and--l-trees,-and-their-root-ids" class="anchor"></a>The <code>-P</code> and <code>-L</code> trees, and their root ids</h3><p>Each package defines a set of trees, each of them having a root id. These roots will be used in <code>--parent-id</code> and in <code>-P</code> and <code>-L</code>.</p><p>The driver can decide any set of mutually disjoint set of roots, without posing problem to the reference resolution. For instance, both <code>-P pkg:&lt;output_dir&gt;/pkg</code> and <code>-P pkg:&lt;output_dir&gt;/pkg/version</code> are acceptable versions. However, we define here &quot;canonical&quot; roots:</p><p>Each installed package <code>&lt;p&gt;</code> defines a single page root id: <code>&lt;p&gt;</code>.</p><p>For each package <code>&lt;p&gt;</code>, each library <code>&lt;l&gt;</code> defines a library root id: <code>&lt;p&gt;/&lt;l&gt;</code>.</p><p>For instance, a package <code>foo</code> with two libraries: <code>foo</code> and <code>foo.bar</code> will define three trees:</p><ul><li>A documentation tree named <code>foo</code>, with root id <code>foo</code>. When referred from other trees, a <code>-P foo:&lt;odoc_dir&gt;/foo</code> argument needs to be added at the link phase.</li></ul><ul><li>A module tree named <code>foo</code>, with root id <code>foo/foo</code>. When referred from other trees, a <code>-L foo:&lt;odoc_dir&gt;/foo/foo</code> argument needs to be added at the link phase.</li></ul><ul><li>A module tree named <code>foo.bar</code>, with root id <code>foo/foo.bar</code>. When referred from other trees, a <code>-L foo.bar:&lt;odoc_dir&gt;/foo/foo.bar</code> argument needs to be added at the link phase.</li></ul><h3 id="link-time-dependencies"><a href="#link-time-dependencies" class="anchor"></a>Link-time dependencies</h3><p>Installed OPAM packages need to specify which trees they may be referencing during the link phase, so that the proper <code>-P</code> and <code>-L</code> arguments are added. (Note that these dependencies can be circular, as they happen during the link phase and only require the artifact from the compile phase.)</p><p>An installed package <code>&lt;p&gt;</code> specifies its tree dependencies in a file at <code>&lt;opam root&gt;/doc/&lt;p&gt;/odoc-config.sexp</code>. This file contains s-expressions.</p><p>Stanzas of the form <code>(packages p1 p2 ...)</code> specifies that page trees <code>p1</code>, <code>p2</code>, ..., should be added using the <code>-P</code> argument: with the canonical roots, it would be <code>-P p1:&lt;output_dir&gt;/p1 -P p2:&lt;output_dir&gt;/p2 -P ...</code>.</p><p>Stanzas of the form <code>(libraries l1 l2 ...)</code> specifies that module trees <code>l1</code>, <code>l2</code>, ..., should be added using the <code>-L</code> argument: with the canonical roots, it would be <code>-L l1:&lt;output_dir&gt;/p1/l1 -L l2&lt;output_dir&gt;/p2/l2 -L ...</code>, where <code>p1</code> is the package <code>l1</code> is in, etc.</p><h3 id="the-units"><a href="#the-units" class="anchor"></a>The units</h3><p>The module units of a package <code>p</code> are all files installed by <code>p</code> that can be found in <code>&lt;opam root&gt;/lib/p/</code> or a subdirectory.</p><p>The page units are those files that can be found in <code>&lt;opam root&gt;/doc/odoc-pages/</code> or a subdirectory, and that have an <code>.mld</code> extension.</p><p>The asset units are those files that can be found in <code>&lt;opam root&gt;/doc/odoc-pages/</code> or a subdirectory, but that do not have an <code>.mld</code> extension. Additionally, they are all files found in <code>&lt;opam root&gt;/doc/odoc-assets/</code>.</p><h3 id="the---parent-id-arguments"><a href="#the---parent-id-arguments" class="anchor"></a>The <code>--parent-id</code> arguments</h3><p>Interface and implementation units have as parent id the root of the library tree they belong to: with &quot;canonical&quot; roots, <code>&lt;pkgname&gt;/&lt;libname&gt;</code>.</p><p>Page units that are found in <code>&lt;opam root&gt;/doc/&lt;pkgname&gt;/odoc-pages/&lt;relpath&gt;/&lt;name&gt;.mld</code> have the parent id from their page tree, followed by <code>&lt;relpath&gt;</code>. So, with canonical roots, <code>&lt;pkgname&gt;/&lt;relpath&gt;</code>.</p><p>Asset units that are found in <code>&lt;opam root&gt;/doc/&lt;pkgname&gt;/odoc-pages/&lt;relpath&gt;/&lt;name&gt;.&lt;ext&gt;</code> have the parent id from their page tree, followed by <code>&lt;relpath&gt;</code>. With canonical roots, <code>&lt;pkgname&gt;/&lt;relpath&gt;</code>.</p><p>Asset units that are found in <code>&lt;opam root&gt;/doc/&lt;pkgname&gt;/odoc-assets/&lt;filename&gt;</code> have the parent id from their page tree, followed by <code>_asset/&lt;filename&gt;</code> <code>&lt;p&gt;/_assets/&lt;filename&gt;</code>.</p><h3 id="the---source-id-arguments"><a href="#the---source-id-arguments" class="anchor"></a>The <code>--source-id</code> arguments</h3><p>The driver could choose the source id without breaking references. However, following the canonical roots convention, implementation units must have as source id: <code>&lt;pkgname&gt;/src/&lt;libraryname&gt;/&lt;filename&gt;.ml</code>.</p><h3 id="ordering-the-generated-pages"><a href="#ordering-the-generated-pages" class="anchor"></a>Ordering the generated pages</h3><p>The canonical hierarchy introduces directories (one per library) that may not be ordered by the author, either by omitting it in the <code>@children_order</code> tag or by not specifying any <code>@children_order</code> tag. In this case, <code>odoc</code> needs to come up with a reasonable default order, which may not be easy without some help from the driver.</p><p>In auto-generated pages (either <code>index.mld</code> in a directory, or <code>page.mld</code>), <code>odoc</code> supports the <code>@order_category &lt;category_name&gt;</code> tag, to help sorting the pages, if it is not sorted by the parent's <code>@children_order</code>. The resulting order is:</p><ul><li>First, pages in the order given in their parent's <code>@children_order</code>,</li><li>Then, pages ordered lexicographically by their <code>@order_category</code>. An undefined category comes before a defined one.</li><li>Inside a category, pages are ordered lexicographically by their first title,</li><li>Two pages with the same name will be ordered using their file name!</li></ul><p>Note that <code>@order_category</code> is not suitable for author use, as it may change in the future. Use this tag only in the driver's autogenerated pages!</p></div></body></html>
