<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Domain_local_await (domain-local-await.domain-local-await.Domain_local_await)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../sherlodoc_db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">domain-local-await</a> &#x00BB; Library <code>domain-local-await</code> &#x00BB; Domain_local_await</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Domain_local_await</span></code><a href="../../src/domain-local-await/Domain_local_await.ml.html" class="source_link">Source</a></h1><p>A scheduler independent blocking mechanism.</p><p>This is designed as a low level mechanism intended for writing higher level libraries that need to block in a scheduler friendly manner.</p><p>A library that needs to suspend and later resume the current thread of execution may simply call <a href="#val-prepare_for_await"><code>prepare_for_await</code></a> to obtain a pair of <code>await</code> and <code>release</code> operations for the purpose.</p><p>To provide an efficient and scheduler friendly implementation of the mechanism, schedulers may install an implementation by wrapping the scheduler main loop with a call to <a href="#val-using"><code>using</code></a>. The implementation is then stored in a domain, and optionally thread, local variable. The overhead that this imposes on a scheduler should be insignificant.</p><p>An application can the choose to use schedulers that provide the necessary implementation. An implementation that works with plain domains and threads is provided as a default.</p><p>The end result is effective interoperability between schedulers and concurrent programming libraries.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#interface-for-blocking">Interface for blocking</a></li><li><a href="#interface-for-schedulers">Interface for schedulers</a><ul><li><a href="#per-thread-configuration">Per thread configuration</a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../index.html">domain-local-await</a><ul><li>Library <code>domain-local-await</code><ul><li><a href="#" class="current_unit">Domain_local_await</a><ul><li><a href="module-type-Thread/index.html">Thread</a></li></ul></li></ul></li><li><a href="../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="interface-for-blocking"><a href="#interface-for-blocking" class="anchor"></a>Interface for blocking</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><a href="../../src/domain-local-await/Domain_local_await.ml.html#type-t" class="source_link">Source</a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.release" class="def record field anchored"><a href="#type-t.release" class="anchor"></a><code><span>release : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>t.release ()</code> resumes the corresponding caller of <code>t.await ()</code> or does nothing in case the corresponding <code>t.await ()</code> has already resumed or the target fiber has been canceled.</p><p><b>NOTE</b>: An implementation of <code>t.release ()</code> should never fail.</p><span class="comment-delim">*)</span></div></li><li id="type-t.await" class="def record field anchored"><a href="#type-t.await" class="anchor"></a><code><span>await : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>t.await ()</code> suspends the caller at most until <code>t.release ()</code> is called.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Represents an asynchronous trigger.</p><p><b>NOTE</b>: <a href="#type-t.release"><code>release</code></a> and <a href="#type-t.await"><code>await</code></a> should be parallelism-safe and ideally optimized with the assumption that <a href="#type-t.release"><code>release</code></a> may be called multiple times and even before <a href="#type-t.await"><code>await</code></a> is called. Furthermore, <a href="#type-t.await"><code>await</code></a> may be called at most once.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prepare_for_await"><a href="#val-prepare_for_await" class="anchor"></a><a href="../../src/domain-local-await/Domain_local_await.ml.html#val-prepare_for_await" class="source_link">Source</a><code><span><span class="keyword">val</span> prepare_for_await : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>prepare_for_await ()</code> prepares and returns a trigger <code>t</code> for at most one use of <code>t.await ()</code> by calling the <code>prepare</code> function registered for the current domain.</p><p><a href="#val-prepare_for_await"><code>prepare_for_await</code></a> and <a href="#type-t.await"><code>t.await</code></a> are allowed to raise an (unspecified) exception that indicates that the caller's fiber has been canceled (and should terminate). If an exception is raised, then the caller should perform whatever cleanup is necessary to e.g. avoid space leaks.</p><p><b>NOTE</b>: It is allowed for two different calls of <code>prepare_for_await</code> to return the same trigger and e.g. share a single trigger per domain or per fiber or even just have one single trigger.</p></div></div><h2 id="interface-for-schedulers"><a href="#interface-for-schedulers" class="anchor"></a>Interface for schedulers</h2><div class="odoc-spec"><div class="spec value anchored" id="val-using"><a href="#val-using" class="anchor"></a><a href="../../src/domain-local-await/Domain_local_await.ml.html#val-using" class="source_link">Source</a><code><span><span class="keyword">val</span> using : <span><span class="label">prepare_for_await</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">while_running</span>:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>using ~prepare_for_await ~while_running</code> registers the given asynchronous trigger mechanism for the current domain, or, if the domain has been configured to use <a href="#val-per_thread"><code>per_thread</code></a> schedulers, the current systhread, for the duration of running the given scheduler. In other words, this sets the implementation of <a href="#val-prepare_for_await"><code>prepare_for_await</code></a> for blocking under the scheduler.</p><p><b>NOTE</b>: The given <code>prepare_for_await</code> function is called every time <a href="#val-prepare_for_await"><code>prepare_for_await</code></a> is called while the scheduler is running.</p><p><b>NOTE</b>: This is normally only called by libraries that implement schedulers and the specified <code>prepare_for_await</code> typically returns a trigger mechanism <a href="#type-t"><code>t</code></a> that tightly integrates with the scheduler by e.g. performing an effect to suspend the current fiber when <a href="#type-t.await"><code>t.await</code></a> is called.</p></div></div><h3 id="per-thread-configuration"><a href="#per-thread-configuration" class="anchor"></a>Per thread configuration</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Thread"><a href="#module-type-Thread" class="anchor"></a><a href="../../src/domain-local-await/Thread_intf.ml.html#module-type-Thread" class="source_link">Source</a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Thread/index.html">Thread</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for a minimal subset of the <code>Stdlib.Thread</code> module needed by domain local await.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-per_thread"><a href="#val-per_thread" class="anchor"></a><a href="../../src/domain-local-await/Domain_local_await.ml.html#val-per_thread" class="source_link">Source</a><code><span><span class="keyword">val</span> per_thread : <span><span>(<span class="keyword">module</span> <a href="module-type-Thread/index.html">Thread</a>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>per_thread (module Thread)</code> configures the current domain to store and select the trigger mechanism per systhread. This can be called at most once per domain before any calls to <a href="#val-prepare_for_await"><code>prepare_for_await</code></a>.</p><p>The reason why this is an opt-in feature is that this allows domain local await to be implemented without depending on <code>Thread</code> which also depends on <code>Unix</code>.</p><p>Usage:</p><pre class="language-ocaml"><code>Domain.spawn @@ fun () -&gt;
  Domain_local_await.per_thread (module Thread);

  (* ... *)

  ()
  |&gt; Thread.create (fun () -&gt;
     Domain_local_await.using
       ~prepare_for_await:prepare_for_scheduler_a
       ~while_running:scheduler_a);

  ()
  |&gt; Thread.create (fun () -&gt;
     Domain_local_await.using
       ~prepare_for_await:prepare_for_scheduler_b
       ~while_running:scheduler_b);

  (* ... *)</code></pre><p><b>NOTE</b>: It is not necessary to use per systhread configuration on a domain unless you want different systhreads to use different schedulers.</p></div></div></div></body></html>
