<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (base.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; Base</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="base"><a href="#base" class="anchor"></a>Base</h1><p><b><a href="base/Base/index.html" title="Base">The full API is browsable here</a></b>.</p><p>Base is a standard library for OCaml. It provides a standard set of general-purpose modules that are well tested, performant, and fully portable across any environment that can run OCaml code.</p><p>Unlike other standard library projects, Base is meant to be used as a wholesale replacement of the standard library distributed with the OCaml compiler. In particular, it makes different choices and doesn't re-export features that are not fully portable such as I/O, which are left to other libraries.</p><p>Note that an API for OCaml's channel-based I/O can be found in the <span class="xref-unresolved" title="Stdio"><code>Stdio</code></span> library.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#relationship-to-core">Relationship to Core</a></li><li><a href="#using-the-ocaml-standard-library-with-base">Using the OCaml standard library with Base</a></li><li><a href="#differences-between-base-and-the-ocaml-standard-library">Differences between Base and the OCaml standard library</a><ul><li><a href="#comparison-operators">Comparison operators</a></li></ul></li><li><a href="#base-and-ppx-code-generators">Base and ppx code generators</a></li><li><a href="#base-coding-rules">Base coding rules</a></li><li><a href="#roadmap">Roadmap</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="#" class="current_unit">Base</a><ul><li>Library <code>base</code><ul><li><a href="base/Base/index.html">Base</a></li></ul></li><li>Library <code>base.base_internalhash_types</code><ul><li><a href="base.base_internalhash_types/Base_internalhash_types/index.html">Base_internalhash_types</a></li></ul></li><li>Library <code>base.caml</code><ul><li><a href="base.caml/Caml/index.html">Caml</a></li></ul></li><li>Library <code>base.md5</code><ul><li><a href="base.md5/Md5_lib/index.html">Md5_lib</a></li></ul></li><li>Library <code>base.shadow_stdlib</code><ul><li><a href="base.shadow_stdlib/Shadow_stdlib/index.html">Shadow_stdlib</a></li></ul></li><li><a href="src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="relationship-to-core"><a href="#relationship-to-core" class="anchor"></a>Relationship to Core</h2><ul><li><b><a href="base/Base/index.html"><code>Base</code></a></b>: Minimal stdlib replacement. Portable and lightweight and intended to be highly stable.</li></ul><ul><li><b><code>Core</code></b>: Extension of Base. More fully featured, with more code and dependencies, and APIs that evolve more quickly. Portable, and works on Javascript.</li></ul><h2 id="using-the-ocaml-standard-library-with-base"><a href="#using-the-ocaml-standard-library-with-base" class="anchor"></a>Using the OCaml standard library with Base</h2><p>Base is intended as a full stdlib replacement. As a result, after an <code>open Base</code>, all the modules, values, types, etc., coming from the OCaml standard library that one normally gets in the default environment are deprecated.</p><p>In order to access these values, one must use the <code>Stdlib</code> library, which re-exports them all through the toplevel name <span class="xref-unresolved" title="Stdlib"><code>Stdlib</code></span>: <code>Stdlib.String</code>, <code>Stdlib.print_string</code>, ...</p><p>The new modules and values made available by Base are documented <a href="base/Base/index.html" title="Base">here</a>.</p><h2 id="differences-between-base-and-the-ocaml-standard-library"><a href="#differences-between-base-and-the-ocaml-standard-library" class="anchor"></a>Differences between Base and the OCaml standard library</h2><p>Programmers who are used to the OCaml standard library should read through this section to understand major differences between the two libraries that one should be aware of when switching to Base.</p><h3 id="comparison-operators"><a href="#comparison-operators" class="anchor"></a>Comparison operators</h3><p>The comparison operators exposed by the OCaml standard library are polymorphic:</p><pre class="language-ocaml"><code>val compare : 'a -&gt; 'a -&gt; int
val ( &lt;= ) : 'a -&gt; 'a -&gt; bool
(* ... *)</code></pre><p>What they implement is structural comparison of the runtime representation of values. Since these are often error-prone, i.e., they don't correspond to what the user expects, they are not exposed directly by Base.</p><p>To use polymorphic comparison with Base, one should use the <span class="xref-unresolved" title="Base.Polymorphic_compare"><code>Polymorphic_compare</code></span> module. The default comparison operators exposed by Base are the integer ones, just like the default arithmetic operators are the integer ones.</p><p>The recommended way to compare arbitrary complex data structures is to use the specific <code>compare</code> functions. For instance:</p><pre class="language-ocaml"><code>List.compare String.compare x y </code></pre><p>The <code>ppx_compare</code> rewriter offers an alternative way to write this:</p><pre class="language-ocaml"><code>[%compare: string list] x y </code></pre><h2 id="base-and-ppx-code-generators"><a href="#base-and-ppx-code-generators" class="anchor"></a>Base and ppx code generators</h2><p>Base uses a few ppx code generators to implement:</p><ul><li>reliable and customizable comparison of OCaml values;</li><li>reliable and customizable hash of OCaml values; and</li><li>conversions between OCaml values and s-expression.</li></ul><p>However, it doesn't need these code generators to build. Instead, it uses ppx as a code verification tool during development. It works in a very similar fashion to <a href="https://github.com/janestreet/ppx_expect">expect tests</a>.</p><p>Whenever you see this in the code source:</p><pre class="language-ocaml"><code>type t = ... [@@deriving_inline sexp_of]
let sexp_of_t = ...
[@@@end]</code></pre><p>the code between the <code>[@@deriving_inline]</code> and the <code>[@@@end]</code> is generated code. The generated code is currently quite big and hard to read, however we are working on making it look like human-written code.</p><p>You can put the following elisp code in your <code>~/.emacs</code> file to hide these blocks:</p><pre>(defun deriving-inline-forward-sexp (&amp;optional arg)
  (search-forward-regexp &quot;\\[@@@end\\]&quot;) nil nil arg)

(defun setup-hide-deriving-inline ()
  (inline)
  (hs-minor-mode t)
  (let ((hs-hide-comments-when-hiding-all nil))
    (hs-hide-all)))

(require 'hideshow)
(add-to-list 'hs-special-modes-alist
             '(tuareg-mode &quot;\\[@@deriving_inline[^]]*\\]&quot; &quot;\\[@@@end\\]&quot; nil
                           deriving-inline-forward-sexp nil))
(add-hook 'tuareg-mode-hook 'setup-hide-deriving-inline)</pre><p>Things are not yet set up in the git repository to make it convenient to change types and update the generated code, but they will be set up soon.</p><h2 id="base-coding-rules"><a href="#base-coding-rules" class="anchor"></a>Base coding rules</h2><p>There are a few coding rules across the code base that are enforced by lint tools.</p><p>These rules are:</p><ul><li>Opening the <code>Stdlib</code> module is not allowed. Inside Base, the OCaml stdlib is shadowed and accessible through the <code>Stdlib</code> module. We forbid opening <code>Stdlib</code> so that we know exactly where things come from.</li><li><code>Stdlib.Foo</code> modules cannot be aliased, one must use <code>Stdlib.Foo</code> explicitly. This is to avoid having to remember a list of aliases at the beginning of each file.</li><li>For some modules that are both in the OCaml stdlib and Base, such as <code>String</code>, we define a module <code>String0</code> for common functions that cannot be defined directly in <code>Base.String</code> to avoid creating a circular dependency. Except for <code>String</code> itself, other modules are not allowed to use <code>Stdlib.String</code> and must use either <code>String</code> or <code>String0</code> instead.</li><li>Indentation is exactly the one of <code>ocp-indent</code>.</li><li>A few other coding style rules enforced by <a href="https://github.com/janestreet/ppx_js_style">ppx_js_style</a>.</li></ul><p>The Base specific coding rules are checked by <code>ppx_base_lint</code>, in the <code>lint</code> subfolder. The indentation rules are checked by a wrapper around <code>ocp-indent</code> and the coding style rules are checked by <code>ppx_js_style</code>.</p><p>These checks are currently not run by <code>dune</code>, but it will soon get a <code>-dev</code> flag to run them automatically.</p><h2 id="roadmap"><a href="#roadmap" class="anchor"></a>Roadmap</h2><p>Base is still under active development and there are several missing feature that are yet to be added. Consult the <a href="https://github.com/janestreet/base/blob/master/ROADMAP.md">roadmap</a> to see what is happening.</p></div></body></html>
