<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>rationale (b0.rationale)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html">B0  <span class="version">v0.0.5</span></a> &#x00BB; Why b0 ?</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="why-b0-?"><a href="#why-b0-?" class="anchor"></a>Why b0 ?</h1><p><b>Note.</b> This was Written in 2017 and is history by now, but it has aged well and still reflects B0's vision.</p><p>A few high-level motivating arguments. To see how b0 supports these points see the <span class="xref-unresolved" title="index.manuals">manuals</span>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#goals">Goals</a></li><li><a href="#generic">Why a generic and modular system ?</a></li><li><a href="#ocaml">Why OCaml as a description language ?</a></li><li><a href="#model">A simpler build model</a></li><li><a href="#metadata">Metadata and build outcome introspection</a></li><li><a href="#deploy">Deployment and software life-cycle operations</a></li><li><a href="#scope">B0's scope</a></li><li><a href="#annex">ANNEX: The problem with rule-based build models</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html">B0  <span class="version">v0.0.5</span></a><ul><li><a href="b00_manual.html">B00 manual</a></li><li><a href="cmdlet_manual.html">Cmdlet manual</a></li><li><a href="driver_dev.html">B0 driver development manual</a></li><li><a href="manual.html">B0 manual</a></li><li><a href="old_manual.html">B0 manual</a></li><li><a href="opam.html"><code>opam</code> support manual</a></li><li><a href="#" class="current_unit">Why b0 ?</a></li><li><a href="release.html">B0 release support manual</a></li><li><a href="todo.html">Design considerations and todo</a></li><li><a href="unit_manual.html">Build unit manual</a></li><li>Library <code>b0</code><ul><li><a href="b0/B0_build/index.html">B0_build</a></li><li><a href="b0/B0_cli/index.html">B0_cli</a></li><li><a href="b0/B0_cmdlet/index.html">B0_cmdlet</a></li><li><a href="b0/B0_def/index.html">B0_def</a></li><li><a href="b0/B0_dir/index.html">B0_dir</a></li><li><a href="b0/B0_driver/index.html">B0_driver</a></li><li><a href="b0/B0_file/index.html">B0_file</a></li><li><a href="b0/B0_meta/index.html">B0_meta</a></li><li><a href="b0/B0_pack/index.html">B0_pack</a></li><li><a href="b0/B0_unit/index.html">B0_unit</a></li></ul></li><li>Library <code>b0.b0</code><ul><li><a href="b0.b0/B0_b0/index.html">B0_b0</a></li><li><a href="b0.b0/B0_cmd_build/index.html">B0_cmd_build</a></li><li><a href="b0.b0/B0_cmd_cmd/index.html">B0_cmd_cmd</a></li><li><a href="b0.b0/B0_cmd_cmdlet/index.html">B0_cmd_cmdlet</a></li><li><a href="b0.b0/B0_cmd_delete/index.html">B0_cmd_delete</a></li><li><a href="b0.b0/B0_cmd_file/index.html">B0_cmd_file</a></li><li><a href="b0.b0/B0_cmd_list/index.html">B0_cmd_list</a></li><li><a href="b0.b0/B0_cmd_log/index.html">B0_cmd_log</a></li><li><a href="b0.b0/B0_cmd_pack/index.html">B0_cmd_pack</a></li><li><a href="b0.b0/B0_cmd_root/index.html">B0_cmd_root</a></li><li><a href="b0.b0/B0_cmd_scope/index.html">B0_cmd_scope</a></li><li><a href="b0.b0/B0_cmd_unit/index.html">B0_cmd_unit</a></li><li><a href="b0.b0/B0_main/index.html">B0_main</a></li></ul></li><li>Library <code>b0.b00</code><ul><li><a href="b0.b00/B00/index.html">B00</a></li><li><a href="b0.b00/B000/index.html">B000</a></li><li><a href="b0.b00/B000_conv/index.html">B000_conv</a></li></ul></li><li>Library <code>b0.b00.kit</code><ul><li><a href="b0.b00.kit/B00_base64/index.html">B00_base64</a></li><li><a href="b0.b00.kit/B00_cli/index.html">B00_cli</a></li><li><a href="b0.b00.kit/B00_cmark/index.html">B00_cmark</a></li><li><a href="b0.b00.kit/B00_editor/index.html">B00_editor</a></li><li><a href="b0.b00.kit/B00_fexts/index.html">B00_fexts</a></li><li><a href="b0.b00.kit/B00_findex/index.html">B00_findex</a></li><li><a href="b0.b00.kit/B00_github/index.html">B00_github</a></li><li><a href="b0.b00.kit/B00_htmlg/index.html">B00_htmlg</a></li><li><a href="b0.b00.kit/B00_http/index.html">B00_http</a></li><li><a href="b0.b00.kit/B00_jsoo/index.html">B00_jsoo</a></li><li><a href="b0.b00.kit/B00_lines/index.html">B00_lines</a></li><li><a href="b0.b00.kit/B00_ocaml/index.html">B00_ocaml</a></li><li><a href="b0.b00.kit/B00_odoc/index.html">B00_odoc</a></li><li><a href="b0.b00.kit/B00_os/index.html">B00_os</a></li><li><a href="b0.b00.kit/B00_pager/index.html">B00_pager</a></li><li><a href="b0.b00.kit/B00_pdf_viewer/index.html">B00_pdf_viewer</a></li><li><a href="b0.b00.kit/B00_rsync/index.html">B00_rsync</a></li><li><a href="b0.b00.kit/B00_serialk_json/index.html">B00_serialk_json</a></li><li><a href="b0.b00.kit/B00_serialk_sexp/index.html">B00_serialk_sexp</a></li><li><a href="b0.b00.kit/B00_serialk_text/index.html">B00_serialk_text</a></li><li><a href="b0.b00.kit/B00_trace/index.html">B00_trace</a></li><li><a href="b0.b00.kit/B00_vcs/index.html">B00_vcs</a></li><li><a href="b0.b00.kit/B00_www_browser/index.html">B00_www_browser</a></li></ul></li><li>Library <code>b0.kit</code><ul><li><a href="b0.kit/B0_expect/index.html">B0_expect</a></li><li><a href="b0.kit/B0_jsoo/index.html">B0_jsoo</a></li><li><a href="b0.kit/B0_kit/index.html">B0_kit</a></li><li><a href="b0.kit/B0_ocaml/index.html">B0_ocaml</a></li><li><a href="b0.kit/B0_ocaml_eco/index.html">B0_ocaml_eco</a></li><li><a href="b0.kit/B0_opam/index.html">B0_opam</a></li><li><a href="b0.kit/B0_release/index.html">B0_release</a></li><li><a href="b0.kit/B0_srcs/index.html">B0_srcs</a></li></ul></li><li>Library <code>b0.std</code><ul><li><a href="b0.std/B0_std/index.html">B0_std</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="goals"><a href="#goals" class="anchor"></a>Goals</h2><p>B0 is a system to assist the programmer during the whole software construction process, from development to deployment. It is a <em>generic</em> system that integrates, using modular descriptions written in OCaml: configuration, build, source or binary deployment and custom software life-cycle operations.</p><h2 id="generic"><a href="#generic" class="anchor"></a>Why a generic and modular system ?</h2><p>B0 provides both genericity and domain specific usability by rethinking how builds are to be described, organized and (re)executed.</p><p>Most software projects need to deal with special build cases, massage and integrate data sources, interact with other languages and adapt to specific systems or deployement environments. In these projects the closed world assumption on which language specific build systems rely quickly degrades the user experience to a series of painful and time consuming workarounds that are better solved by a generic system.</p><p>However a good generic system must be able to express easy to use domain specific descriptions that match the user experience of a language specific system. Besides these descriptions should be modularized, distributed and reused as we do with software: via libraries.</p><h2 id="ocaml"><a href="#ocaml" class="anchor"></a>Why OCaml as a description language ?</h2><p>B0 is an EDSL that provides build description expressiveness, reuse and distribution from the onset.</p><p>Build system DSLs tend to constrain their expressive power and rely on the brittleness of shell script language conventions. Most of the time this ends up not being sufficient: general computation, abstraction and datatypes beyond strings are needed. This results in users metaprogramming build DSLs using other tools and languages hereby adding a layer of indirection and complexity only to be able to deal with a defective one.</p><p>B0 does not follow the DSL road again but instead, treats the root cause: the user is provided with the full power of OCaml and its rich datatype and abstraction capabilities. This allows to devise high-level and abstract build descriptions that are directly &quot;compiled&quot; down to low-level build operations without going through an indirection layer.</p><p>At the same time this trivially solves the description reuse and distribution problem by piggybacking on the OCaml packaging infrastructure.</p><h2 id="model"><a href="#model" class="anchor"></a>A simpler build model</h2><p>B0 provides a simple build model that permits build description abstraction and directly matches both the operational and user mental model of the build system.</p><p>Build descriptions are at the center of the system. They must be easy to define, understand and reuse. Their executions and outcomes must be easy to debug, fast and correct.</p><p>In order to acheive this b0 departs from the prevalent rule-based build model which exposes concepts that are not needed and does not match the user's mental model (see the annex at the end of this file for a discussion). B0 sees a build system as a direct sequence of build operations that perform side effects on the file system. In order words: a build script written in OCaml.</p><p>This procedural approach makes it easy to expose at the API level, build fragments at various abstraction levels, e.g. the actual building blocks of &quot;easy to use&quot; domain specific descriptions.</p><p>Build operations are annoted with precise specification of their input (environment, file reads, tool binary) and output (allowed exit codes, file writes). These specifications allows to see them as pure and deterministic functions. In turn this makes it trivial for the build script to be automatically parallelized and incrementally re-executed by memoizing the &quot;functions&quot; via an on-disk cache.</p><h2 id="metadata"><a href="#metadata" class="anchor"></a>Metadata and build outcome introspection</h2><p>B0 provides support for build understanding and DRY custom software life-cycle operations by keeping track of low and high-level metadata about build outcomes.</p><p>Low-level metadata about the build is automatically serialized by the system. This includes the precise configuration that was used for the build and all the build operations performed and information about their execution. This provides a strong ground for build understanding and debugging. For example, any written file can be queried for the actual build operation that wrote it, build parallelism can be studied after the fact using trace analyzers, etc.</p><p>For high-level information b0 allows to attach custom typed metadata to the essential components it deals with: source and built files, statically known build units and packages. Part of this metadata is known before the build starts and part of it may depend on the build configuration. In the end all that information is serialized alongside the build outcomes. This is useful for driving the build (e.g. looking up and compiling against vendored library dependencies) and for further processing the source or build outcomes in a DRY manner (e.g. for deployment or packaging).</p><h2 id="deploy"><a href="#deploy" class="anchor"></a>Deployment and software life-cycle operations</h2><p>B0 provides custom and reusable support for massaging, distributing and deploying the project sources and build outcomes.</p><p>Software needs to be tested and distributed in order to be run. This means disseminating and running build outcomes or sources at different locations: locally, on servers, on devices, in package repositories, staging areas, etc. Traditionnaly this happens through an insipid soup of custom shell scripts loosely tied to (re)invocations of the build system.</p><p>In b0 custom deployment procedures and software life-cycle operations are fully integrated in the project description via the notion of deployment and hooks: customizable procedures to stage sources or build outcomes resulting from multiple build variants. The metadata mentioned in the last section allows to keep all this smooth and DRY.</p><h2 id="scope"><a href="#scope" class="anchor"></a>B0's scope</h2><p>Build is an important part of b0 and we believe it provides discriminating and outstanding support for it. The user can express builds and their configuration using distributable descriptions of various abstraction level in a natural and introspectable build model.</p><p>However b0's support does not stop at the end of a build. It provides additional description capabilities for all the life-cycle operations that are associated with software construction.</p><p>B0 is not just a build system: it is a system for software construction care. A framework in which general software life-cycle and construction problems can be expressed and solved.</p><h2 id="annex"><a href="#annex" class="anchor"></a>ANNEX: The problem with rule-based build models</h2><p>Rule-based build model expose build structure as a directed acyclic graph (DAG) of dependencies between file targets. This DAG is implicitly defined via a set of build rule patterns which match targets and hereby define their prerequisites and the recipe of commands needed to produce them once their prerequisites are ready.</p><p>We argue this is not a very good build model:</p><ol><li>Pattern rules lead to rule matching. In rule matching a more specific build rule can be selected to build a particular target. If new rules can be added to the set of global rules, this leads to a system that is very difficult to understand: any part of the system can affect the other. In other words the pattern rule approach is anti-modular and uncompositional.</li><li>Pattern rules are effectively a form of rule meta-programming which is not needed if there are functions in the description language.</li><li>The complete build description of a target is scattered among different build rules as needed by its prerequisites. In order to reconstruct and understand the actual sequence of operations that actually occurs, the programmer has to replay the rule matching algorithm in his head to find out the recipes that will be executed. This is similar to the hell of callback programming: the final description of a build product is non-obvious and scattered among different handlers whose invocation order is unclear and non-trivial.</li><li>The rule-based model is at odds with what the user eventually sees and wants to specify: a sequence of commands that need to be issued in order to produce a given target. In other words this model neither matches the actual mental model of the user nor the effective visible behaviour of the build system.</li><li>Build abstraction cannot be performed inside the rule-based system. As an escape hatch it can be performed by an external system via meta-programming but, this along with 1. and 2., further obscures build understanding and hampers usability.</li></ol></div></body></html>
