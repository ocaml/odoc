<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>old_manual (b0.old_manual)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html">B0  <span class="version">v0.0.5</span></a> &#x00BB; B0 manual</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="b0-manual"><a href="#b0-manual" class="anchor"></a>B0 manual</h1><p>The old manual, kept for reference.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#quickstart">Quick start</a></li><li><a href="#concepts">Conceptual overview</a><ul><li><a href="#model">Build model</a></li><li><a href="#concept_conf">Configuration</a></li><li><a href="#concept_variants">Build variants</a></li><li><a href="#concept_deploy">Deployments</a></li><li><a href="#concept_b0">The <code>b0</code> and <code>d0</code> tools</a></li><li><a href="#concept_b0_dir">A tour of the _b0 directory</a></li></ul></li><li><a href="#configuration">Configuration</a><ul><li><a href="#last_stored_conf">Last and stored configuration</a></li><li><a href="#key_values">Key value terminology</a></li></ul></li><li><a href="#variants">Build variants and variant schemes</a><ul><li><a href="#nop">The nop variant scheme</a></li><li><a href="#default_variant">The default variant and variant schemes</a></li><li><a href="#initial_variant">The initial variant</a></li></ul></li><li><a href="#descr_values">Description values</a></li><li><a href="#deployments">Deployments</a></li><li><a href="#descriptions">Descriptions files</a><ul><li><a href="#root">Root description and directory</a></li></ul></li><li><a href="#b0b0">B0.b0 description files</a><ul><li><a href="#b0_key_sem">Key parsing and semantics</a></li><li><a href="#b0_key_ref">Key reference</a></li><li><a href="#b0_merge"><code>B0.b0</code> key merges</a></li></ul></li><li><a href="#more">More build concepts</a><ul><li><a href="#concept_cmd_stamps">Output command digests</a></li><li><a href="#cleaning">Cleaning build</a></li><li><a href="#correct">Build correctness</a></li></ul></li><li><a href="#recipes">Recipes and menagerie</a><ul><li><a href="#conf">Writing conf discovery</a></li></ul></li><li><a href="#todo">Old <code>TODO.md</code></a><ul><li><a href="#b0.def">B0.Def</a></li><li><a href="#b0.conf">B0.Conf</a></li><li><a href="#b0.pkg">B0.Pkg</a></li><li><a href="#`b0-build`-improvements">`b0 build` improvements</a></li><li><a href="#`b0`-driver">`b0` driver</a></li><li><a href="#b0.tool">B0.Tool</a></li><li><a href="#proxy-variants-and-_b0">Proxy variants and _b0</a></li><li><a href="#variants'y">Variants</a></li><li><a href="#build-context">Build context</a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html">B0  <span class="version">v0.0.5</span></a><ul><li><a href="b00_manual.html">B00 manual</a></li><li><a href="cmdlet_manual.html">Cmdlet manual</a></li><li><a href="driver_dev.html">B0 driver development manual</a></li><li><a href="manual.html">B0 manual</a></li><li><a href="#" class="current_unit">B0 manual</a></li><li><a href="opam.html"><code>opam</code> support manual</a></li><li><a href="rationale.html">Why b0 ?</a></li><li><a href="release.html">B0 release support manual</a></li><li><a href="todo.html">Design considerations and todo</a></li><li><a href="unit_manual.html">Build unit manual</a></li><li>Library <code>b0</code><ul><li><a href="b0/B0_build/index.html">B0_build</a></li><li><a href="b0/B0_cli/index.html">B0_cli</a></li><li><a href="b0/B0_cmdlet/index.html">B0_cmdlet</a></li><li><a href="b0/B0_def/index.html">B0_def</a></li><li><a href="b0/B0_dir/index.html">B0_dir</a></li><li><a href="b0/B0_driver/index.html">B0_driver</a></li><li><a href="b0/B0_file/index.html">B0_file</a></li><li><a href="b0/B0_meta/index.html">B0_meta</a></li><li><a href="b0/B0_pack/index.html">B0_pack</a></li><li><a href="b0/B0_unit/index.html">B0_unit</a></li></ul></li><li>Library <code>b0.b0</code><ul><li><a href="b0.b0/B0_b0/index.html">B0_b0</a></li><li><a href="b0.b0/B0_cmd_build/index.html">B0_cmd_build</a></li><li><a href="b0.b0/B0_cmd_cmd/index.html">B0_cmd_cmd</a></li><li><a href="b0.b0/B0_cmd_cmdlet/index.html">B0_cmd_cmdlet</a></li><li><a href="b0.b0/B0_cmd_delete/index.html">B0_cmd_delete</a></li><li><a href="b0.b0/B0_cmd_file/index.html">B0_cmd_file</a></li><li><a href="b0.b0/B0_cmd_list/index.html">B0_cmd_list</a></li><li><a href="b0.b0/B0_cmd_log/index.html">B0_cmd_log</a></li><li><a href="b0.b0/B0_cmd_pack/index.html">B0_cmd_pack</a></li><li><a href="b0.b0/B0_cmd_root/index.html">B0_cmd_root</a></li><li><a href="b0.b0/B0_cmd_scope/index.html">B0_cmd_scope</a></li><li><a href="b0.b0/B0_cmd_unit/index.html">B0_cmd_unit</a></li><li><a href="b0.b0/B0_main/index.html">B0_main</a></li></ul></li><li>Library <code>b0.b00</code><ul><li><a href="b0.b00/B00/index.html">B00</a></li><li><a href="b0.b00/B000/index.html">B000</a></li><li><a href="b0.b00/B000_conv/index.html">B000_conv</a></li></ul></li><li>Library <code>b0.b00.kit</code><ul><li><a href="b0.b00.kit/B00_base64/index.html">B00_base64</a></li><li><a href="b0.b00.kit/B00_cli/index.html">B00_cli</a></li><li><a href="b0.b00.kit/B00_cmark/index.html">B00_cmark</a></li><li><a href="b0.b00.kit/B00_editor/index.html">B00_editor</a></li><li><a href="b0.b00.kit/B00_fexts/index.html">B00_fexts</a></li><li><a href="b0.b00.kit/B00_findex/index.html">B00_findex</a></li><li><a href="b0.b00.kit/B00_github/index.html">B00_github</a></li><li><a href="b0.b00.kit/B00_htmlg/index.html">B00_htmlg</a></li><li><a href="b0.b00.kit/B00_http/index.html">B00_http</a></li><li><a href="b0.b00.kit/B00_jsoo/index.html">B00_jsoo</a></li><li><a href="b0.b00.kit/B00_lines/index.html">B00_lines</a></li><li><a href="b0.b00.kit/B00_ocaml/index.html">B00_ocaml</a></li><li><a href="b0.b00.kit/B00_odoc/index.html">B00_odoc</a></li><li><a href="b0.b00.kit/B00_os/index.html">B00_os</a></li><li><a href="b0.b00.kit/B00_pager/index.html">B00_pager</a></li><li><a href="b0.b00.kit/B00_pdf_viewer/index.html">B00_pdf_viewer</a></li><li><a href="b0.b00.kit/B00_rsync/index.html">B00_rsync</a></li><li><a href="b0.b00.kit/B00_serialk_json/index.html">B00_serialk_json</a></li><li><a href="b0.b00.kit/B00_serialk_sexp/index.html">B00_serialk_sexp</a></li><li><a href="b0.b00.kit/B00_serialk_text/index.html">B00_serialk_text</a></li><li><a href="b0.b00.kit/B00_trace/index.html">B00_trace</a></li><li><a href="b0.b00.kit/B00_vcs/index.html">B00_vcs</a></li><li><a href="b0.b00.kit/B00_www_browser/index.html">B00_www_browser</a></li></ul></li><li>Library <code>b0.kit</code><ul><li><a href="b0.kit/B0_expect/index.html">B0_expect</a></li><li><a href="b0.kit/B0_jsoo/index.html">B0_jsoo</a></li><li><a href="b0.kit/B0_kit/index.html">B0_kit</a></li><li><a href="b0.kit/B0_ocaml/index.html">B0_ocaml</a></li><li><a href="b0.kit/B0_ocaml_eco/index.html">B0_ocaml_eco</a></li><li><a href="b0.kit/B0_opam/index.html">B0_opam</a></li><li><a href="b0.kit/B0_release/index.html">B0_release</a></li><li><a href="b0.kit/B0_srcs/index.html">B0_srcs</a></li></ul></li><li>Library <code>b0.std</code><ul><li><a href="b0.std/B0_std/index.html">B0_std</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="quickstart"><a href="#quickstart" class="anchor"></a>Quick start</h2><h2 id="concepts"><a href="#concepts" class="anchor"></a>Conceptual overview</h2><h3 id="model"><a href="#model" class="anchor"></a>Build model</h3><p>Effectively a <code>B0</code> build system is an OCaml program that executes arbitrary external commands in parallel and whose effects on the file system are memoized across program runs with an on-disk cache.</p><p>There is no notion of build rule in <code>B0</code>: you simply generate and execute program commands using arbitrary OCaml functions. This allows to define modular and rich data structures for describing builds that are &quot;compiled&quot; down, on each build, to parallel invocations of memoized commands.</p><h3 id="concept_conf"><a href="#concept_conf" class="anchor"></a>Configuration</h3><p>Next to this simple build model <code>B0</code> adds a configuration mecanism under the form of a typed, persisted, key-value store which builds can consult and depend on.</p><p>Since outputs from previous builds are kept in the cache, build configurations can be switched over and back almost instantaneously without loosing the earlier CPU cycles.</p><p>The configuration layer is also cross-compilation ready: any configuration key value can differ for the build and host operating system and the build system of B0 keeps tracks of build tools that are build and used by the build system to make sure they are built with the build OS toolchain. For programmers of the build system, cross compilation is oblivious in B0, it happens without the user having to perform anything special. More on <a href="#configuration" title="configuration">configuration</a>.</p><h3 id="concept_variants"><a href="#concept_variants" class="anchor"></a>Build variants</h3><p>The basic build library and model allows build operations to act anywhere and can be used as such. However to structure the builds, the notion of <em>build variant</em> is added on top of that. Build variant allow builds with different configurations to live next to each other or be performed in containers or on remote machines. They define a basic directory layout in which the build occurs and setup the <span class="xref-unresolved" title="Env">build environment</span> in which the configuration occurs and build tools are looked up. More <a href="#variants" title="variants">on variants</a>.</p><h3 id="concept_deploy"><a href="#concept_deploy" class="anchor"></a>Deployments</h3><p>Deployments abstract the general process of extracting part of the sources and/or build artefacts of your software to a new location. Examples of deployments are: installing build artefacts in a system (FIXME unclear), pushing build artefacts to a remote server or device, making source or binary distribution tarballs and pushing them to a location, interacting with package manager repositories.</p><p>More <a href="#deployments" title="deployments">on deployments</a>.</p><h3 id="concept_b0"><a href="#concept_b0" class="anchor"></a>The <code>b0</code> and <code>d0</code> tools</h3><p>The <code>b0</code> and <code>d0</code> tool allow to build projects that are described by writing one or more <code>B0.ml</code> OCaml files in a source tree or a composition thereof.</p><p>More <a href="#descriptions" title="descriptions">on description files</a>.</p><h3 id="concept_b0_dir"><a href="#concept_b0_dir" class="anchor"></a>A tour of the _b0 directory</h3><p>Generally the layout of the build directory is as follows:</p><ul><li><code>_b0/cache</code>, holds the build cache.</li><li><code>_b0/defaults</code>, holds description defaults.</li><li><code>_b0/i</code>, holds the <a href="#root" title="root">root description</a> and compiled <a href="b0/B0_driver/index.html" title="B0_driver">driver instances</a>.</li><li><code>_b0/v</code>, path to build variants.</li><li><code>_b0/d</code>, path to deployments.</li></ul><p>The structure of a build variant <code>n</code> is as follows:</p><ul><li><code>_b0/v/n/scheme</code>, holds the variant's scheme name.</li><li><code>_b0/v/n/outcome</code>, holds the variant's build outcome (if any).</li><li><code>_b0/v/n/conf</code>, holds the variant's configuration (if any).</li><li><code>_b0/v/n/trash</code>, holds the build variant unit trash (if any).</li><li><code>_b0/v/n/index</code>, holds the variant's cache index (if any).</li><li><code>_b0/v/n/proxy</code>, path to data related to a proxy build (if any).</li><li><code>_b0/v/n/b</code>, path to the variant's build directory</li><li><code>_b0/v/n/b/u1</code>, holds the build of unit <code>u1</code> of the build variant.</li><li><code>_b0/v/n/b/u2</code>, holds the build of unit <code>u2</code> of the build variant.</li></ul><p>The structure of a deployment <code>n</code> is as follows:</p><ul><li><code>_b0/d/n/scheme</code>, holds the deployment scheme name.</li><li><code>_b0/d/n/conf</code>, holds the deployment configuration (if any).</li><li><code>_b0/d/n/s</code>, holds the deployment's staging directory.</li></ul><h2 id="configuration"><a href="#configuration" class="anchor"></a>Configuration</h2><p>A <span class="xref-unresolved" title="Conf"><em>configuration</em></span> is a set of typed key-value bindings consulted by descriptions and build procedures to adjust their outcomes to the build environment and desires of the end user.</p><p>A <span class="xref-unresolved" title="Conf.key">configuration key</span> the user did not explicitely set has a <em>default</em> value, specified in the description at key creation time. This value is either <span class="xref-unresolved" title="Conf.const">constant</span> or <span class="xref-unresolved" title="Conf.discover">discovered</span> via a function.</p><p>A key can belong to at most one <span class="xref-unresolved" title="Conf.Group"><em>group</em></span> which is simply a named set of related keys. Groups are used to easily select a subset of keys for user interaction. For example on <code>b0 key get</code> command invocations, using the <code>-g ocaml</code> option will report the value of all configuration keys that declared themselves to be part of the <code>ocaml</code> group.</p><p>Configuration <span class="xref-unresolved" title="Conf.Preset"><em>presets</em></span> are named sets of key-value bindings defined in descriptions. They are a convenience to set key subsets in bulk in configurations.</p><h4 id="last_stored_conf"><a href="#last_stored_conf" class="anchor"></a>Last and stored configuration</h4><p>The configuration used by the last build is persisted in the build outcome and called the <em>last configuration</em>. It is immutable and contains only the key-value pairs of the configuration that were accessed by the last build. It can be accessed via the <code>b0 key get --last</code> command.</p><p>The mutable <em>stored configuration</em> is the configuration to be used by the next build. It can be acted upon via the <code>b0 key get</code> and <code>b0 key set</code> commands.</p><h4 id="key_values"><a href="#key_values" class="anchor"></a>Key value terminology</h4><p>A configuration key has different values depending where and in which context it is looked up:</p><ul><li><em>Last value</em>. The value used by the last build and stored in the last build outcome, if any.</li><li><em>Stored value</em>. The value from the stored configuration, if any.</li><li><em>Default value</em>. The value given at key definition time. This is either a constant or a value discovered by a function. The default value is used by a build if the key has no stored or environment value (see below). If the default value is discovered, the discovered value gets saved in the stored which is persisted at the end of the build to avoid repeated discovery; this behaviour may however be prevented by the default value <span class="xref-unresolved" title="Conf.discover">definition</span>.</li><li><em>Environment value</em>. The value found, if any, for a key named <code>key</code> in a <code>B0_C_$KEY</code> environment variable where <code>$KEY</code> is <code>key</code> uppercased and with <code>'.'</code> replaced by <code>'_'</code>. In a build this value overrides both the stored and default value of a key. It ends up defining the last value of a key but it doesn't get saved in the stored configuration.</li><li><em>Effective value</em> (for a build). The value used during a build: the environment value or if undefined, the stored value or if undefined, the default value.</li><li><em>Preset value</em>. The value of the key in a configuration <span class="xref-unresolved" title="Conf.Preset">preset</span>. This is either a constant or a discovered value. It is used to set the stored value of a key to a user preference defined in the description.</li></ul><p>During a build the effective value of keys is looked up using the stored configuration. As a side effect new key-value pairs may be added to the stored configuration for keys whose default value is used <em>and discovered</em> during the build. This modified stored configuration is persisted at the end of the build.</p><h2 id="variants"><a href="#variants" class="anchor"></a>Build variants and variant schemes</h2><p>A build variant is a build performed in a particular environment with a particular configuration.</p><p>The build environment is defined by a variant <em>scheme</em> which is responsible for setting up the environment for the variant. For example this can be: configuring and setting up the environment for an opam switch, spin a container or ssh to a remote machine. Build variants are identified by a name <code>n</code> which is used to operate on the variant. The build directory of a variant <code>n</code> is isolated from the others in <code>_b0/v/n</code>. Variants are created via:</p><pre class="language-ocaml"><code>b0 variant create [SCHEME] [-n NAME]</code></pre><p>or implicitely on the first <code>b0 build</code> if there's no existing variant (see <a href="#initial_variant" title="initial_variant">The initial variant</a>). If you don't specify a variant name on creation a unique one will be automatically derived from the scheme name. If you don't specify a scheme, the default scheme (likely the <a href="#nop" title="nop">nop scheme</a>) will be used.</p><p><code>b0</code> allows variants to exist and be acted upon side by side, use <code>b0 variant list</code> to list them. Most <code>b0</code> commands act on the variant specified explicitely via the <code>-w</code> or <code>--variant</code> argument or on the <em>default variant</em> as reported by <code>b0 variant get</code>. If there is no default variant or if it doesn't exist commands might error.</p><h3 id="nop"><a href="#nop" class="anchor"></a>The nop variant scheme</h3><p>The variant scheme <code>Variant.Scheme.nop</code> available under the name <code>nop</code> is the simplest variant scheme. It does nothing, it runs builds in the environment where the build tool <code>b0</code> itself is run.</p><h3 id="default_variant"><a href="#default_variant" class="anchor"></a>The default variant and variant schemes</h3><p>The default variant can be consulted, set or cleared via:</p><pre class="language-ocaml"><code>b0 variant get [--effective | --stored]
b0 variant set [--clear | VARIANT]</code></pre><p>If the <code>B0_VARIANT</code> environment variable is defined, it's value will define the default. The default variant is automatically set to a newly created variant this can be prevented with the <code>-c</code> option:</p><pre class="language-ocaml"><code>b0 variant create -c SCHEME  # Do not set the new variant as the default</code></pre><h3 id="initial_variant"><a href="#initial_variant" class="anchor"></a>The initial variant</h3><p>If no variant exists and there is no default variant when <code>b0 build</code> (or equivalently <code>b0</code>) is run, a variant is created using the default variant scheme. So on a fresh checkout of your project:</p><pre class="language-ocaml"><code>b0</code></pre><p>automatically creates a variant, set it as the default one and builds your project.</p><h2 id="descr_values"><a href="#descr_values" class="anchor"></a>Description values</h2><p><code>B0</code> descriptions are made of a grab bag of OCaml values, configuration keys, build units, packages, variants, variant schemes, deployments, etc. In order to operate on these values from end-user interfaces (e.g. the <code>b0</code> and <code>d0</code> tools), the following must be guaranteed:</p><ol><li>Values and their names need to be defined during the toplevel initialization phase of the program without being conditioned by external factors <code>B0</code> may not be aware of (FIXME implement <code>Def</code> locking).</li><li>Values names need to be unique to ensure all the values are accessible and can be operated on.</li></ol><p>As far as 1. is concerned, <code>B0</code> relies on the discpline of <code>B0.ml</code> file writers. They should define all their description values through toplevel <code>let</code> definitions and <b>never</b> conditionalize their existence or the definition of their components. For examples this should <b>NOT</b> be done:</p><pre class="language-ocaml"><code>let myprogram =
  (* NEVER DO THIS *)
  let default = Conf.const (if Sys.win32 then &quot;bla.exe&quot; else &quot;blu&quot;) in
  Conf.(key &quot;myprogram&quot; ~default)</code></pre><p>As far as 2. is concerned. <code>B0</code> handles this automatically. In two manners:</p><ul><li>If a name used in a description clashes with a name defined by a library <code>B0</code> logs a warning and automatically rename the new definition.</li><li>When multiple <code>B0.ml</code> are composed toghether. The names defined by subdescriptions get automatically namespaced by their position in the file hierarchy. TODO Give example.</li></ul><h2 id="deployments"><a href="#deployments" class="anchor"></a>Deployments</h2><p>Deployements are handled via the <code>d0</code> tool. They do not necessarily need a build to exist but can request for builds of specific packages to exist. They occur through a sequence of steps, all of which are configurable and made available through <em>deployment schemes</em>.</p><ol><li>Pre-stage check and build requirements.</li><li>Stage function, prepare deploy artefacts in the deployment staging directory.</li><li>Post-stage check.</li><li>Pre-push check.</li><li>Deployment push, push the staged artefacts.</li><li>Post-push check.</li></ol><h2 id="descriptions"><a href="#descriptions" class="anchor"></a>Descriptions files</h2><p>A description file is either:</p><ol><li>A <code>B0.b0</code> file that <a href="#b0b0" title="b0b0">describes</a> how to compile a description.</li><li>A <code>B0.ml</code> OCaml file in a directory without a <code>B0.b0</code> file.</li></ol><p>If your description is simple or uses only the default <code>B0</code> library then a simple <code>B0.ml</code> description will do. If not, a <code>B0.b0</code> file is an s-expression based <a href="#b0b0" title="b0b0">configuration file</a> that describes how to compile a self-contained and isolated description. It can specify additional (and conditional) sources and libraries to use, compilation flags and control how subdescriptions (see below) are looked up.</p><h3 id="root"><a href="#root" class="anchor"></a>Root description and directory</h3><p><code>b0</code> supports file hierarchies that contain more than one description file. In general, to ease build setup understanding, it is better to keep a single description per project. However multiple descriptions allow to merge the description of multiple parallel and interdependent projects into a <em>root description</em> that is built in a <em>root directory</em>. We first explain formally how an invocation of <code>b0</code> finds the root directory, examples follow. Given the root directory we can proceed to describe which descriptions belong to the root description. When started in a directory <code>dir</code>, <code>b0</code>, unless invoked with <code>--root</code> option, finds a <em>root directory</em> for the build as follows:</p><ol><li>Starting with <code>dir</code> (included) and moving up in the hierarchy, find the first <code>start</code> directory with a description file (a <code>B0.b0</code> or <code>B0.ml</code> file). If there is no such directory there is no root directory and no build description.</li><li><p>From <code>start</code> move to the parent directory <code>up</code> and:</p><ul><li>If <code>up</code> has a description file and does not exclude <code>start</code> via the <a href="#b0_key_ref" title="b0_key_ref"><code>subs</code> key</a> of an <code>up/B0.b0</code> file, let <code>start</code> be <code>up</code> and go to 2.</li><li>If there is no description in <code>up</code> or if it excludes <code>start</code> then <code>start</code> is the root directory.</li></ul></li></ol><p>Here's an example of a file hierarchy with multiple descriptions:</p><pre>d
‚îî‚îÄ‚îÄ root
    ‚îú‚îÄ‚îÄ B0.b0
    ‚îú‚îÄ‚îÄ B0.ml
    ‚îú‚îÄ‚îÄ p1
    ‚îÇ   ‚îú‚îÄ‚îÄ B0.b0
    ‚îÇ   ‚îî‚îÄ‚îÄ B0.ml
    ‚îú‚îÄ‚îÄ p2
    ‚îÇ   ‚îú‚îÄ‚îÄ B0.ml
    ‚îÇ   ‚îú‚îÄ‚îÄ hop
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ B0.ml
    ‚îÇ   ‚îî‚îÄ‚îÄ sub
    ‚îÇ       ‚îú‚îÄ‚îÄ a
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ B0.ml
    ‚îÇ       ‚îî‚îÄ‚îÄ b
    ‚îî‚îÄ‚îÄ src
        ‚îú‚îÄ‚îÄ bin
        ‚îî‚îÄ‚îÄ lib</pre><p>In the example above starting a driver in <code>d/root</code>, <code>d/root/src/bin</code>, <code>d/root/p1</code>, <code>d/root/p2/sub/b</code> will all find the root directory <code>d/root</code>. However starting a driver in <code>d/root/p2/sub/a</code> will find the root directory <code>d/root/p2/sub/a</code> as there is no description in <code>root/p2/sub</code>. Adding an empty file <code>d/root/p2/sub/B0.b0</code> would allow to find <code>d/root</code>.</p><p>Given a root directory with (a possibly empty) description, <code>b0</code> gathers and <a href="#b0_merge" title="b0_merge">merge</a> the descriptions files of all <em>direct</em> subdirectories and recursively into the <em>root description</em>. The <a href="#b0_key_ref" title="b0_key_ref"><code>subs</code> key</a> of <code>B0.b0</code> files can be used to control which <em>direct</em> subdirectories are looked up. The OCaml sources of different sub descriptions cannot refer to each other directly; they are properly isolated and linked in any (but deterministic) order.</p><p>Assuming no <code>B0.b0</code> file makes use of the <code>subs</code> key in the above example, the root description in <code>root</code> takes into account all descriptions files except <code>d/root/p2/sub/a/B0.ml</code>. Here again adding an empty file <code>d/root/p2/sub/B0.b0</code> would allow to take it into account.</p><h2 id="b0b0"><a href="#b0b0" class="anchor"></a>B0.b0 description files</h2><p>A <code>B0.b0</code> description file is a possibly empty sequence of s-expressions of the form <code>(key value)</code>. Here's an annoted example:</p><pre>(b0-version 0)       ; Mandatory, except if the file is empty
(libs (b0_cmdliner)) ; Always compile with the external b0_cmdliner library
; Describe the sources that make up the description in dependency order.
; As a convention if you split your build in many build files put them
; in a B0.d/ directory. If the [srcs] key is absent and a B0.ml file
; exists next to the B0.b0 file it is always automatically added as if
; (&quot;B0.ml&quot; () &quot;B0.ml file&quot;) was appended at the end of srcs.
(srcs
  ; If the source path has no suffix looks up both for an .ml and mli file
  ((B0.d/util () &quot;Utility module&quot;)
   ; The following source needs the b0_jsoo library and is only added to
   ; the description if the library is found to be installed.
   (B0.d/with_jsoo.ml (b0_jsoo) &quot;Description with jsoo support&quot;)))
(compile (-w -23)) ; Disable warning 23 for compiling the description</pre><h3 id="b0_key_sem"><a href="#b0_key_sem" class="anchor"></a>Key parsing and semantics</h3><p>An <code>B0.b0</code> file without keys and without a <code>B0.ml</code> file sitting next to it is an <em>empty</em> and valid description. If a key is defined more than once, the last one takes over; other than that the key order is irrelevant. Except for keys that start with <code>x-</code>, unknown keys trigger parse warnings.</p><p><b>Relative file paths.</b> Relative file paths are relative to the description file directory.</p><p><b>Library lookup.</b> FIXME. Library lookup is currently quite restricted and done according to the following name mapping:</p><ul><li><code>libname</code>, <code>$LIBDIR/libname/libname.cm[x]a</code></li><li><code>libname.sub</code>, <code>$LIBDIR/libname/libname_sub.cm[x]a</code></li></ul><p>With <code>$LIBDIR</code> being defined (first match) by:</p><ol><li>The value of the environment variable <code>B0_DRIVER_LIBDIR</code></li><li>The value of the environment variable <code>OPAM_SWITCH_PREFIX</code> post</li><li>The value of <code>$(ocamlc -where)/..</code></li></ol><p>Dependency resolution on the libraries is not performed and <code>cmi</code> files have to be in the corresponding <code>libname</code> directory.</p><h3 id="b0_key_ref"><a href="#b0_key_ref" class="anchor"></a>Key reference</h3><ul><li><code>(b0-version 0)</code>. File format version, mandatory, except if the description is empty.</li><li><code>(libs (&lt;libname&gt;...))</code>. Libraries unconditionally used to compile and link.</li><li><code>(drop-libs (&lt;libname&gt;...))</code>. Libraries dropped from compile and link (e.g. to drop <code>B0</code> or <code>B0_care</code>).</li><li><code>(srcs ((&lt;path&gt; (&lt;libname&gt;...) &lt;docstring&gt;)...))</code> OCaml source files to use for the description. Each source is described by a path to an ml file, libraries whose existence condition their usage and a documentation string describing their purpose. If <code>&lt;path&gt;</code> doesn't end with <code>.ml</code> assumes both <code>&lt;path&gt;.ml</code> and <code>&lt;path&gt;.mli</code> exist and are used. A <code>B0.ml</code> file sitting next to the <code>B0.b0</code> is always automatically added at the end of the list.</li><li><p><code>(subs (&lt;op&gt; (&lt;dirname&gt;...)))</code>. Subdescription lookup.</p><ul><li>By default, if unspecified, all the subdirectories of the directory in which the <code>B0.b0</code> resides that do not start with <code>.</code> or <code>_</code> are looked up for descriptions.</li><li>If <code>&lt;op&gt;</code> is <code>include</code> only the specified list of directory names are looked up.</li><li>If <code>&lt;op&gt;</code> is <code>exclude</code> excludes the given list of directory names from the default lookup.</li></ul></li><li><code>(compile-kind &lt;kind&gt;)</code> with <code>&lt;kind&gt;</code> one of <code>byte</code>, <code>native</code>, <code>auto</code>. The kind of binary to compile to. Allows to force the use of <code>ocamlc</code> or <code>ocamlopt</code>. Defaults to <code>auto</code> which selects native code if available and bytecode otherwise. Subdescriptions propagate their constraint to the root. Inconsistent compilation kind in subdescripitions lead to failure. Can be overriden with the `--d-compile-kind` option or by the <code>B0_D_COMPILE_KIND</code> environment variable.</li><li><code>(b0-dir &lt;path&gt;)</code>. The b0 directoy to use. Can be overriden on the command line with the `--b0-dir` option or by the <code>B0_DIR</code> environment variable. Defaults to <code>_b0</code>.</li><li><code>(driver-dir &lt;path&gt;)</code>. The driver directory to use. Can be overriden on the command line or by the <code>B0_DRIVER_DIR</code> environment variable.</li><li><code>(compile (&lt;arg&gt;...))</code>. Arguments added to byte and native compilation. More can be added on the command line via the `--d-compile` option.</li><li><code>(compile-byte (&lt;arg&gt;...))</code>. Arguments added to byte compilation.</li><li><code>(compile-native (&lt;arg&gt;...))</code>. Arguments added to native compilation.</li><li><code>(link (&lt;arg&gt;...))</code>. Arguments added to byte and native linking. More can be added on the command line via theh `--d-link` option.</li><li><code>(link-byte (&lt;arg&gt;...))</code>. Arguments added to byte linking.</li><li><code>(link-native (&lt;arg&gt;...))</code>. Arguments added to native linking.</li><li><code>(ocamlfind &lt;bin&gt;)</code>. <code>ocamlfind</code> binary to use. Ignored in subdescriptions.</li><li><code>(ocamlc &lt;bin&gt;)</code>. <code>ocamlc</code> binary to use. Ignored in subdescriptions. Can be overriden with the `--d-ocamlc` option or by the <code>B0_D_OCAMLC</code> environment variable.</li><li><code>(ocamlopt &lt;bin&gt;)</code>. <code>ocamlopt</code> binary to use. Ignored in subdescriptions. Can be overriden with the `--d-ocamlopt` option or by the <code>B0_D_OCAMLOPT</code> environment variable.</li><li><code>(x-&lt;key&gt; value)</code>. Arbitrary user defined key.</li></ul><h3 id="b0_merge"><a href="#b0_merge" class="anchor"></a><code>B0.b0</code> key merges</h3><p>When multiple <code>B0.b0</code> file are used, their specification is merged with the root description. During this process the key values of subdescriptions are either:</p><ul><li>Ignored (e.g. <code>ocamlc</code>, <code>ocamlopt</code>, etc.).</li><li>Merged according to key specific strategies which can fail; one example of failure is when one subdescription mandates <code>(compile-kind native)</code> and another one <code>(compile-kind byte)</code>.</li></ul><h2 id="more"><a href="#more" class="anchor"></a>More build concepts</h2><h3 id="concept_cmd_stamps"><a href="#concept_cmd_stamps" class="anchor"></a>Output command digests</h3><p>Commands are assumed to be pure functions of their inputs and declared process environment.</p><p>Concatenate and digest: The digest of the executable, the command line arguments, the spawn process environment, the digest of the contents of inputs, the output path. This becomes the name of the file in the cache.</p><h3 id="cleaning"><a href="#cleaning" class="anchor"></a>Cleaning build</h3><p>In a cleaning run, outputs that are not rebuild and were present in the previous run are deleted at the end of the run.</p><h3 id="correct"><a href="#correct" class="anchor"></a>Build correctness</h3><p>If you spend some time thinking about building software incrementally and correctly you quickly realize that our current file system and tool based approach is entirely hopless. The fact that you can't guarantee noone fiddles with the outputs of your build steps across build system runs. <code>B0</code> is not different and you can entirely trip it by fiddling with the contents of its <code>_b0</code> dir.</p><h2 id="recipes"><a href="#recipes" class="anchor"></a>Recipes and menagerie</h2><h3 id="conf"><a href="#conf" class="anchor"></a>Writing conf discovery</h3><p>Error only if really needed. Otherwise log with warning and default to a reasonable deafult value. Build units can still abort if they can't use the value.</p><h2 id="todo"><a href="#todo" class="anchor"></a>Old <code>TODO.md</code></h2><ul><li>Allow tool lookup to be an option Review what happens in build outcomes on failure.</li><li>Build part cleaning</li><li>Redo build finish reporting and cycle analysis, start from the parts, not from the ops !</li><li>Tool version example.</li><li>OCaml version example/scheme.</li><li>Doc vs synopsis, e.g. for variants. Maybe not. Lookup in the API.</li><li>`b0 env`, `b0 exec-env`</li><li>Consider reording tool &amp; conf. Also `Conf` became a mess make it more `Build`-like.</li><li>Build need a way to know if we are a root unit or not.</li><li>Serialization move away from Marshal, so that proxy build data can be read back.</li><li>Find something forwards looking w.r.t relative paths specified to units. We don't want to be in the build fun I think. src_root which defaults to sub description location ?</li><li>`Build.await_file` ? Basically `Build.read` but without the read.</li><li>Add `unit path <code>-b</code>`</li><li>Page `cmd` info, like we page `log`.</li><li>copy_file handle permissions</li><li>Add a flag to allow multiple writes.</li><li>Reproducible builds. Should we force by default BUILD_PATH_PREFIX_MAP in the environment ? https://reproducible-builds.org/specs/build-path-prefix-map/</li><li>https://hub.docker.com/r/ocaml/opam2-staging/tags/</li><li>B0_ocaml, stub changes do not retrigger some compilation. Make library archive depend on stubs. May also be the reason for spurious failures in examples.</li><li>b0 log <code>-f</code> <code>-n</code> <code>-i</code> <code>--failure</code> <code>--reads</code> <code>--writes</code> <code>--file</code> <code>--pkg</code></li><li>Distingish paths in `Cmd.t` ?</li></ul><h3 id="b0.def"><a href="#b0.def" class="anchor"></a>B0.Def</h3><ul><li>Provide a way to lock definitions so that any def afterwards raises. This ensures that description files do not generate definitions dynamically (e.g. conf keys, build units, variants schemes).</li><li>For B0 as a library. Provide a way to disable the retaining of definitions (Unit.list, Variant.Scheme.list). Related to locking.</li></ul><h3 id="b0.conf"><a href="#b0.conf" class="anchor"></a>B0.Conf</h3><p>Discover should be `Build.t` based. This will give us caching/reacting to the environment for free and will allow to hide the build aim. Add a special build unit for it: this can give a directory to write things in aswell.</p><h3 id="b0.pkg"><a href="#b0.pkg" class="anchor"></a>B0.Pkg</h3><p>Should have a unit associated or maybe not it should be easy to sync on all the units of a package once we have the notion of package in units. This should be sufficient for `META` file generation and `opam` file sync.</p><h3 id="`b0-build`-improvements"><a href="#`b0-build`-improvements" class="anchor"></a>`b0 build` improvements</h3><ul><li>Implement `--c-$VAR val ` to set configuration values.</li><li>Improve `-u` unit requests, in particular at the API level we need `Build.request : Build.t -&gt; Unit.t -&gt; unit`. Also add `--no-deps`, `--no-prev`.</li><li><p>Incremental performance. Already pretty good but could be better:</p><ul><li>Consider not re-hashing the cache elements, keep their hash in the build outcome. I.e. trust that noone fiddles with _b0/cache</li><li>Implement a fast check for the whole build on the roots. This is cheating but is useful for e.g. `b0 run` to quickly check and report the user is running outdated programs. It's also useful for projects like `odig` to see if the doc are up-to-date before showing them.</li><li>Implement per unit fast checks. This is less cheating, the parts that pass the check don't need to be trashed and relinked and we avoid computing all the commands.</li><li>Dolan. Make the cache read only.</li><li>Michel. Hash server using modern fs notification APIs. b0 simply consults the server.</li></ul></li></ul><h3 id="`b0`-driver"><a href="#`b0`-driver" class="anchor"></a>`b0` driver</h3><ul><li>Something is wrong with the error strategy lots of boiler plate. Also the variant access API is messy.</li><li>`B0.b0` make `b0-version` really mandatory except on empty files.</li></ul><h3 id="b0.tool"><a href="#b0.tool" class="anchor"></a>B0.Tool</h3><p>Provide support for checking minimal version. Or not.</p><h3 id="proxy-variants-and-_b0"><a href="#proxy-variants-and-_b0" class="anchor"></a>Proxy variants and _b0</h3><p>In `B0_docker` The current scheme means that we copy rather than link(2). This is due to the way we mount stuff and the business of excluding parts of `_b0`. The whole way of proxying needs revisiting so that we can simply mount the root dir without excluding `_b0`. This should not be a big deal, somehow we only need to deal with `_b0/i` so that the proxy instance can live there (e.g. setup `B0_DRIVER_DIR` and/or forward with `--d-dir`).</p><p>However we also want to keep the current style for e.g. `ssh` proxies where we don't want to rsync all the local variants.</p><h3 id="variants'y"><a href="#variants'y" class="anchor"></a>Variants</h3><ul><li>Do we want a configuration API ? Also should we really namespace the variants ? With the current scheme we end up with a lot of redundancy on project composition.</li><li>Logging for setup operations.</li><li>Add a suggested name to the Variant.Scheme API, naming a variant after the variant scheme may not work that well (but that may be due to 1.).</li><li>Document/think about how a new scheme can be added e.g. to a whole opam switch. (Add a new package with the scheme, set environment variable `B0_D_LIBS`).</li><li>Proxy results, they should be stored seperatly so that we don't try build them.</li><li>Proxy we might want to access the namespaced name. E.g. for the docker image.</li><li>Metadata on variants ? Could be useful for cross-variant deployements.</li><li>Review direct functions signature, unify with proxy_conf ?</li><li>need to distinguish b0 runs from build product runs.</li><li>It is unclear whether proxy scheme should hard-code the proxied variant. Maybe this could show up and specified in the cli interface e.g. via `--proxy`.</li></ul><h3 id="build-context"><a href="#build-context" class="anchor"></a>Build context</h3><p>A topkg-like build context is needed. It's a bit unclear where this should fit. Ponder the following alternative.</p><ol><li>A configuration key in B0_care.</li><li>A value held by `Env` and thus defined by the variant scheme.</li></ol><p>In any case this should be exposed in `Build.t` values.</p><p>Also maybe another name than build context should be found. Source context, run runner, goal.</p><p>In general the behaviour of <code>b0</code> tries to be as independent from the operating context as possible. However some <span class="xref-unresolved" title="Conf">configuration keys</span> and/or actions are sensitive to the what is called the <em>build context</em>. This makes the invocations to specify on the command line and in package descriptions (e.g. the <code>build:</code> field of <code>opam</code> files) terser and thus generally improves the DRYness of the tool.</p><p>More specifically <code>b0</code> distinguishes between the following contexts:</p><ul><li><code>`Distrib</code> iff <code>not (vcs s)</code>. No VCS is present this is a build from a distribution. If there are configuration bits they should be setup according to the build environment.</li><li><code>`Dev</code> iff <code>(vcs c) &amp;&amp; not (dev_pkg c)</code>. This is a development build invoked manually in a source repository. The repository checkout should likely not be touched and configuration bits not be setup. This is happening for example if the developer is building the software in her working source repository by invoking <code>b0</code>.</li><li><code>`Dev_pkg</code> iff <code>(vcs c) &amp;&amp; (dev_pkg c)</code>. This is a package manager development build. In this case the repository checkout may need to be massaged into a pseudo-distribution for the software to be installed. This meas that distribution watermaking and massaging should be performed. See <span class="xref-unresolved" title="distrib">distribution description</span> and the <code>prepare_on_pin</code> argument. Besides existing configuration bits should be setup according to the build environment.</li></ul></div></body></html>
