// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.2

//# unitInfo: Provides: CamlinternalFormatBasics
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function erase_rel(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, erase_rel(rest)];
      case 1:
       var rest$0 = param[1]; return [1, erase_rel(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, erase_rel(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, erase_rel(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, erase_rel(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, erase_rel(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, erase_rel(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, erase_rel(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1];
       return [8, ty, erase_rel(rest$7)];
      case 9:
       var rest$8 = param[3], ty1 = param[1];
       return [9, ty1, ty1, erase_rel(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, erase_rel(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, erase_rel(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, erase_rel(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, erase_rel(rest$12)];
      default: var rest$13 = param[1]; return [14, erase_rel(rest$13)];
    }
   }
   function concat_fmtty(fmtty1, fmtty2){
    if(typeof fmtty1 === "number") return fmtty2;
    switch(fmtty1[0]){
      case 0:
       var rest = fmtty1[1]; return [0, concat_fmtty(rest, fmtty2)];
      case 1:
       var rest$0 = fmtty1[1]; return [1, concat_fmtty(rest$0, fmtty2)];
      case 2:
       var rest$1 = fmtty1[1]; return [2, concat_fmtty(rest$1, fmtty2)];
      case 3:
       var rest$2 = fmtty1[1]; return [3, concat_fmtty(rest$2, fmtty2)];
      case 4:
       var rest$3 = fmtty1[1]; return [4, concat_fmtty(rest$3, fmtty2)];
      case 5:
       var rest$4 = fmtty1[1]; return [5, concat_fmtty(rest$4, fmtty2)];
      case 6:
       var rest$5 = fmtty1[1]; return [6, concat_fmtty(rest$5, fmtty2)];
      case 7:
       var rest$6 = fmtty1[1]; return [7, concat_fmtty(rest$6, fmtty2)];
      case 8:
       var rest$7 = fmtty1[2], ty = fmtty1[1];
       return [8, ty, concat_fmtty(rest$7, fmtty2)];
      case 9:
       var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
       return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
      case 10:
       var rest$9 = fmtty1[1]; return [10, concat_fmtty(rest$9, fmtty2)];
      case 11:
       var rest$10 = fmtty1[1]; return [11, concat_fmtty(rest$10, fmtty2)];
      case 12:
       var rest$11 = fmtty1[1]; return [12, concat_fmtty(rest$11, fmtty2)];
      case 13:
       var rest$12 = fmtty1[1]; return [13, concat_fmtty(rest$12, fmtty2)];
      default:
       var rest$13 = fmtty1[1]; return [14, concat_fmtty(rest$13, fmtty2)];
    }
   }
   function concat_fmt(fmt1, fmt2){
    if(typeof fmt1 === "number") return fmt2;
    switch(fmt1[0]){
      case 0:
       var rest = fmt1[1]; return [0, concat_fmt(rest, fmt2)];
      case 1:
       var rest$0 = fmt1[1]; return [1, concat_fmt(rest$0, fmt2)];
      case 2:
       var rest$1 = fmt1[2], pad = fmt1[1];
       return [2, pad, concat_fmt(rest$1, fmt2)];
      case 3:
       var rest$2 = fmt1[2], pad$0 = fmt1[1];
       return [3, pad$0, concat_fmt(rest$2, fmt2)];
      case 4:
       var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
       return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
      case 5:
       var
        rest$4 = fmt1[4],
        prec$0 = fmt1[3],
        pad$2 = fmt1[2],
        iconv$0 = fmt1[1];
       return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
      case 6:
       var
        rest$5 = fmt1[4],
        prec$1 = fmt1[3],
        pad$3 = fmt1[2],
        iconv$1 = fmt1[1];
       return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
      case 7:
       var
        rest$6 = fmt1[4],
        prec$2 = fmt1[3],
        pad$4 = fmt1[2],
        iconv$2 = fmt1[1];
       return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
      case 8:
       var
        rest$7 = fmt1[4],
        prec$3 = fmt1[3],
        pad$5 = fmt1[2],
        fconv = fmt1[1];
       return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
      case 9:
       var rest$8 = fmt1[2], pad$6 = fmt1[1];
       return [9, pad$6, concat_fmt(rest$8, fmt2)];
      case 10:
       var rest$9 = fmt1[1]; return [10, concat_fmt(rest$9, fmt2)];
      case 11:
       var rest$10 = fmt1[2], str = fmt1[1];
       return [11, str, concat_fmt(rest$10, fmt2)];
      case 12:
       var rest$11 = fmt1[2], chr = fmt1[1];
       return [12, chr, concat_fmt(rest$11, fmt2)];
      case 13:
       var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
       return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
      case 14:
       var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
       return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
      case 15:
       var rest$14 = fmt1[1]; return [15, concat_fmt(rest$14, fmt2)];
      case 16:
       var rest$15 = fmt1[1]; return [16, concat_fmt(rest$15, fmt2)];
      case 17:
       var rest$16 = fmt1[2], fmting_lit = fmt1[1];
       return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
      case 18:
       var rest$17 = fmt1[2], fmting_gen = fmt1[1];
       return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
      case 19:
       var rest$18 = fmt1[1]; return [19, concat_fmt(rest$18, fmt2)];
      case 20:
       var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
       return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
      case 21:
       var rest$20 = fmt1[2], counter = fmt1[1];
       return [21, counter, concat_fmt(rest$20, fmt2)];
      case 22:
       var rest$21 = fmt1[1]; return [22, concat_fmt(rest$21, fmt2)];
      case 23:
       var rest$22 = fmt1[2], ign = fmt1[1];
       return [23, ign, concat_fmt(rest$22, fmt2)];
      default:
       var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
       return [24, arity, f, concat_fmt(rest$23, fmt2)];
    }
   }
   var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
   runtime.caml_register_global
    (0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib
//# unitInfo: Requires: CamlinternalFormatBasics
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_false$0 = "false",
    cst_true$0 = "true",
    caml_atomic_cas = runtime.caml_atomic_cas,
    caml_atomic_load = runtime.caml_atomic_load,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_channel_size = runtime.caml_ml_channel_size,
    caml_ml_channel_size_64 = runtime.caml_ml_channel_size_64,
    caml_ml_close_channel = runtime.caml_ml_close_channel,
    caml_ml_flush = runtime.caml_ml_flush,
    caml_ml_input = runtime.caml_ml_input,
    caml_ml_input_char = runtime.caml_ml_input_char,
    caml_ml_open_descriptor_in = runtime.caml_ml_open_descriptor_in,
    caml_ml_open_descriptor_out = runtime.caml_ml_open_descriptor_out,
    caml_ml_output = runtime.caml_ml_output,
    caml_ml_output_bytes = runtime.caml_ml_output_bytes,
    caml_ml_output_char = runtime.caml_ml_output_char,
    caml_ml_set_binary_mode = runtime.caml_ml_set_binary_mode,
    caml_ml_set_channel_name = runtime.caml_ml_set_channel_name,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_concat = runtime.caml_string_concat,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_sys_open = runtime.caml_sys_open,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Invalid_argument = global_data.Invalid_argument,
    Failure = global_data.Failure,
    Match_failure = global_data.Match_failure,
    Assert_failure = global_data.Assert_failure,
    Not_found = global_data.Not_found,
    Out_of_memory = global_data.Out_of_memory,
    Stack_overflow = global_data.Stack_overflow,
    Sys_error = global_data.Sys_error,
    End_of_file = global_data.End_of_file,
    Division_by_zero = global_data.Division_by_zero,
    Sys_blocked_io = global_data.Sys_blocked_io,
    Undefined_recursive_module = global_data.Undefined_recursive_module;
   function failwith(s){
    throw caml_maybe_attach_backtrace([0, Failure, s], 1);
   }
   function invalid_arg(s){
    throw caml_maybe_attach_backtrace([0, Invalid_argument, s], 1);
   }
   var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
   function min(x, y){return runtime.caml_lessequal(x, y) ? x : y;}
   function max(x, y){return runtime.caml_greaterequal(x, y) ? x : y;}
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lnot(x){return x ^ -1;}
   var
    infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)),
    neg_infinity =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)),
    nan =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32760)),
    max_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)),
    min_float =
      caml_int64_float_of_bits(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)),
    epsilon_float =
      caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)),
    symbol_concat = caml_string_concat,
    cst_char_of_int = "char_of_int",
    cst_true = cst_true$0,
    cst_false = cst_false$0,
    cst_bool_of_string = "bool_of_string",
    _a_ = [0, 1],
    _b_ = [0, 0];
   function char_of_int(n){
    if(0 <= n && 255 >= n) return n;
    return invalid_arg(cst_char_of_int);
   }
   function string_of_bool(b){return b ? cst_true : cst_false;}
   function bool_of_string(param){
    return param !== cst_false$0
            ? param !== cst_true$0 ? invalid_arg(cst_bool_of_string) : 1
            : 0;
   }
   function bool_of_string_opt(param){
    return param !== cst_false$0 ? param !== cst_true$0 ? 0 : _a_ : _b_;
   }
   function string_of_int(n){return "" + n;}
   function int_of_string_opt(s){
    try{var _w_ = [0, caml_int_of_string(s)]; return _w_;}
    catch(_x_){
     var _v_ = caml_wrap_exception(_x_);
     if(_v_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function valid_float_lexem(s1){
    var l = caml_ml_string_length(s1), i = 0;
    for(;;){
     if(l <= i) return s1 + ".";
     var match = runtime.caml_string_get(s1, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return s1;
     }
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function string_of_float(f){
    return valid_float_lexem(runtime.caml_format_float("%.12g", f));
   }
   function float_of_string_opt(s){
    try{var _t_ = [0, caml_float_of_string(s)]; return _t_;}
    catch(_u_){
     var _s_ = caml_wrap_exception(_u_);
     if(_s_[1] === Failure) return 0;
     throw caml_maybe_attach_backtrace(_s_, 0);
    }
   }
   function symbol(l1, l2){
    if(! l1) return l2;
    var _q_ = l1[2], h1 = l1[1];
    if(! _q_) return [0, h1, l2];
    var match = _q_[2], h2 = _q_[1];
    if(! match) return [0, h1, [0, h2, l2]];
    var
     tl = match[2],
     h3 = match[1],
     block = [0, h3, 24029],
     dst = block,
     offset = 1,
     l1$0 = tl;
    for(;;){
     if(l1$0){
      var _r_ = l1$0[2], h1$0 = l1$0[1];
      if(_r_){
       var match$0 = _r_[2], h2$0 = _r_[1];
       if(match$0){
        var tl$0 = match$0[2], h3$0 = match$0[1], dst$0 = [0, h3$0, 24029];
        dst[1 + offset] = [0, h1$0, [0, h2$0, dst$0]];
        dst = dst$0;
        offset = 1;
        l1$0 = tl$0;
        continue;
       }
       dst[1 + offset] = [0, h1$0, [0, h2$0, l2]];
      }
      else
       dst[1 + offset] = [0, h1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, h1, [0, h2, block]];
    }
   }
   var
    stdin = caml_ml_open_descriptor_in(0),
    stdout = caml_ml_open_descriptor_out(1),
    stderr = caml_ml_open_descriptor_out(2),
    _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]],
    _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]],
    cst_output = "output",
    cst_output_substring = "output_substring",
    _e_ = [0, 0, [0, 7, 0]],
    _f_ = [0, 0, [0, 6, 0]],
    cst_input = "input",
    cst_really_input = "really_input";
   function open_out_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_out(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_out(name){return open_out_gen(_c_, 438, name);}
   function open_out_bin(name){return open_out_gen(_d_, 438, name);}
   function flush_all(param){
    var param$0 = runtime.caml_ml_out_channels_list(0);
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     try{caml_ml_flush(a);}
     catch(_p_){
      var _o_ = caml_wrap_exception(_p_);
      if(_o_[1] !== Sys_error) throw caml_maybe_attach_backtrace(_o_, 0);
     }
     param$0 = l;
    }
   }
   function output_bytes(oc, s){
    return caml_ml_output_bytes(oc, s, 0, caml_ml_bytes_length(s));
   }
   function output_string(oc, s){
    return caml_ml_output(oc, s, 0, caml_ml_string_length(s));
   }
   function output(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_output_bytes(oc, s, ofs, len);
    return invalid_arg(cst_output);
   }
   function output_substring(oc, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(s) - len | 0) >= ofs)
     return caml_ml_output(oc, s, ofs, len);
    return invalid_arg(cst_output_substring);
   }
   function output_value(chan, v){
    return runtime.caml_output_value(chan, v, 0);
   }
   function close_out(oc){
    caml_ml_flush(oc);
    return caml_ml_close_channel(oc);
   }
   function close_out_noerr(oc){
    try{caml_ml_flush(oc);}catch(_n_){}
    try{var _l_ = caml_ml_close_channel(oc); return _l_;}catch(_m_){return 0;}
   }
   function open_in_gen(mode, perm, name){
    var c = caml_ml_open_descriptor_in(caml_sys_open(name, mode, perm));
    caml_ml_set_channel_name(c, name);
    return c;
   }
   function open_in(name){return open_in_gen(_e_, 0, name);}
   function open_in_bin(name){return open_in_gen(_f_, 0, name);}
   function input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_ml_input(ic, s, ofs, len);
    return invalid_arg(cst_input);
   }
   function unsafe_really_input(ic, s, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 >= len$0) return 0;
     var r = caml_ml_input(ic, s, ofs$0, len$0);
     if(0 === r) throw caml_maybe_attach_backtrace(End_of_file, 1);
     var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
     ofs$0 = ofs$1;
     len$0 = len$1;
    }
   }
   function really_input(ic, s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return unsafe_really_input(ic, s, ofs, len);
    return invalid_arg(cst_really_input);
   }
   function really_input_string(ic, len){
    var s = caml_create_bytes(len);
    really_input(ic, s, 0, len);
    return caml_string_of_bytes(s);
   }
   function input_line(chan){
    function build_result(buf, pos, param){
     var pos$0 = pos, param$0 = param;
     for(;;){
      if(! param$0) return buf;
      var tl = param$0[2], hd = param$0[1], len = caml_ml_bytes_length(hd);
      runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len | 0, len);
      var pos$1 = pos$0 - len | 0;
      pos$0 = pos$1;
      param$0 = tl;
     }
    }
    var accu = 0, len = 0;
    for(;;){
     var n = runtime.caml_ml_input_scan_line(chan);
     if(0 === n){
      if(! accu) throw caml_maybe_attach_backtrace(End_of_file, 1);
      var _k_ = build_result(caml_create_bytes(len), len, accu);
     }
     else{
      if(0 >= n){
       var beg = caml_create_bytes(- n | 0);
       caml_ml_input(chan, beg, 0, - n | 0);
       var len$1 = len - n | 0, accu$0 = [0, beg, accu];
       accu = accu$0;
       len = len$1;
       continue;
      }
      var res = caml_create_bytes(n - 1 | 0);
      caml_ml_input(chan, res, 0, n - 1 | 0);
      caml_ml_input_char(chan);
      if(accu)
       var
        len$0 = (len + n | 0) - 1 | 0,
        _k_ = build_result(caml_create_bytes(len$0), len$0, [0, res, accu]);
      else
       var _k_ = res;
     }
     return caml_string_of_bytes(_k_);
    }
   }
   function close_in_noerr(ic){
    try{var _i_ = caml_ml_close_channel(ic); return _i_;}catch(_j_){return 0;}
   }
   function print_char(c){return caml_ml_output_char(stdout, c);}
   function print_string(s){return output_string(stdout, s);}
   function print_bytes(s){return output_bytes(stdout, s);}
   function print_int(i){return output_string(stdout, "" + i);}
   function print_float(f){return output_string(stdout, string_of_float(f));}
   function print_endline(s){
    output_string(stdout, s);
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function print_newline(param){
    caml_ml_output_char(stdout, 10);
    return caml_ml_flush(stdout);
   }
   function prerr_char(c){return caml_ml_output_char(stderr, c);}
   function prerr_string(s){return output_string(stderr, s);}
   function prerr_bytes(s){return output_bytes(stderr, s);}
   function prerr_int(i){return output_string(stderr, "" + i);}
   function prerr_float(f){return output_string(stderr, string_of_float(f));}
   function prerr_endline(s){
    output_string(stderr, s);
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function prerr_newline(param){
    caml_ml_output_char(stderr, 10);
    return caml_ml_flush(stderr);
   }
   function read_line(param){caml_ml_flush(stdout); return input_line(stdin);}
   function read_int(param){return caml_int_of_string(read_line(0));}
   function read_int_opt(param){return int_of_string_opt(read_line(0));}
   function read_float(param){return caml_float_of_string(read_line(0));}
   function read_float_opt(param){return float_of_string_opt(read_line(0));}
   function string_of_format(param){var str = param[2]; return str;}
   function symbol$0(_h_, param){
    var
     str2 = param[2],
     fmt2 = param[1],
     str1 = _h_[2],
     fmt1 = _h_[1],
     s2 = "%," + str2;
    return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), str1 + s2];
   }
   var exit_function = [0, flush_all];
   function at_exit(f){
    for(;;){
     var f_yet_to_run = [0, 1], old_exit = caml_atomic_load(exit_function);
     let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
     var
      new_exit =
        function(param){
         if(caml_atomic_cas(f_yet_to_run$0, 1, 0)) caml_call1(f, 0);
         return caml_call1(old_exit$0, 0);
        },
      success = caml_atomic_cas(exit_function, old_exit, new_exit),
      _g_ = 1 - success;
     if(! _g_) return _g_;
    }
   }
   var do_domain_local_at_exit = [0, function(param){return 0;}];
   function do_at_exit(param){
    caml_call1(do_domain_local_at_exit[1], 0);
    return caml_call1(caml_atomic_load(exit_function), 0);
   }
   function exit(retcode){
    do_at_exit(0);
    return runtime.caml_sys_exit(retcode);
   }
   runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
   var
    Stdlib =
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       2147483647,
       -2147483648,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       symbol_concat,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       symbol,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       runtime.caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit];
   runtime.caml_register_global(45, Stdlib, "Stdlib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Either
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function left(v){return [0, v];}
   function right(v){return [1, v];}
   function is_left(param){return 0 === param[0] ? 1 : 0;}
   function is_right(param){return 0 === param[0] ? 0 : 1;}
   function find_left(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function find_right(param){
    if(0 === param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function map_left(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_right(f, e){
    if(0 === e[0]) return e;
    var v = e[1];
    return [1, caml_call1(f, v)];
   }
   function map(left, right, param){
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(left, v)];}
    var v$0 = param[1];
    return [1, caml_call1(right, v$0)];
   }
   function fold(left, right, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(left, v);}
    var v$0 = param[1];
    return caml_call1(right, v$0);
   }
   function equal(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 === e2[0]){var v2 = e2[1]; return caml_call2(left, v1, v2);}
    }
    else{
     var v1$0 = e1[1];
     if(0 !== e2[0]){var v2$0 = e2[1]; return caml_call2(right, v1$0, v2$0);}
    }
    return 0;
   }
   function compare(left, right, e1, e2){
    if(0 === e1[0]){
     var v1 = e1[1];
     if(0 !== e2[0]) return -1;
     var v2 = e2[1];
     return caml_call2(left, v1, v2);
    }
    var v1$0 = e1[1];
    if(0 === e2[0]) return 1;
    var v2$0 = e2[1];
    return caml_call2(right, v1$0, v2$0);
   }
   var
    Stdlib_Either =
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map,
       fold,
       fold,
       fold,
       equal,
       compare];
   runtime.caml_register_global(0, Stdlib_Either, "Stdlib__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Sys
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    ocaml_version = "5.2.0",
    ocaml_release = [0, 5, 2, 0, 0],
    Stdlib = global_data.Stdlib,
    executable_name = runtime.caml_sys_executable_name(0),
    os_type = runtime.caml_sys_get_config(0)[1],
    backend_type = [0, "js_of_ocaml"],
    unix = runtime.caml_sys_const_ostype_unix(0),
    win32 = runtime.caml_sys_const_ostype_win32(0),
    cygwin = runtime.caml_sys_const_ostype_cygwin(0),
    max_array_length = runtime.caml_sys_const_max_wosize(0),
    max_floatarray_length = max_array_length / 2 | 0,
    max_string_length = (4 * max_array_length | 0) - 1 | 0;
   function getenv_opt(s){
    try{var _d_ = [0, runtime.caml_sys_getenv(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var interactive = [0, 0];
   function set_signal(sig_num, sig_beh){return 0;}
   var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
   function catch_break(on){return on ? 0 : 0;}
   function Make(_b_, _a_){return [0, 1];}
   var
    Immediate64 = [0, Make],
    Stdlib_Sys =
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       32,
       32,
       0,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       -1,
       -2,
       -3,
       -4,
       -5,
       -6,
       -7,
       -8,
       -9,
       -10,
       -11,
       -12,
       -13,
       -14,
       -15,
       -16,
       -17,
       -18,
       -19,
       -20,
       -21,
       -22,
       -23,
       -24,
       -25,
       -26,
       -27,
       -28,
       Break,
       catch_break,
       ocaml_version,
       0,
       ocaml_release,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
   runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Obj
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Obj_extension_constructor$1 = "Obj.extension_constructor",
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function is_block(a){return 1 - (typeof a === "number" ? 1 : 0);}
   var
    double_field = runtime.caml_array_get,
    set_double_field = runtime.caml_array_set,
    cst_Obj_extension_constructor = cst_Obj_extension_constructor$1,
    cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
   function of_val(x){
    a:
    {
     if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1){var slot = x[1]; break a;}
     var slot = x;
    }
    a:
    {
     if(is_block(slot) && caml_obj_tag(slot) === 248){var name = slot[1]; break a;}
     var name = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
    }
    return caml_obj_tag(name) === 252
            ? slot
            : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
   }
   function name(slot){return slot[1];}
   function id(slot){return slot[2];}
   var
    Extension_constructor = [0, of_val, name, id],
    max_ephe_length = Stdlib_Sys[13] - 2 | 0,
    cst_Obj_Ephemeron_create = "Obj.Ephemeron.create",
    cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key",
    cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy",
    cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key",
    cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key",
    cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key",
    cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
   function create(l){
    var _f_ = 0 <= l ? 1 : 0, _g_ = _f_ ? l <= max_ephe_length ? 1 : 0 : _f_;
    if(1 - _g_) caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
    return runtime.caml_ephe_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _c_ = 0 <= o ? 1 : 0,
     _d_ = _c_ ? o < length(e) ? 1 : 0 : _c_,
     _e_ = 1 - _d_;
    return _e_ ? caml_call1(Stdlib[1], msg) : _e_;
   }
   function get_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_key_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function set_key(e, o, x){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
    return runtime.caml_ephe_set_key(e, o, x);
   }
   function unset_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
    return runtime.caml_ephe_unset_key(e, o);
   }
   function check_key(e, o){
    raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit_key(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _a_ = 0 !== l ? 1 : 0,
      _b_ = _a_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _a_;
     return _b_;
    }
    return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
   }
   var
    Stdlib_Obj =
      [0,
       is_block,
       double_field,
       set_double_field,
       0,
       243,
       244,
       245,
       246,
       247,
       248,
       249,
       250,
       251,
       251,
       252,
       253,
       254,
       255,
       1000,
       1001,
       1002,
       Extension_constructor,
       [0,
        create,
        length,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        runtime.caml_ephe_get_data,
        runtime.caml_ephe_get_data_copy,
        runtime.caml_ephe_set_data,
        runtime.caml_ephe_unset_data,
        runtime.caml_ephe_check_data,
        runtime.caml_ephe_blit_data,
        max_ephe_length]];
   runtime.caml_register_global(11, Stdlib_Obj, "Stdlib__Obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Type
//# unitInfo: Requires: Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Id = "Id",
    _a_ = [0, 0];
   function make(param){
    var Id = [248, cst_Id, runtime.caml_fresh_oo_id(0)];
    return [0, Id];
   }
   function uid(A){
    var _b_ = caml_call1(Stdlib_Obj[22][1], A[1]);
    return caml_call1(Stdlib_Obj[22][3], _b_);
   }
   function provably_equal(A, B){return A[1] === B[1] ? _a_ : 0;}
   var Id = [0, make, uid, provably_equal], Stdlib_Type = [0, Id];
   runtime.caml_register_global(3, Stdlib_Type, "Stdlib__Type");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Atomic
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_atomic_exchange = runtime.caml_atomic_exchange,
    caml_atomic_fetch_add = runtime.caml_atomic_fetch_add;
   function set(r, x){caml_atomic_exchange(r, x); return 0;}
   function incr(r){caml_atomic_fetch_add(r, 1); return 0;}
   function decr(r){caml_atomic_fetch_add(r, -1); return 0;}
   var
    Stdlib_Atomic =
      [0,
       function(_a_){return [0, _a_];},
       runtime.caml_atomic_make_contended,
       runtime.caml_atomic_load,
       set,
       caml_atomic_exchange,
       runtime.caml_atomic_cas,
       caml_atomic_fetch_add,
       incr,
       decr];
   runtime.caml_register_global(0, Stdlib_Atomic, "Stdlib__Atomic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalLazy
//# unitInfo: Requires: Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_lazy_update_to_forward = runtime.caml_lazy_update_to_forward,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined =
      [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
   function force_gen_lazy_block(only_val, blk){
    if(0 !== runtime.caml_lazy_update_to_forcing(blk))
     throw caml_maybe_attach_backtrace(Undefined, 1);
    if(only_val){
     var closure$0 = blk[1];
     blk[1] = 0;
     var result$0 = caml_call1(closure$0, 0);
     blk[1] = result$0;
     caml_lazy_update_to_forward(blk);
     return result$0;
    }
    var closure = blk[1];
    blk[1] = 0;
    try{
     var result = caml_call1(closure, 0);
     blk[1] = result;
     caml_lazy_update_to_forward(blk);
     return result;
    }
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     blk[1] = function(param){throw caml_maybe_attach_backtrace(e, 0);};
     runtime.caml_lazy_reset_to_lazy(blk);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function force_lazy_block(blk){return force_gen_lazy_block(0, blk);}
   function force_gen(only_val, lzv){
    var t = runtime.caml_obj_tag(lzv);
    if(t === Stdlib_Obj[12]) return lzv[1];
    if(t === Stdlib_Obj[6]) throw caml_maybe_attach_backtrace(Undefined, 1);
    return t !== Stdlib_Obj[8] ? lzv : force_gen_lazy_block(only_val, lzv);
   }
   var CamlinternalLazy = [0, Undefined, force_lazy_block, force_gen];
   runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lazy
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Undefined = CamlinternalLazy[1];
   function force_val(l){return caml_call2(CamlinternalLazy[3], 1, l);}
   function from_fun(f){
    var x = runtime.caml_obj_block(Stdlib_Obj[8], 1);
    x[1] = f;
    return x;
   }
   function from_val(v){
    var t = caml_obj_tag(v);
    if
     (t !== Stdlib_Obj[12]
      && t !== Stdlib_Obj[8] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[16])
     return v;
    return runtime.caml_lazy_make_forward(v);
   }
   function is_val(l){
    var _i_ = Stdlib_Obj[8];
    return caml_obj_tag(l) !== _i_ ? 1 : 0;
   }
   function map(f, x){
    return [246,
            function(_f_){
             var _g_ = caml_obj_tag(x);
             a:
             if(250 === _g_)
              var _h_ = x[1];
             else{
              if(246 !== _g_ && 244 !== _g_){var _h_ = x; break a;}
              var _h_ = caml_call1(CamlinternalLazy[2], x);
             }
             return caml_call1(f, _h_);
            }];
   }
   function map_val(f, x){
    if(! is_val(x))
     return [246,
             function(_c_){
              var _d_ = caml_obj_tag(x);
              a:
              if(250 === _d_)
               var _e_ = x[1];
              else{
               if(246 !== _d_ && 244 !== _d_){var _e_ = x; break a;}
               var _e_ = caml_call1(CamlinternalLazy[2], x);
              }
              return caml_call1(f, _e_);
             }];
    var _a_ = caml_obj_tag(x);
    a:
    if(250 === _a_)
     var _b_ = x[1];
    else{
     if(246 !== _a_ && 244 !== _a_){var _b_ = x; break a;}
     var _b_ = caml_call1(CamlinternalLazy[2], x);
    }
    return from_val(caml_call1(f, _b_));
   }
   var
    Stdlib_Lazy =
      [0, Undefined, map, is_val, from_val, map_val, from_fun, force_val];
   runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Seq
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Atomic, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib = global_data.Stdlib,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    cst_Seq_init = "Seq.init",
    cst_Seq_take = "Seq.take",
    cst_Seq_drop = "Seq.drop";
   function empty(param){return 0;}
   function return$0(x, param){return [0, x, empty];}
   function cons(x, next, param){return [0, x, next];}
   function append(seq1, seq2, param){
    var match = caml_call1(seq1, 0);
    if(! match) return caml_call1(seq2, 0);
    var next = match[2], x = match[1];
    return [0, x, function(_au_){return append(next, seq2, _au_);}];
   }
   function map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return [0, caml_call1(f, x), function(_at_){return map(f, next, _at_);}];
   }
   function filter_map(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(match$0){
      var y = match$0[1];
      return [0, y, function(_as_){return filter_map(f, next, _as_);}];
     }
     seq$0 = next;
    }
   }
   function filter(f, seq, param){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     if(caml_call1(f, x))
      return [0, x, function(_ar_){return filter(f, next, _ar_);}];
     seq$0 = next;
    }
   }
   function concat(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append(x, function(_aq_){return concat(next, _aq_);}, 0);
   }
   function flat_map(f, seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var next = match[2], x = match[1];
    return append
            (caml_call1(f, x),
             function(_ap_){return flat_map(f, next, _ap_);},
             0);
   }
   function fold_left(f, acc, seq){
    var acc$0 = acc, seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return acc$0;
     var next = match[2], x = match[1], acc$1 = caml_call2(f, acc$0, x);
     acc$0 = acc$1;
     seq$0 = next;
    }
   }
   function iter(f, seq){
    var seq$0 = seq;
    for(;;){
     var match = caml_call1(seq$0, 0);
     if(! match) return 0;
     var next = match[2], x = match[1];
     caml_call1(f, x);
     seq$0 = next;
    }
   }
   function unfold(f, u, param){
    var match = caml_call1(f, u);
    if(! match) return 0;
    var match$0 = match[1], u$0 = match$0[2], x = match$0[1];
    return [0, x, function(_ao_){return unfold(f, u$0, _ao_);}];
   }
   function is_empty(xs){return caml_call1(xs, 0) ? 0 : 1;}
   function uncons(xs){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return [0, [0, x, xs$0]];
   }
   function length(xs$1){
    var accu = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var xs$0 = match[2], accu$0 = accu + 1 | 0;
     accu = accu$0;
     xs = xs$0;
    }
   }
   function iteri(f, xs$1){
    var i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     xs = xs$0;
    }
   }
   function fold_lefti(f, accu$1, xs$1){
    var accu = accu$1, i = 0, xs = xs$1;
    for(;;){
     var match = caml_call1(xs, 0);
     if(! match) return accu;
     var
      xs$0 = match[2],
      x = match[1],
      accu$0 = caml_call3(f, accu, i, x),
      i$0 = i + 1 | 0;
     accu = accu$0;
     i = i$0;
     xs = xs$0;
    }
   }
   function for_all(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], _an_ = caml_call1(p, x);
     if(! _an_) return _an_;
     xs$0 = xs$1;
    }
   }
   function exists(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], _am_ = caml_call1(p, x);
     if(_am_) return _am_;
     xs$0 = xs$1;
    }
   }
   function find(p, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, x];
     xs$0 = xs$1;
    }
   }
   function find_index(p, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1];
     if(caml_call1(p, x)) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
     xs$0 = xs$1;
    }
   }
   function find_map(f, xs){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call1(f, x);
     if(result) return result;
     xs$0 = xs$1;
    }
   }
   function find_mapi(f, xs){
    var i = 0, xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = i + 1 | 0;
     i = i$0;
     xs$0 = xs$1;
    }
   }
   function iter2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1];
     caml_call2(f, x, y);
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function fold_left2(f, accu, xs, ys){
    var accu$0 = accu, xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return accu$0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return accu$0;
     var
      ys$1 = match$0[2],
      y = match$0[1],
      accu$1 = caml_call3(f, accu$0, x, y);
     accu$0 = accu$1;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function for_all2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 1;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], _al_ = caml_call2(f, x, y);
     if(! _al_) return _al_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function exists2(f, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(ys$0, 0);
     if(! match$0) return 0;
     var ys$1 = match$0[2], y = match$0[1], _ak_ = caml_call2(f, x, y);
     if(_ak_) return _ak_;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function equal(eq, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(match){
      if(match$0){
       var
        ys$1 = match$0[2],
        y = match$0[1],
        xs$1 = match[2],
        x = match[1],
        _aj_ = caml_call2(eq, x, y);
       if(! _aj_) return _aj_;
       xs$0 = xs$1;
       ys$0 = ys$1;
       continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function compare(cmp, xs, ys){
    var xs$0 = xs, ys$0 = ys;
    for(;;){
     var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
     if(! match) return match$0 ? -1 : 0;
     var xs$1 = match[2], x = match[1];
     if(! match$0) return 1;
     var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x, y);
     if(0 !== c) return c;
     xs$0 = xs$1;
     ys$0 = ys$1;
    }
   }
   function init_aux(f, i, j, param){
    if(i >= j) return 0;
    var _ah_ = i + 1 | 0;
    return [0,
            caml_call1(f, i),
            function(_ai_){return init_aux(f, _ah_, j, _ai_);}];
   }
   function init(n, f){
    if(0 > n) return caml_call1(Stdlib[1], cst_Seq_init);
    var _af_ = 0;
    return function(_ag_){return init_aux(f, _af_, n, _ag_);};
   }
   function repeat(x, param){
    return [0, x, function(_ae_){return repeat(x, _ae_);}];
   }
   function forever(f, param){
    return [0, caml_call1(f, 0), function(_ad_){return forever(f, _ad_);}];
   }
   function cycle_nonempty(xs, param){
    return append(xs, function(_ac_){return cycle_nonempty(xs, _ac_);}, 0);
   }
   function cycle(xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    function _$_(_ab_){return cycle_nonempty(xs, _ab_);}
    return [0, x, function(_aa_){return append(xs$0, _$_, _aa_);}];
   }
   function iterate1(f, x, param){
    var y = caml_call1(f, x);
    return [0, y, function(___){return iterate1(f, y, ___);}];
   }
   function iterate(f, x){
    function next(_Z_){return iterate1(f, x, _Z_);}
    return function(_Y_){return [0, x, next];};
   }
   function mapi_aux(f, i, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _W_ = i + 1 | 0;
    return [0,
            caml_call2(f, i, x),
            function(_X_){return mapi_aux(f, _W_, xs$0, _X_);}];
   }
   function mapi(f, xs){
    var _U_ = 0;
    return function(_V_){return mapi_aux(f, _U_, xs, _V_);};
   }
   function tail_scan(f, s, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], s$0 = caml_call2(f, s, x);
    return [0, s$0, function(_T_){return tail_scan(f, s$0, xs$0, _T_);}];
   }
   function scan(f, s, xs){
    function next(_S_){return tail_scan(f, s, xs, _S_);}
    return function(_R_){return [0, s, next];};
   }
   function take_aux(n, xs){
    return 0 === n
            ? empty
            : function
             (param){
              var match = caml_call1(xs, 0);
              if(! match) return 0;
              var xs$0 = match[2], x = match[1];
              return [0, x, take_aux(n - 1 | 0, xs$0)];
             };
   }
   function take(n, xs){
    if(n < 0) caml_call1(Stdlib[1], cst_Seq_take);
    return take_aux(n, xs);
   }
   function drop(n, xs){
    return 0 <= n
            ? 0
              === n
              ? xs
              : function
               (param){
                var n$0 = n, xs$0 = xs;
                for(;;){
                 var match = caml_call1(xs$0, 0);
                 if(! match) return 0;
                 var xs$1 = match[2], n$1 = n$0 - 1 | 0;
                 if(0 === n$1) return caml_call1(xs$1, 0);
                 n$0 = n$1;
                 xs$0 = xs$1;
                }
               }
            : caml_call1(Stdlib[1], cst_Seq_drop);
   }
   function take_while(p, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1];
    return caml_call1(p, x)
            ? [0, x, function(_Q_){return take_while(p, xs$0, _Q_);}]
            : 0;
   }
   function drop_while(p, xs, param){
    var xs$0 = xs;
    for(;;){
     var node = caml_call1(xs$0, 0);
     if(! node) return 0;
     var xs$1 = node[2], x = node[1];
     if(! caml_call1(p, x)) return node;
     xs$0 = xs$1;
    }
   }
   function group(eq, xs, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], _J_ = caml_call1(eq, x);
    function _K_(_P_){return drop_while(_J_, xs$0, _P_);}
    var _L_ = caml_call1(eq, x);
    function next(_O_){return take_while(_L_, xs$0, _O_);}
    return [0,
            function(_N_){return [0, x, next];},
            function(_M_){return group(eq, _K_, _M_);}];
   }
   var
    Forced_twice =
      [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)],
    to_lazy = Stdlib_Lazy[6],
    _a_ = [0, "seq.ml", 616, 4];
   function failure(param){
    throw caml_maybe_attach_backtrace(Forced_twice, 1);
   }
   function memoize(xs){
    function s$0(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, memoize(xs$0)];
    }
    var s = caml_call1(to_lazy, s$0);
    return function(param){
     var _I_ = runtime.caml_obj_tag(s);
     if(250 === _I_) return s[1];
     if(246 !== _I_ && 244 !== _I_) return s;
     return caml_call1(CamlinternalLazy[2], s);};
   }
   function once(xs){
    function f(param){
     var match = caml_call1(xs, 0);
     if(! match) return 0;
     var xs$0 = match[2], x = match[1];
     return [0, x, once(xs$0)];
    }
    var action = caml_call1(Stdlib_Atomic[1], f);
    return function(param){
     var f = caml_call2(Stdlib_Atomic[5], action, failure);
     return caml_call1(f, 0);};
   }
   function zip(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0, [0, x, y], function(_H_){return zip(xs$0, ys$0, _H_);}];
   }
   function map2(f, xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return 0;
    var xs$0 = match[2], x = match[1], match$0 = caml_call1(ys, 0);
    if(! match$0) return 0;
    var ys$0 = match$0[2], y = match$0[1];
    return [0,
            caml_call2(f, x, y),
            function(_G_){return map2(f, xs$0, ys$0, _G_);}];
   }
   function interleave(xs, ys, param){
    var match = caml_call1(xs, 0);
    if(! match) return caml_call1(ys, 0);
    var xs$0 = match[2], x = match[1];
    return [0, x, function(_F_){return interleave(ys, xs$0, _F_);}];
   }
   function sorted_merge1(cmp, x, xs, y, ys){
    return 0 < caml_call2(cmp, x, y)
            ? [0,
              y,
              function(_D_){
               var match = caml_call1(ys, 0);
               if(! match) return [0, x, xs];
               var ys$0 = match[2], y = match[1];
               return sorted_merge1(cmp, x, xs, y, ys$0);
              }]
            : [0,
              x,
              function(_E_){
               var match = caml_call1(xs, 0);
               if(! match) return [0, y, ys];
               var xs$0 = match[2], x = match[1];
               return sorted_merge1(cmp, x, xs$0, y, ys);
              }];
   }
   function sorted_merge(cmp, xs, ys, param){
    var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
    if(match){
     if(match$0){
      var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x = match[1];
      return sorted_merge1(cmp, x, xs$0, y, ys$0);
     }
     var c = match;
    }
    else{if(! match$0) return 0; var c = match$0;}
    return c;
   }
   function map_fst(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], x = match[1][1];
    return [0, x, function(_C_){return map_fst(xys$0, _C_);}];
   }
   function map_snd(xys, param){
    var match = caml_call1(xys, 0);
    if(! match) return 0;
    var xys$0 = match[2], y = match[1][2];
    return [0, y, function(_B_){return map_snd(xys$0, _B_);}];
   }
   function unzip(xys){
    return [0,
            function(_A_){return map_fst(xys, _A_);},
            function(_z_){return map_snd(xys, _z_);}];
   }
   function filter_map_find_left_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 === match$0[0]){
      var y = match$0[1];
      return [0,
              y,
              function(_y_){return filter_map_find_left_map(f, xs$1, _y_);}];
     }
     xs$0 = xs$1;
    }
   }
   function filter_map_find_right_map(f, xs, param){
    var xs$0 = xs;
    for(;;){
     var match = caml_call1(xs$0, 0);
     if(! match) return 0;
     var xs$1 = match[2], x = match[1], match$0 = caml_call1(f, x);
     if(0 !== match$0[0]){
      var z = match$0[1];
      return [0,
              z,
              function(_x_){return filter_map_find_right_map(f, xs$1, _x_);}];
     }
     xs$0 = xs$1;
    }
   }
   function partition_map(f, xs){
    return [0,
            function(_w_){return filter_map_find_left_map(f, xs, _w_);},
            function(_v_){return filter_map_find_right_map(f, xs, _v_);}];
   }
   function partition(p, xs){
    function _s_(x){return 1 - caml_call1(p, x);}
    return [0,
            function(_u_){return filter(p, xs, _u_);},
            function(_t_){return filter(_s_, xs, _t_);}];
   }
   function peel(xss){
    return unzip(function(_r_){return filter_map(uncons, xss, _r_);});
   }
   function transpose(xss, param){
    var match = peel(xss), tails = match[2], heads = match[1];
    if(! is_empty(heads))
     return [0, heads, function(_q_){return transpose(tails, _q_);}];
    if(is_empty(tails)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function _b_(remainders, xss, param){
    var match = caml_call1(xss, 0);
    if(! match) return transpose(remainders, 0);
    var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
    if(match$0){
     var
      xs$0 = match$0[2],
      x = match$0[1],
      match$1 = peel(remainders),
      tails = match$1[2],
      heads = match$1[1],
      _l_ = function(_p_){return [0, xs$0, tails];};
     return [0,
             function(_o_){return [0, x, heads];},
             function(_n_){return _b_(_l_, xss$0, _n_);}];
    }
    var
     match$2 = peel(remainders),
     tails$0 = match$2[2],
     heads$0 = match$2[1];
    return [0, heads$0, function(_m_){return _b_(tails$0, xss$0, _m_);}];
   }
   function map_product(f, xs, ys){
    function _f_(x){
     function _j_(y){return caml_call2(f, x, y);}
     return function(_k_){return map(_j_, ys, _k_);};
    }
    function xss(_i_){return map(_f_, xs, _i_);}
    function _e_(_h_){return _b_(empty, xss, _h_);}
    return function(_g_){return concat(_e_, _g_);};
   }
   function product(xs, ys){
    return map_product(function(x, y){return [0, x, y];}, xs, ys);
   }
   function of_dispenser(it){
    function c(param){
     var match = caml_call1(it, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, x, c];
    }
    return c;
   }
   function to_dispenser(xs){
    var s = [0, xs];
    return function(param){
     var match = caml_call1(s[1], 0);
     if(! match) return 0;
     var xs = match[2], x = match[1];
     s[1] = xs;
     return [0, x];};
   }
   function ints(i, param){
    var _c_ = i + 1 | 0;
    return [0, i, function(_d_){return ints(_c_, _d_);}];
   }
   var
    Stdlib_Seq =
      [0,
       is_empty,
       uncons,
       length,
       iter,
       fold_left,
       iteri,
       fold_lefti,
       for_all,
       exists,
       find,
       find_index,
       find_map,
       find_mapi,
       iter2,
       fold_left2,
       for_all2,
       exists2,
       equal,
       compare,
       empty,
       return$0,
       cons,
       init,
       unfold,
       repeat,
       forever,
       cycle,
       iterate,
       map,
       mapi,
       filter,
       filter_map,
       scan,
       take,
       drop,
       take_while,
       drop_while,
       group,
       memoize,
       Forced_twice,
       once,
       transpose,
       append,
       concat,
       flat_map,
       flat_map,
       zip,
       map2,
       interleave,
       sorted_merge,
       product,
       map_product,
       unzip,
       unzip,
       partition_map,
       partition,
       of_dispenser,
       to_dispenser,
       ints];
   runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Option
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_option_is_None = "option is None";
   function some(v){return [0, v];}
   function value(o, default$0){
    if(! o) return default$0;
    var v = o[1];
    return v;
   }
   function get(param){
    if(! param) return caml_call1(Stdlib[1], cst_option_is_None);
    var v = param[1];
    return v;
   }
   function bind(o, f){
    if(! o) return 0;
    var v = o[1];
    return caml_call1(f, v);
   }
   function join(param){if(! param) return 0; var o = param[1]; return o;}
   function map(f, o){
    if(! o) return 0;
    var v = o[1];
    return [0, caml_call1(f, v)];
   }
   function fold(none, some, param){
    if(! param) return none;
    var v = param[1];
    return caml_call1(some, v);
   }
   function iter(f, param){
    if(! param) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function equal(eq, o0, o1){
    if(o0){
     if(o1){var v1 = o1[1], v0 = o0[1]; return caml_call2(eq, v0, v1);}
    }
    else if(! o1) return 1;
    return 0;
   }
   function compare(cmp, o0, o1){
    if(! o0) return o1 ? -1 : 0;
    var v0 = o0[1];
    if(! o1) return 1;
    var v1 = o1[1];
    return caml_call2(cmp, v0, v1);
   }
   function to_result(none, param){
    if(! param) return [1, none];
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(! param) return Stdlib_Seq[20];
    var v = param[1];
    return caml_call1(Stdlib_Seq[21], v);
   }
   var
    Stdlib_Option =
      [0,
       0,
       some,
       value,
       get,
       bind,
       join,
       map,
       fold,
       iter,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
   runtime.caml_register_global(3, Stdlib_Option, "Stdlib__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Result
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    cst_result_is_Error = "result is Error _",
    cst_result_is_Ok = "result is Ok _";
   function ok(v){return [0, v];}
   function error(e){return [1, e];}
   function value(r, default$0){
    if(0 !== r[0]) return default$0;
    var v = r[1];
    return v;
   }
   function get_ok(param){
    if(0 !== param[0]) return caml_call1(Stdlib[1], cst_result_is_Error);
    var v = param[1];
    return v;
   }
   function get_error(param){
    if(0 === param[0]) return caml_call1(Stdlib[1], cst_result_is_Ok);
    var e = param[1];
    return e;
   }
   function bind(r, f){
    if(0 !== r[0]) return r;
    var v = r[1];
    return caml_call1(f, v);
   }
   function join(e){if(0 !== e[0]) return e; var r = e[1]; return r;}
   function map(f, e){
    if(0 !== e[0]) return e;
    var v = e[1];
    return [0, caml_call1(f, v)];
   }
   function map_error(f, v){
    if(0 === v[0]) return v;
    var e = v[1];
    return [1, caml_call1(f, e)];
   }
   function fold(ok, error, param){
    if(0 === param[0]){var v = param[1]; return caml_call1(ok, v);}
    var e = param[1];
    return caml_call1(error, e);
   }
   function iter(f, param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return caml_call1(f, v);
   }
   function iter_error(f, param){
    if(0 === param[0]) return 0;
    var e = param[1];
    return caml_call1(f, e);
   }
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function equal(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 === r1[0]){var v1 = r1[1]; return caml_call2(ok, v0, v1);}
    }
    else{
     var e0 = r0[1];
     if(0 !== r1[0]){var e1 = r1[1]; return caml_call2(error, e0, e1);}
    }
    return 0;
   }
   function compare(ok, error, r0, r1){
    if(0 === r0[0]){
     var v0 = r0[1];
     if(0 !== r1[0]) return -1;
     var v1 = r1[1];
     return caml_call2(ok, v0, v1);
    }
    var e0 = r0[1];
    if(0 === r1[0]) return 1;
    var e1 = r1[1];
    return caml_call2(error, e0, e1);
   }
   function to_option(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v];
   }
   function to_list(param){
    if(0 !== param[0]) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function to_seq(param){
    if(0 !== param[0]) return Stdlib_Seq[20];
    var v = param[1];
    return caml_call1(Stdlib_Seq[21], v);
   }
   var
    Stdlib_Result =
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
   runtime.caml_register_global(4, Stdlib_Result, "Stdlib__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bool
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_hash = runtime.caml_hash;
   function equal(_d_, _c_){return _d_ === _c_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    cst_true = "true",
    cst_false = "false";
   function to_float(param){return param ? 1. : 0.;}
   function to_string(param){return param ? cst_true : cst_false;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Bool =
      [0,
       function(_b_){return 1 - _b_;},
       equal,
       compare,
       function(_a_){return _a_;},
       to_float,
       to_string,
       seeded_hash,
       hash];
   runtime.caml_register_global(4, Stdlib_Bool, "Stdlib__Bool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Char
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_hash = runtime.caml_hash,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\\\\",
    cst$0 = "\\'",
    Stdlib = global_data.Stdlib,
    cst_Char_chr = "Char.chr",
    cst_b = "\\b",
    cst_t = "\\t",
    cst_n = "\\n",
    cst_r = "\\r";
   function chr(n){
    if(0 <= n && 255 >= n) return n;
    return caml_call1(Stdlib[1], cst_Char_chr);
   }
   function escaped(c){
    a:
    {
     if(40 <= c){
      if(92 === c) return cst;
      if(127 > c) break a;
     }
     else{
      if(32 <= c){if(39 <= c) return cst$0; break a;}
      if(14 > c)
       switch(c){
         case 8:
          return cst_b;
         case 9:
          return cst_t;
         case 10:
          return cst_n;
         case 13:
          return cst_r;
       }
     }
     var s = caml_create_bytes(4);
     caml_bytes_unsafe_set(s, 0, 92);
     caml_bytes_unsafe_set(s, 1, 48 + (c / 100 | 0) | 0);
     caml_bytes_unsafe_set(s, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
     caml_bytes_unsafe_set(s, 3, 48 + (c % 10 | 0) | 0);
     return caml_string_of_bytes(s);
    }
    var s$0 = caml_create_bytes(1);
    caml_bytes_unsafe_set(s$0, 0, c);
    return caml_string_of_bytes(s$0);
   }
   function lowercase_ascii(c){return 25 < c - 65 >>> 0 ? c : c + 32 | 0;}
   function uppercase_ascii(c){return 25 < c - 97 >>> 0 ? c : c - 32 | 0;}
   function compare(c1, c2){return c1 - c2 | 0;}
   function equal(c1, c2){return 0 === (c1 - c2 | 0) ? 1 : 0;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Char =
      [0,
       chr,
       escaped,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal,
       seeded_hash,
       hash];
   runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Uchar
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_uchar_ml = "uchar.ml",
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    err_no_pred = "U+0000 has no predecessor",
    err_no_succ = "U+10FFFF has no successor",
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value",
    cst_is_not_a_latin1_character = " is not a latin1 character",
    cst_U = "U+",
    lo_bound = 55295,
    hi_bound = 57344;
   function succ(u){
    return u === 55295
            ? hi_bound
            : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
   }
   function pred(u){
    return u === 57344
            ? lo_bound
            : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
   }
   function is_valid(i){
    var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
    if(_o_)
     var _p_ = _o_;
    else
     var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
    return _p_;
   }
   function of_int(i){
    if(is_valid(i)) return i;
    var
     _m_ =
       caml_call2
        (Stdlib[28], caml_format_int("%X", i), cst_is_not_an_Unicode_scalar_v);
    return caml_call1(Stdlib[1], _m_);
   }
   function is_char(u){return u < 256 ? 1 : 0;}
   function of_char(c){return c;}
   function to_char(u){
    if(255 >= u) return u;
    var
     _k_ =
       caml_call2
        (Stdlib[28],
         caml_format_int("%04X", u),
         cst_is_not_a_latin1_character),
     _l_ = caml_call2(Stdlib[28], cst_U, _k_);
    return caml_call1(Stdlib[1], _l_);
   }
   function unsafe_to_char(_j_){return _j_;}
   function equal(_i_, _h_){return _i_ === _h_ ? 1 : 0;}
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_uchar_ml, 85, 7],
    _b_ = [0, cst_uchar_ml, 80, 18],
    _c_ = [0, cst_uchar_ml, 91, 7],
    _d_ = [0, cst_uchar_ml, 88, 18];
   function hash(_g_){return _g_;}
   function utf_decode_is_valid(d){return 1 === (d >>> 27 | 0) ? 1 : 0;}
   function utf_decode_length(d){return (d >>> 24 | 0) & 7;}
   function utf_decode_uchar(d){return d & 16777215;}
   function utf_decode(n, u){return (8 | n) << 24 | u;}
   function utf_decode_invalid(n){return n << 24 | 65533;}
   function utf_8_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u) return 1;
    if(2047 >= u) return 2;
    if(65535 >= u) return 3;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return 4;
   }
   function utf_16_byte_length(u){
    if(0 > u) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if(65535 >= u) return 2;
    if(1114111 < u)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    return 4;
   }
   var
    Stdlib_Uchar =
      [0,
       0,
       1114111,
       65279,
       65533,
       succ,
       pred,
       is_valid,
       of_int,
       function(_f_){return _f_;},
       function(_e_){return _e_;},
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal,
       compare,
       hash,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid,
       utf_8_byte_length,
       utf_16_byte_length];
   runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__List
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_List_map2$1 = "List.map2",
    cst_List_nth$1 = "List.nth",
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    cst_hd = "hd",
    cst_tl = "tl",
    cst_nth = "nth",
    cst_List_nth = cst_List_nth$1,
    cst_List_nth$0 = cst_List_nth$1;
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var l = param[2], len$0 = len + 1 | 0;
     len = len$0;
     param = l;
    }
   }
   function cons(a, l){return [0, a, l];}
   function hd(param){
    if(! param) return caml_call1(Stdlib[2], cst_hd);
    var a = param[1];
    return a;
   }
   function tl(param){
    if(! param) return caml_call1(Stdlib[2], cst_tl);
    var l = param[2];
    return l;
   }
   function nth(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return caml_call1(Stdlib[2], cst_nth);
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return a;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function nth_opt(l, n){
    if(0 > n) return caml_call1(Stdlib[1], cst_List_nth$0);
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0;
     var l$1 = l$0[2], a = l$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   var
    append = Stdlib[37],
    cst_List_init = "List.init",
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_List_rev_map2 = "List.rev_map2",
    cst_List_iter2 = "List.iter2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_fold_right2 = "List.fold_right2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_exists2 = "List.exists2",
    _a_ = [0, 0, 0],
    cst_List_combine = "List.combine";
   function rev_append(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function rev(l){return rev_append(l, 0);}
   function init(len, f){
    if(0 > len) return caml_call1(Stdlib[1], cst_List_init);
    var last = len - 1 | 0, i$1 = 0;
    if(last < 0) return 0;
    if(0 === last) return [0, caml_call1(f, i$1), 0];
    var
     r1 = caml_call1(f, i$1),
     r2 = caml_call1(f, 1),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2;
    for(;;){
     if(last < i)
      dst[1 + offset] = 0;
     else{
      if(i !== last){
       var
        r1$0 = caml_call1(f, i),
        r2$0 = caml_call1(f, i + 1 | 0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$0, dst$0];
       var i$0 = i + 2 | 0;
       dst = dst$0;
       offset = 1;
       i = i$0;
       continue;
      }
      dst[1 + offset] = [0, caml_call1(f, i), 0];
     }
     return [0, r1, block];
    }
   }
   function flatten(param){
    if(! param) return 0;
    var r = param[2], l = param[1], _I_ = flatten(r);
    return caml_call2(Stdlib[37], l, _I_);
   }
   function map(f, param){
    if(! param) return 0;
    var match = param[2], a1 = param[1];
    if(! match){var r1$0 = caml_call1(f, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call1(f, a1),
     r2 = caml_call1(f, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     param$0 = l;
    for(;;){
     if(param$0){
      var match$0 = param$0[2], a1$0 = param$0[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call1(f, a1$0),
        r2$0 = caml_call1(f, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       dst = dst$0;
       offset = 1;
       param$0 = l$0;
       continue;
      }
      var r1$2 = caml_call1(f, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function mapi(f, l$1){
    var i$1 = 0;
    if(! l$1) return 0;
    var match = l$1[2], a1 = l$1[1];
    if(! match){var r1$0 = caml_call2(f, i$1, a1); return [0, r1$0, 0];}
    var
     l = match[2],
     a2 = match[1],
     r1 = caml_call2(f, i$1, a1),
     r2 = caml_call2(f, 1, a2),
     block = [0, r2, 24029],
     dst = block,
     offset = 1,
     i = 2,
     param = l;
    for(;;){
     if(param){
      var match$0 = param[2], a1$0 = param[1];
      if(match$0){
       var
        l$0 = match$0[2],
        a2$0 = match$0[1],
        r1$1 = caml_call2(f, i, a1$0),
        r2$0 = caml_call2(f, i + 1 | 0, a2$0),
        dst$0 = [0, r2$0, 24029];
       dst[1 + offset] = [0, r1$1, dst$0];
       var i$0 = i + 2 | 0;
       dst = dst$0;
       offset = 1;
       i = i$0;
       param = l$0;
       continue;
      }
      var r1$2 = caml_call2(f, i, a1$0);
      dst[1 + offset] = [0, r1$2, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, r1, block];
    }
   }
   function rev_map(f, l){
    var accu = 0, param = l;
    for(;;){
     if(! param) return accu;
     var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu];
     accu = accu$0;
     param = l$0;
    }
   }
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = l;
    }
   }
   function iteri(f, l$0){
    var i = 0, param = l$0;
    for(;;){
     if(! param) return 0;
     var l = param[2], a = param[1];
     caml_call2(f, i, a);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = l;
    }
   }
   function fold_left(f, accu, l){
    var accu$0 = accu, l$0 = l;
    for(;;){
     if(! l$0) return accu$0;
     var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a);
     accu$0 = accu$1;
     l$0 = l$1;
    }
   }
   function fold_right(f, l, accu){
    if(! l) return accu;
    var l$0 = l[2], a = l[1];
    return caml_call2(f, a, fold_right(f, l$0, accu));
   }
   function map2(f, l1, l2){
    if(l1){
     var _G_ = l1[2], a1 = l1[1];
     if(_G_){
      if(l2){
       var match = l2[2];
       if(match){
        var
         l2$0 = match[2],
         b2 = match[1],
         b1 = l2[1],
         l1$0 = _G_[2],
         a2 = _G_[1],
         r1 = caml_call2(f, a1, b1),
         r2 = caml_call2(f, a2, b2),
         block = [0, r2, 24029],
         dst = block,
         offset = 1,
         l1$1 = l1$0,
         l2$1 = l2$0;
        for(;;){
         a:
         {
          if(l1$1){
           var _H_ = l1$1[2], a1$0 = l1$1[1];
           if(_H_){
            if(l2$1){
             var match$0 = l2$1[2];
             if(match$0){
              var
               l2$2 = match$0[2],
               b2$0 = match$0[1],
               b1$1 = l2$1[1],
               l1$2 = _H_[2],
               a2$0 = _H_[1],
               r1$1 = caml_call2(f, a1$0, b1$1),
               r2$0 = caml_call2(f, a2$0, b2$0),
               dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$1, dst$0];
              dst = dst$0;
              offset = 1;
              l1$1 = l1$2;
              l2$1 = l2$2;
              continue;
             }
            }
           }
           else if(l2$1 && ! l2$1[2]){
            var b1$2 = l2$1[1], r1$2 = caml_call2(f, a1$0, b1$2);
            dst[1 + offset] = [0, r1$2, 0];
            break a;
           }
          }
          else if(! l2$1){dst[1 + offset] = 0; break a;}
          dst[1 + offset] = caml_call1(Stdlib[1], cst_List_map2$0);
         }
         return [0, r1, block];
        }
       }
      }
     }
     else if(l2 && ! l2[2]){
      var b1$0 = l2[1], r1$0 = caml_call2(f, a1, b1$0);
      return [0, r1$0, 0];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_map2);
   }
   function rev_map2(f, l1, l2){
    var accu = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu];
       accu = accu$0;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu;
     return caml_call1(Stdlib[1], cst_List_rev_map2);
    }
   }
   function iter2(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_iter2);
    }
   }
   function fold_left2(f, accu, l1, l2){
    var accu$0 = accu, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        accu$1 = caml_call3(f, accu$0, a1, a2);
       accu$0 = accu$1;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return accu$0;
     return caml_call1(Stdlib[1], cst_List_fold_left2);
    }
   }
   function fold_right2(f, l1, l2, accu){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
     }
    }
    else if(! l2) return accu;
    return caml_call1(Stdlib[1], cst_List_fold_right2);
   }
   function for_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 1;
     var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
     if(! _F_) return _F_;
     param$0 = l;
    }
   }
   function exists(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _E_ = caml_call1(p, a);
     if(_E_) return _E_;
     param$0 = l;
    }
   }
   function for_all2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _D_ = caml_call2(p, a1, a2);
       if(! _D_) return _D_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Stdlib[1], cst_List_for_all2);
    }
   }
   function exists2(p, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _C_ = caml_call2(p, a1, a2);
       if(_C_) return _C_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Stdlib[1], cst_List_exists2);
    }
   }
   function mem(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1],
      _B_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_B_) return _B_;
     param$0 = l;
    }
   }
   function memq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1], _A_ = a === x ? 1 : 0;
     if(_A_) return _A_;
     param$0 = l;
    }
   }
   function assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return b;
     param$0 = l;
    }
   }
   function assoc_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(0 === caml_compare(a, x)) return [0, b];
     param$0 = l;
    }
   }
   function assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return b;
     param$0 = l;
    }
   }
   function assq_opt(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
     if(a === x) return [0, b];
     param$0 = l;
    }
   }
   function mem_assoc(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      l = param$0[2],
      a = param$0[1][1],
      _z_ = 0 === caml_compare(a, x) ? 1 : 0;
     if(_z_) return _z_;
     param$0 = l;
    }
   }
   function mem_assq(x, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], a = param$0[1][1], _y_ = a === x ? 1 : 0;
     if(_y_) return _y_;
     param$0 = l;
    }
   }
   function remove_assoc(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return 0 === caml_compare(a, x) ? l : [0, pair, remove_assoc(x, l)];
   }
   function remove_assq(x, param){
    if(! param) return 0;
    var l = param[2], pair = param[1], a = pair[1];
    return a === x ? l : [0, pair, remove_assq(x, l)];
   }
   function find(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return x;
     param$0 = l;
    }
   }
   function find_opt(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)) return [0, x];
     param$0 = l;
    }
   }
   function find_index(p){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], a = param[1];
      if(caml_call1(p, a)) return [0, i$0];
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      param = l;
     }};
   }
   function find_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], result = caml_call1(f, x);
     if(result) return result;
     param$0 = l;
    }
   }
   function find_mapi(f){
    var i = 0;
    return function(param$0){
     var i$0 = i, param = param$0;
     for(;;){
      if(! param) return 0;
      var l = param[2], x = param[1], result = caml_call2(f, i$0, x);
      if(result) return result;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      param = l;
     }};
   }
   function find_all(p, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1];
     if(caml_call1(p, x)){
      var block = [0, x, 24029], dst = block, offset = 1, param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1];
       if(caml_call1(p, x$0)){
        var dst$0 = [0, x$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        param$1 = l$0;
       }
       else
        param$1 = l$0;
      }
     }
     else
      param$0 = l;
    }
   }
   function filteri(p, l$1){
    var i = 0, param = l$1;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], i$0 = i + 1 | 0;
     if(caml_call2(p, i, x)) break;
     i = i$0;
     param = l;
    }
    var
     block = [0, x, 24029],
     dst = block,
     offset = 1,
     i$1 = i$0,
     param$0 = l;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var l$0 = param$0[2], x$0 = param$0[1], i$2 = i$1 + 1 | 0;
     if(caml_call2(p, i$1, x$0)){
      var dst$0 = [0, x$0, 24029];
      dst[1 + offset] = dst$0;
      dst = dst$0;
      offset = 1;
      i$1 = i$2;
      param$0 = l$0;
     }
     else{i$1 = i$2; param$0 = l$0;}
    }
   }
   function filter_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], x = param$0[1], match = caml_call1(f, x);
     if(match){
      var
       v = match[1],
       block = [0, v, 24029],
       dst = block,
       offset = 1,
       param$1 = l;
      for(;;){
       if(! param$1){dst[1 + offset] = 0; return block;}
       var l$0 = param$1[2], x$0 = param$1[1], match$0 = caml_call1(f, x$0);
       if(match$0){
        var v$0 = match$0[1], dst$0 = [0, v$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        param$1 = l$0;
       }
       else
        param$1 = l$0;
      }
     }
     else
      param$0 = l;
    }
   }
   function concat_map(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var xs = param$0[2], x = param$0[1], ys = caml_call1(f, x);
     if(ys){
      var
       ys$1 = ys[2],
       y = ys[1],
       block = [0, y, 24029],
       dst = block,
       offset = 1,
       ys$2 = ys$1,
       xs$1 = xs;
      for(;;)
       if(ys$2){
        var ys$3 = ys$2[2], y$0 = ys$2[1], dst$0 = [0, y$0, 24029];
        dst[1 + offset] = dst$0;
        dst = dst$0;
        offset = 1;
        ys$2 = ys$3;
       }
       else{
        if(! xs$1){dst[1 + offset] = 0; return block;}
        var xs$0 = xs$1[2], x$0 = xs$1[1], ys$0 = caml_call1(f, x$0);
        ys$2 = ys$0;
        xs$1 = xs$0;
       }
     }
     else
      param$0 = xs;
    }
   }
   function fold_left_map(f, accu, l){
    var accu$0 = accu, l_accu = 0, param = l;
    for(;;){
     if(! param) return [0, accu$0, rev(l_accu)];
     var
      l$0 = param[2],
      x = param[1],
      match = caml_call2(f, accu$0, x),
      x$0 = match[2],
      accu$1 = match[1],
      l_accu$0 = [0, x$0, l_accu];
     accu$0 = accu$1;
     l_accu = l_accu$0;
     param = l$0;
    }
   }
   function partition(p, l){
    var yes = 0, no = 0, param = l;
    for(;;){
     if(! param){var _x_ = rev(no); return [0, rev(yes), _x_];}
     var l$0 = param[2], x = param[1];
     if(caml_call1(p, x)){
      var yes$0 = [0, x, yes];
      yes = yes$0;
      param = l$0;
     }
     else{var no$0 = [0, x, no]; no = no$0; param = l$0;}
    }
   }
   function partition_map(p, l){
    var left = 0, right = 0, param = l;
    for(;;){
     if(! param){var _w_ = rev(right); return [0, rev(left), _w_];}
     var l$0 = param[2], x = param[1], match = caml_call1(p, x);
     if(0 === match[0]){
      var v = match[1], left$0 = [0, v, left];
      left = left$0;
      param = l$0;
     }
     else{
      var v$0 = match[1], right$0 = [0, v$0, right];
      right = right$0;
      param = l$0;
     }
    }
   }
   function split(param){
    if(! param) return _a_;
    var
     l = param[2],
     match = param[1],
     y = match[2],
     x = match[1],
     match$0 = split(l),
     ry = match$0[2],
     rx = match$0[1];
    return [0, [0, x, rx], [0, y, ry]];
   }
   function combine(l1, l2){
    if(l1){
     if(l2){
      var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
      return [0, [0, a1, a2], combine(l1$0, l2$0)];
     }
    }
    else if(! l2) return 0;
    return caml_call1(Stdlib[1], cst_List_combine);
   }
   function merge(cmp, l1, l2){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    return 0 < caml_call2(cmp, h1, h2)
            ? [0, h2, merge(cmp, l1, t2)]
            : [0, h1, merge(cmp, t1, l2)];
   }
   function stable_sort(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _v_ = l[2];
      if(_v_){
       var match$2 = _v_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _v_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu];
        l2 = t2;
        accu = accu$1;
        continue;
       }
       var _u_ = rev_append(l1, accu);
      }
      else
       var _u_ = rev_append(l2, accu);
      return [0, _u_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _t_ = l[2];
      if(_t_){
       var match$2 = _t_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _t_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu];
         l2 = t2;
         accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu];
        l1 = t1;
        accu = accu$1;
        continue;
       }
       var _s_ = rev_append(l1, accu);
      }
      else
       var _s_ = rev_append(l2, accu);
      return [0, _s_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function sort_uniq(cmp, l){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _m_ = l[2];
      if(_m_){
       var match$2 = _m_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _m_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _n_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]],
          s$0 = _n_;
        else if(0 <= c$1){
         var c$3 = caml_call2(cmp, x1$0, x3);
         if(0 === c$3)
          var _o_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 <= c$3)
          var
           c$4 = caml_call2(cmp, x2$0, x3),
           _p_ =
             0 === c$4
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                <= c$4
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]],
           _o_ = _p_;
         else
          var _o_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         var s$0 = _o_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 === c$5)
          var _q_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 <= c$5)
          var
           c$6 = caml_call2(cmp, x1$0, x3),
           _r_ =
             0 === c$6
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                <= c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]],
           _q_ = _r_;
         else
          var _q_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _q_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 < c){
         var accu$1 = [0, h1, accu];
         l1 = t1;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h2, accu];
        l2 = t2;
        accu = accu$2;
        continue;
       }
       var _l_ = rev_append(l1, accu);
      }
      else
       var _l_ = rev_append(l2, accu);
      return [0, _l_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2),
         s =
           0 === c$0
            ? [0, x1, 0]
            : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _f_ = l[2];
      if(_f_){
       var match$2 = _f_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _f_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 === c$1)
         var
          c$2 = caml_call2(cmp, x2$0, x3),
          _g_ =
            0 === c$2
             ? [0, x2$0, 0]
             : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]],
          s$0 = _g_;
        else if(0 < c$1){
         var c$3 = caml_call2(cmp, x2$0, x3);
         if(0 === c$3)
          var _h_ = [0, x1$0, [0, x2$0, 0]];
         else if(0 < c$3)
          var _h_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else
          var
           c$4 = caml_call2(cmp, x1$0, x3),
           _i_ =
             0 === c$4
              ? [0, x1$0, [0, x2$0, 0]]
              : 0
                < c$4
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
           _h_ = _i_;
         var s$0 = _h_;
        }
        else{
         var c$5 = caml_call2(cmp, x1$0, x3);
         if(0 === c$5)
          var _j_ = [0, x2$0, [0, x1$0, 0]];
         else if(0 < c$5)
          var _j_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
         else
          var
           c$6 = caml_call2(cmp, x2$0, x3),
           _k_ =
             0 === c$6
              ? [0, x2$0, [0, x1$0, 0]]
              : 0
                < c$6
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]],
           _j_ = _k_;
         var s$0 = _j_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = n >> 1,
      n2 = n - n1 | 0,
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 === c){
         var accu$0 = [0, h1, accu];
         l1 = t1;
         l2 = t2;
         accu = accu$0;
         continue;
        }
        if(0 <= c){
         var accu$1 = [0, h2, accu];
         l2 = t2;
         accu = accu$1;
         continue;
        }
        var accu$2 = [0, h1, accu];
        l1 = t1;
        accu = accu$2;
        continue;
       }
       var _e_ = rev_append(l1, accu);
      }
      else
       var _e_ = rev_append(l2, accu);
      return [0, _e_, tl$0];
     }
    }
    var len = length(l);
    return 2 <= len ? sort(len, l)[1] : l;
   }
   function compare_lengths(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], l1$1 = l1$0[2];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function compare_length_with(l, n){
    var l$0 = l, n$0 = n;
    for(;;){
     if(! l$0) return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
     var l$1 = l$0[2];
     if(0 >= n$0) return 1;
     var n$1 = n$0 - 1 | 0;
     l$0 = l$1;
     n$0 = n$1;
    }
   }
   function is_empty(param){return param ? 0 : 1;}
   function equal(eq, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _d_ = caml_call2(eq, a1, a2);
       if(! _d_) return _d_;
       l1$0 = l1$1;
       l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function compare(cmp, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0 ? -1 : 0;
     var l1$1 = l1$0[2], a1 = l1$0[1];
     if(! l2$0) return 1;
     var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
     if(0 !== c) return c;
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function to_seq(l){
    function aux(l, param){
     if(! l) return 0;
     var tail = l[2], x = l[1];
     return [0, x, function(_c_){return aux(tail, _c_);}];
    }
    return function(_b_){return aux(l, _b_);};
   }
   function of_seq(seq){
    var match = caml_call1(seq, 0);
    if(! match) return 0;
    var seq$0 = match[2], x1 = match[1], match$0 = caml_call1(seq$0, 0);
    if(! match$0) return [0, x1, 0];
    var
     seq$1 = match$0[2],
     x2 = match$0[1],
     block = [0, x2, 24029],
     dst = block,
     offset = 1,
     seq$2 = seq$1;
    for(;;){
     var match$1 = caml_call1(seq$2, 0);
     if(match$1){
      var
       seq$3 = match$1[2],
       x1$0 = match$1[1],
       match$2 = caml_call1(seq$3, 0);
      if(match$2){
       var seq$4 = match$2[2], x2$0 = match$2[1], dst$0 = [0, x2$0, 24029];
       dst[1 + offset] = [0, x1$0, dst$0];
       dst = dst$0;
       offset = 1;
       seq$2 = seq$4;
       continue;
      }
      dst[1 + offset] = [0, x1$0, 0];
     }
     else
      dst[1 + offset] = 0;
     return [0, x1, block];
    }
   }
   var
    Stdlib_List =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       is_empty,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       stable_sort,
       stable_sort,
       stable_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(17, Stdlib_List, "Stdlib__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_hash = runtime.caml_hash;
   function abs(x){return 0 <= x ? x : - x | 0;}
   function lognot(x){return x ^ -1;}
   function equal(_b_, _a_){return _b_ === _a_ ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function min(x, y){return x <= y ? x : y;}
   function max(x, y){return y <= x ? x : y;}
   function to_string(x){return "" + x;}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int =
      [0,
       0,
       1,
       -1,
       abs,
       2147483647,
       -2147483648,
       lognot,
       equal,
       compare,
       min,
       max,
       to_string,
       seeded_hash,
       hash];
   runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bytes
//# unitInfo: Requires: Stdlib, Stdlib__Char, Stdlib__Int, Stdlib__Seq, Stdlib__Sys, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_bytes_ml = "bytes.ml",
    cst_index_out_of_bounds$3 = "index out of bounds",
    caml_blit_bytes = runtime.caml_blit_bytes,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_get16 = runtime.caml_bytes_get16,
    caml_bytes_get32 = runtime.caml_bytes_get32,
    caml_bytes_get64 = runtime.caml_bytes_get64,
    caml_bytes_of_string = runtime.caml_bytes_of_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fill_bytes = runtime.caml_fill_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Char = global_data.Stdlib__Char;
   function make(n, c){
    var s = caml_create_bytes(n);
    caml_fill_bytes(s, 0, n, c);
    return s;
   }
   function init(n, f){
    var s = caml_create_bytes(n), _ap_ = n - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_bytes_unsafe_set(s, i, caml_call1(f, i));
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return s;
   }
   var
    empty = caml_create_bytes(0),
    cst_String_sub_Bytes_sub = "String.sub / Bytes.sub",
    cst_Bytes_extend = "Bytes.extend",
    cst_String_fill_Bytes_fill = "String.fill / Bytes.fill",
    cst_Bytes_blit = "Bytes.blit",
    cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string",
    cst_Bytes_concat = "Bytes.concat",
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function copy(s){
    var len = caml_ml_bytes_length(s), r = caml_create_bytes(len);
    caml_blit_bytes(s, 0, r, 0, len);
    return r;
   }
   function to_string(b){return caml_string_of_bytes(copy(b));}
   function of_string(s){return copy(caml_bytes_of_string(s));}
   function sub(s, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs){
     var r = caml_create_bytes(len);
     caml_blit_bytes(s, ofs, r, 0, len);
     return r;
    }
    return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
   }
   function sub_string(b, ofs, len){
    return caml_string_of_bytes(sub(b, ofs, len));
   }
   function symbol(a, b){
    var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
    a:
    {
     if(a < 0){if(_an_ && ! match) break a;} else if(! _an_ && match) break a;
     return c;
    }
    return caml_call1(Stdlib[1], cst_Bytes_extend);
   }
   function extend(s, left, right){
    var
     len = symbol(symbol(caml_ml_bytes_length(s), left), right),
     r = caml_create_bytes(len);
    if(0 <= left)
     var dstoff = left, srcoff = 0;
    else
     var dstoff = 0, srcoff = - left | 0;
    var
     cpylen =
       caml_call2
        (Stdlib_Int[10],
         caml_ml_bytes_length(s) - srcoff | 0,
         len - dstoff | 0);
    if(0 < cpylen) caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
    return r;
   }
   function fill(s, ofs, len, c){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(s) - len | 0) >= ofs)
     return caml_fill_bytes(s, ofs, len, c);
    return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
   }
   function blit(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (caml_ml_bytes_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return caml_blit_bytes(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Bytes_blit);
   }
   function blit_string(s1, ofs1, s2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1
        && 0 <= ofs2 && (caml_ml_bytes_length(s2) - len | 0) >= ofs2)
     return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
    return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
   }
   function iter(f, a){
    var _al_ = caml_ml_bytes_length(a) - 1 | 0, _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      caml_call1(f, caml_bytes_unsafe_get(a, i));
      var _am_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _am_;
     }
    }
    return 0;
   }
   function iteri(f, a){
    var _ai_ = caml_ml_bytes_length(a) - 1 | 0, _ah_ = 0;
    if(_ai_ >= 0){
     var i = _ah_;
     for(;;){
      caml_call2(f, i, caml_bytes_unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      i = _aj_;
     }
    }
    return 0;
   }
   function concat(sep, l){
    if(! l) return empty;
    var seplen = caml_ml_bytes_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_bytes_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Bytes_concat);
       acc = acc$0;
       param = tl;
      }
      var _ag_ = acc;
      break a;
     }
     var _ag_ = caml_ml_bytes_length(hd) + acc | 0;
    }
    var dst = caml_create_bytes(_ag_), pos = pos$1, param$0 = l;
    for(;;){
     if(! param$0) return dst;
     var hd$0 = param$0[1];
     if(! param$0[2]){
      caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
      return dst;
     }
     var tl$0 = param$0[2];
     caml_blit_bytes(hd$0, 0, dst, pos, caml_ml_bytes_length(hd$0));
     caml_blit_bytes
      (sep, 0, dst, pos + caml_ml_bytes_length(hd$0) | 0, seplen);
     var pos$0 = (pos + caml_ml_bytes_length(hd$0) | 0) + seplen | 0;
     pos = pos$0;
     param$0 = tl$0;
    }
   }
   function cat(s1, s2){
    var
     l1 = caml_ml_bytes_length(s1),
     l2 = caml_ml_bytes_length(s2),
     r = caml_create_bytes(l1 + l2 | 0);
    caml_blit_bytes(s1, 0, r, 0, l1);
    caml_blit_bytes(s2, 0, r, l1, l2);
    return r;
   }
   function is_space(param){
    var _af_ = param - 9 | 0;
    a:
    {
     if(4 < _af_ >>> 0){if(23 !== _af_) break a;} else if(2 === _af_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    var len = caml_ml_bytes_length(s), i = [0, 0];
    for(;;){
     if(i[1] >= len) break;
     if(! is_space(caml_bytes_unsafe_get(s, i[1]))) break;
     i[1]++;
    }
    var j = [0, len - 1 | 0];
    for(;;){
     if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s, j[1]))){j[1]--; continue;}
     return i[1] <= j[1] ? sub(s, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
    }
   }
   function unsafe_escape(s){
    var n = [0, 0], ___ = caml_ml_bytes_length(s) - 1 | 0, _Z_ = 0;
    if(___ >= 0){
     var i$0 = _Z_;
     for(;;){
      var match = caml_bytes_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _ac_ = match - 34 | 0;
          if(58 < _ac_ >>> 0){
           if(93 <= _ac_) break c;
          }
          else if(56 < _ac_ - 1 >>> 0) break b;
          var _ad_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _ad_ = 4;
        break a;
       }
       var _ad_ = 2;
      }
      n[1] = n[1] + _ad_ | 0;
      var _ae_ = i$0 + 1 | 0;
      if(___ === i$0) break;
      i$0 = _ae_;
     }
    }
    if(n[1] === caml_ml_bytes_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _aa_ = caml_ml_bytes_length(s) - 1 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      var c = caml_bytes_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c / 100 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        n[1]++;
        caml_bytes_unsafe_set(s$0, n[1], 48 + (c % 10 | 0) | 0);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return s$0;
   }
   function escaped(b){var b$0 = copy(b); return unsafe_escape(b$0);}
   function map(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _X_ = l - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(s, i)));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return r;
   }
   function mapi(f, s){
    var l = caml_ml_bytes_length(s);
    if(0 === l) return s;
    var r = caml_create_bytes(l), _U_ = l - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(s, i)));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return r;
   }
   function fold_left(f, x, a){
    var r = [0, x], _R_ = caml_ml_bytes_length(a) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get(a, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _O_ = caml_ml_bytes_length(a) - 1 | 0;
    if(_O_ >= 0){
     var i = _O_;
     for(;;){
      r[1] = caml_call2(f, caml_bytes_unsafe_get(a, i), r[1]);
      var _P_ = i - 1 | 0;
      if(0 === i) break;
      i = _P_;
     }
    }
    return r[1];
   }
   function exists(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, caml_bytes_unsafe_get(s, i))) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, s){
    var n = caml_ml_bytes_length(s), i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, caml_bytes_unsafe_get(s, i))) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function uppercase_ascii(s){return map(Stdlib_Char[4], s);}
   function lowercase_ascii(s){return map(Stdlib_Char[3], s);}
   function apply1(f, s){
    if(0 === caml_ml_bytes_length(s)) return s;
    var r = copy(s);
    caml_bytes_unsafe_set(r, 0, caml_call1(f, caml_bytes_unsafe_get(s, 0)));
    return r;
   }
   function capitalize_ascii(s){return apply1(Stdlib_Char[4], s);}
   function uncapitalize_ascii(s){return apply1(Stdlib_Char[3], s);}
   function starts_with(prefix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_pre = caml_ml_bytes_length(prefix),
     _N_ = len_pre <= len_s ? 1 : 0;
    if(! _N_) return _N_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_bytes_unsafe_get(s, i) !== caml_bytes_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_bytes_length(s),
     len_suf = caml_ml_bytes_length(suffix),
     diff = len_s - len_suf | 0,
     _M_ = 0 <= diff ? 1 : 0;
    if(! _M_) return _M_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_bytes_unsafe_get(s, diff + i | 0)
       !== caml_bytes_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_bytes_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_bytes_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_bytes_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_bytes_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_bytes_length(s) > i) return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_bytes_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _K_ = 1; return _K_;}
     catch(_L_){
      var _J_ = caml_wrap_exception(_L_);
      if(_J_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_J_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_bytes_length(s) > i)
     try{rindex_rec(s, i, c); var _H_ = 1; return _H_;}
     catch(_I_){
      var _G_ = caml_wrap_exception(_I_);
      if(_G_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_G_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   var
    compare = runtime.caml_bytes_compare,
    cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_bytes_length(s)],
     _C_ = caml_ml_bytes_length(s) - 1 | 0;
    if(_C_ >= 0){
     var i = _C_;
     for(;;){
      if(caml_bytes_unsafe_get(s, i) === sep){
       var _E_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
       j[1] = i;
      }
      var _F_ = i - 1 | 0;
      if(0 === i) break;
      i = _F_;
     }
    }
    var _D_ = r[1];
    return [0, sub(s, 0, j[1]), _D_];
   }
   function to_seq(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _A_ = i + 1 | 0;
     return [0, x, function(_B_){return aux(_A_, _B_);}];
    }
    var _y_ = 0;
    return function(_z_){return aux(_y_, _z_);};
   }
   function to_seqi(s){
    function aux(i, param){
     if(i === caml_ml_bytes_length(s)) return 0;
     var x = caml_bytes_get(s, i), _w_ = i + 1 | 0;
     return [0, [0, i, x], function(_x_){return aux(_w_, _x_);}];
    }
    var _u_ = 0;
    return function(_v_){return aux(_u_, _v_);};
   }
   function of_seq(i){
    var n = [0, 0], buf = [0, make(256, 0)];
    caml_call2
     (Stdlib_Seq[4],
      function(c){
       if(n[1] === caml_ml_bytes_length(buf[1])){
        var
         new_len =
           caml_call2
            (Stdlib_Int[10],
             2 * caml_ml_bytes_length(buf[1]) | 0,
             Stdlib_Sys[12]);
        if(caml_ml_bytes_length(buf[1]) === new_len)
         caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
        var new_buf = make(new_len, 0);
        blit(buf[1], 0, new_buf, 0, n[1]);
        buf[1] = new_buf;
       }
       caml_bytes_set(buf[1], n[1], c);
       n[1]++;
       return 0;
      },
      i);
    return sub(buf[1], 0, n[1]);
   }
   function unsafe_get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function unsafe_get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int8(b, i){
    var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
    return caml_bytes_get(b, i) << _t_ >> _s_;
   }
   function get_uint16_le(b, i){
    return Stdlib_Sys[11]
            ? caml_bswap16(caml_bytes_get16(b, i))
            : caml_bytes_get16(b, i);
   }
   function get_uint16_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get16(b, i)
            : caml_bswap16(caml_bytes_get16(b, i));
   }
   function get_int16_ne(b, i){
    var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
    return caml_bytes_get16(b, i) << _r_ >> _q_;
   }
   function get_int16_le(b, i){
    var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_le(b, i) << _p_ >> _o_;
   }
   function get_int16_be(b, i){
    var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
    return get_uint16_be(b, i) << _n_ >> _m_;
   }
   function get_int32_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int32_bswap(caml_bytes_get32(b, i))
            : caml_bytes_get32(b, i);
   }
   function get_int32_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get32(b, i)
            : caml_int32_bswap(caml_bytes_get32(b, i));
   }
   function get_int64_le(b, i){
    return Stdlib_Sys[11]
            ? caml_int64_bswap(caml_bytes_get64(b, i))
            : caml_bytes_get64(b, i);
   }
   function get_int64_be(b, i){
    return Stdlib_Sys[11]
            ? caml_bytes_get64(b, i)
            : caml_int64_bswap(caml_bytes_get64(b, i));
   }
   function unsafe_set_uint16_le(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, caml_bswap16(x)); return;}
    caml_bytes_set16(b, i, x);
    return;
   }
   function unsafe_set_uint16_be(b, i, x){
    if(Stdlib_Sys[11]){caml_bytes_set16(b, i, x); return;}
    caml_bytes_set16(b, i, caml_bswap16(x));
    return;
   }
   function set_int16_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, caml_bswap16(x))
            : caml_bytes_set16(b, i, x);
   }
   function set_int16_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set16(b, i, x)
            : caml_bytes_set16(b, i, caml_bswap16(x));
   }
   function set_int32_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, caml_int32_bswap(x))
            : caml_bytes_set32(b, i, x);
   }
   function set_int32_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set32(b, i, x)
            : caml_bytes_set32(b, i, caml_int32_bswap(x));
   }
   function set_int64_le(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, caml_int64_bswap(x))
            : caml_bytes_set64(b, i, x);
   }
   function set_int64_be(b, i, x){
    return Stdlib_Sys[11]
            ? caml_bytes_set64(b, i, x)
            : caml_bytes_set64(b, i, caml_int64_bswap(x));
   }
   var
    set_uint8 = caml_bytes_set,
    set_uint16_ne = caml_bytes_set16,
    dec_invalid = Stdlib_Uchar[22],
    _a_ = [0, cst_bytes_ml, 679, 9],
    _b_ = [0, cst_bytes_ml, 654, 20],
    cst_index_out_of_bounds = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3,
    _c_ = [0, cst_bytes_ml, 777, 9],
    _d_ = [0, cst_bytes_ml, 766, 20],
    cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3,
    cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3,
    _e_ = [0, cst_bytes_ml, 831, 9],
    _f_ = [0, cst_bytes_ml, 820, 20];
   function dec_ret(n, u){
    var _l_ = caml_call1(Stdlib_Uchar[9], u);
    return caml_call2(Stdlib_Uchar[21], n, _l_);
   }
   function not_in_x80_to_xBF(b){return 2 !== (b >>> 6 | 0) ? 1 : 0;}
   function not_in_xA0_to_xBF(b){return 5 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x80_to_x9F(b){return 4 !== (b >>> 5 | 0) ? 1 : 0;}
   function not_in_x90_to_xBF(b){
    var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
    return _k_;
   }
   function not_in_x80_to_x8F(b){return 8 !== (b >>> 4 | 0) ? 1 : 0;}
   function utf_8_uchar_3(b0, b1, b2){
    return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
   }
   function utf_8_uchar_4(b0, b1, b2, b3){
    return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
   }
   function get_utf_8_uchar(b, i){
    var b0 = caml_bytes_get(b, i), max = caml_ml_bytes_length(b) - 1 | 0;
    a:
    {
     if(224 <= b0){
      if(237 <= b0){
       if(245 <= b0) break a;
       switch(b0 - 237 | 0){
         case 0:
          var i$0 = i + 1 | 0;
          if(max < i$0) return caml_call1(dec_invalid, 1);
          var b1$4 = caml_bytes_unsafe_get(b, i$0);
          if(not_in_x80_to_x9F(b1$4)) return caml_call1(dec_invalid, 1);
          var i$1 = i$0 + 1 | 0;
          if(max < i$1) return caml_call1(dec_invalid, 2);
          var b2$3 = caml_bytes_unsafe_get(b, i$1);
          return not_in_x80_to_xBF(b2$3)
                  ? caml_call1(dec_invalid, 2)
                  : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$3));
         case 3:
          var i$4 = i + 1 | 0;
          if(max < i$4) return caml_call1(dec_invalid, 1);
          var b1$2 = caml_bytes_unsafe_get(b, i$4);
          if(not_in_x90_to_xBF(b1$2)) return caml_call1(dec_invalid, 1);
          var i$5 = i$4 + 1 | 0;
          if(max < i$5) return caml_call1(dec_invalid, 2);
          var b2$1 = caml_bytes_unsafe_get(b, i$5);
          if(not_in_x80_to_xBF(b2$1)) return caml_call1(dec_invalid, 2);
          var i$6 = i$5 + 1 | 0;
          if(max < i$6) return caml_call1(dec_invalid, 3);
          var b3$1 = caml_bytes_unsafe_get(b, i$6);
          return not_in_x80_to_xBF(b3$1)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$1, b3$1));
         case 7:
          var i$10 = i + 1 | 0;
          if(max < i$10) return caml_call1(dec_invalid, 1);
          var b1$0 = caml_bytes_unsafe_get(b, i$10);
          if(not_in_x80_to_x8F(b1$0)) return caml_call1(dec_invalid, 1);
          var i$11 = i$10 + 1 | 0;
          if(max < i$11) return caml_call1(dec_invalid, 2);
          var b2 = caml_bytes_unsafe_get(b, i$11);
          if(not_in_x80_to_xBF(b2)) return caml_call1(dec_invalid, 2);
          var i$12 = i$11 + 1 | 0;
          if(max < i$12) return caml_call1(dec_invalid, 3);
          var b3 = caml_bytes_unsafe_get(b, i$12);
          return not_in_x80_to_xBF(b3)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$0, b2, b3));
         case 1:
         case 2: break;
         default:
          var i$7 = i + 1 | 0;
          if(max < i$7) return caml_call1(dec_invalid, 1);
          var b1$1 = caml_bytes_unsafe_get(b, i$7);
          if(not_in_x80_to_xBF(b1$1)) return caml_call1(dec_invalid, 1);
          var i$8 = i$7 + 1 | 0;
          if(max < i$8) return caml_call1(dec_invalid, 2);
          var b2$0 = caml_bytes_unsafe_get(b, i$8);
          if(not_in_x80_to_xBF(b2$0)) return caml_call1(dec_invalid, 2);
          var i$9 = i$8 + 1 | 0;
          if(max < i$9) return caml_call1(dec_invalid, 3);
          var b3$0 = caml_bytes_unsafe_get(b, i$9);
          return not_in_x80_to_xBF(b3$0)
                  ? caml_call1(dec_invalid, 3)
                  : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$0, b3$0));
       }
      }
      else if(225 > b0){
       var i$13 = i + 1 | 0;
       if(max < i$13) return caml_call1(dec_invalid, 1);
       var b1$5 = caml_bytes_unsafe_get(b, i$13);
       if(not_in_xA0_to_xBF(b1$5)) return caml_call1(dec_invalid, 1);
       var i$14 = i$13 + 1 | 0;
       if(max < i$14) return caml_call1(dec_invalid, 2);
       var b2$4 = caml_bytes_unsafe_get(b, i$14);
       return not_in_x80_to_xBF(b2$4)
               ? caml_call1(dec_invalid, 2)
               : dec_ret(3, utf_8_uchar_3(b0, b1$5, b2$4));
      }
      var i$2 = i + 1 | 0;
      if(max < i$2) return caml_call1(dec_invalid, 1);
      var b1$3 = caml_bytes_unsafe_get(b, i$2);
      if(not_in_x80_to_xBF(b1$3)) return caml_call1(dec_invalid, 1);
      var i$3 = i$2 + 1 | 0;
      if(max < i$3) return caml_call1(dec_invalid, 2);
      var b2$2 = caml_bytes_unsafe_get(b, i$3);
      return not_in_x80_to_xBF(b2$2)
              ? caml_call1(dec_invalid, 2)
              : dec_ret(3, utf_8_uchar_3(b0, b1$3, b2$2));
     }
     if(128 > b0) return dec_ret(1, b0);
     if(194 <= b0){
      var i$15 = i + 1 | 0;
      if(max < i$15) return caml_call1(dec_invalid, 1);
      var b1 = caml_bytes_unsafe_get(b, i$15);
      return not_in_x80_to_xBF(b1)
              ? caml_call1(dec_invalid, 1)
              : dec_ret(2, (b0 & 31) << 6 | b1 & 63);
     }
    }
    return caml_call1(dec_invalid, 1);
   }
   function set_utf_8_uchar(b, i, u){
    function set(_i_, _h_, _g_){caml_bytes_unsafe_set(_i_, _h_, _g_); return;}
    var
     max = caml_ml_bytes_length(b) - 1 | 0,
     u$0 = caml_call1(Stdlib_Uchar[10], u);
    if(0 > u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(127 >= u$0){caml_bytes_set(b, i, u$0); return 1;}
    if(2047 >= u$0){
     var last$1 = i + 1 | 0;
     return max < last$1
             ? 0
             : (caml_bytes_set
                (b, i, 192 | u$0 >>> 6 | 0),
               set(b, last$1, 128 | u$0 & 63),
               2);
    }
    if(65535 >= u$0){
     var last$0 = i + 2 | 0;
     return max < last$0
             ? 0
             : (caml_bytes_set
                (b, i, 224 | u$0 >>> 12 | 0),
               set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63),
               set(b, last$0, 128 | u$0 & 63),
               3);
    }
    if(1114111 < u$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var last = i + 3 | 0;
    return max < last
            ? 0
            : (caml_bytes_set
               (b, i, 240 | u$0 >>> 18 | 0),
              set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63),
              set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63),
              set(b, last, 128 | u$0 & 63),
              4);
   }
   function is_valid_utf_8(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     var match = caml_bytes_unsafe_get(b, i);
     a:
     {
      if(224 <= match){
       if(237 <= match){
        if(245 <= match) break a;
        switch(match - 237 | 0){
          case 0:
           var last = i + 2 | 0;
           if
            (max >= last
             &&
              !
              not_in_x80_to_x9F(caml_bytes_unsafe_get(b, i + 1 | 0))
              && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last))){var i$0 = last + 1 | 0; i = i$0; continue;}
           return 0;
          case 3:
           var last$1 = i + 3 | 0;
           if
            (max >= last$1
             &&
              !
              not_in_x90_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$1))){var i$2 = last$1 + 1 | 0; i = i$2; continue;}
           return 0;
          case 7:
           var last$3 = i + 3 | 0;
           if
            (max >= last$3
             &&
              !
              not_in_x80_to_x8F(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$3))){var i$4 = last$3 + 1 | 0; i = i$4; continue;}
           return 0;
          case 1:
          case 2: break;
          default:
           var last$2 = i + 3 | 0;
           if
            (max >= last$2
             &&
              !
              not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
              &&
               !
               not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 2 | 0))
               && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$2))){var i$3 = last$2 + 1 | 0; i = i$3; continue;}
           return 0;
        }
       }
       else if(225 > match){
        var last$4 = i + 2 | 0;
        if
         (max >= last$4
          &&
           !
           not_in_xA0_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
           && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$4))){var i$5 = last$4 + 1 | 0; i = i$5; continue;}
        return 0;
       }
       var last$0 = i + 2 | 0;
       if
        (max >= last$0
         &&
          !
          not_in_x80_to_xBF(caml_bytes_unsafe_get(b, i + 1 | 0))
          && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$0))){var i$1 = last$0 + 1 | 0; i = i$1; continue;}
       return 0;
      }
      if(128 > match){var i$7 = i + 1 | 0; i = i$7; continue;}
      if(194 <= match){
       var last$5 = i + 1 | 0;
       if
        (max >= last$5
         && ! not_in_x80_to_xBF(caml_bytes_unsafe_get(b, last$5))){var i$6 = last$5 + 1 | 0; i = i$6; continue;}
       return 0;
      }
     }
     return 0;
    }
   }
   function get_utf_16be_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_be(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds);
   }
   function set_utf_16be_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_be(b, i, hi);
     unsafe_set_uint16_be(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
   }
   function is_valid_utf_16be(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_be(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   function get_utf_16le_uchar(b, i){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     if(i === max) return caml_call1(dec_invalid, 1);
     var hi = unsafe_get_uint16_le(b, i);
     if(55296 <= hi && 57343 >= hi){
      if(56319 < hi) return caml_call1(dec_invalid, 2);
      var last = i + 3 | 0;
      if(max < last) return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
      var lo = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= lo && 57343 >= lo){
       var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
       return dec_ret(4, u);
      }
      return caml_call1(dec_invalid, 2);
     }
     return dec_ret(2, hi);
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
   }
   function set_utf_16le_uchar(b, i, u){
    var max = caml_ml_bytes_length(b) - 1 | 0;
    if(0 <= i && max >= i){
     var u$0 = caml_call1(Stdlib_Uchar[10], u);
     if(0 > u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     if(65535 >= u$0){
      var last$0 = i + 1 | 0;
      return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
     }
     if(1114111 < u$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     var last = i + 3 | 0;
     if(max < last) return 0;
     var
      u$1 = u$0 - 65536 | 0,
      hi = 55296 | u$1 >>> 10 | 0,
      lo = 56320 | u$1 & 1023;
     unsafe_set_uint16_le(b, i, hi);
     unsafe_set_uint16_le(b, i + 2 | 0, lo);
     return 4;
    }
    return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
   }
   function is_valid_utf_16le(b){
    var max = caml_ml_bytes_length(b) - 1 | 0, i = 0;
    for(;;){
     if(max < i) return 1;
     if(i === max) return 0;
     var u = unsafe_get_uint16_le(b, i);
     if(55296 <= u && 57343 >= u){
      if(56319 < u) return 0;
      var last = i + 3 | 0;
      if(max < last) return 0;
      var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
      if(56320 <= u$0 && 57343 >= u$0){
       var i$1 = i + 4 | 0;
       i = i$1;
       continue;
      }
      return 0;
     }
     var i$0 = i + 2 | 0;
     i = i$0;
    }
   }
   var
    Stdlib_Bytes =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       runtime.caml_bytes_equal,
       starts_with,
       ends_with,
       caml_string_of_bytes,
       caml_bytes_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       caml_bytes_get,
       get_int8,
       caml_bytes_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       caml_bytes_get32,
       get_int32_be,
       get_int32_le,
       caml_bytes_get64,
       get_int64_be,
       get_int64_le,
       set_uint8,
       caml_bytes_set,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       caml_bytes_set16,
       set_int16_be,
       set_int16_le,
       caml_bytes_set32,
       set_int32_be,
       set_int32_le,
       caml_bytes_set64,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__String
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_blit_string = runtime.caml_blit_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_hash = runtime.caml_string_hash,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    empty = cst$0,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    bts = Stdlib_Bytes[44],
    bos = Stdlib_Bytes[45];
   function make(n, c){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
   }
   function init(n, f){
    return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
   }
   var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
   function sub(s, ofs, len){
    var _X_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _X_, ofs, len));
   }
   var blit = Stdlib_Bytes[12], cst_String_concat = "String.concat";
   function concat(sep, l){
    if(! l) return cst;
    var seplen = caml_ml_string_length(sep);
    a:
    {
     b:
     {
      var acc = 0, param = l, pos$1 = 0;
      for(;;){
       if(! param) break;
       var hd = param[1];
       if(! param[2]) break b;
       var
        tl = param[2],
        x = (caml_ml_string_length(hd) + seplen | 0) + acc | 0,
        acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_String_concat);
       acc = acc$0;
       param = tl;
      }
      var _W_ = acc;
      break a;
     }
     var _W_ = caml_ml_string_length(hd) + acc | 0;
    }
    var dst = runtime.caml_create_bytes(_W_), pos = pos$1, param$0 = l;
    for(;;){
     if(param$0){
      var hd$0 = param$0[1];
      if(param$0[2]){
       var tl$0 = param$0[2];
       caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
       caml_blit_string
        (sep, 0, dst, pos + caml_ml_string_length(hd$0) | 0, seplen);
       var pos$0 = (pos + caml_ml_string_length(hd$0) | 0) + seplen | 0;
       pos = pos$0;
       param$0 = tl$0;
       continue;
      }
      caml_blit_string(hd$0, 0, dst, pos, caml_ml_string_length(hd$0));
     }
     return caml_call1(bts, dst);
    }
   }
   var
    cat = Stdlib[28],
    cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from",
    cst_String_index_from_opt_Byte =
      "String.index_from_opt / Bytes.index_from_opt",
    cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from",
    cst_String_rindex_from_opt_Byt =
      "String.rindex_from_opt / Bytes.rindex_from_opt",
    cst_String_contains_from_Bytes =
      "String.contains_from / Bytes.contains_from",
    cst_String_rcontains_from_Byte =
      "String.rcontains_from / Bytes.rcontains_from";
   function iter(f, s){
    var _U_ = caml_ml_string_length(s) - 1 | 0, _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_call1(f, caml_string_unsafe_get(s, i));
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return 0;
   }
   function iteri(f, s){
    var _R_ = caml_ml_string_length(s) - 1 | 0, _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(s, i));
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      i = _S_;
     }
    }
    return 0;
   }
   function map(f, s){
    var _P_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _P_));
   }
   function mapi(f, s){
    var _O_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _O_));
   }
   function fold_right(f, x, a){
    var _N_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[20], f, _N_, a);
   }
   function fold_left(f, a, x){
    var _M_ = caml_call1(bos, x);
    return caml_call3(Stdlib_Bytes[19], f, a, _M_);
   }
   function exists(f, s){
    var _L_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[22], f, _L_);
   }
   function for_all(f, s){
    var _K_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[21], f, _K_);
   }
   function is_space(param){
    var _J_ = param - 9 | 0;
    a:
    {
     if(4 < _J_ >>> 0){if(23 !== _J_) break a;} else if(2 === _J_) break a;
     return 1;
    }
    return 0;
   }
   function trim(s){
    if(s == cst$0) return s;
    if
     (!
      is_space(caml_string_unsafe_get(s, 0))
      &&
       !
       is_space(caml_string_unsafe_get(s, caml_ml_string_length(s) - 1 | 0)))
     return s;
    var _I_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _I_));
   }
   function escaped(s){
    var b = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[87], b));
   }
   function index_rec(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index(s, c){return index_rec(s, caml_ml_string_length(s), 0, c);}
   function index_rec_opt(s, lim, i, c){
    var i$0 = i;
    for(;;){
     if(lim <= i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 + 1 | 0;
     i$0 = i$1;
    }
   }
   function index_opt(s, c){
    return index_rec_opt(s, caml_ml_string_length(s), 0, c);
   }
   function index_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
   }
   function index_from_opt(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i) return index_rec_opt(s, l, i, c);
    return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
   }
   function rindex_rec(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(caml_string_unsafe_get(s, i$0) === c) return i$0;
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex(s, c){
    return rindex_rec(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i) return rindex_rec(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
   }
   function rindex_rec_opt(s, i, c){
    var i$0 = i;
    for(;;){
     if(0 > i$0) return 0;
     if(caml_string_unsafe_get(s, i$0) === c) return [0, i$0];
     var i$1 = i$0 - 1 | 0;
     i$0 = i$1;
    }
   }
   function rindex_opt(s, c){
    return rindex_rec_opt(s, caml_ml_string_length(s) - 1 | 0, c);
   }
   function rindex_from_opt(s, i, c){
    if(-1 <= i && caml_ml_string_length(s) > i)
     return rindex_rec_opt(s, i, c);
    return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
   }
   function contains_from(s, i, c){
    var l = caml_ml_string_length(s);
    if(0 <= i && l >= i)
     try{index_rec(s, l, i, c); var _G_ = 1; return _G_;}
     catch(_H_){
      var _F_ = caml_wrap_exception(_H_);
      if(_F_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_F_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
   }
   function contains(s, c){return contains_from(s, 0, c);}
   function rcontains_from(s, i, c){
    if(0 <= i && caml_ml_string_length(s) > i)
     try{rindex_rec(s, i, c); var _D_ = 1; return _D_;}
     catch(_E_){
      var _C_ = caml_wrap_exception(_E_);
      if(_C_ === Stdlib[8]) return 0;
      throw caml_maybe_attach_backtrace(_C_, 0);
     }
    return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
   }
   function uppercase_ascii(s){
    var _B_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _B_));
   }
   function lowercase_ascii(s){
    var _A_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _A_));
   }
   function capitalize_ascii(s){
    var _z_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _z_));
   }
   function uncapitalize_ascii(s){
    var _y_ = caml_call1(bos, s);
    return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _y_));
   }
   function starts_with(prefix, s){
    var
     len_s = caml_ml_string_length(s),
     len_pre = caml_ml_string_length(prefix),
     _x_ = len_pre <= len_s ? 1 : 0;
    if(! _x_) return _x_;
    var i = 0;
    for(;;){
     if(i === len_pre) return 1;
     if(caml_string_unsafe_get(s, i) !== caml_string_unsafe_get(prefix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function ends_with(suffix, s){
    var
     len_s = caml_ml_string_length(s),
     len_suf = caml_ml_string_length(suffix),
     diff = len_s - len_suf | 0,
     _w_ = 0 <= diff ? 1 : 0;
    if(! _w_) return _w_;
    var i = 0;
    for(;;){
     if(i === len_suf) return 1;
     if
      (caml_string_unsafe_get(s, diff + i | 0)
       !== caml_string_unsafe_get(suffix, i))
      return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function hash(x){return caml_string_hash(0, x);}
   function split_on_char(sep, s){
    var
     r = [0, 0],
     j = [0, caml_ml_string_length(s)],
     _s_ = caml_ml_string_length(s) - 1 | 0;
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      if(caml_string_unsafe_get(s, i) === sep){
       var _u_ = r[1];
       r[1] = [0, sub(s, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _u_];
       j[1] = i;
      }
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      i = _v_;
     }
    }
    var _t_ = r[1];
    return [0, sub(s, 0, j[1]), _t_];
   }
   var compare = runtime.caml_string_compare;
   function to_seq(s){
    var _r_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[47], _r_);
   }
   function to_seqi(s){
    var _q_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[48], _q_);
   }
   function of_seq(g){
    return caml_call1(bts, caml_call1(Stdlib_Bytes[49], g));
   }
   function get_utf_8_uchar(s, i){
    var _p_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[50], _p_, i);
   }
   function is_valid_utf_8(s){
    var _o_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[52], _o_);
   }
   function get_utf_16be_uchar(s, i){
    var _n_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[53], _n_, i);
   }
   function is_valid_utf_16be(s){
    var _m_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[55], _m_);
   }
   function get_utf_16le_uchar(s, i){
    var _l_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[56], _l_, i);
   }
   function is_valid_utf_16le(s){
    var _k_ = caml_call1(bos, s);
    return caml_call1(Stdlib_Bytes[58], _k_);
   }
   function get_int8(s, i){
    var _j_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[60], _j_, i);
   }
   function get_uint16_le(s, i){
    var _i_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[63], _i_, i);
   }
   function get_uint16_be(s, i){
    var _h_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[62], _h_, i);
   }
   function get_int16_ne(s, i){
    var _g_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[64], _g_, i);
   }
   function get_int16_le(s, i){
    var _f_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[66], _f_, i);
   }
   function get_int16_be(s, i){
    var _e_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[65], _e_, i);
   }
   function get_int32_le(s, i){
    var _d_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[69], _d_, i);
   }
   function get_int32_be(s, i){
    var _c_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[68], _c_, i);
   }
   function get_int64_le(s, i){
    var _b_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[72], _b_, i);
   }
   function get_int64_be(s, i){
    var _a_ = caml_call1(bos, s);
    return caml_call2(Stdlib_Bytes[71], _a_, i);
   }
   var
    Stdlib_String =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat,
       cat,
       caml_string_equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       runtime.caml_string_get,
       get_int8,
       runtime.caml_string_get16,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       runtime.caml_string_get32,
       hash,
       caml_string_hash,
       get_int32_be,
       get_int32_le,
       runtime.caml_string_get64,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Unit
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "()";
   function equal(_b_, param){return 1;}
   function compare(_a_, param){return 0;}
   function to_string(param){return cst;}
   var Stdlib_Unit = [0, equal, compare, to_string];
   runtime.caml_register_global(1, Stdlib_Unit, "Stdlib__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Marshal
//# unitInfo: Requires: Stdlib, Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Marshal_from_bytes$1 = "Marshal.from_bytes",
    caml_marshal_data_size = runtime.caml_marshal_data_size,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    cst_Marshal_to_buffer_substrin =
      "Marshal.to_buffer: substring out of bounds";
   function to_buffer(buff, ofs, len, v, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buff) - len | 0) >= ofs)
     return runtime.caml_output_value_to_buffer(buff, ofs, len, v, flags);
    return caml_call1(Stdlib[1], cst_Marshal_to_buffer_substrin);
   }
   var
    cst_Marshal_data_size = "Marshal.data_size",
    cst_Marshal_from_bytes = cst_Marshal_from_bytes$1,
    cst_Marshal_from_bytes$0 = cst_Marshal_from_bytes$1;
   function data_size(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 16 | 0) >= ofs)
     return caml_marshal_data_size(buff, ofs);
    return caml_call1(Stdlib[1], cst_Marshal_data_size);
   }
   function total_size(buff, ofs){return 16 + data_size(buff, ofs) | 0;}
   function from_bytes(buff, ofs){
    if(0 <= ofs && (caml_ml_bytes_length(buff) - 16 | 0) >= ofs){
     var len = caml_marshal_data_size(buff, ofs);
     return (caml_ml_bytes_length(buff) - (16 + len | 0) | 0) < ofs
             ? caml_call1(Stdlib[1], cst_Marshal_from_bytes$0)
             : runtime.caml_input_value_from_bytes(buff, ofs);
    }
    return caml_call1(Stdlib[1], cst_Marshal_from_bytes);
   }
   function from_string(buff, ofs){
    return from_bytes(caml_call1(Stdlib_Bytes[45], buff), ofs);
   }
   var
    Stdlib_Marshal =
      [0,
       runtime.caml_output_value,
       to_buffer,
       runtime.caml_input_value,
       from_bytes,
       from_string,
       16,
       data_size,
       total_size];
   runtime.caml_register_global(6, Stdlib_Marshal, "Stdlib__Marshal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Array
//# unitInfo: Requires: Stdlib, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_array_sub = runtime.caml_array_sub,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Floatarray = [0],
    cst_Array_init = "Array.init",
    cst_Array_make_matrix = "Array.make_matrix",
    cst_Array_init_matrix = "Array.init_matrix",
    cst_Array_sub = "Array.sub",
    cst_Array_fill = "Array.fill",
    cst_Array_blit = "Array.blit",
    cst_Array_iter2_arrays_must_ha =
      "Array.iter2: arrays must have the same length",
    cst_Array_map2_arrays_must_hav =
      "Array.map2: arrays must have the same length",
    cst_Array_for_all2 = "Array.for_all2",
    cst_Array_exists2 = "Array.exists2",
    cst_Array_combine = "Array.combine";
   function init(l, f){
    if(0 === l) return [0];
    if(0 > l) return caml_call1(Stdlib[1], cst_Array_init);
    var res = caml_make_vect(l, caml_call1(f, 0)), _aE_ = l - 1 | 0, _aD_ = 1;
    if(_aE_ >= 1){
     var i = _aD_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _aF_ = i + 1 | 0;
      if(_aE_ === i) break;
      i = _aF_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, init){
    if(sy < 0) caml_call1(Stdlib[1], cst_Array_make_matrix);
    var res = caml_make_vect(sx, [0]);
    if(0 < sy){
     var _aB_ = sx - 1 | 0, _aA_ = 0;
     if(_aB_ >= 0){
      var x = _aA_;
      for(;;){
       res[1 + x] = caml_make_vect(sy, init);
       var _aC_ = x + 1 | 0;
       if(_aB_ === x) break;
       x = _aC_;
      }
     }
    }
    return res;
   }
   function init_matrix(sx, sy, f){
    if(sy < 0) caml_call1(Stdlib[1], cst_Array_init_matrix);
    var res = caml_make_vect(sx, [0]);
    if(0 < sy){
     var _av_ = sx - 1 | 0, _au_ = 0;
     if(_av_ >= 0){
      var x = _au_;
      for(;;){
       var
        row = caml_make_vect(sy, caml_call2(f, x, 0)),
        _ax_ = sy - 1 | 0,
        _aw_ = 1;
       if(_ax_ >= 1){
        var y = _aw_;
        for(;;){
         row[1 + y] = caml_call2(f, x, y);
         var _az_ = y + 1 | 0;
         if(_ax_ === y) break;
         y = _az_;
        }
       }
       res[1 + x] = row;
       var _ay_ = x + 1 | 0;
       if(_av_ === x) break;
       x = _ay_;
      }
     }
    }
    return res;
   }
   function copy(a){
    var l = a.length - 1;
    return 0 === l ? [0] : caml_array_sub(a, 0, l);
   }
   function append(a1, a2){
    var l1 = a1.length - 1;
    return 0 === l1
            ? copy(a2)
            : 0
              === a2.length - 1
              ? caml_array_sub(a1, 0, l1)
              : runtime.caml_array_append(a1, a2);
   }
   function sub(a, ofs, len){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return caml_array_sub(a, ofs, len);
    return caml_call1(Stdlib[1], cst_Array_sub);
   }
   function fill(a, ofs, len, v){
    if(0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
     return runtime.caml_array_fill(a, ofs, len, v);
    return caml_call1(Stdlib[1], cst_Array_fill);
   }
   function blit(a1, ofs1, a2, ofs2, len){
    if
     (0 <= len
      &&
       0 <= ofs1
       &&
        (a1.length - 1 - len | 0) >= ofs1
        && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
     return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
    return caml_call1(Stdlib[1], cst_Array_blit);
   }
   function iter(f, a){
    var _as_ = a.length - 2 | 0, _ar_ = 0;
    if(_as_ >= 0){
     var i = _ar_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _at_ = i + 1 | 0;
      if(_as_ === i) break;
      i = _at_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
    var _ap_ = a.length - 2 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return 0;
   }
   function map(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call1(f, a[1])),
     _am_ = l - 1 | 0,
     _al_ = 1;
    if(_am_ >= 1){
     var i = _al_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _an_ = i + 1 | 0;
      if(_am_ === i) break;
      i = _an_;
     }
    }
    return r;
   }
   function map_inplace(f, a){
    var _aj_ = a.length - 2 | 0, _ai_ = 0;
    if(_aj_ >= 0){
     var i = _ai_;
     for(;;){
      a[1 + i] = caml_call1(f, a[1 + i]);
      var _ak_ = i + 1 | 0;
      if(_aj_ === i) break;
      i = _ak_;
     }
    }
    return 0;
   }
   function mapi_inplace(f, a){
    var _ag_ = a.length - 2 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      a[1 + i] = caml_call2(f, i, a[1 + i]);
      var _ah_ = i + 1 | 0;
      if(_ag_ === i) break;
      i = _ah_;
     }
    }
    return 0;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
    if(0 === la) return [0];
    var
     r = caml_make_vect(la, caml_call2(f, a[1], b[1])),
     _ad_ = la - 1 | 0,
     _ac_ = 1;
    if(_ad_ >= 1){
     var i = _ac_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      i = _ae_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var _aa_ = a.length - 2 | 0, _$_ = 0;
    if(_aa_ >= 0){
     var i = _$_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _ab_ = i + 1 | 0;
      if(_aa_ === i) break;
      i = _ab_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var
     r = caml_make_vect(l, caml_call2(f, 0, a[1])),
     _Z_ = l - 1 | 0,
     _Y_ = 1;
    if(_Z_ >= 1){
     var i = _Y_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var ___ = i + 1 | 0;
      if(_Z_ === i) break;
      i = ___;
     }
    }
    return r;
   }
   function to_list(a){
    var i$1 = a.length - 2 | 0, i = i$1, res = 0;
    for(;;){
     if(0 > i) return res;
     var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0;
     i = i$0;
     res = res$0;
    }
   }
   function list_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var t = param$0[2], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = t;
    }
   }
   function of_list(l){
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     a = caml_make_vect(list_length(0, l), hd),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   function fold_left(f, x, a){
    var r = [0, x], _W_ = a.length - 2 | 0, _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _X_ = i + 1 | 0;
      if(_W_ === i) break;
      i = _X_;
     }
    }
    return r[1];
   }
   function fold_left_map(f, acc, input_array){
    var len = input_array.length - 1;
    if(0 === len) return [0, acc, [0]];
    var
     match = caml_call2(f, acc, input_array[1]),
     elt = match[2],
     acc$0 = match[1],
     output_array = caml_make_vect(len, elt),
     acc$1 = [0, acc$0],
     _T_ = len - 1 | 0,
     _S_ = 1;
    if(_T_ >= 1){
     var i = _S_;
     for(;;){
      var
       match$0 = caml_call2(f, acc$1[1], input_array[1 + i]),
       elt$0 = match$0[2],
       acc$2 = match$0[1];
      acc$1[1] = acc$2;
      output_array[1 + i] = elt$0;
      var _U_ = i + 1 | 0;
      if(_T_ === i) break;
      i = _U_;
     }
    }
    return [0, acc$1[1], output_array];
   }
   function fold_right(f, a, x){
    var r = [0, x], _Q_ = a.length - 2 | 0;
    if(_Q_ >= 0){
     var i = _Q_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _R_ = i - 1 | 0;
      if(0 === i) break;
      i = _R_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_for_all2);
    var i = 0;
    for(;;){
     if(i === n1) return 1;
     if(! caml_call2(p, l1[1 + i], l2[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function exists2(p, l1, l2){
    var n1 = l1.length - 1, n2 = l2.length - 1;
    if(n1 !== n2) return caml_call1(Stdlib[1], cst_Array_exists2);
    var i = 0;
    for(;;){
     if(i === n1) return 0;
     if(caml_call2(p, l1[1 + i], l2[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === runtime.caml_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function memq(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x === a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_index(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_mapi(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call2(f, i, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function split(x){
    if(runtime.caml_equal(x, [0])) return [0, [0], [0]];
    var
     match = x[1],
     b0 = match[2],
     a0 = match[1],
     n = x.length - 1,
     a = caml_make_vect(n, a0),
     b = caml_make_vect(n, b0),
     _O_ = n - 1 | 0,
     _N_ = 1;
    if(_O_ >= 1){
     var i = _N_;
     for(;;){
      var match$0 = x[1 + i], bi = match$0[2], ai = match$0[1];
      a[1 + i] = ai;
      b[1 + i] = bi;
      var _P_ = i + 1 | 0;
      if(_O_ === i) break;
      i = _P_;
     }
    }
    return [0, a, b];
   }
   function combine(a, b){
    var na = a.length - 1, nb = b.length - 1;
    if(na !== nb) caml_call1(Stdlib[1], cst_Array_combine);
    if(0 === na) return [0];
    var x = caml_make_vect(na, [0, a[1], b[1]]), _L_ = na - 1 | 0, _K_ = 1;
    if(_L_ >= 1){
     var i = _K_;
     for(;;){
      x[1 + i] = [0, a[1 + i], b[1 + i]];
      var _M_ = i + 1 | 0;
      if(_L_ === i) break;
      i = _M_;
     }
    }
    return x;
   }
   var
    Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "array.ml", 369, 4];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      var _D_ = i31 + 1 | 0, _E_ = caml_check_bound(a, _D_)[1 + _D_];
      if(caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _E_) < 0)
       x[1] = i31 + 1 | 0;
      var
       _F_ = i31 + 2 | 0,
       _G_ = caml_check_bound(a, _F_)[1 + _F_],
       _H_ = x[1];
      if(caml_call2(cmp, caml_check_bound(a, _H_)[1 + _H_], _G_) < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if((i31 + 1 | 0) < l){
      var _I_ = i31 + 1 | 0, _J_ = caml_check_bound(a, _I_)[1 + _I_];
      if(0 > caml_call2(cmp, caml_check_bound(a, i31)[1 + i31], _J_))
       return i31 + 1 | 0;
     }
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _x_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_x_ >= 0){
     var i$6 = _x_;
     for(;;){
      var e$1 = caml_check_bound(a, i$6)[1 + i$6];
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_check_bound(a, j)[1 + j], e$1)) break;
        var _u_ = caml_check_bound(a, j)[1 + j];
        caml_check_bound(a, i)[1 + i] = _u_;
        i = j;
       }
       caml_check_bound(a, i)[1 + i] = e$1;
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_check_bound(a, i$0)[1 + i$0] = e$1;
      }
      var _C_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _C_;
     }
    }
    var _y_ = l - 1 | 0;
    if(_y_ >= 2){
     var i$4 = _y_;
     for(;;){
      var e$0 = caml_check_bound(a, i$4)[1 + i$4];
      a[1 + i$4] = caml_check_bound(a, 0)[1];
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1), _v_ = caml_check_bound(a, j$0)[1 + j$0];
        caml_check_bound(a, i$1)[1 + i$1] = _v_;
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          if
           (0 <= caml_call2(cmp, caml_check_bound(a, father)[1 + father], e$0))
           break;
          var _w_ = caml_check_bound(a, father)[1 + father];
          caml_check_bound(a, i$3)[1 + i$3] = _w_;
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_check_bound(a, i$3)[1 + i$3] = e$0;
         break a;
        }
        caml_check_bound(a, 0)[1] = e$0;
       }
       var _B_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _B_;
      }
     }
    }
    var _z_ = 1 < l ? 1 : 0;
    if(_z_){
     var e = caml_check_bound(a, 1)[2];
     a[2] = caml_check_bound(a, 0)[1];
     a[1] = e;
     var _A_ = 0;
    }
    else
     var _A_ = _z_;
    return _A_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_check_bound(src2, src2ofs)[1 + src2ofs],
      s1$1 = caml_check_bound(a, src1ofs)[1 + src1ofs],
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_check_bound(dst, d)[1 + d] = s2;
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_check_bound(src2, i2$0)[1 + i2$0];
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_check_bound(dst, d)[1 + d] = s1;
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_check_bound(a, i1$0)[1 + i1$0];
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _m_ = len - 1 | 0, _l_ = 0;
     if(_m_ >= 0){
      var i = _l_;
      for(;;){
       var
        _n_ = srcofs + i | 0,
        e = caml_check_bound(a, _n_)[1 + _n_],
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        var _o_ = j[1];
        if(0 >= caml_call2(cmp, caml_check_bound(dst, _o_)[1 + _o_], e))
         break;
        var
         _p_ = j[1],
         _q_ = caml_check_bound(dst, _p_)[1 + _p_],
         _r_ = j[1] + 1 | 0;
        caml_check_bound(dst, _r_)[1 + _r_] = _q_;
        j[1]--;
       }
       var _s_ = j[1] + 1 | 0;
       caml_check_bound(dst, _s_)[1 + _s_] = e;
       var _t_ = i + 1 | 0;
       if(_m_ === i) break;
       i = _t_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var
     l1 = l / 2 | 0,
     l2 = l - l1 | 0,
     t = caml_make_vect(l2, caml_check_bound(a, 0)[1]);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function shuffle(rand, a){
    var _j_ = a.length - 2 | 0;
    if(_j_ >= 1){
     var i = _j_;
     for(;;){
      var j = caml_call1(rand, i + 1 | 0), v = a[1 + i];
      a[1 + i] = caml_check_bound(a, j)[1 + j];
      a[1 + j] = v;
      var _k_ = i - 1 | 0;
      if(1 === i) break;
      i = _k_;
     }
    }
    return 0;
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _h_ = i + 1 | 0;
     return [0, x, function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _d_ = i + 1 | 0;
     return [0, [0, i, x], function(_e_){return aux(_d_, _e_);}];
    }
    var _b_ = 0;
    return function(_c_){return aux(_b_, _c_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2);
    if(! l) return [0];
    var
     tl = l[2],
     hd = l[1],
     len = list_length(0, l),
     a = caml_make_vect(len, hd),
     i$1 = len - 2 | 0,
     i = i$1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = hd$0;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl$0;
    }
   }
   var
    Stdlib_Array =
      [0,
       init,
       make_matrix,
       init_matrix,
       append,
       runtime.caml_array_concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       split,
       combine,
       sort,
       stable_sort,
       stable_sort,
       shuffle,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(16, Stdlib_Array, "Stdlib__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Float
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Float_array_blit$1 = "Float.array.blit",
    cst_float_ml = "float.ml",
    caml_array_get = runtime.caml_array_get,
    caml_array_set = runtime.caml_array_set,
    caml_float_compare = runtime.caml_float_compare,
    caml_floatarray_blit = runtime.caml_floatarray_blit,
    caml_floatarray_create = runtime.caml_floatarray_create,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_nextafter_float = runtime.caml_nextafter_float,
    caml_signbit_float = runtime.caml_signbit_float,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    infinity = Stdlib[22],
    neg_infinity = Stdlib[23],
    nan = Stdlib[24],
    signaling_nan =
      runtime.caml_int64_float_of_bits
       (runtime.caml_int64_create_lo_mi_hi(1, 0, 32752));
   function is_finite(x){return x - x == 0. ? 1 : 0;}
   function is_infinite(x){return 1. / x == 0. ? 1 : 0;}
   function is_nan(x){return x != x ? 1 : 0;}
   var
    max_float = Stdlib[25],
    min_float = Stdlib[26],
    epsilon = Stdlib[27],
    of_string_opt = Stdlib[36],
    to_string = Stdlib[35],
    cst_Float_Array_init = "Float.Array.init",
    cst_Float_Array_make_matrix = "Float.Array.make_matrix",
    cst_Float_Array_init_matrix = "Float.Array.init_matrix",
    cst_Float_Array_concat = "Float.Array.concat",
    _a_ = [0, cst_float_ml, 254, 14],
    cst_Float_Array_sub = "Float.Array.sub",
    cst_Float_Array_fill = "Float.Array.fill",
    cst_Float_array_blit = cst_Float_array_blit$1,
    cst_Float_array_blit$0 = cst_Float_array_blit$1,
    cst_Float_Array_iter2_arrays_m =
      "Float.Array.iter2: arrays must have the same length",
    cst_Float_Array_map2_arrays_mu =
      "Float.Array.map2: arrays must have the same length";
   function is_integer(x){
    var _ax_ = x == runtime.caml_trunc_float(x) ? 1 : 0;
    return _ax_ ? is_finite(x) : _ax_;
   }
   function succ(x){return caml_nextafter_float(x, infinity);}
   function pred(x){return caml_nextafter_float(x, neg_infinity);}
   function equal(x, y){return 0 === caml_float_compare(x, y) ? 1 : 0;}
   function min(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x != x ? x : y;
    }
    return y != y ? y : x;
   }
   function max(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y != y ? y : x;
    }
    return x != x ? x : y;
   }
   function min_max(x, y){
    if(x == x && y == y){
     a:
     if(! (x < y)){
      if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
      return [0, y, x];
     }
     return [0, x, y];
    }
    return [0, nan, nan];
   }
   function min_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return y != y ? x : y;
    }
    return x != x ? y : x;
   }
   function max_num(x, y){
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return x != x ? y : x;
    }
    return y != y ? x : y;
   }
   function min_max_num(x, y){
    if(x != x) return [0, y, y];
    if(y != y) return [0, x, x];
    a:
    if(! (x < y)){
     if(! caml_signbit_float(y) && caml_signbit_float(x)) break a;
     return [0, y, x];
    }
    return [0, x, y];
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   function unsafe_fill(a, ofs, len, v){
    var _av_ = (ofs + len | 0) - 1 | 0;
    if(_av_ >= ofs){
     var i = ofs;
     for(;;){
      a[1 + i] = v;
      var _aw_ = i + 1 | 0;
      if(_av_ === i) break;
      i = _aw_;
     }
    }
    return 0;
   }
   function check(a, ofs, len, msg){
    var _ar_ = ofs < 0 ? 1 : 0;
    if(_ar_)
     var _as_ = _ar_;
    else{
     var _at_ = len < 0 ? 1 : 0;
     if(_at_)
      var _as_ = _at_;
     else
      var
       _au_ = (ofs + len | 0) < 0 ? 1 : 0,
       _as_ = _au_ || (a.length - 1 < (ofs + len | 0) ? 1 : 0);
    }
    return _as_ ? caml_call1(Stdlib[1], msg) : _as_;
   }
   function make(n, v){
    var result = caml_floatarray_create(n);
    unsafe_fill(result, 0, n, v);
    return result;
   }
   function init(l, f){
    if(0 > l) return caml_call1(Stdlib[1], cst_Float_Array_init);
    var res = caml_floatarray_create(l), _ap_ = l - 1 | 0, _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      i = _aq_;
     }
    }
    return res;
   }
   function make_matrix(sx, sy, v){
    if(sy < 0) caml_call1(Stdlib[1], cst_Float_Array_make_matrix);
    var res = caml_make_vect(sx, caml_floatarray_create(0));
    if(0 < sy){
     var _am_ = sx - 1 | 0, _al_ = 0;
     if(_am_ >= 0){
      var x = _al_;
      for(;;){
       res[1 + x] = make(sy, v);
       var _an_ = x + 1 | 0;
       if(_am_ === x) break;
       x = _an_;
      }
     }
    }
    return res;
   }
   function init_matrix(sx, sy, f){
    if(sy < 0) caml_call1(Stdlib[1], cst_Float_Array_init_matrix);
    var res = caml_make_vect(sx, caml_floatarray_create(0));
    if(0 < sy){
     var _ag_ = sx - 1 | 0, _af_ = 0;
     if(_ag_ >= 0){
      var x = _af_;
      for(;;){
       var row = caml_floatarray_create(sy), _ai_ = sy - 1 | 0, _ah_ = 0;
       if(_ai_ >= 0){
        var y = _ah_;
        for(;;){
         row[1 + y] = caml_call2(f, x, y);
         var _ak_ = y + 1 | 0;
         if(_ai_ === y) break;
         y = _ak_;
        }
       }
       res[1 + x] = row;
       var _aj_ = x + 1 | 0;
       if(_ag_ === x) break;
       x = _aj_;
      }
     }
    }
    return res;
   }
   function append(a1, a2){
    var
     l1 = a1.length - 1,
     l2 = a2.length - 1,
     result = caml_floatarray_create(l1 + l2 | 0);
    caml_floatarray_blit(a1, 0, result, 0, l1);
    caml_floatarray_blit(a2, 0, result, l1, l2);
    return result;
   }
   function concat(l){
    var acc = 0, param = l;
    for(;;){
     if(! param) break;
     var
      tl = param[2],
      hd = param[1],
      x = hd.length - 1 + acc | 0,
      acc$0 = acc <= x ? x : caml_call1(Stdlib[1], cst_Float_Array_concat);
     acc = acc$0;
     param = tl;
    }
    var result = caml_floatarray_create(acc), l$0 = l, i = 0;
    for(;;){
     if(! l$0){
      if(i === acc) return result;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
     var tl$0 = l$0[2], hd$0 = l$0[1], hlen = hd$0.length - 1;
     caml_floatarray_blit(hd$0, 0, result, i, hlen);
     var i$0 = i + hlen | 0;
     l$0 = tl$0;
     i = i$0;
    }
   }
   function sub(a, ofs, len){
    check(a, ofs, len, cst_Float_Array_sub);
    var result = caml_floatarray_create(len);
    caml_floatarray_blit(a, ofs, result, 0, len);
    return result;
   }
   function copy(a){
    var l = a.length - 1, result = caml_floatarray_create(l);
    caml_floatarray_blit(a, 0, result, 0, l);
    return result;
   }
   function fill(a, ofs, len, v){
    check(a, ofs, len, cst_Float_Array_fill);
    return unsafe_fill(a, ofs, len, v);
   }
   function blit(src, sofs, dst, dofs, len){
    check(src, sofs, len, cst_Float_array_blit);
    check(dst, dofs, len, cst_Float_array_blit$0);
    return caml_floatarray_blit(src, sofs, dst, dofs, len);
   }
   function to_list(a){
    return caml_call2
            (Stdlib_List[11],
             a.length - 1,
             function(_ae_){return a[1 + _ae_];});
   }
   function of_list(l){
    var
     result = caml_floatarray_create(caml_call1(Stdlib_List[1], l)),
     i = 0,
     l$0 = l;
    for(;;){
     if(! l$0) return result;
     var t = l$0[2], h = l$0[1];
     result[1 + i] = h;
     var i$0 = i + 1 | 0;
     i = i$0;
     l$0 = t;
    }
   }
   function iter(f, a){
    var _ac_ = a.length - 2 | 0, _ab_ = 0;
    if(_ac_ >= 0){
     var i = _ab_;
     for(;;){
      caml_call1(f, a[1 + i]);
      var _ad_ = i + 1 | 0;
      if(_ac_ === i) break;
      i = _ad_;
     }
    }
    return 0;
   }
   function iter2(f, a, b){
    if(a.length - 1 !== b.length - 1)
     return caml_call1(Stdlib[1], cst_Float_Array_iter2_arrays_m);
    var _$_ = a.length - 2 | 0, ___ = 0;
    if(_$_ >= 0){
     var i = ___;
     for(;;){
      caml_call2(f, a[1 + i], b[1 + i]);
      var _aa_ = i + 1 | 0;
      if(_$_ === i) break;
      i = _aa_;
     }
    }
    return 0;
   }
   function map(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _Y_ = l - 1 | 0,
     _X_ = 0;
    if(_Y_ >= 0){
     var i = _X_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _Z_ = i + 1 | 0;
      if(_Y_ === i) break;
      i = _Z_;
     }
    }
    return r;
   }
   function map_inplace(f, a){
    var _V_ = a.length - 2 | 0, _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      a[1 + i] = caml_call1(f, a[1 + i]);
      var _W_ = i + 1 | 0;
      if(_V_ === i) break;
      i = _W_;
     }
    }
    return 0;
   }
   function map2(f, a, b){
    var la = a.length - 1, lb = b.length - 1;
    if(la !== lb)
     return caml_call1(Stdlib[1], cst_Float_Array_map2_arrays_mu);
    var r = caml_floatarray_create(la), _S_ = la - 1 | 0, _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
      var _T_ = i + 1 | 0;
      if(_S_ === i) break;
      i = _T_;
     }
    }
    return r;
   }
   function iteri(f, a){
    var _P_ = a.length - 2 | 0, _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      caml_call2(f, i, a[1 + i]);
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      i = _Q_;
     }
    }
    return 0;
   }
   function mapi(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _M_ = l - 1 | 0,
     _L_ = 0;
    if(_M_ >= 0){
     var i = _L_;
     for(;;){
      r[1 + i] = caml_call2(f, i, a[1 + i]);
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return r;
   }
   function mapi_inplace(f, a){
    var _J_ = a.length - 2 | 0, _I_ = 0;
    if(_J_ >= 0){
     var i = _I_;
     for(;;){
      a[1 + i] = caml_call2(f, i, a[1 + i]);
      var _K_ = i + 1 | 0;
      if(_J_ === i) break;
      i = _K_;
     }
    }
    return 0;
   }
   function fold_left(f, x, a){
    var r = [0, x], _G_ = a.length - 2 | 0, _F_ = 0;
    if(_G_ >= 0){
     var i = _F_;
     for(;;){
      r[1] = caml_call2(f, r[1], a[1 + i]);
      var _H_ = i + 1 | 0;
      if(_G_ === i) break;
      i = _H_;
     }
    }
    return r[1];
   }
   function fold_right(f, a, x){
    var r = [0, x], _D_ = a.length - 2 | 0;
    if(_D_ >= 0){
     var i = _D_;
     for(;;){
      r[1] = caml_call2(f, a[1 + i], r[1]);
      var _E_ = i - 1 | 0;
      if(0 === i) break;
      i = _E_;
     }
    }
    return r[1];
   }
   function exists(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function for_all(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 1;
     if(! caml_call1(p, a[1 + i])) return 0;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(0 === caml_float_compare(a[1 + i], x)) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function mem_ieee(x, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(x == a[1 + i]) return 1;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_opt(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var x = a[1 + i];
     if(caml_call1(p, x)) return [0, x];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_index(p, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     if(caml_call1(p, a[1 + i])) return [0, i];
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_map(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call1(f, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function find_mapi(f, a){
    var n = a.length - 1, i = 0;
    for(;;){
     if(i === n) return 0;
     var r = caml_call2(f, i, a[1 + i]);
     if(r) return r;
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   var
    Bottom = [248, "Stdlib.Float.Array.Bottom", runtime.caml_fresh_oo_id(0)],
    _b_ = [0, cst_float_ml, 484, 6];
   function sort(cmp, a){
    function maxson(l, i){
     var i31 = ((i + i | 0) + i | 0) + 1 | 0, x = [0, i31];
     if((i31 + 2 | 0) < l){
      if
       (caml_call2
         (cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0))
        < 0)
       x[1] = i31 + 1 | 0;
      if
       (caml_call2
         (cmp, caml_array_get(a, x[1]), caml_array_get(a, i31 + 2 | 0))
        < 0)
       x[1] = i31 + 2 | 0;
      return x[1];
     }
     if
      ((i31 + 1 | 0) < l
       &&
        0
        >
         caml_call2
          (cmp, caml_array_get(a, i31), caml_array_get(a, i31 + 1 | 0)))
      return i31 + 1 | 0;
     if(i31 < l) return i31;
     throw caml_maybe_attach_backtrace([0, Bottom, i], 1);
    }
    var l = a.length - 1, _x_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
    if(_x_ >= 0){
     var i$6 = _x_;
     for(;;){
      var e$1 = caml_array_get(a, i$6);
      try{
       var i = i$6;
       for(;;){
        var j = maxson(l, i);
        if(0 >= caml_call2(cmp, caml_array_get(a, j), e$1)) break;
        caml_array_set(a, i, caml_array_get(a, j));
        i = j;
       }
       caml_array_set(a, i, e$1);
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn[1] !== Bottom) throw caml_maybe_attach_backtrace(exn, 0);
       var i$0 = exn[2];
       caml_array_set(a, i$0, e$1);
      }
      var _C_ = i$6 - 1 | 0;
      if(0 === i$6) break;
      i$6 = _C_;
     }
    }
    var _y_ = l - 1 | 0;
    if(_y_ >= 2){
     var i$4 = _y_;
     for(;;){
      var e$0 = caml_array_get(a, i$4);
      caml_array_set(a, i$4, caml_array_get(a, 0));
      var i$5 = 0;
      try{
       var i$1 = i$5;
       for(;;){
        var j$0 = maxson(i$4, i$1);
        caml_array_set(a, i$1, caml_array_get(a, j$0));
        i$1 = j$0;
       }
      }
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(exn$0[1] !== Bottom) throw caml_maybe_attach_backtrace(exn$0, 0);
       var i$2 = exn$0[2];
       a:
       {
        b:
        {
         var i$3 = i$2;
         for(;;){
          var father = (i$3 - 1 | 0) / 3 | 0;
          if(i$3 === father)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          if(0 <= caml_call2(cmp, caml_array_get(a, father), e$0)) break;
          caml_array_set(a, i$3, caml_array_get(a, father));
          if(0 >= father) break b;
          i$3 = father;
         }
         caml_array_set(a, i$3, e$0);
         break a;
        }
        caml_array_set(a, 0, e$0);
       }
       var _B_ = i$4 - 1 | 0;
       if(2 === i$4) break;
       i$4 = _B_;
      }
     }
    }
    var _z_ = 1 < l ? 1 : 0;
    if(_z_){
     var e = caml_array_get(a, 1);
     caml_array_set(a, 1, caml_array_get(a, 0));
     var _A_ = caml_array_set(a, 0, e);
    }
    else
     var _A_ = _z_;
    return _A_;
   }
   function stable_sort(cmp, a){
    function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs){
     var
      src1r = src1ofs + src1len | 0,
      src2r = src2ofs + src2len | 0,
      s2$1 = caml_array_get(src2, src2ofs),
      s1$1 = caml_array_get(a, src1ofs),
      i1 = src1ofs,
      s1 = s1$1,
      i2 = src2ofs,
      s2 = s2$1,
      d = dstofs;
     for(;;)
      if(0 < caml_call2(cmp, s1, s2)){
       caml_array_set(dst, d, s2);
       var i2$0 = i2 + 1 | 0;
       if(i2$0 >= src2r) return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
       var d$0 = d + 1 | 0, s2$0 = caml_array_get(src2, i2$0);
       i2 = i2$0;
       s2 = s2$0;
       d = d$0;
      }
      else{
       caml_array_set(dst, d, s1);
       var i1$0 = i1 + 1 | 0;
       if(i1$0 >= src1r)
        return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
       var d$1 = d + 1 | 0, s1$0 = caml_array_get(a, i1$0);
       i1 = i1$0;
       s1 = s1$0;
       d = d$1;
      }
    }
    function isortto(srcofs, dst, dstofs, len){
     var _v_ = len - 1 | 0, _u_ = 0;
     if(_v_ >= 0){
      var i = _u_;
      for(;;){
       var
        e = caml_array_get(a, srcofs + i | 0),
        j = [0, (dstofs + i | 0) - 1 | 0];
       for(;;){
        if(dstofs > j[1]) break;
        if(0 >= caml_call2(cmp, caml_array_get(dst, j[1]), e)) break;
        caml_array_set(dst, j[1] + 1 | 0, caml_array_get(dst, j[1]));
        j[1]--;
       }
       caml_array_set(dst, j[1] + 1 | 0, e);
       var _w_ = i + 1 | 0;
       if(_v_ === i) break;
       i = _w_;
      }
     }
     return 0;
    }
    function sortto(srcofs, dst, dstofs, len){
     if(len <= 5) return isortto(srcofs, dst, dstofs, len);
     var l1 = len / 2 | 0, l2 = len - l1 | 0;
     sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
     sortto(srcofs, a, srcofs + l2 | 0, l1);
     return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
    var l = a.length - 1;
    if(l <= 5) return isortto(0, a, 0, l);
    var l1 = l / 2 | 0, l2 = l - l1 | 0, t = caml_floatarray_create(l2);
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
   }
   function shuffle(rand, a){
    var _s_ = a.length - 2 | 0;
    if(_s_ >= 1){
     var i = _s_;
     for(;;){
      var j = caml_call1(rand, i + 1 | 0), v = a[1 + i];
      a[1 + i] = caml_array_get(a, j);
      a[1 + j] = v;
      var _t_ = i - 1 | 0;
      if(1 === i) break;
      i = _t_;
     }
    }
    return 0;
   }
   function to_seq(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _q_ = i + 1 | 0;
     return [0, x, function(_r_){return aux(_q_, _r_);}];
    }
    var _o_ = 0;
    return function(_p_){return aux(_o_, _p_);};
   }
   function to_seqi(a){
    function aux(i, param){
     if(i >= a.length - 1) return 0;
     var x = a[1 + i], _m_ = i + 1 | 0;
     return [0, [0, i, x], function(_n_){return aux(_m_, _n_);}];
    }
    var _k_ = 0;
    return function(_l_){return aux(_k_, _l_);};
   }
   function of_seq(i$2){
    var
     l =
       caml_call3
        (Stdlib_Seq[5], function(acc, x){return [0, x, acc];}, 0, i$2),
     len = caml_call1(Stdlib_List[1], l),
     a = caml_floatarray_create(len),
     i$1 = len - 1 | 0,
     i = i$1,
     param = l;
    for(;;){
     if(! param) return a;
     var tl = param[2], hd = param[1];
     a[1 + i] = hd;
     var i$0 = i - 1 | 0;
     i = i$0;
     param = tl;
    }
   }
   function map_to_array(f, a){
    var l = a.length - 1;
    if(0 === l) return [0];
    var r = caml_make_vect(l, caml_call1(f, a[1])), _i_ = l - 1 | 0, _h_ = 1;
    if(_i_ >= 1){
     var i = _h_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _j_ = i + 1 | 0;
      if(_i_ === i) break;
      i = _j_;
     }
    }
    return r;
   }
   function map_from_array(f, a){
    var
     l = a.length - 1,
     r = caml_floatarray_create(l),
     _f_ = l - 1 | 0,
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      r[1 + i] = caml_call1(f, a[1 + i]);
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return r;
   }
   var
    Stdlib_Float =
      [0,
       0.,
       1.,
       -1.,
       succ,
       pred,
       infinity,
       neg_infinity,
       nan,
       signaling_nan,
       nan,
       3.141592653589793,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal,
       min,
       max,
       min_max,
       min_num,
       max_num,
       min_max_num,
       seeded_hash,
       hash,
       [0,
        function(_d_){return _d_.length - 1;},
        caml_array_get,
        caml_array_set,
        make,
        caml_floatarray_create,
        init,
        make_matrix,
        init_matrix,
        append,
        concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        map_inplace,
        mapi,
        mapi_inplace,
        fold_left,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        mem,
        mem_ieee,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        sort,
        stable_sort,
        stable_sort,
        shuffle,
        to_seq,
        to_seqi,
        of_seq,
        map_to_array,
        map_from_array],
       [0,
        function(_c_){return _c_.length - 1;},
        caml_array_get,
        caml_array_set,
        make,
        caml_floatarray_create,
        init,
        make_matrix,
        init_matrix,
        append,
        concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        map_inplace,
        mapi,
        mapi_inplace,
        fold_left,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        mem,
        mem_ieee,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        sort,
        stable_sort,
        stable_sort,
        shuffle,
        to_seq,
        to_seqi,
        of_seq,
        map_to_array,
        map_from_array]];
   runtime.caml_register_global(25, Stdlib_Float, "Stdlib__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int32
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   function lognot(n){return n ^ -1;}
   var
    _a_ = Stdlib_Sys[9],
    _b_ = [0, "int32.ml", 69, 6],
    minus_one = -1,
    min_int = -2147483648,
    max_int = 2147483647;
   if(32 === _a_)
    var
     max_int$0 = Stdlib[19],
     unsigned_to_int =
       function(n){
        if(caml_greaterequal(n, 0) && caml_lessequal(n, max_int$0))
         return [0, n];
        return 0;
       };
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var unsigned_to_int = function(n){return [0, n & -1];};
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _d_ = [0, runtime.caml_int_of_string(s)]; return _d_;}
    catch(_e_){
     var _c_ = caml_wrap_exception(_e_);
     if(_c_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_c_, 0);
    }
   }
   var compare = caml_int_compare, equal = runtime.caml_equal;
   function unsigned_compare(n, m){
    var y = m + 2147483648 | 0, x = n + 2147483648 | 0;
    return caml_int_compare(x, y);
   }
   function unsigned_lt(n, m){
    return caml_lessthan(n + 2147483648 | 0, m + 2147483648 | 0);
   }
   function min(x, y){return caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(caml_lessthan(d, 0)) return unsigned_lt(n, d) ? zero : one;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return unsigned_lt(r, d) ? q : q + 1 | 0;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int32 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(15, Stdlib_Int32, "Stdlib__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Int64
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768),
    max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Stdlib = global_data.Stdlib,
    _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
   function succ(n){return caml_int64_add(n, _a_);}
   function pred(n){return caml_int64_sub(n, _b_);}
   function abs(n){
    return caml_greaterequal(n, _c_) ? n : runtime.caml_int64_neg(n);
   }
   function lognot(n){return runtime.caml_int64_xor(n, _d_);}
   var
    max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]),
    _e_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function unsigned_to_int(n){
    if(caml_greaterequal(n, _e_) && caml_lessequal(n, max_int$0))
     return [0, runtime.caml_int64_to_int32(n)];
    return 0;
   }
   function to_string(n){return runtime.caml_int64_format("%d", n);}
   function of_string_opt(s){
    try{var _g_ = [0, runtime.caml_int64_of_string(s)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   function compare(x, y){return caml_int64_compare(x, y);}
   var equal = runtime.caml_equal;
   function unsigned_compare(n, m){
    var y = caml_int64_sub(m, min_int), x = caml_int64_sub(n, min_int);
    return caml_int64_compare(x, y);
   }
   function unsigned_lt(n, m){
    return caml_lessthan
            (caml_int64_sub(n, min_int), caml_int64_sub(m, min_int));
   }
   function min(x, y){return caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(caml_lessthan(d, zero)) return unsigned_lt(n, d) ? zero : one;
    var
     q =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_div
          (runtime.caml_int64_shift_right_unsigned(n, 1), d),
         1),
     r = caml_int64_sub(n, caml_int64_mul(q, d));
    return unsigned_lt(r, d) ? q : caml_int64_add(q, _a_);
   }
   function unsigned_rem(n, d){
    return caml_int64_sub(n, caml_int64_mul(unsigned_div(n, d), d));
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Int64 =
      [0,
       zero,
       one,
       minus_one,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(12, Stdlib_Int64, "Stdlib__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Nativeint
//# unitInfo: Requires: Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_hash = runtime.caml_hash,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    zero = 0,
    one = 1;
   function succ(n){return n + 1 | 0;}
   function pred(n){return n - 1 | 0;}
   function abs(n){return caml_greaterequal(n, 0) ? n : - n | 0;}
   var
    size = Stdlib_Sys[9],
    min_int = 1 << (size - 1 | 0),
    max_int = min_int - 1 | 0;
   function lognot(n){return n ^ -1;}
   var max_int$0 = Stdlib[19];
   function unsigned_to_int(n){
    if(caml_greaterequal(n, 0) && caml_lessequal(n, max_int$0)) return [0, n];
    return 0;
   }
   function to_string(n){return runtime.caml_format_int("%d", n);}
   function of_string_opt(s){
    try{var _b_ = [0, runtime.caml_int_of_string(s)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var compare = caml_int_compare;
   function equal(x, y){return 0 === caml_int_compare(x, y) ? 1 : 0;}
   function unsigned_compare(n, m){
    var y = m - min_int | 0, x = n - min_int | 0;
    return caml_int_compare(x, y);
   }
   function unsigned_lt(n, m){
    return caml_lessthan(n - min_int | 0, m - min_int | 0);
   }
   function min(x, y){return caml_lessequal(x, y) ? x : y;}
   function max(x, y){return caml_greaterequal(x, y) ? x : y;}
   function unsigned_div(n, d){
    if(caml_lessthan(d, 0)) return unsigned_lt(n, d) ? zero : one;
    var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul(q, d) | 0;
    return unsigned_lt(r, d) ? q : q + 1 | 0;
   }
   function unsigned_rem(n, d){
    return n - caml_mul(unsigned_div(n, d), d) | 0;
   }
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function hash(x){return caml_hash(10, 100, 0, x);}
   var
    Stdlib_Nativeint =
      [0,
       zero,
       one,
       -1,
       unsigned_div,
       unsigned_rem,
       succ,
       pred,
       abs,
       size,
       max_int,
       min_int,
       lognot,
       unsigned_to_int,
       of_string_opt,
       to_string,
       compare,
       unsigned_compare,
       equal,
       min,
       max,
       seeded_hash,
       hash];
   runtime.caml_register_global(13, Stdlib_Nativeint, "Stdlib__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Lexing
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Int, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_pos = [0, cst, 0, 0, -1],
    zero_pos = [0, cst, 1, 0, 0],
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    cst_Lexing_lex_refill_cannot_g = "Lexing.lex_refill: cannot grow buffer";
   function engine(tbl, state, buf){
    var
     result = runtime.caml_lex_engine(tbl, state, buf),
     _n_ = 0 <= result ? 1 : 0,
     _o_ = _n_ ? buf[12] !== dummy_pos ? 1 : 0 : _n_;
    if(_o_){
     buf[11] = buf[12];
     var _p_ = buf[12];
     buf[12] = [0, _p_[1], _p_[2], _p_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function new_engine(tbl, state, buf){
    var
     result = runtime.caml_new_lex_engine(tbl, state, buf),
     _k_ = 0 <= result ? 1 : 0,
     _l_ = _k_ ? buf[12] !== dummy_pos ? 1 : 0 : _k_;
    if(_l_){
     buf[11] = buf[12];
     var _m_ = buf[12];
     buf[12] = [0, _m_[1], _m_[2], _m_[3], buf[4] + buf[6] | 0];
    }
    return result;
   }
   function from_function(opt, read_fun){
    var
     with_positions = opt ? opt[1] : 1,
     _f_ = with_positions ? zero_pos : dummy_pos,
     _g_ = with_positions ? zero_pos : dummy_pos,
     aux_buffer = caml_create_bytes(512);
    return [0,
            function(lexbuf){
             var
              read =
                caml_call2
                 (read_fun, aux_buffer, caml_ml_bytes_length(aux_buffer)),
              n = 0 < read ? read : (lexbuf[9] = 1, 0);
             if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0)){
              if
               (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                <= caml_ml_bytes_length(lexbuf[2]))
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 lexbuf[2],
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
              else{
               var
                newlen =
                  caml_call2
                   (Stdlib_Int[10],
                    2 * caml_ml_bytes_length(lexbuf[2]) | 0,
                    Stdlib_Sys[12]);
               if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                caml_call1(Stdlib[2], cst_Lexing_lex_refill_cannot_g);
               var newbuf = caml_create_bytes(newlen);
               caml_call5
                (Stdlib_Bytes[11],
                 lexbuf[2],
                 lexbuf[5],
                 newbuf,
                 0,
                 lexbuf[3] - lexbuf[5] | 0);
               lexbuf[2] = newbuf;
              }
              var s = lexbuf[5];
              lexbuf[4] = lexbuf[4] + s | 0;
              lexbuf[6] = lexbuf[6] - s | 0;
              lexbuf[5] = 0;
              lexbuf[7] = lexbuf[7] - s | 0;
              lexbuf[3] = lexbuf[3] - s | 0;
              var t = lexbuf[10], _i_ = t.length - 2 | 0, _h_ = 0;
              if(_i_ >= 0){
               var i = _h_;
               for(;;){
                var v = caml_check_bound(t, i)[1 + i];
                if(0 <= v) caml_check_bound(t, i)[1 + i] = v - s | 0;
                var _j_ = i + 1 | 0;
                if(_i_ === i) break;
                i = _j_;
               }
              }
             }
             caml_call5
              (Stdlib_Bytes[11], aux_buffer, 0, lexbuf[2], lexbuf[3], n);
             lexbuf[3] = lexbuf[3] + n | 0;
             return 0;
            },
            caml_create_bytes(1024),
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            [0],
            _g_,
            _f_];
   }
   function from_channel(with_positions, ic){
    return from_function
            (with_positions,
             function(buf, n){return caml_call4(Stdlib[84], ic, buf, 0, n);});
   }
   function from_string(opt, s){
    var
     with_positions = opt ? opt[1] : 1,
     _d_ = with_positions ? zero_pos : dummy_pos,
     _e_ = with_positions ? zero_pos : dummy_pos;
    return [0,
            function(lexbuf){lexbuf[9] = 1; return 0;},
            caml_call1(Stdlib_Bytes[5], s),
            runtime.caml_ml_string_length(s),
            0,
            0,
            0,
            0,
            0,
            1,
            [0],
            _e_,
            _d_];
   }
   function set_position(lexbuf, position){
    lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
    lexbuf[4] = position[4];
    return 0;
   }
   function set_filename(lexbuf, fname){
    var _c_ = lexbuf[12];
    lexbuf[12] = [0, fname, _c_[2], _c_[3], _c_[4]];
    return 0;
   }
   function with_positions(lexbuf){return lexbuf[12] !== dummy_pos ? 1 : 0;}
   function lexeme(lexbuf){
    var len = lexbuf[6] - lexbuf[5] | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], lexbuf[5], len);
   }
   function sub_lexeme(lexbuf, i1, i2){
    var len = i2 - i1 | 0;
    return caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len);
   }
   function sub_lexeme_opt(lexbuf, i1, i2){
    if(0 > i1) return 0;
    var len = i2 - i1 | 0;
    return [0, caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len)];
   }
   function sub_lexeme_char(lexbuf, i){return caml_bytes_get(lexbuf[2], i);}
   function sub_lexeme_char_opt(lexbuf, i){
    return 0 <= i ? [0, caml_bytes_get(lexbuf[2], i)] : 0;
   }
   function lexeme_char(lexbuf, i){
    return caml_bytes_get(lexbuf[2], lexbuf[5] + i | 0);
   }
   function lexeme_start(lexbuf){return lexbuf[11][4];}
   function lexeme_end(lexbuf){return lexbuf[12][4];}
   function lexeme_start_p(lexbuf){return lexbuf[11];}
   function lexeme_end_p(lexbuf){return lexbuf[12];}
   function new_line(lexbuf){
    var
     lcp = lexbuf[12],
     _a_ = lcp !== dummy_pos ? 1 : 0,
     _b_ =
       _a_
        ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0)
        : _a_;
    return _b_;
   }
   function flush_input(lb){
    lb[6] = 0;
    lb[4] = 0;
    var lcp = lb[12];
    if(lcp !== dummy_pos)
     lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
    lb[3] = 0;
    return 0;
   }
   var
    Stdlib_Lexing =
      [0,
       dummy_pos,
       from_channel,
       from_string,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
   runtime.caml_register_global(7, Stdlib_Lexing, "Stdlib__Lexing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Parsing
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Lexing, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    YYexit = [248, "Stdlib.Parsing.YYexit", caml_fresh_oo_id(0)],
    Parse_error = [248, "Stdlib.Parsing.Parse_error", caml_fresh_oo_id(0)],
    env =
      [0,
       caml_make_vect(100, 0),
       caml_make_vect(100, 0),
       caml_make_vect(100, Stdlib_Lexing[1]),
       caml_make_vect(100, Stdlib_Lexing[1]),
       100,
       0,
       0,
       0,
       Stdlib_Lexing[1],
       Stdlib_Lexing[1],
       0,
       0,
       0,
       0,
       0,
       0];
   function grow_stacks(param){
    var
     oldsize = env[5],
     newsize = oldsize * 2 | 0,
     new_s = caml_make_vect(newsize, 0),
     new_v = caml_make_vect(newsize, 0),
     new_start = caml_make_vect(newsize, Stdlib_Lexing[1]),
     new_end = caml_make_vect(newsize, Stdlib_Lexing[1]);
    caml_call5(Stdlib_Array[9], env[1], 0, new_s, 0, oldsize);
    env[1] = new_s;
    caml_call5(Stdlib_Array[9], env[2], 0, new_v, 0, oldsize);
    env[2] = new_v;
    caml_call5(Stdlib_Array[9], env[3], 0, new_start, 0, oldsize);
    env[3] = new_start;
    caml_call5(Stdlib_Array[9], env[4], 0, new_end, 0, oldsize);
    env[4] = new_end;
    env[5] = newsize;
    return;
   }
   function clear_parser(param){
    caml_call4(Stdlib_Array[8], env[2], 0, env[5], 0);
    env[8] = 0;
    return 0;
   }
   var
    current_lookahead_fun = [0, function(param){return 0;}],
    cst_syntax_error = "syntax error";
   function yyparse(tables, start, lexer, lexbuf){
    var
     init_asp = env[11],
     init_sp = env[14],
     init_stackbase = env[6],
     init_state = env[15],
     init_curr_char = env[7],
     init_lval = env[8],
     init_errflag = env[16];
    env[6] = env[14] + 1 | 0;
    env[7] = start;
    env[10] = lexbuf[12];
    try{
     var cmd = 0, arg = 0;
     for(;;)
      switch(runtime.caml_parse_engine(tables, env, cmd, arg)){
        case 0:
         var arg$0 = caml_call1(lexer, lexbuf);
         env[9] = lexbuf[11];
         env[10] = lexbuf[12];
         cmd = 1;
         arg = arg$0;
         break;
        case 1:
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        case 2:
         grow_stacks(0); cmd = 2; arg = 0; break;
        case 3:
         grow_stacks(0); cmd = 3; arg = 0; break;
        case 4:
         try{
          var
           _i_ = env[13],
           _j_ = caml_call1(caml_check_bound(tables[1], _i_)[1 + _i_], env),
           _k_ = 4,
           value = _j_,
           action = _k_;
         }
         catch(_m_){
          var _h_ = caml_wrap_exception(_m_);
          if(_h_ !== Parse_error) throw caml_maybe_attach_backtrace(_h_, 0);
          var value = 0, action = 5;
         }
         cmd = action;
         arg = value;
         break;
        default: caml_call1(tables[14], cst_syntax_error); cmd = 5; arg = 0;
      }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), curr_char = env[7];
     env[11] = init_asp;
     env[14] = init_sp;
     env[6] = init_stackbase;
     env[15] = init_state;
     env[7] = init_curr_char;
     env[8] = init_lval;
     env[16] = init_errflag;
     if(exn[1] === YYexit){var v = exn[2]; return v;}
     current_lookahead_fun[1] =
      function(tok){
       if(! caml_call1(Stdlib_Obj[1], tok))
        return caml_check_bound(tables[2], tok)[1 + tok] === curr_char ? 1 : 0;
       var _l_ = runtime.caml_obj_tag(tok);
       return caml_check_bound(tables[3], _l_)[1 + _l_] === curr_char ? 1 : 0;
      };
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function peek_val(env, n){
    var _g_ = env[11] - n | 0;
    return caml_check_bound(env[2], _g_)[1 + _g_];
   }
   function symbol_start_pos(param){
    var i$1 = env[12], i = i$1;
    for(;;){
     if(0 >= i){
      var _f_ = env[11];
      return caml_check_bound(env[4], _f_)[1 + _f_];
     }
     var
      _d_ = (env[11] - i | 0) + 1 | 0,
      st = caml_check_bound(env[3], _d_)[1 + _d_],
      _e_ = (env[11] - i | 0) + 1 | 0,
      en = caml_check_bound(env[4], _e_)[1 + _e_];
     if(runtime.caml_notequal(st, en)) return st;
     var i$0 = i - 1 | 0;
     i = i$0;
    }
   }
   function symbol_end_pos(param){
    var _c_ = env[11];
    return caml_check_bound(env[4], _c_)[1 + _c_];
   }
   function rhs_start_pos(n){
    var _b_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[3], _b_)[1 + _b_];
   }
   function rhs_end_pos(n){
    var _a_ = env[11] - (env[12] - n | 0) | 0;
    return caml_check_bound(env[4], _a_)[1 + _a_];
   }
   function symbol_start(param){return symbol_start_pos(0)[4];}
   function symbol_end(param){return symbol_end_pos(0)[4];}
   function rhs_start(n){return rhs_start_pos(n)[4];}
   function rhs_end(n){return rhs_end_pos(n)[4];}
   function is_current_lookahead(tok){
    return caml_call1(current_lookahead_fun[1], tok);
   }
   function parse_error(param){return 0;}
   var
    Stdlib_Parsing =
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       runtime.caml_set_parser_trace,
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
   runtime.caml_register_global(7, Stdlib_Parsing, "Stdlib__Parsing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Set
//# unitInfo: Requires: Stdlib, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Set_bal$3 = "Set.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    cst_Set_bal = cst_Set_bal$3,
    cst_Set_bal$0 = cst_Set_bal$3,
    cst_Set_bal$1 = cst_Set_bal$3,
    cst_Set_bal$2 = cst_Set_bal$3,
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, 0, 0],
    _c_ = [0, "set.ml", 571, 18],
    Stdlib_Set =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[4];
         return h;
        }
        function create(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         var _Y_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, v, r, _Y_];
        }
        function bal(l, v, r){
         if(l) var h = l[4], hl = h; else var hl = 0;
         if(r) var h$0 = r[4], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Set_bal$0);
          var lr = l[3], lv = l[2], ll = l[1], _T_ = height(lr);
          if(_T_ <= height(ll)) return create(ll, lv, create(lr, v, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Set_bal);
          var lrr = lr[3], lrv = lr[2], lrl = lr[1], _U_ = create(lrr, v, r);
          return create(create(ll, lv, lrl), lrv, _U_);
         }
         if((hl + 2 | 0) >= hr){
          var _X_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, v, r, _X_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Set_bal$2);
         var rr = r[3], rv = r[2], rl = r[1], _V_ = height(rl);
         if(_V_ <= height(rr)) return create(create(l, v, rl), rv, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Set_bal$1);
         var rlr = rl[3], rlv = rl[2], rll = rl[1], _W_ = create(rlr, rv, rr);
         return create(create(l, v, rll), rlv, _W_);
        }
        function add(x, t){
         if(! t) return [0, 0, x, 0, 1];
         var r = t[3], v = t[2], l = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c) return t;
         if(0 <= c){var rr = add(x, r); return r === rr ? t : bal(l, v, rr);}
         var ll = add(x, l);
         return l === ll ? t : bal(ll, v, r);
        }
        function singleton(x){return [0, 0, x, 0, 1];}
        function add_min_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(add_min_element(x, l), v, r);
        }
        function add_max_element(x, param){
         if(! param) return singleton(x);
         var r = param[3], v = param[2], l = param[1];
         return bal(l, v, add_max_element(x, r));
        }
        function join(l, v, r){
         if(! l) return add_min_element(v, r);
         if(! r) return add_max_element(v, l);
         var
          rh = r[4],
          rr = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[4],
          lr = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, join(lr, v, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, rl), rv, rr)
                   : create(l, v, r);
        }
        function min_elt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var v = param$0[2]; return v;}
          param$0 = l;
         }
        }
        function min_elt_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var v = param$0[2]; return [0, v];}
          param$0 = l;
         }
        }
        function max_elt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[3]){var v = param$0[2]; return v;}
          var r = param$0[3];
          param$0 = r;
         }
        }
        function max_elt_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[3]){var v = param$0[2]; return [0, v];}
          var r = param$0[3];
          param$0 = r;
         }
        }
        function remove_min_elt(param){
         if(! param) return caml_call1(Stdlib[1], cst_Set_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[3], v = param[2];
          return bal(remove_min_elt(l), v, r);
         }
         var r$0 = param[3];
         return r$0;
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var _S_ = remove_min_elt(t2);
         return join(t1, min_elt(t2), _S_);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, 1, r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, r)];
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _R_ = 0 === c ? 1 : 0;
          if(_R_) return _R_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function remove(x, t){
         if(! t) return 0;
         var t2 = t[3], v = t[2], t1 = t[1], c = caml_call2(Ord[1], x, v);
         if(0 === c){
          if(! t1) return t2;
          if(! t2) return t1;
          var _Q_ = remove_min_elt(t2);
          return bal(t1, min_elt(t2), _Q_);
         }
         if(0 <= c){
          var rr = remove(x, t2);
          return t2 === rr ? t : bal(t1, v, rr);
         }
         var ll = remove(x, t1);
         return t1 === ll ? t : bal(ll, v, t2);
        }
        function union(s1, s2){
         if(! s1) return s2;
         if(! s2) return s1;
         var
          h2 = s2[4],
          r2 = s2[3],
          v2 = s2[2],
          l2 = s2[1],
          h1 = s1[4],
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1];
         if(h2 <= h1){
          if(1 === h2) return add(v2, s1);
          var
           match = split(v1, s2),
           r2$0 = match[3],
           l2$0 = match[1],
           _O_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1, _O_);
         }
         if(1 === h1) return add(v1, s2);
         var
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _P_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2, _P_);
        }
        function inter(s1, s2){
         if(! s1) return 0;
         if(! s2) return 0;
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _L_ = split(v1, s2),
          l2 = _L_[1];
         if(_L_[2]){
          var r2 = _L_[3], _M_ = inter(r1, r2);
          return join(inter(l1, l2), v1, _M_);
         }
         var r2$0 = _L_[3], _N_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _N_);
        }
        function split_bis(x, param){
         if(! param) return [0, 0, function(param){return 0;}];
         var
          r = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return 0;
         if(0 <= c){
          var match = split_bis(x, r);
          if(! match) return 0;
          var rr = match[2], lr = match[1];
          return [0, join(l, v, lr), rr];
         }
         var match$0 = split_bis(x, l);
         if(! match$0) return 0;
         var rl = match$0[2], ll = match$0[1];
         return [0, ll, function(param){return join(rl(0), v, r);}];
        }
        function disjoint(s1, s2){
         var s1$0 = s1, s2$0 = s2;
         for(;;){
          if(s1$0 && s2$0){
           var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
           if(s1$0 === s2$0) return 0;
           var match = split_bis(v1, s2$0);
           if(! match) return 0;
           var r2 = match[2], l2 = match[1], _K_ = disjoint(l1, l2);
           if(! _K_) return _K_;
           var s2$1 = r2(0);
           s1$0 = r1;
           s2$0 = s2$1;
           continue;
          }
          return 1;
         }
        }
        function diff(s1, s2){
         if(! s1) return 0;
         if(! s2) return s1;
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _H_ = split(v1, s2),
          l2 = _H_[1];
         if(_H_[2]){
          var r2 = _H_[3], _I_ = diff(r1, r2);
          return concat(diff(l1, l2), _I_);
         }
         var r2$0 = _H_[3], _J_ = diff(r1, r2$0);
         return join(diff(l1, l2), v1, _J_);
        }
        function cons_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var r = s$0[3], v = s$0[2], l = s$0[1], e$1 = [0, v, r, e$0];
          s$0 = l;
          e$0 = e$1;
         }
        }
        function compare(s1, s2){
         var
          e2$2 = cons_enum(s2, 0),
          e1$2 = cons_enum(s1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[3],
           r2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[3],
           r1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(s1, s2){return 0 === compare(s1, s2) ? 1 : 0;}
        function subset(s1, s2){
         var s1$0 = s1, s2$0 = s2;
         for(;;){
          if(! s1$0) return 1;
          if(! s2$0) return 0;
          var
           r2 = s2$0[3],
           v2 = s2$0[2],
           l2 = s2$0[1],
           r1 = s1$0[3],
           v1 = s1$0[2],
           l1 = s1$0[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 === c){
           var _E_ = subset(l1, l2);
           if(! _E_) return _E_;
           s1$0 = r1;
           s2$0 = r2;
          }
          else if(0 <= c){
           var _F_ = subset([0, 0, v1, r1, 0], r2);
           if(! _F_) return _F_;
           s1$0 = l1;
          }
          else{
           var _G_ = subset([0, l1, v1, 0, 0], l2);
           if(! _G_) return _G_;
           s1$0 = r1;
          }
         }
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call1(f, v);
          param$0 = r;
         }
        }
        function fold(f, s, accu){
         var s$0 = s, accu$0 = accu;
         for(;;){
          if(! s$0) return accu$0;
          var
           r = s$0[3],
           v = s$0[2],
           l = s$0[1],
           accu$1 = caml_call2(f, v, fold(f, l, accu$0));
          s$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call1(p, v);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call1(p, v);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function filter(p, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = filter(p, l),
          pv = caml_call1(p, v),
          r$0 = filter(p, r);
         if(! pv) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return t;
         return join(l$0, v, r$0);
        }
        function partition(p, param){
         if(! param) return _b_;
         var
          r = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pv = caml_call1(p, v),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pv){var _w_ = concat(lf, rf); return [0, join(lt, v, rt), _w_];}
         var _x_ = join(lf, v, rf);
         return [0, concat(lt, rt), _x_];
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[3], l = param[1], _v_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _v_ | 0;
        }
        function elements_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, v, elements_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function elements(s){return elements_aux(0, s);}
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return v;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = l$0;
           for(;;){
            if(! param) return v0;
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){v0 = v0$0; param = l;} else param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0];
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){v0 = v0$0; param = l;} else param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = r$0;
           for(;;){
            if(! param) return v0;
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){v0 = v0$0; param = r;} else param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var r$0 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0];
            var r = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){v0 = v0$0; param = r;} else param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, v];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function try_join(l, v, r){
         a:
         {
          if(0 !== l){
           var _u_ = max_elt(l);
           if(0 <= caml_call2(Ord[1], _u_, v)) break a;
          }
          if(0 !== r){
           var _t_ = min_elt(r);
           if(0 <= caml_call2(Ord[1], v, _t_)) break a;
          }
          return join(l, v, r);
         }
         return union(l, add(v, r));
        }
        function map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          l$0 = map(f, l),
          v$0 = caml_call1(f, v),
          r$0 = map(f, r);
         if(l === l$0 && v === v$0 && r === r$0) return t;
         return try_join(l$0, v$0, r$0);
        }
        function filter_map(f, t){
         if(! t) return 0;
         var
          r = t[3],
          v = t[2],
          l = t[1],
          t1 = filter_map(f, l),
          v$0 = caml_call1(f, v),
          t2 = filter_map(f, r);
         if(v$0){
          var v$1 = v$0[1];
          if(l === t1 && v === v$1 && r === t2) return t;
          return try_join(t1, v$1, t2);
         }
         if(! t1) return t2;
         if(! t2) return t1;
         var _s_ = remove_min_elt(t2);
         return try_join(t1, min_elt(t2), _s_);
        }
        function of_list(l){
         if(! l) return empty;
         var _n_ = l[2], x0 = l[1];
         if(! _n_) return singleton(x0);
         var _o_ = _n_[2], x1 = _n_[1];
         if(! _o_) return add(x1, singleton(x0));
         var _p_ = _o_[2], x2 = _o_[1];
         if(! _p_) return add(x2, add(x1, singleton(x0)));
         var _q_ = _p_[2], x3 = _p_[1];
         if(! _q_) return add(x3, add(x2, add(x1, singleton(x0))));
         if(_q_[2]){
          var
           l$0 = caml_call2(Stdlib_List[62], Ord[1], l),
           sub =
             function(n, l){
              if(3 >= n >>> 0)
               switch(n){
                 case 0:
                  return [0, 0, l];
                 case 1:
                  if(l){
                   var l$3 = l[2], x0 = l[1];
                   return [0, [0, 0, x0, 0, 1], l$3];
                  }
                  break;
                 case 2:
                  if(l){
                   var match$1 = l[2];
                   if(match$1){
                    var l$4 = match$1[2], x1 = match$1[1], x0$0 = l[1];
                    return [0, [0, [0, 0, x0$0, 0, 1], x1, 0, 2], l$4];
                   }
                  }
                  break;
                 default:
                  if(l){
                   var _r_ = l[2];
                   if(_r_){
                    var match$2 = _r_[2];
                    if(match$2){
                     var
                      l$5 = match$2[2],
                      x2 = match$2[1],
                      x1$0 = _r_[1],
                      x0$1 = l[1];
                     return [0,
                             [0, [0, 0, x0$1, 0, 1], x1$0, [0, 0, x2, 0, 1], 2],
                             l$5];
                    }
                   }
                  }
               }
              var
               nl = n / 2 | 0,
               match = sub(nl, l),
               l$0 = match[2],
               left = match[1];
              if(! l$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
              var
               l$1 = l$0[2],
               mid = l$0[1],
               match$0 = sub((n - nl | 0) - 1 | 0, l$1),
               l$2 = match$0[2],
               right = match$0[1];
              return [0, create(left, mid, right), l$2];
             };
          return sub(caml_call1(Stdlib_List[1], l$0), l$0)[1];
         }
         var x4 = _q_[1];
         return add(x4, add(x3, add(x2, add(x1, singleton(x0)))));
        }
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5], function(s, x){return add(x, s);}, m, i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], _l_ = cons_enum(t, rest);
         return [0, x, function(_m_){return seq_of_enum(_l_, _m_);}];
        }
        function to_seq(c){
         var _j_ = cons_enum(c, 0);
         return function(_k_){return seq_of_enum(_j_, _k_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var r = s$0[3], v = s$0[2], l = s$0[1], e$1 = [0, v, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var rest = c[3], t = c[2], x = c[1], _h_ = snoc_enum(t, rest);
         return [0, x, function(_i_){return rev_seq_of_enum(_h_, _i_);}];
        }
        function to_rev_seq(c){
         var _f_ = snoc_enum(c, 0);
         return function(_g_){return rev_seq_of_enum(_f_, _g_);};
        }
        function to_seq_from(low, s){
         a:
         {
          b:
          {
           var s$0 = s, c = 0;
           for(;;){
            if(! s$0) break;
            var
             r = s$0[3],
             v = s$0[2],
             l = s$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, r, c];
             s$0 = l;
             c = c$0;
            }
            else
             s$0 = r;
           }
           var _d_ = c;
           break a;
          }
          var _d_ = [0, v, r, c];
         }
         return function(_e_){return seq_of_enum(_d_, _e_);};
        }
        return [0,
                empty,
                add,
                singleton,
                remove,
                union,
                inter,
                disjoint,
                diff,
                cardinal,
                elements,
                min_elt,
                min_elt_opt,
                max_elt,
                max_elt_opt,
                min_elt,
                min_elt_opt,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                iter,
                fold,
                map,
                filter,
                filter_map,
                partition,
                split,
                is_empty,
                mem,
                equal,
                compare,
                subset,
                for_all,
                exists,
                elements,
                of_list,
                to_seq_from,
                to_seq,
                to_rev_seq,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Set, "Stdlib__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Map
//# unitInfo: Requires: Stdlib, Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    cst_Map_bal = cst_Map_bal$3,
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _a_ = [0, 0, 0, 0],
    _b_ = [0, "map.ml", 408, 10],
    _c_ = [0, 0, 0],
    Stdlib_Map =
      [0,
       function(Ord){
        function height(param){
         if(! param) return 0;
         var h = param[5];
         return h;
        }
        function create(l, x, d, r){
         var
          hl = height(l),
          hr = height(r),
          _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
         return [0, l, x, d, r, _K_];
        }
        function singleton(x, d){return [0, 0, x, d, 0, 1];}
        function bal(l, x, d, r){
         if(l) var h = l[5], hl = h; else var hl = 0;
         if(r) var h$0 = r[5], hr = h$0; else var hr = 0;
         if((hr + 2 | 0) < hl){
          if(! l) return caml_call1(Stdlib[1], cst_Map_bal$0);
          var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
          if(_F_ <= height(ll))
           return create(ll, lv, ld, create(lr, x, d, r));
          if(! lr) return caml_call1(Stdlib[1], cst_Map_bal);
          var
           lrr = lr[4],
           lrd = lr[3],
           lrv = lr[2],
           lrl = lr[1],
           _G_ = create(lrr, x, d, r);
          return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
         }
         if((hl + 2 | 0) >= hr){
          var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
          return [0, l, x, d, r, _J_];
         }
         if(! r) return caml_call1(Stdlib[1], cst_Map_bal$2);
         var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
         if(_H_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
         if(! rl) return caml_call1(Stdlib[1], cst_Map_bal$1);
         var
          rlr = rl[4],
          rld = rl[3],
          rlv = rl[2],
          rll = rl[1],
          _I_ = create(rlr, rv, rd, rr);
         return create(create(l, x, d, rll), rlv, rld, _I_);
        }
        var empty = 0;
        function is_empty(param){return param ? 0 : 1;}
        function add(x, data, m){
         if(! m) return [0, 0, x, data, 0, 1];
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return d === data ? m : [0, l, x, data, r, h];
         if(0 <= c){
          var rr = add(x, data, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = add(x, data, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function find(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return d;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function find_first(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_first_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = l$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = l;
            }
            else
             param = r;
           }
          }
          else
           param$1 = r$0;
         }
        }
        function find_last(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, v0, d0];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_last_opt(f, param$0){
         var param$1 = param$0;
         for(;;){
          if(! param$1) return 0;
          var
           r$0 = param$1[4],
           d0$1 = param$1[3],
           v0$1 = param$1[2],
           l$0 = param$1[1];
          if(caml_call1(f, v0$1)){
           var v0 = v0$1, d0 = d0$1, param = r$0;
           for(;;){
            if(! param) return [0, [0, v0, d0]];
            var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
            if(caml_call1(f, v0$0)){
             v0 = v0$0;
             d0 = d0$0;
             param = r;
            }
            else
             param = l;
           }
          }
          else
           param$1 = l$0;
         }
        }
        function find_opt(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v);
          if(0 === c) return [0, d];
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function mem(x, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           v = param$0[2],
           l = param$0[1],
           c = caml_call2(Ord[1], x, v),
           _E_ = 0 === c ? 1 : 0;
          if(_E_) return _E_;
          var r$0 = 0 <= c ? r : l;
          param$0 = r$0;
         }
        }
        function min_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, v, d];}
          param$0 = l;
         }
        }
        function min_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var l = param$0[1];
          if(! l){var d = param$0[3], v = param$0[2]; return [0, [0, v, d]];}
          param$0 = l;
         }
        }
        function max_binding(param){
         var param$0 = param;
         for(;;){
          if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, v, d];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function max_binding_opt(param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          if(! param$0[4]){
           var d = param$0[3], v = param$0[2];
           return [0, [0, v, d]];
          }
          var r = param$0[4];
          param$0 = r;
         }
        }
        function remove_min_binding(param){
         if(! param) return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
         var l = param[1];
         if(l){
          var r = param[4], d = param[3], v = param[2];
          return bal(remove_min_binding(l), v, d, r);
         }
         var r$0 = param[4];
         return r$0;
        }
        function _d_(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return bal(t1, x, d, remove_min_binding(t2));
        }
        function remove(x, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return _d_(l, r);
         if(0 <= c){
          var rr = remove(x, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = remove(x, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function update(x, f, m){
         if(! m){
          var match$0 = caml_call1(f, 0);
          if(! match$0) return 0;
          var data$0 = match$0[1];
          return [0, 0, x, data$0, 0, 1];
         }
         var
          h = m[5],
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c){
          var match = caml_call1(f, [0, d]);
          if(! match) return _d_(l, r);
          var data = match[1];
          return d === data ? m : [0, l, x, data, r, h];
         }
         if(0 <= c){
          var rr = update(x, f, r);
          return r === rr ? m : bal(l, v, d, rr);
         }
         var ll = update(x, f, l);
         return l === ll ? m : bal(ll, v, d, r);
        }
        function add_to_list(x, data, m){
         function add(param){
          if(! param) return [0, [0, data, 0]];
          var l = param[1];
          return [0, [0, data, l]];
         }
         return update(x, add, m);
        }
        function iter(f, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
          iter(f, l);
          caml_call2(f, v, d);
          param$0 = r;
         }
        }
        function map(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = map(f, l),
          d$0 = caml_call1(f, d),
          r$0 = map(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function mapi(f, param){
         if(! param) return 0;
         var
          h = param[5],
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = mapi(f, l),
          d$0 = caml_call2(f, v, d),
          r$0 = mapi(f, r);
         return [0, l$0, v, d$0, r$0, h];
        }
        function fold(f, m, accu){
         var m$0 = m, accu$0 = accu;
         for(;;){
          if(! m$0) return accu$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           accu$1 = caml_call3(f, v, d, fold(f, l, accu$0));
          m$0 = r;
          accu$0 = accu$1;
         }
        }
        function for_all(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 1;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _B_ = caml_call2(p, v, d);
          if(_B_){
           var _C_ = for_all(p, l);
           if(_C_){param$0 = r; continue;}
           var _D_ = _C_;
          }
          else
           var _D_ = _B_;
          return _D_;
         }
        }
        function exists(p, param){
         var param$0 = param;
         for(;;){
          if(! param$0) return 0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           _y_ = caml_call2(p, v, d);
          if(_y_)
           var _z_ = _y_;
          else{
           var _A_ = exists(p, l);
           if(! _A_){param$0 = r; continue;}
           var _z_ = _A_;
          }
          return _z_;
         }
        }
        function add_min_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(add_min_binding(k, x, l), v, d, r);
        }
        function add_max_binding(k, x, param){
         if(! param) return singleton(k, x);
         var r = param[4], d = param[3], v = param[2], l = param[1];
         return bal(l, v, d, add_max_binding(k, x, r));
        }
        function join(l, v, d, r){
         if(! l) return add_min_binding(v, d, r);
         if(! r) return add_max_binding(v, d, l);
         var
          rh = r[5],
          rr = r[4],
          rd = r[3],
          rv = r[2],
          rl = r[1],
          lh = l[5],
          lr = l[4],
          ld = l[3],
          lv = l[2],
          ll = l[1];
         return (rh + 2 | 0) < lh
                 ? bal(ll, lv, ld, join(lr, v, d, r))
                 : (lh
                   + 2
                   | 0)
                   < rh
                   ? bal(join(l, v, d, rl), rv, rd, rr)
                   : create(l, v, d, r);
        }
        function concat(t1, t2){
         if(! t1) return t2;
         if(! t2) return t1;
         var match = min_binding(t2), d = match[2], x = match[1];
         return join(t1, x, d, remove_min_binding(t2));
        }
        function concat_or_join(t1, v, d, t2){
         if(! d) return concat(t1, t2);
         var d$0 = d[1];
         return join(t1, v, d$0, t2);
        }
        function split(x, param){
         if(! param) return _a_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          c = caml_call2(Ord[1], x, v);
         if(0 === c) return [0, l, [0, d], r];
         if(0 <= c){
          var
           match = split(x, r),
           rr = match[3],
           pres = match[2],
           lr = match[1];
          return [0, join(l, v, d, lr), pres, rr];
         }
         var
          match$0 = split(x, l),
          rl = match$0[3],
          pres$0 = match$0[2],
          ll = match$0[1];
         return [0, ll, pres$0, join(rl, v, d, r)];
        }
        function merge(f, s1, s2){
         if(s1){
          var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
          if(height(s2) <= h1){
           var
            match = split(v1, s2),
            r2 = match[3],
            d2 = match[2],
            l2 = match[1],
            _u_ = merge(f, r1, r2),
            _v_ = caml_call3(f, v1, [0, d1], d2);
           return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
          }
         }
         else if(! s2) return 0;
         if(! s2)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         var
          r2$0 = s2[4],
          d2$0 = s2[3],
          v2 = s2[2],
          l2$0 = s2[1],
          match$0 = split(v2, s1),
          r1$0 = match$0[3],
          d1$0 = match$0[2],
          l1$0 = match$0[1],
          _w_ = merge(f, r1$0, r2$0),
          _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
         return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
        }
        function union(f, s1, s2){
         if(s1){
          if(s2){
           var
            h2 = s2[5],
            r2 = s2[4],
            d2 = s2[3],
            v2 = s2[2],
            l2 = s2[1],
            h1 = s1[5],
            r1 = s1[4],
            d1 = s1[3],
            v1 = s1[2],
            l1 = s1[1];
           if(h2 <= h1){
            var
             match = split(v1, s2),
             r2$0 = match[3],
             d2$0 = match[2],
             l2$0 = match[1],
             l = union(f, l1, l2$0),
             r = union(f, r1, r2$0);
            if(! d2$0) return join(l, v1, d1, r);
            var d2$1 = d2$0[1];
            return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
           }
           var
            match$0 = split(v2, s1),
            r1$0 = match$0[3],
            d1$0 = match$0[2],
            l1$0 = match$0[1],
            l$0 = union(f, l1$0, l2),
            r$0 = union(f, r1$0, r2);
           if(! d1$0) return join(l$0, v2, d2, r$0);
           var d1$1 = d1$0[1];
           return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
          }
          var s = s1;
         }
         else
          var s = s2;
         return s;
        }
        function filter(p, m){
         if(! m) return 0;
         var
          r = m[4],
          d = m[3],
          v = m[2],
          l = m[1],
          l$0 = filter(p, l),
          pvd = caml_call2(p, v, d),
          r$0 = filter(p, r);
         if(! pvd) return concat(l$0, r$0);
         if(l === l$0 && r === r$0) return m;
         return join(l$0, v, d, r$0);
        }
        function filter_map(f, param){
         if(! param) return 0;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          l$0 = filter_map(f, l),
          fvd = caml_call2(f, v, d),
          r$0 = filter_map(f, r);
         if(! fvd) return concat(l$0, r$0);
         var d$0 = fvd[1];
         return join(l$0, v, d$0, r$0);
        }
        function partition(p, param){
         if(! param) return _c_;
         var
          r = param[4],
          d = param[3],
          v = param[2],
          l = param[1],
          match = partition(p, l),
          lf = match[2],
          lt = match[1],
          pvd = caml_call2(p, v, d),
          match$0 = partition(p, r),
          rf = match$0[2],
          rt = match$0[1];
         if(pvd){
          var _s_ = concat(lf, rf);
          return [0, join(lt, v, d, rt), _s_];
         }
         var _t_ = join(lf, v, d, rf);
         return [0, concat(lt, rt), _t_];
        }
        function cons_enum(m, e){
         var m$0 = m, e$0 = e;
         for(;;){
          if(! m$0) return e$0;
          var
           r = m$0[4],
           d = m$0[3],
           v = m$0[2],
           l = m$0[1],
           e$1 = [0, v, d, r, e$0];
          m$0 = l;
          e$0 = e$1;
         }
        }
        function compare(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? -1 : 0;
          if(! e2) return 1;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           c = caml_call2(Ord[1], v1, v2);
          if(0 !== c) return c;
          var c$0 = caml_call2(cmp, d1, d2);
          if(0 !== c$0) return c$0;
          var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
          e1 = e1$1;
          e2 = e2$1;
         }
        }
        function equal(cmp, m1, m2){
         var
          e2$2 = cons_enum(m2, 0),
          e1$2 = cons_enum(m1, 0),
          e1 = e1$2,
          e2 = e2$2;
         for(;;){
          if(! e1) return e2 ? 0 : 1;
          if(! e2) return 0;
          var
           e2$0 = e2[4],
           r2 = e2[3],
           d2 = e2[2],
           v2 = e2[1],
           e1$0 = e1[4],
           r1 = e1[3],
           d1 = e1[2],
           v1 = e1[1],
           _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
          if(_p_){
           var _q_ = caml_call2(cmp, d1, d2);
           if(_q_){
            var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0);
            e1 = e1$1;
            e2 = e2$1;
            continue;
           }
           var _r_ = _q_;
          }
          else
           var _r_ = _p_;
          return _r_;
         }
        }
        function cardinal(param){
         if(! param) return 0;
         var r = param[4], l = param[1], _o_ = cardinal(r);
         return (cardinal(l) + 1 | 0) + _o_ | 0;
        }
        function bindings_aux(accu, param){
         var accu$0 = accu, param$0 = param;
         for(;;){
          if(! param$0) return accu$0;
          var
           r = param$0[4],
           d = param$0[3],
           v = param$0[2],
           l = param$0[1],
           accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)];
          accu$0 = accu$1;
          param$0 = l;
         }
        }
        function bindings(s){return bindings_aux(0, s);}
        function of_list(bs){
         return caml_call3
                 (Stdlib_List[26],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  empty,
                  bs);
        }
        function add_seq(i, m){
         return caml_call3
                 (Stdlib_Seq[5],
                  function(m, param){
                   var v = param[2], k = param[1];
                   return add(k, v, m);
                  },
                  m,
                  i);
        }
        function of_seq(i){return add_seq(i, empty);}
        function seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _m_ = cons_enum(t, rest);
         return [0, [0, k, v], function(_n_){return seq_of_enum(_m_, _n_);}];
        }
        function to_seq(m){
         var _k_ = cons_enum(m, 0);
         return function(_l_){return seq_of_enum(_k_, _l_);};
        }
        function snoc_enum(s, e){
         var s$0 = s, e$0 = e;
         for(;;){
          if(! s$0) return e$0;
          var
           r = s$0[4],
           d = s$0[3],
           v = s$0[2],
           l = s$0[1],
           e$1 = [0, v, d, l, e$0];
          s$0 = r;
          e$0 = e$1;
         }
        }
        function rev_seq_of_enum(c, param){
         if(! c) return 0;
         var
          rest = c[4],
          t = c[3],
          v = c[2],
          k = c[1],
          _i_ = snoc_enum(t, rest);
         return [0,
                 [0, k, v],
                 function(_j_){return rev_seq_of_enum(_i_, _j_);}];
        }
        function to_rev_seq(c){
         var _g_ = snoc_enum(c, 0);
         return function(_h_){return rev_seq_of_enum(_g_, _h_);};
        }
        function to_seq_from(low, m){
         a:
         {
          b:
          {
           var m$0 = m, c = 0;
           for(;;){
            if(! m$0) break;
            var
             r = m$0[4],
             d = m$0[3],
             v = m$0[2],
             l = m$0[1],
             n = caml_call2(Ord[1], v, low);
            if(0 === n) break b;
            if(0 <= n){
             var c$0 = [0, v, d, r, c];
             m$0 = l;
             c = c$0;
            }
            else
             m$0 = r;
           }
           var _e_ = c;
           break a;
          }
          var _e_ = [0, v, d, r, c];
         }
         return function(_f_){return seq_of_enum(_e_, _f_);};
        }
        return [0,
                empty,
                add,
                add_to_list,
                update,
                singleton,
                remove,
                merge,
                union,
                cardinal,
                bindings,
                min_binding,
                min_binding_opt,
                max_binding,
                max_binding_opt,
                min_binding,
                min_binding_opt,
                find,
                find_opt,
                find_first,
                find_first_opt,
                find_last,
                find_last_opt,
                iter,
                fold,
                map,
                mapi,
                filter,
                filter_map,
                partition,
                split,
                is_empty,
                mem,
                equal,
                compare,
                for_all,
                exists,
                bindings,
                of_list,
                to_seq,
                to_rev_seq,
                to_seq_from,
                add_seq,
                of_seq];
       }];
   runtime.caml_register_global(12, Stdlib_Map, "Stdlib__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Stack
//# unitInfo: Requires: Stdlib__List, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_List = global_data.Stdlib__List,
    Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0];}
   function clear(s){s[1] = 0; s[2] = 0; return 0;}
   function copy(s){return [0, s[1], s[2]];}
   function push(x, s){s[1] = [0, x, s[1]]; s[2] = s[2] + 1 | 0; return 0;}
   function pop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return hd;
   }
   function pop_opt(s){
    var match = s[1];
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return [0, hd];
   }
   function drop(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var tl = match[2];
    s[1] = tl;
    s[2] = s[2] - 1 | 0;
    return 0;
   }
   function top(s){
    var match = s[1];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var hd = match[1];
    return hd;
   }
   function top_opt(s){
    var match = s[1];
    if(! match) return 0;
    var hd = match[1];
    return [0, hd];
   }
   function is_empty(s){return 0 === s[1] ? 1 : 0;}
   function length(s){return s[2];}
   function iter(f, s){return caml_call2(Stdlib_List[18], f, s[1]);}
   function fold(f, acc, s){return caml_call3(Stdlib_List[26], f, acc, s[1]);}
   function to_seq(s){return caml_call1(Stdlib_List[64], s[1]);}
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return push(x, q);}, i);
   }
   function of_seq(g){var s = create(0); add_seq(s, g); return s;}
   var
    Stdlib_Stack =
      [0,
       Empty,
       create,
       push,
       pop,
       pop_opt,
       drop,
       top,
       top_opt,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Queue
//# unitInfo: Requires: Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Seq = global_data.Stdlib__Seq,
    Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, 0, 0, 0];}
   function clear(q){q[1] = 0; q[2] = 0; q[3] = 0; return 0;}
   function add(x, q){
    var cell = [0, x, 0], match = q[3];
    return match
            ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0)
            : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
   }
   function peek(q){
    var match = q[2];
    if(! match) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = match[1];
    return content;
   }
   function peek_opt(q){
    var match = q[2];
    if(! match) return 0;
    var content = match[1];
    return [0, content];
   }
   function take(q){
    var _f_ = q[2];
    if(! _f_) throw caml_maybe_attach_backtrace(Empty, 1);
    var content = _f_[1];
    if(_f_[2]){
     var next = _f_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return content;
    }
    clear(q);
    return content;
   }
   function take_opt(q){
    var _e_ = q[2];
    if(! _e_) return 0;
    var content = _e_[1];
    if(_e_[2]){
     var next = _e_[2];
     q[1] = q[1] - 1 | 0;
     q[2] = next;
     return [0, content];
    }
    clear(q);
    return [0, content];
   }
   function copy(q){
    var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
    for(;;){
     if(! cell){q_res[3] = prev; return q_res;}
     var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
     if(prev) prev[2] = prev$0; else q_res[2] = prev$0;
     prev = prev$0;
     cell = next;
    }
   }
   function is_empty(q){return 0 === q[1] ? 1 : 0;}
   function length(q){return q[1];}
   function iter(f, q){
    var cell$0 = q[2], cell = cell$0;
    for(;;){
     if(! cell) return 0;
     var content = cell[1], next = cell[2];
     caml_call1(f, content);
     cell = next;
    }
   }
   function fold(f, accu$1, q){
    var cell$0 = q[2], accu = accu$1, cell = cell$0;
    for(;;){
     if(! cell) return accu;
     var
      content = cell[1],
      next = cell[2],
      accu$0 = caml_call2(f, accu, content);
     accu = accu$0;
     cell = next;
    }
   }
   function transfer(q1, q2){
    var _d_ = 0 < q1[1] ? 1 : 0;
    if(! _d_) return _d_;
    var match = q2[3];
    return match
            ? (q2
               [1]
              = q2[1] + q1[1] | 0,
              match[2] = q1[2],
              q2[3] = q1[3],
              clear(q1))
            : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
   }
   function to_seq(q){
    function aux(c, param){
     if(! c) return 0;
     var x = c[1], next = c[2];
     return [0, x, function(_c_){return aux(next, _c_);}];
    }
    var _a_ = q[2];
    return function(_b_){return aux(_a_, _b_);};
   }
   function add_seq(q, i){
    return caml_call2(Stdlib_Seq[4], function(x){return add(x, q);}, i);
   }
   function of_seq(g){var q = create(0); add_seq(q, g); return q;}
   var
    Stdlib_Queue =
      [0,
       Empty,
       create,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear,
       copy,
       is_empty,
       length,
       iter,
       fold,
       transfer,
       to_seq,
       add_seq,
       of_seq];
   runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Buffer
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Seq, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_blit_string = runtime.caml_blit_string,
    caml_bswap16 = runtime.caml_bswap16,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_bytes_set32 = runtime.caml_bytes_set32,
    caml_bytes_set64 = runtime.caml_bytes_set64,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    cst_Buffer_sub = "Buffer.sub",
    cst_Buffer_blit = "Buffer.blit",
    cst_Buffer_nth = "Buffer.nth",
    cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer";
   function create(n){
    var
     n$0 = 1 <= n ? n : 1,
     n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0,
     s = caml_create_bytes(n$1);
    return [0, [0, s, n$1], 0, s];
   }
   function contents(b){return caml_call3(Stdlib_Bytes[8], b[1][1], 0, b[2]);}
   function to_bytes(b){return caml_call3(Stdlib_Bytes[7], b[1][1], 0, b[2]);}
   function sub(b, ofs, len){
    if(0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
     return caml_call3(Stdlib_Bytes[8], b[1][1], ofs, len);
    return caml_call1(Stdlib[1], cst_Buffer_sub);
   }
   function blit(src, srcoff, dst, dstoff, len){
    if
     (0 <= len
      &&
       0 <= srcoff
       &&
        (src[2] - len | 0) >= srcoff
        && 0 <= dstoff && (caml_ml_bytes_length(dst) - len | 0) >= dstoff)
     return caml_call5(Stdlib_Bytes[11], src[1][1], srcoff, dst, dstoff, len);
    return caml_call1(Stdlib[1], cst_Buffer_blit);
   }
   function nth(b, ofs){
    var position = b[2], match = b[1], length = match[2], buffer = match[1];
    if(0 <= ofs && position > ofs && length >= position)
     return runtime.caml_bytes_unsafe_get(buffer, ofs);
    return caml_call1(Stdlib[1], cst_Buffer_nth);
   }
   function length(b){return b[2];}
   function clear(b){b[2] = 0; return 0;}
   function reset(b){
    b[2] = 0;
    var inner = [0, b[3], caml_ml_bytes_length(b[3])];
    b[1] = inner;
    return 0;
   }
   function resize(b, more){
    var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
    for(;;){
     if(new_len[1] >= (old_pos + more | 0)) break;
     new_len[1] = 2 * new_len[1] | 0;
    }
    if(Stdlib_Sys[12] < new_len[1])
     if((old_pos + more | 0) <= Stdlib_Sys[12])
      new_len[1] = Stdlib_Sys[12];
     else
      caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
    var new_buffer = caml_create_bytes(new_len[1]);
    caml_call5(Stdlib_Bytes[11], b[1][1], 0, new_buffer, 0, b[2]);
    b[1] = [0, new_buffer, new_len[1]];
    return;
   }
   function add_char(b, c){
    var pos = b[2], match = b[1], length = match[2], buffer = match[1];
    if(length <= pos){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], c);
    }
    else
     caml_bytes_unsafe_set(buffer, pos, c);
    b[2] = pos + 1 | 0;
    return 0;
   }
   var
    uchar_utf_8_byte_length_max = 4,
    uchar_utf_16_byte_length_max = 4,
    cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes",
    cst_Buffer_add_channel = "Buffer.add_channel",
    _a_ = [0, "buffer.ml", 220, 9],
    cst_Buffer_truncate = "Buffer.truncate";
   function add_utf_8_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_8_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[51], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_8_byte_length_max);
    }
   }
   function add_utf_16be_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[54], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_utf_16le_uchar(b, u){
    for(;;){
     var pos = b[2];
     if(b[1][2] <= pos) resize(b, uchar_utf_16_byte_length_max);
     var n = caml_call3(Stdlib_Bytes[57], b[1][1], pos, u);
     if(0 !== n){b[2] = pos + n | 0; return 0;}
     resize(b, uchar_utf_16_byte_length_max);
    }
   }
   function add_substring(b, s, offset, len){
    var _s_ = offset < 0 ? 1 : 0;
    if(_s_)
     var _t_ = _s_;
    else
     var
      _u_ = len < 0 ? 1 : 0,
      _t_ = _u_ || ((caml_ml_string_length(s) - len | 0) < offset ? 1 : 0);
    if(_t_) caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, offset, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, offset, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_subbytes(b, s, offset, len){
    return add_substring(b, caml_call1(Stdlib_Bytes[44], s), offset, len);
   }
   function add_string(b, s){
    var
     len = caml_ml_string_length(s),
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + len | 0;
    if(length < new_position){
     resize(b, len);
     caml_call5(Stdlib_Bytes[12], s, 0, b[1][1], b[2], len);
    }
    else
     caml_blit_string(s, 0, buffer, position, len);
    b[2] = new_position;
    return 0;
   }
   function add_bytes(b, s){
    return add_string(b, caml_call1(Stdlib_Bytes[44], s));
   }
   function add_buffer(b, bs){return add_subbytes(b, bs[1][1], 0, bs[2]);}
   function add_channel(b, ic, to_read$1){
    var
     _q_ = to_read$1 < 0 ? 1 : 0,
     _r_ = _q_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
    if(_r_) caml_call1(Stdlib[1], cst_Buffer_add_channel);
    if(b[1][2] < (b[2] + to_read$1 | 0)) resize(b, to_read$1);
    var
     ofs$1 = b[2],
     buf = b[1][1],
     already_read = 0,
     ofs = ofs$1,
     to_read = to_read$1;
    for(;;){
     if(0 !== to_read){
      var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
      if(0 !== r){
       var
        already_read$0 = already_read + r | 0,
        ofs$0 = ofs + r | 0,
        to_read$0 = to_read - r | 0;
       already_read = already_read$0;
       ofs = ofs$0;
       to_read = to_read$0;
       continue;
      }
     }
     b[2] = b[2] + already_read | 0;
     if(already_read < to_read$1)
      throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     return 0;
    }
   }
   function output_buffer(oc, b){
    return caml_call4(Stdlib[68], oc, b[1][1], 0, b[2]);
   }
   function add_substitute(b, f, s){
    var lim$1 = caml_ml_string_length(s), previous = 32, i$4 = 0;
    for(;;){
     if(i$4 >= lim$1){
      var _o_ = 92 === previous ? 1 : 0;
      return _o_ ? add_char(b, previous) : _o_;
     }
     var previous$0 = caml_string_get(s, i$4);
     if(36 === previous$0)
      if(92 === previous){
       add_char(b, previous$0);
       var i$5 = i$4 + 1 | 0;
       previous = 32;
       i$4 = i$5;
      }
      else{
       var start = i$4 + 1 | 0;
       try{
        if(lim$1 <= start) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
        var opening = caml_string_get(s, start);
        a:
        {
         if(40 !== opening && 123 !== opening){
          var lim$0 = caml_ml_string_length(s);
          b:
          {
           c:
           {
            d:
            {
             var i$2 = start;
             for(;;){
              if(lim$0 <= i$2) break c;
              var match = caml_string_get(s, i$2);
              if(91 <= match){
               if(97 <= match){
                if(123 <= match) break d;
               }
               else if(95 !== match) break d;
              }
              else
               if(58 <= match){
                if(65 > match) break;
               }
               else if(48 > match) break d;
              var i$3 = i$2 + 1 | 0;
              i$2 = i$3;
             }
            }
            var stop$0 = i$2;
            break b;
           }
           var stop$0 = lim$0;
          }
          if(stop$0 === start)
           throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          var
           val =
             [0,
              caml_call3(Stdlib_String[16], s, start, stop$0 - start | 0),
              stop$0];
          break a;
         }
         var new_start = start + 1 | 0, k$2 = 0;
         if(40 === opening)
          var closing = 41;
         else{
          if(123 !== opening)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
          var closing = 125;
         }
         var lim = caml_ml_string_length(s), k = k$2, stop = new_start;
         for(;;){
          if(lim <= stop) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          if(caml_string_get(s, stop) === opening){
           var i = stop + 1 | 0, k$0 = k + 1 | 0;
           k = k$0;
           stop = i;
          }
          else if(caml_string_get(s, stop) === closing){
           if(0 === k) break;
           var i$0 = stop + 1 | 0, k$1 = k - 1 | 0;
           k = k$1;
           stop = i$0;
          }
          else{var i$1 = stop + 1 | 0; stop = i$1;}
         }
         var
          val =
            [0,
             caml_call3
              (Stdlib_String[16], s, new_start, (stop - start | 0) - 1 | 0),
             stop + 1 | 0];
        }
       }
       catch(_p_){
        var _n_ = caml_wrap_exception(_p_);
        if(_n_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_n_, 0);
        add_char(b, 36);
        previous = 32;
        i$4 = start;
        continue;
       }
       var next_i = val[2], ident = val[1];
       add_string(b, caml_call1(f, ident));
       previous = 32;
       i$4 = next_i;
      }
     else{
      if(92 === previous) add_char(b, previous);
      if(92 !== previous$0) add_char(b, previous$0);
      var i$6 = i$4 + 1 | 0;
      previous = previous$0;
      i$4 = i$6;
     }
    }
   }
   function truncate(b, len){
    if(0 <= len && b[2] >= len){b[2] = len; return 0;}
    return caml_call1(Stdlib[1], cst_Buffer_truncate);
   }
   function to_seq(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _l_ = i + 1 | 0;
     return [0, x, function(_m_){return aux(_l_, _m_);}];
    }
    var _j_ = 0;
    return function(_k_){return aux(_j_, _k_);};
   }
   function to_seqi(b){
    function aux(i, param){
     if(b[2] <= i) return 0;
     var x = caml_bytes_get(b[1][1], i), _h_ = i + 1 | 0;
     return [0, [0, i, x], function(_i_){return aux(_h_, _i_);}];
    }
    var _f_ = 0;
    return function(_g_){return aux(_f_, _g_);};
   }
   function add_seq(b, seq){
    return caml_call2
            (Stdlib_Seq[4], function(_e_){return add_char(b, _e_);}, seq);
   }
   function of_seq(i){var b = create(32); add_seq(b, i); return b;}
   function add_int8(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 1 | 0;
    if(length < new_position){
     resize(b, 1);
     caml_bytes_set(b[1][1], b[2], x);
    }
    else
     caml_bytes_unsafe_set(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 2 | 0;
    if(length < new_position){
     resize(b, 2);
     caml_bytes_set16(b[1][1], b[2], x);
    }
    else
     caml_bytes_set16(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int32_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 4 | 0;
    if(length < new_position){
     resize(b, 4);
     caml_bytes_set32(b[1][1], b[2], x);
    }
    else
     caml_bytes_set32(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int64_ne(b, x){
    var
     position = b[2],
     match = b[1],
     length = match[2],
     buffer = match[1],
     new_position = position + 8 | 0;
    if(length < new_position){
     resize(b, 8);
     caml_bytes_set64(b[1][1], b[2], x);
    }
    else
     caml_bytes_set64(buffer, position, x);
    b[2] = new_position;
    return 0;
   }
   function add_int16_le(b, x){
    var _d_ = Stdlib_Sys[11] ? caml_bswap16(x) : x;
    return add_int16_ne(b, _d_);
   }
   function add_int16_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_bswap16(x);
    return add_int16_ne(b, x$0);
   }
   function add_int32_le(b, x){
    var _c_ = Stdlib_Sys[11] ? caml_int32_bswap(x) : x;
    return add_int32_ne(b, _c_);
   }
   function add_int32_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int32_bswap(x);
    return add_int32_ne(b, x$0);
   }
   function add_int64_le(b, x){
    var _b_ = Stdlib_Sys[11] ? caml_int64_bswap(x) : x;
    return add_int64_ne(b, _b_);
   }
   function add_int64_be(b, x){
    var x$0 = Stdlib_Sys[11] ? x : caml_int64_bswap(x);
    return add_int64_ne(b, x$0);
   }
   var
    Stdlib_Buffer =
      [0,
       create,
       contents,
       to_bytes,
       sub,
       blit,
       nth,
       length,
       clear,
       reset,
       output_buffer,
       truncate,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       to_seq,
       to_seqi,
       add_seq,
       of_seq,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
   runtime.caml_register_global(14, Stdlib_Buffer, "Stdlib__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Mutex
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_mutex_lock = runtime.caml_ml_mutex_lock,
    caml_ml_mutex_unlock = runtime.caml_ml_mutex_unlock,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function protect(m, f){
    caml_ml_mutex_lock(m);
    try{var x = caml_call1(f, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_ml_mutex_unlock(m);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    caml_ml_mutex_unlock(m);
    return x;
   }
   var
    Stdlib_Mutex =
      [0,
       runtime.caml_ml_mutex_new,
       caml_ml_mutex_lock,
       runtime.caml_ml_mutex_try_lock,
       caml_ml_mutex_unlock,
       protect];
   runtime.caml_register_global(0, Stdlib_Mutex, "Stdlib__Mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Condition
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Stdlib_Condition =
      [0,
       runtime.caml_ml_condition_new,
       runtime.caml_ml_condition_wait,
       runtime.caml_ml_condition_signal,
       runtime.caml_ml_condition_broadcast];
   runtime.caml_register_global(0, Stdlib_Condition, "Stdlib__Condition");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Semaphore
//# unitInfo: Requires: Stdlib, Stdlib__Condition, Stdlib__Mutex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib = global_data.Stdlib,
    cst_Semaphore_Counting_init_wr =
      "Semaphore.Counting.init: wrong initial value",
    cst_Semaphore_Counting_release = "Semaphore.Counting.release: overflow";
   function make(v){
    if(v < 0) caml_call1(Stdlib[1], cst_Semaphore_Counting_init_wr);
    var _c_ = caml_call1(Stdlib_Condition[1], 0);
    return [0, caml_call1(Stdlib_Mutex[1], 0), v, _c_];
   }
   function release(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    if(s[2] < Stdlib[19]){
     s[2] = s[2] + 1 | 0;
     caml_call1(Stdlib_Condition[3], s[3]);
     return caml_call1(Stdlib_Mutex[4], s[1]);
    }
    caml_call1(Stdlib_Mutex[4], s[1]);
    throw caml_maybe_attach_backtrace
           ([0, Stdlib[11], cst_Semaphore_Counting_release], 1);
   }
   function acquire(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    for(;;){
     if(0 !== s[2]){
      s[2] = s[2] - 1 | 0;
      return caml_call1(Stdlib_Mutex[4], s[1]);
     }
     caml_call2(Stdlib_Condition[2], s[3], s[1]);
    }
   }
   function try_acquire(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    var ret = 0 === s[2] ? 0 : (s[2] = s[2] - 1 | 0, 1);
    caml_call1(Stdlib_Mutex[4], s[1]);
    return ret;
   }
   function get_value(s){return s[2];}
   var Counting = [0, make, release, acquire, try_acquire, get_value];
   function make$0(b){
    var _a_ = caml_call1(Stdlib_Condition[1], 0), _b_ = b ? 1 : 0;
    return [0, caml_call1(Stdlib_Mutex[1], 0), _b_, _a_];
   }
   function release$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    s[2] = 1;
    caml_call1(Stdlib_Condition[3], s[3]);
    return caml_call1(Stdlib_Mutex[4], s[1]);
   }
   function acquire$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    for(;;){
     if(0 !== s[2]){s[2] = 0; return caml_call1(Stdlib_Mutex[4], s[1]);}
     caml_call2(Stdlib_Condition[2], s[3], s[1]);
    }
   }
   function try_acquire$0(s){
    caml_call1(Stdlib_Mutex[2], s[1]);
    var ret = 0 === s[2] ? 0 : (s[2] = 0, 1);
    caml_call1(Stdlib_Mutex[4], s[1]);
    return ret;
   }
   var
    Binary = [0, make$0, release$0, acquire$0, try_acquire$0],
    Stdlib_Semaphore = [0, Counting, Binary];
   runtime.caml_register_global(5, Stdlib_Semaphore, "Stdlib__Semaphore");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Domain
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Atomic, Stdlib__Condition, Stdlib__List, Stdlib__Mutex
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_domain_dls_get = runtime.caml_domain_dls_get,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_domain_id = runtime.caml_ml_domain_id,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Condition = global_data.Stdlib__Condition,
    Stdlib_Mutex = global_data.Stdlib__Mutex,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure;
   function cpu_relax(param){return runtime.caml_ml_domain_cpu_relax(0);}
   var none = [0, 0];
   function create_dls(param){
    var st = caml_make_vect(8, none);
    runtime.caml_domain_dls_set(st);
    return;
   }
   create_dls(0);
   var
    key_counter = caml_call1(Stdlib_Atomic[1], 0),
    parent_keys = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, "domain.ml", 184, 13];
   function new_key(split_from_parent, init_orphan){
    var
     idx = caml_call2(Stdlib_Atomic[7], key_counter, 1),
     k = [0, idx, init_orphan];
    if(split_from_parent){
     var split = split_from_parent[1], ki = [0, k, split];
     for(;;){
      var l = caml_call1(Stdlib_Atomic[3], parent_keys);
      if(! (1 - caml_call3(Stdlib_Atomic[6], parent_keys, l, [0, ki, l])))
       break;
     }
    }
    return k;
   }
   function maybe_grow(idx){
    for(;;){
     var st = caml_domain_dls_get(0), sz = st.length - 1;
     if(idx < sz) return st;
     var new_sz = sz;
     for(;;){if(idx < new_sz) break; var s = 2 * new_sz | 0; new_sz = s;}
     var new_st = caml_make_vect(new_sz, none);
     caml_call5(Stdlib_Array[9], st, 0, new_st, 0, sz);
     if(runtime.caml_domain_dls_compare_and_set(st, new_st)) return new_st;
    }
   }
   function set(param, x){
    var idx = param[1], st = maybe_grow(idx);
    caml_check_bound(st, idx)[1 + idx] = x;
    return 0;
   }
   function get(param){
    var
     init = param[2],
     idx = param[1],
     st = maybe_grow(idx),
     oldval = caml_check_bound(st, idx)[1 + idx];
    if(oldval !== none) return oldval;
    var
     new_obj = caml_call1(init, 0),
     st$0 = caml_domain_dls_get(0),
     curval = caml_check_bound(st$0, idx)[1 + idx],
     _e_ = curval === oldval ? (st$0[1 + idx] = new_obj, 1) : 0;
    if(_e_) return new_obj;
    var updated_obj = caml_check_bound(st$0, idx)[1 + idx];
    if(updated_obj !== none) return updated_obj;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function get_id(param){var domain = param[1]; return domain;}
   function self(param){return caml_ml_domain_id(0);}
   function is_main_domain(param){return 0 === caml_ml_domain_id(0) ? 1 : 0;}
   var
    first_domain_spawned = caml_call1(Stdlib_Atomic[1], 0),
    first_spawn_function = [0, function(param){return;}],
    cst_first_domain_already_spawn = "first domain already spawned";
   function before_first_spawn(f){
    if(caml_call1(Stdlib_Atomic[3], first_domain_spawned))
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_first_domain_already_spawn], 1);
    var old_f = first_spawn_function[1];
    function new_f(param){caml_call1(old_f, 0); return caml_call1(f, 0);}
    first_spawn_function[1] = new_f;
    return 0;
   }
   var
    at_exit_key =
      new_key(0, function(param){return function(param){return 0;};});
   function at_exit(f){
    var old_exit = get(at_exit_key);
    function new_exit(param){
     caml_call1(f, 0);
     return caml_call1(old_exit, 0);
    }
    return set(at_exit_key, new_exit);
   }
   function do_at_exit(param){
    var f = get(at_exit_key);
    return caml_call1(f, 0);
   }
   Stdlib[104][1] = do_at_exit;
   function spawn(f){
    if(1 - caml_call1(Stdlib_Atomic[3], first_domain_spawned)){
     caml_call2(Stdlib_Atomic[4], first_domain_spawned, 1);
     caml_call1(first_spawn_function[1], 0);
     first_spawn_function[1] = function(param){return 0;};
    }
    var
     _b_ = caml_call1(Stdlib_Atomic[3], parent_keys),
     pk =
       caml_call2
        (Stdlib_List[20],
         function(param){
          var split = param[2], k = param[1];
          return [0, k, caml_call1(split, get(k))];
         },
         _b_),
     _c_ = caml_call1(Stdlib_Condition[1], 0),
     term_sync = [0, 0, caml_call1(Stdlib_Mutex[1], 0), _c_];
    function body(param){
     try{
      create_dls(0);
      caml_call2
       (Stdlib_List[18],
        function(param){var v = param[2], k = param[1]; return set(k, v);},
        pk);
      var res = caml_call1(f, 0);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      try{do_at_exit(0);}catch(_d_){}
      throw caml_maybe_attach_backtrace(exn, 0);
     }
     do_at_exit(0);
     return res;
    }
    var domain = runtime.caml_domain_spawn(body, term_sync);
    return [0, domain, term_sync];
   }
   function join(param){
    var term_sync = param[2];
    function loop(param){
     for(;;){
      var match = term_sync[1];
      if(match){var res = match[1]; return res;}
      caml_call2(Stdlib_Condition[2], term_sync[3], term_sync[2]);
     }
    }
    var match = caml_call2(Stdlib_Mutex[5], term_sync[2], loop);
    if(0 === match[0]){var x = match[1]; return x;}
    var ex = match[1];
    throw caml_maybe_attach_backtrace(ex, 1);
   }
   var
    recommended_domain_count = runtime.caml_recommended_domain_count,
    Stdlib_Domain =
      [0,
       spawn,
       join,
       get_id,
       self,
       before_first_spawn,
       at_exit,
       cpu_relax,
       is_main_domain,
       recommended_domain_count,
       [0, new_key, get, set]];
   runtime.caml_register_global(9, Stdlib_Domain, "Stdlib__Domain");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalFormat
//# unitInfo: Requires: CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Int, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$43 = "",
    cst_and = " and ",
    cst_Li$3 = "%Li",
    cst_i$3 = "%i",
    cst_li$3 = "%li",
    cst_ni$3 = "%ni",
    cst_u$0 = "%u",
    cst$42 = "' '",
    cst$41 = "'#'",
    cst$39 = "'*'",
    cst$40 = "'+'",
    cst$44 = ", ",
    cst_0$3 = "0",
    cst_at_character_number = ": at character number ",
    cst$38 = "@[",
    cst$37 = "@{",
    cst_bad_input_format_type_mism =
      "bad input: format type mismatch between ",
    cst_bad_input_format_type_mism$0 =
      "bad input: format type mismatch between %S and %S",
    cst_camlinternalFormat_ml = "camlinternalFormat.ml",
    cst_invalid_format = "invalid format ",
    cst_precision$3 = "precision",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_format_float = runtime.caml_format_float,
    caml_format_int = runtime.caml_format_int,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$9 = "%{",
    cst$10 = "%}",
    cst$11 = "%(",
    cst$12 = "%)",
    cst$13 = "%?",
    cst$18 = cst$37,
    cst$19 = cst$38,
    cst$20 = cst$37,
    cst$21 = cst$38,
    cst$22 = cst$37,
    cst$23 = cst$38,
    cst$26 = cst$39,
    cst$24 = "'-'",
    cst$25 = cst$39,
    cst$27 = cst$40,
    cst$28 = cst$41,
    cst$29 = cst$42,
    cst$30 = cst$40,
    cst$31 = "'_'",
    sub_format = [0, 0, cst$43],
    formatting_lit = [0, "@;", 1, 0],
    cst$35 = cst$41,
    cst$32 = cst$40,
    cst$33 = cst$40,
    cst$34 = cst$42,
    cst$36 = cst$40,
    cst_unexpected_end_of_format = "unexpected end of format",
    cst$17 = ".",
    cst$14 = "%!",
    cst$15 = cst$37,
    cst$16 = cst$38,
    cst$8 = "%%",
    cst$0 = "@]",
    cst$1 = "@}",
    cst$2 = "@?",
    cst$3 = "@\n",
    cst$4 = "@.",
    cst$5 = "@@",
    cst$6 = "@%",
    cst$7 = "@",
    cst = ".*",
    Assert_failure = global_data.Assert_failure,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    _a_ = [0, 0, 0],
    cst_c = "%c",
    cst_s = "%s",
    cst_i = cst_i$3,
    cst_li = cst_li$3,
    cst_ni = cst_ni$3,
    cst_Li = cst_Li$3,
    cst_f = "%f",
    cst_B = "%B",
    cst_a = "%a",
    cst_t = "%t",
    cst_r = "%r",
    cst_r$0 = "%_r",
    cst_0c = "0c",
    _b_ = [0, cst_camlinternalFormat_ml, 850, 23],
    _c_ = [0, cst_camlinternalFormat_ml, 837, 26],
    _d_ = [0, cst_camlinternalFormat_ml, 847, 28],
    _e_ = [0, cst_camlinternalFormat_ml, 815, 21],
    _f_ = [0, cst_camlinternalFormat_ml, 819, 21],
    _g_ = [0, cst_camlinternalFormat_ml, 823, 19],
    _h_ = [0, cst_camlinternalFormat_ml, 827, 22],
    _i_ = [0, cst_camlinternalFormat_ml, 832, 30],
    _j_ = [0, cst_camlinternalFormat_ml, 851, 23],
    _k_ = [0, cst_camlinternalFormat_ml, 836, 26],
    _l_ = [0, cst_camlinternalFormat_ml, 846, 28],
    _m_ = [0, cst_camlinternalFormat_ml, 814, 21],
    _n_ = [0, cst_camlinternalFormat_ml, 818, 21],
    _o_ = [0, cst_camlinternalFormat_ml, 822, 19],
    _p_ = [0, cst_camlinternalFormat_ml, 826, 22],
    _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
   function create_char_set(param){return caml_call2(Stdlib_Bytes[1], 32, 0);}
   function add_in_char_set(char_set, c){
    var
     str_ind = c >>> 3 | 0,
     mask = 1 << (c & 7),
     _cU_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
    return caml_bytes_set(char_set, str_ind, caml_call1(Stdlib[29], _cU_));
   }
   function freeze_char_set(char_set){
    return caml_call1(Stdlib_Bytes[6], char_set);
   }
   function rev_char_set(char_set){
    var char_set$0 = create_char_set(0), i = 0;
    for(;;){
     var _cS_ = caml_string_get(char_set, i) ^ 255;
     caml_bytes_set(char_set$0, i, caml_call1(Stdlib[29], _cS_));
     var _cT_ = i + 1 | 0;
     if(31 === i) return caml_call1(Stdlib_Bytes[44], char_set$0);
     i = _cT_;
    }
   }
   function is_in_char_set(char_set, c){
    var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
    return 0 !== (caml_string_get(char_set, str_ind) & mask) ? 1 : 0;
   }
   function pad_of_pad_opt(pad_opt){
    if(! pad_opt) return 0;
    var width = pad_opt[1];
    return [0, 1, width];
   }
   function param_format_of_ignored_format(ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        return [0, [0, fmt]];
       case 1:
        return [0, [1, fmt]];
       case 2:
        return [0, [19, fmt]];
       default: return [0, [22, fmt]];
     }
    switch(ign[0]){
      case 0:
       var pad_opt = ign[1]; return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
      case 1:
       var pad_opt$0 = ign[1];
       return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
      case 2:
       var pad_opt$1 = ign[2], iconv = ign[1];
       return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
      case 3:
       var pad_opt$2 = ign[2], iconv$0 = ign[1];
       return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
      case 4:
       var pad_opt$3 = ign[2], iconv$1 = ign[1];
       return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
      case 5:
       var pad_opt$4 = ign[2], iconv$2 = ign[1];
       return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
      case 6:
       var prec_opt = ign[2], pad_opt$5 = ign[1];
       if(prec_opt)
        var ndec = prec_opt[1], _cR_ = [0, ndec];
       else
        var _cR_ = 0;
       return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _cR_, fmt]];
      case 7:
       var pad_opt$6 = ign[1];
       return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
      case 8:
       var fmtty = ign[2], pad_opt$7 = ign[1];
       return [0, [13, pad_opt$7, fmtty, fmt]];
      case 9:
       var fmtty$0 = ign[2], pad_opt$8 = ign[1];
       return [0, [14, pad_opt$8, fmtty$0, fmt]];
      case 10:
       var char_set = ign[2], width_opt = ign[1];
       return [0, [20, width_opt, char_set, fmt]];
      default: var counter = ign[1]; return [0, [21, counter, fmt]];
    }
   }
   function default_float_precision(fconv){return 5 === fconv[2] ? 12 : -6;}
   function buffer_create(init_size){
    return [0, 0, caml_create_bytes(init_size)];
   }
   function buffer_check_size(buf, overhead){
    var
     len = runtime.caml_ml_bytes_length(buf[2]),
     min_len = buf[1] + overhead | 0;
    if(len < min_len){
     var
      new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len),
      new_str = caml_create_bytes(new_len);
     caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
     buf[2] = new_str;
    }
    return;
   }
   function buffer_add_char(buf, c){
    buffer_check_size(buf, 1);
    caml_bytes_set(buf[2], buf[1], c);
    buf[1] = buf[1] + 1 | 0;
    return;
   }
   function buffer_add_string(buf, s){
    var str_len = caml_ml_string_length(s);
    buffer_check_size(buf, str_len);
    caml_call5(Stdlib_String[6], s, 0, buf[2], buf[1], str_len);
    buf[1] = buf[1] + str_len | 0;
    return;
   }
   function buffer_contents(buf){
    return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
   }
   function char_of_iconv(iconv){
    switch(iconv){
      case 6:
      case 7:
       return 120;
      case 8:
      case 9:
       return 88;
      case 10:
      case 11:
       return 111;
      case 12:
      case 15:
       return 117;
      case 0:
      case 1:
      case 2:
      case 13:
       return 100;
      default: return 105;
    }
   }
   function char_of_fconv(opt, fconv){
    var cF = opt ? opt[1] : 70;
    switch(fconv[2]){
      case 0:
       return 102;
      case 1:
       return 101;
      case 2:
       return 69;
      case 3:
       return 103;
      case 4:
       return 71;
      case 5:
       return cF;
      case 6:
       return 104;
      case 7:
       return 72;
      default: return 70;
    }
   }
   function bprint_padty(buf, padty){
    switch(padty){
      case 0:
       return buffer_add_char(buf, 45);
      case 1:
       return;
      default: return buffer_add_char(buf, 48);
    }
   }
   function bprint_ignored_flag(buf, ign_flag){
    return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
   }
   function bprint_pad_opt(buf, pad_opt){
    if(! pad_opt) return;
    var width = pad_opt[1];
    return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
   }
   function bprint_padding(buf, pad){
    if(typeof pad === "number") return;
    if(0 === pad[0]){
     var n = pad[2], padty = pad[1];
     bprint_padty(buf, padty);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    var padty$0 = pad[1];
    bprint_padty(buf, padty$0);
    return buffer_add_char(buf, 42);
   }
   function bprint_precision(buf, prec){
    if(typeof prec !== "number"){
     var n = prec[1];
     buffer_add_char(buf, 46);
     return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
    }
    if(prec) return buffer_add_string(buf, cst);
    return;
   }
   function bprint_iconv_flag(buf, iconv){
    switch(iconv){
      case 1:
      case 4:
       return buffer_add_char(buf, 43);
      case 2:
      case 5:
       return buffer_add_char(buf, 32);
      case 7:
      case 9:
      case 11:
      case 13:
      case 14:
      case 15:
       return buffer_add_char(buf, 35);
      default: return;
    }
   }
   function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c){
    buffer_add_char(buf, 37);
    bprint_ignored_flag(buf, ign_flag);
    bprint_iconv_flag(buf, iconv);
    bprint_padding(buf, pad);
    bprint_precision(buf, prec);
    buffer_add_char(buf, c);
    return buffer_add_char(buf, char_of_iconv(iconv));
   }
   function bprint_fconv_flag(buf, fconv){
    switch(fconv[1]){
      case 0: break;
      case 1:
       buffer_add_char(buf, 43); break;
      default: buffer_add_char(buf, 32);
    }
    if(8 <= fconv[2]) return buffer_add_char(buf, 35);
    return;
   }
   function string_of_formatting_lit(formatting_lit){
    if(typeof formatting_lit === "number")
     switch(formatting_lit){
       case 0:
        return cst$0;
       case 1:
        return cst$1;
       case 2:
        return cst$2;
       case 3:
        return cst$3;
       case 4:
        return cst$4;
       case 5:
        return cst$5;
       default: return cst$6;
     }
    switch(formatting_lit[0]){
      case 0:
       var str = formatting_lit[1]; return str;
      case 1:
       var str$0 = formatting_lit[1]; return str$0;
      default:
       var c = formatting_lit[1], _cQ_ = caml_call2(Stdlib_String[1], 1, c);
       return caml_call2(Stdlib[28], cst$7, _cQ_);
    }
   }
   function bprint_char_literal(buf, chr){
    return 37 === chr
            ? buffer_add_string(buf, cst$8)
            : buffer_add_char(buf, chr);
   }
   function bprint_string_literal(buf, str){
    var _cO_ = caml_ml_string_length(str) - 1 | 0, _cN_ = 0;
    if(_cO_ >= 0){
     var i = _cN_;
     for(;;){
      bprint_char_literal(buf, caml_string_get(str, i));
      var _cP_ = i + 1 | 0;
      if(_cO_ === i) break;
      i = _cP_;
     }
    }
    return;
   }
   function bprint_fmtty(buf, fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return;
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1];
        buffer_add_string(buf, cst_c);
        fmtty$0 = fmtty$1;
        break;
       case 1:
        var fmtty$2 = fmtty$0[1];
        buffer_add_string(buf, cst_s);
        fmtty$0 = fmtty$2;
        break;
       case 2:
        var fmtty$3 = fmtty$0[1];
        buffer_add_string(buf, cst_i);
        fmtty$0 = fmtty$3;
        break;
       case 3:
        var fmtty$4 = fmtty$0[1];
        buffer_add_string(buf, cst_li);
        fmtty$0 = fmtty$4;
        break;
       case 4:
        var fmtty$5 = fmtty$0[1];
        buffer_add_string(buf, cst_ni);
        fmtty$0 = fmtty$5;
        break;
       case 5:
        var fmtty$6 = fmtty$0[1];
        buffer_add_string(buf, cst_Li);
        fmtty$0 = fmtty$6;
        break;
       case 6:
        var fmtty$7 = fmtty$0[1];
        buffer_add_string(buf, cst_f);
        fmtty$0 = fmtty$7;
        break;
       case 7:
        var fmtty$8 = fmtty$0[1];
        buffer_add_string(buf, cst_B);
        fmtty$0 = fmtty$8;
        break;
       case 8:
        var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
        buffer_add_string(buf, cst$9);
        bprint_fmtty(buf, sub_fmtty);
        buffer_add_string(buf, cst$10);
        fmtty$0 = fmtty$9;
        break;
       case 9:
        var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
        buffer_add_string(buf, cst$11);
        bprint_fmtty(buf, sub_fmtty$0);
        buffer_add_string(buf, cst$12);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1];
        buffer_add_string(buf, cst_a);
        fmtty$0 = fmtty$11;
        break;
       case 11:
        var fmtty$12 = fmtty$0[1];
        buffer_add_string(buf, cst_t);
        fmtty$0 = fmtty$12;
        break;
       case 12:
        var fmtty$13 = fmtty$0[1];
        buffer_add_string(buf, cst$13);
        fmtty$0 = fmtty$13;
        break;
       case 13:
        var fmtty$14 = fmtty$0[1];
        buffer_add_string(buf, cst_r);
        fmtty$0 = fmtty$14;
        break;
       default:
        var fmtty$15 = fmtty$0[1];
        buffer_add_string(buf, cst_r$0);
        fmtty$0 = fmtty$15;
     }
    }
   }
   function int_of_custom_arity(param){
    if(! param) return 0;
    var x = param[1];
    return 1 + int_of_custom_arity(x) | 0;
   }
   function string_of_fmt(fmt){
    var buf = buffer_create(16);
    function fmtiter(fmt, ign_flag){
     var fmt$0 = fmt, ign_flag$0 = ign_flag;
     for(;;){
      if(typeof fmt$0 === "number") return;
      switch(fmt$0[0]){
        case 0:
         var rest = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 99);
         fmt$0 = rest;
         ign_flag$0 = 0;
         break;
        case 1:
         var rest$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 67);
         fmt$0 = rest$0;
         ign_flag$0 = 0;
         break;
        case 2:
         var rest$1 = fmt$0[2], pad = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad);
         buffer_add_char(buf, 115);
         fmt$0 = rest$1;
         ign_flag$0 = 0;
         break;
        case 3:
         var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$0);
         buffer_add_char(buf, 83);
         fmt$0 = rest$2;
         ign_flag$0 = 0;
         break;
        case 4:
         var
          rest$3 = fmt$0[4],
          prec = fmt$0[3],
          pad$1 = fmt$0[2],
          iconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_iconv_flag(buf, iconv);
         bprint_padding(buf, pad$1);
         bprint_precision(buf, prec);
         buffer_add_char(buf, char_of_iconv(iconv));
         fmt$0 = rest$3;
         ign_flag$0 = 0;
         break;
        case 5:
         var
          rest$4 = fmt$0[4],
          prec$0 = fmt$0[3],
          pad$2 = fmt$0[2],
          iconv$0 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
         fmt$0 = rest$4;
         ign_flag$0 = 0;
         break;
        case 6:
         var
          rest$5 = fmt$0[4],
          prec$1 = fmt$0[3],
          pad$3 = fmt$0[2],
          iconv$1 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
         fmt$0 = rest$5;
         ign_flag$0 = 0;
         break;
        case 7:
         var
          rest$6 = fmt$0[4],
          prec$2 = fmt$0[3],
          pad$4 = fmt$0[2],
          iconv$2 = fmt$0[1];
         bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
         fmt$0 = rest$6;
         ign_flag$0 = 0;
         break;
        case 8:
         var
          rest$7 = fmt$0[4],
          prec$3 = fmt$0[3],
          pad$5 = fmt$0[2],
          fconv = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_fconv_flag(buf, fconv);
         bprint_padding(buf, pad$5);
         bprint_precision(buf, prec$3);
         buffer_add_char(buf, char_of_fconv(0, fconv));
         fmt$0 = rest$7;
         ign_flag$0 = 0;
         break;
        case 9:
         var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_padding(buf, pad$6);
         buffer_add_char(buf, 66);
         fmt$0 = rest$8;
         ign_flag$0 = 0;
         break;
        case 10:
         var rest$9 = fmt$0[1];
         buffer_add_string(buf, cst$14);
         fmt$0 = rest$9;
         break;
        case 11:
         var rest$10 = fmt$0[2], str = fmt$0[1];
         bprint_string_literal(buf, str);
         fmt$0 = rest$10;
         break;
        case 12:
         var rest$11 = fmt$0[2], chr = fmt$0[1];
         bprint_char_literal(buf, chr);
         fmt$0 = rest$11;
         break;
        case 13:
         var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt);
         buffer_add_char(buf, 123);
         bprint_fmtty(buf, fmtty);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 125);
         fmt$0 = rest$12;
         ign_flag$0 = 0;
         break;
        case 14:
         var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, pad_opt$0);
         buffer_add_char(buf, 40);
         bprint_fmtty(buf, fmtty$0);
         buffer_add_char(buf, 37);
         buffer_add_char(buf, 41);
         fmt$0 = rest$13;
         ign_flag$0 = 0;
         break;
        case 15:
         var rest$14 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 97);
         fmt$0 = rest$14;
         ign_flag$0 = 0;
         break;
        case 16:
         var rest$15 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 116);
         fmt$0 = rest$15;
         ign_flag$0 = 0;
         break;
        case 17:
         var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
         bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
         fmt$0 = rest$16;
         break;
        case 18:
         var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
         if(0 === fmting_gen[0]){
          var str$0 = fmting_gen[1][2];
          buffer_add_string(buf, cst$15);
          buffer_add_string(buf, str$0);
         }
         else{
          var str$1 = fmting_gen[1][2];
          buffer_add_string(buf, cst$16);
          buffer_add_string(buf, str$1);
         }
         fmt$0 = rest$17;
         break;
        case 19:
         var rest$18 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         buffer_add_char(buf, 114);
         fmt$0 = rest$18;
         ign_flag$0 = 0;
         break;
        case 20:
         var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_pad_opt(buf, width_opt);
         var
          print_char =
            function(buf, i){
             var c = caml_call1(Stdlib[29], i);
             return 37 === c
                     ? (buffer_add_char(buf, 37), buffer_add_char(buf, 37))
                     : 64
                       === c
                       ? (buffer_add_char(buf, 37), buffer_add_char(buf, 64))
                       : buffer_add_char(buf, c);
            };
         buffer_add_char(buf, 91);
         var
          set =
            is_in_char_set(char_set, 0)
             ? (buffer_add_char(buf, 94), rev_char_set(char_set))
             : char_set;
         let set$0 = set;
         var
          is_alone =
            function(c){
             var
              after = caml_call1(Stdlib_Char[1], c + 1 | 0),
              before = caml_call1(Stdlib_Char[1], c - 1 | 0),
              _cJ_ = is_in_char_set(set$0, c);
             if(_cJ_)
              var
               _cK_ = is_in_char_set(set$0, before),
               _cL_ = _cK_ ? is_in_char_set(set$0, after) : _cK_,
               _cM_ = 1 - _cL_;
             else
              var _cM_ = _cJ_;
             return _cM_;
            };
         if(is_alone(93)) buffer_add_char(buf, 93);
         a:
         b:
         {
          c:
          {
           d:
           {
            var i = 1;
            for(;;){
             if(i >= 256) break;
             if(is_in_char_set(set, caml_call1(Stdlib[29], i))){
              var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
              if(48 < switcher >>> 0){
               if(210 <= switcher) break d;
              }
              else if(46 < switcher - 1 >>> 0){
               var i$2 = i + 1 | 0;
               i = i$2;
               continue;
              }
              var i$1 = i + 1 | 0;
              if(is_in_char_set(set, caml_call1(Stdlib[29], i$1))){
               var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
               if(48 < switcher$0 >>> 0){
                if(210 <= switcher$0) break c;
               }
               else if
                (46 < switcher$0 - 1 >>> 0
                 && ! is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                print_char(buf, i$1 - 1 | 0);
                var i$5 = i$1 + 1 | 0;
                i = i$5;
                continue;
               }
               if(is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))){
                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                for(;;){
                 if(256 === j$0) break;
                 if(! is_in_char_set(set, caml_call1(Stdlib[29], j$0))) break;
                 var j$1 = j$0 + 1 | 0;
                 j$0 = j$1;
                }
                print_char(buf, i$3);
                print_char(buf, 45);
                print_char(buf, j$0 - 1 | 0);
                if(j$0 >= 256) break b;
                var i$7 = j$0 + 1 | 0;
                i = i$7;
               }
               else{
                print_char(buf, i$1 - 1 | 0);
                print_char(buf, i$1);
                var i$4 = i$1 + 2 | 0;
                i = i$4;
               }
              }
              else{
               print_char(buf, i$1 - 1 | 0);
               var i$6 = i$1 + 1 | 0;
               i = i$6;
              }
             }
             else{var i$0 = i + 1 | 0; i = i$0;}
            }
            break a;
           }
           print_char(buf, 255);
           break a;
          }
          print_char(buf, 254);
          print_char(buf, 255);
          break a;
         }
         if(is_alone(45)) buffer_add_char(buf, 45);
         buffer_add_char(buf, 93);
         fmt$0 = rest$19;
         ign_flag$0 = 0;
         break;
        case 21:
         var rest$20 = fmt$0[2], counter = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         switch(counter){
           case 0:
            var _cF_ = 108; break;
           case 1:
            var _cF_ = 110; break;
           default: var _cF_ = 78;
         }
         buffer_add_char(buf, _cF_);
         fmt$0 = rest$20;
         ign_flag$0 = 0;
         break;
        case 22:
         var rest$21 = fmt$0[1];
         buffer_add_char(buf, 37);
         bprint_ignored_flag(buf, ign_flag$0);
         bprint_string_literal(buf, cst_0c);
         fmt$0 = rest$21;
         ign_flag$0 = 0;
         break;
        case 23:
         var
          rest$22 = fmt$0[2],
          ign = fmt$0[1],
          fmt$1 = param_format_of_ignored_format(ign, rest$22)[1];
         fmt$0 = fmt$1;
         ign_flag$0 = 1;
         break;
        default:
         var
          rest$23 = fmt$0[3],
          arity = fmt$0[1],
          _cH_ = int_of_custom_arity(arity),
          _cG_ = 1;
         if(_cH_ >= 1){
          var i$8 = _cG_;
          for(;;){
           buffer_add_char(buf, 37);
           bprint_ignored_flag(buf, ign_flag$0);
           buffer_add_char(buf, 63);
           var _cI_ = i$8 + 1 | 0;
           if(_cH_ === i$8) break;
           i$8 = _cI_;
          }
         }
         fmt$0 = rest$23;
         ign_flag$0 = 0;
      }
     }
    }
    fmtiter(fmt, 0);
    return buffer_contents(buf);
   }
   function symm(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var rest = param[1]; return [0, symm(rest)];
      case 1:
       var rest$0 = param[1]; return [1, symm(rest$0)];
      case 2:
       var rest$1 = param[1]; return [2, symm(rest$1)];
      case 3:
       var rest$2 = param[1]; return [3, symm(rest$2)];
      case 4:
       var rest$3 = param[1]; return [4, symm(rest$3)];
      case 5:
       var rest$4 = param[1]; return [5, symm(rest$4)];
      case 6:
       var rest$5 = param[1]; return [6, symm(rest$5)];
      case 7:
       var rest$6 = param[1]; return [7, symm(rest$6)];
      case 8:
       var rest$7 = param[2], ty = param[1]; return [8, ty, symm(rest$7)];
      case 9:
       var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
       return [9, ty2, ty1, symm(rest$8)];
      case 10:
       var rest$9 = param[1]; return [10, symm(rest$9)];
      case 11:
       var rest$10 = param[1]; return [11, symm(rest$10)];
      case 12:
       var rest$11 = param[1]; return [12, symm(rest$11)];
      case 13:
       var rest$12 = param[1]; return [13, symm(rest$12)];
      default: var rest$13 = param[1]; return [14, symm(rest$13)];
    }
   }
   function fmtty_rel_det(param){
    if(typeof param === "number")
     return [0,
             function(param){return;},
             function(param){return;},
             function(param){return;},
             function(param){return;}];
    switch(param[0]){
      case 0:
       var
        rest = param[1],
        match = fmtty_rel_det(rest),
        de = match[4],
        ed = match[3],
        af = match[2],
        fa = match[1];
       return [0,
               function(param){fa(0); return;},
               function(param){af(0); return;},
               ed,
               de];
      case 1:
       var
        rest$0 = param[1],
        match$0 = fmtty_rel_det(rest$0),
        de$0 = match$0[4],
        ed$0 = match$0[3],
        af$0 = match$0[2],
        fa$0 = match$0[1];
       return [0,
               function(param){fa$0(0); return;},
               function(param){af$0(0); return;},
               ed$0,
               de$0];
      case 2:
       var
        rest$1 = param[1],
        match$1 = fmtty_rel_det(rest$1),
        de$1 = match$1[4],
        ed$1 = match$1[3],
        af$1 = match$1[2],
        fa$1 = match$1[1];
       return [0,
               function(param){fa$1(0); return;},
               function(param){af$1(0); return;},
               ed$1,
               de$1];
      case 3:
       var
        rest$2 = param[1],
        match$2 = fmtty_rel_det(rest$2),
        de$2 = match$2[4],
        ed$2 = match$2[3],
        af$2 = match$2[2],
        fa$2 = match$2[1];
       return [0,
               function(param){fa$2(0); return;},
               function(param){af$2(0); return;},
               ed$2,
               de$2];
      case 4:
       var
        rest$3 = param[1],
        match$3 = fmtty_rel_det(rest$3),
        de$3 = match$3[4],
        ed$3 = match$3[3],
        af$3 = match$3[2],
        fa$3 = match$3[1];
       return [0,
               function(param){fa$3(0); return;},
               function(param){af$3(0); return;},
               ed$3,
               de$3];
      case 5:
       var
        rest$4 = param[1],
        match$4 = fmtty_rel_det(rest$4),
        de$4 = match$4[4],
        ed$4 = match$4[3],
        af$4 = match$4[2],
        fa$4 = match$4[1];
       return [0,
               function(param){fa$4(0); return;},
               function(param){af$4(0); return;},
               ed$4,
               de$4];
      case 6:
       var
        rest$5 = param[1],
        match$5 = fmtty_rel_det(rest$5),
        de$5 = match$5[4],
        ed$5 = match$5[3],
        af$5 = match$5[2],
        fa$5 = match$5[1];
       return [0,
               function(param){fa$5(0); return;},
               function(param){af$5(0); return;},
               ed$5,
               de$5];
      case 7:
       var
        rest$6 = param[1],
        match$6 = fmtty_rel_det(rest$6),
        de$6 = match$6[4],
        ed$6 = match$6[3],
        af$6 = match$6[2],
        fa$6 = match$6[1];
       return [0,
               function(param){fa$6(0); return;},
               function(param){af$6(0); return;},
               ed$6,
               de$6];
      case 8:
       var
        rest$7 = param[2],
        match$7 = fmtty_rel_det(rest$7),
        de$7 = match$7[4],
        ed$7 = match$7[3],
        af$7 = match$7[2],
        fa$7 = match$7[1];
       return [0,
               function(param){fa$7(0); return;},
               function(param){af$7(0); return;},
               ed$7,
               de$7];
      case 9:
       var
        rest$8 = param[3],
        ty2 = param[2],
        ty1 = param[1],
        match$8 = fmtty_rel_det(rest$8),
        de$8 = match$8[4],
        ed$8 = match$8[3],
        af$8 = match$8[2],
        fa$8 = match$8[1],
        ty = trans(symm(ty1), ty2),
        match$9 = fmtty_rel_det(ty),
        jd = match$9[4],
        dj = match$9[3],
        ga = match$9[2],
        ag = match$9[1];
       return [0,
               function(param){fa$8(0); ag(0); return;},
               function(param){ga(0); af$8(0); return;},
               function(param){ed$8(0); dj(0); return;},
               function(param){jd(0); de$8(0); return;}];
      case 10:
       var
        rest$9 = param[1],
        match$10 = fmtty_rel_det(rest$9),
        de$9 = match$10[4],
        ed$9 = match$10[3],
        af$9 = match$10[2],
        fa$9 = match$10[1];
       return [0,
               function(param){fa$9(0); return;},
               function(param){af$9(0); return;},
               ed$9,
               de$9];
      case 11:
       var
        rest$10 = param[1],
        match$11 = fmtty_rel_det(rest$10),
        de$10 = match$11[4],
        ed$10 = match$11[3],
        af$10 = match$11[2],
        fa$10 = match$11[1];
       return [0,
               function(param){fa$10(0); return;},
               function(param){af$10(0); return;},
               ed$10,
               de$10];
      case 12:
       var
        rest$11 = param[1],
        match$12 = fmtty_rel_det(rest$11),
        de$11 = match$12[4],
        ed$11 = match$12[3],
        af$11 = match$12[2],
        fa$11 = match$12[1];
       return [0,
               function(param){fa$11(0); return;},
               function(param){af$11(0); return;},
               ed$11,
               de$11];
      case 13:
       var
        rest$12 = param[1],
        match$13 = fmtty_rel_det(rest$12),
        de$12 = match$13[4],
        ed$12 = match$13[3],
        af$12 = match$13[2],
        fa$12 = match$13[1];
       return [0,
               function(param){fa$12(0); return;},
               function(param){af$12(0); return;},
               function(param){ed$12(0); return;},
               function(param){de$12(0); return;}];
      default:
       var
        rest$13 = param[1],
        match$14 = fmtty_rel_det(rest$13),
        de$13 = match$14[4],
        ed$13 = match$14[3],
        af$13 = match$14[2],
        fa$13 = match$14[1];
       return [0,
               function(param){fa$13(0); return;},
               function(param){af$13(0); return;},
               function(param){ed$13(0); return;},
               function(param){de$13(0); return;}];
    }
   }
   function trans(ty1, ty2){
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           if(typeof ty1 !== "number"){
            switch(ty1[0]){
              case 0:
               var rest1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 0:
                   var rest2 = ty2[1]; return [0, trans(rest1, rest2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 1:
               var rest1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 1:
                   var rest2$0 = ty2[1]; return [1, trans(rest1$0, rest2$0)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 2:
               var rest1$1 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 2:
                   var rest2$1 = ty2[1]; return [2, trans(rest1$1, rest2$1)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 3:
               var rest1$2 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 3:
                   var rest2$2 = ty2[1]; return [3, trans(rest1$2, rest2$2)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 4:
               var rest1$3 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 4:
                   var rest2$3 = ty2[1]; return [4, trans(rest1$3, rest2$3)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 5:
               var rest1$4 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 5:
                   var rest2$4 = ty2[1]; return [5, trans(rest1$4, rest2$4)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 6:
               var rest1$5 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 6:
                   var rest2$5 = ty2[1]; return [6, trans(rest1$5, rest2$5)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 7:
               var rest1$6 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 7:
                   var rest2$6 = ty2[1]; return [7, trans(rest1$6, rest2$6)];
                  case 8:
                   break f;
                  case 9:
                   break g;
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               break;
              case 8:
               var rest1$7 = ty1[2], ty1$0 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   var
                    rest2$7 = ty2[2],
                    ty2$0 = ty2[1],
                    _cE_ = trans(rest1$7, rest2$7);
                   return [8, trans(ty1$0, ty2$0), _cE_];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
              case 9:
               var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 8:
                   break f;
                  case 9:
                   var
                    rest2$8 = ty2[3],
                    ty22 = ty2[2],
                    ty21 = ty2[1],
                    ty = trans(symm(ty12), ty21),
                    match = fmtty_rel_det(ty),
                    f4 = match[4],
                    f2 = match[2];
                   f2(0);
                   f4(0);
                   return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   break e;
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
              case 10:
               var rest1$9 = ty1[1];
               if(typeof ty2 !== "number" && 10 === ty2[0]){
                var rest2$9 = ty2[1];
                return [10, trans(rest1$9, rest2$9)];
               }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
              case 11:
               var rest1$10 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   var rest2$10 = ty2[1];
                   return [11, trans(rest1$10, rest2$10)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
              case 12:
               var rest1$11 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   var rest2$11 = ty2[1];
                   return [12, trans(rest1$11, rest2$11)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
              case 13:
               var rest1$12 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   var rest2$12 = ty2[1];
                   return [13, trans(rest1$12, rest2$12)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              default:
               var rest1$13 = ty1[1];
               if(typeof ty2 !== "number")
                switch(ty2[0]){
                  case 10:
                   break a;
                  case 11:
                   break b;
                  case 12:
                   break c;
                  case 13:
                   break d;
                  case 14:
                   var rest2$13 = ty2[1];
                   return [14, trans(rest1$13, rest2$13)];
                }
               throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           if(typeof ty2 === "number") return 0;
           switch(ty2[0]){
             case 10:
              break a;
             case 11:
              break b;
             case 12:
              break c;
             case 13:
              break d;
             case 14:
              break e;
             case 8:
              break f;
             case 9: break;
             default:
              throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           }
          }
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        }
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function fmtty_of_fmt(fmtty){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number") return 0;
     switch(fmtty$0[0]){
       case 0:
        var rest = fmtty$0[1]; return [0, fmtty_of_fmt(rest)];
       case 1:
        var rest$0 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$0)];
       case 2:
        var rest$1 = fmtty$0[2], pad = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
       case 3:
        var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
       case 4:
        var
         rest$3 = fmtty$0[4],
         prec = fmtty$0[3],
         pad$1 = fmtty$0[2],
         ty_rest = fmtty_of_fmt(rest$3),
         prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
        return fmtty_of_padding_fmtty(pad$1, prec_ty);
       case 5:
        var
         rest$4 = fmtty$0[4],
         prec$0 = fmtty$0[3],
         pad$2 = fmtty$0[2],
         ty_rest$0 = fmtty_of_fmt(rest$4),
         prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
        return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
       case 6:
        var
         rest$5 = fmtty$0[4],
         prec$1 = fmtty$0[3],
         pad$3 = fmtty$0[2],
         ty_rest$1 = fmtty_of_fmt(rest$5),
         prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
        return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
       case 7:
        var
         rest$6 = fmtty$0[4],
         prec$2 = fmtty$0[3],
         pad$4 = fmtty$0[2],
         ty_rest$2 = fmtty_of_fmt(rest$6),
         prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
        return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
       case 8:
        var
         rest$7 = fmtty$0[4],
         prec$3 = fmtty$0[3],
         pad$5 = fmtty$0[2],
         ty_rest$3 = fmtty_of_fmt(rest$7),
         prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
        return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
       case 9:
        var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
        return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
       case 10:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 11:
        var fmtty$2 = fmtty$0[2]; fmtty$0 = fmtty$2; break;
       case 12:
        var fmtty$3 = fmtty$0[2]; fmtty$0 = fmtty$3; break;
       case 13:
        var rest$9 = fmtty$0[3], ty = fmtty$0[2];
        return [8, ty, fmtty_of_fmt(rest$9)];
       case 14:
        var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
        return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
       case 15:
        var rest$11 = fmtty$0[1]; return [10, fmtty_of_fmt(rest$11)];
       case 16:
        var rest$12 = fmtty$0[1]; return [11, fmtty_of_fmt(rest$12)];
       case 17:
        var fmtty$4 = fmtty$0[2]; fmtty$0 = fmtty$4; break;
       case 18:
        var
         rest$13 = fmtty$0[2],
         formatting_gen = fmtty$0[1],
         _cB_ = fmtty_of_fmt(rest$13);
        if(0 === formatting_gen[0])
         var fmt = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt);
        else
         var fmt$0 = formatting_gen[1][1], _cC_ = fmtty_of_fmt(fmt$0);
        return caml_call2(CamlinternalFormatBasics[1], _cC_, _cB_);
       case 19:
        var rest$14 = fmtty$0[1]; return [13, fmtty_of_fmt(rest$14)];
       case 20:
        var rest$15 = fmtty$0[3]; return [1, fmtty_of_fmt(rest$15)];
       case 21:
        var rest$16 = fmtty$0[2]; return [2, fmtty_of_fmt(rest$16)];
       case 22:
        var rest$17 = fmtty$0[1]; return [0, fmtty_of_fmt(rest$17)];
       case 23:
        var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            return [14, fmtty_of_fmt(fmtty$5)];
           default: fmtty$0 = fmtty$5;
         }
        else
         switch(ign[0]){
           case 0:
            fmtty$0 = fmtty$5; break;
           case 1:
            fmtty$0 = fmtty$5; break;
           case 2:
            fmtty$0 = fmtty$5; break;
           case 3:
            fmtty$0 = fmtty$5; break;
           case 4:
            fmtty$0 = fmtty$5; break;
           case 5:
            fmtty$0 = fmtty$5; break;
           case 6:
            fmtty$0 = fmtty$5; break;
           case 7:
            fmtty$0 = fmtty$5; break;
           case 8:
            fmtty$0 = fmtty$5; break;
           case 9:
            var fmtty$6 = ign[2], _cD_ = fmtty_of_fmt(fmtty$5);
            return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _cD_);
           case 10:
            fmtty$0 = fmtty$5; break;
           default: fmtty$0 = fmtty$5;
         }
        break;
       default:
        var rest$18 = fmtty$0[3], arity = fmtty$0[1];
        return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
     }
    }
   }
   function fmtty_of_custom(arity, fmtty){
    if(! arity) return fmtty;
    var arity$0 = arity[1];
    return [12, fmtty_of_custom(arity$0, fmtty)];
   }
   function fmtty_of_padding_fmtty(pad, fmtty){
    return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
   }
   function fmtty_of_precision_fmtty(prec, fmtty){
    return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
   }
   var
    Type_mismatch =
      [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)],
    cst_d = "%d",
    cst_d$0 = "%+d",
    cst_d$1 = "% d",
    cst_i$0 = cst_i$3,
    cst_i$1 = "%+i",
    cst_i$2 = "% i",
    cst_x = "%x",
    cst_x$0 = "%#x",
    cst_X = "%X",
    cst_X$0 = "%#X",
    cst_o = "%o",
    cst_o$0 = "%#o",
    cst_u = cst_u$0,
    cst_Ld = "%Ld",
    cst_Ld$0 = "%+Ld",
    cst_Ld$1 = "% Ld",
    cst_Li$0 = cst_Li$3,
    cst_Li$1 = "%+Li",
    cst_Li$2 = "% Li",
    cst_Lx = "%Lx",
    cst_Lx$0 = "%#Lx",
    cst_LX = "%LX",
    cst_LX$0 = "%#LX",
    cst_Lo = "%Lo",
    cst_Lo$0 = "%#Lo",
    cst_Lu = "%Lu",
    cst_ld = "%ld",
    cst_ld$0 = "%+ld",
    cst_ld$1 = "% ld",
    cst_li$0 = cst_li$3,
    cst_li$1 = "%+li",
    cst_li$2 = "% li",
    cst_lx = "%lx",
    cst_lx$0 = "%#lx",
    cst_lX = "%lX",
    cst_lX$0 = "%#lX",
    cst_lo = "%lo",
    cst_lo$0 = "%#lo",
    cst_lu = "%lu",
    cst_nd = "%nd",
    cst_nd$0 = "%+nd",
    cst_nd$1 = "% nd",
    cst_ni$0 = cst_ni$3,
    cst_ni$1 = "%+ni",
    cst_ni$2 = "% ni",
    cst_nx = "%nx",
    cst_nx$0 = "%#nx",
    cst_nX = "%nX",
    cst_nX$0 = "%#nX",
    cst_no = "%no",
    cst_no$0 = "%#no",
    cst_nu = "%nu",
    _r_ = [0, 103],
    cst_neg_infinity = "neg_infinity",
    cst_infinity = "infinity",
    cst_nan = "nan",
    _s_ = [0, cst_camlinternalFormat_ml, 1558, 4],
    cst_Printf_bad_conversion = "Printf: bad conversion %[",
    _t_ = [0, cst_camlinternalFormat_ml, 1626, 39],
    _u_ = [0, cst_camlinternalFormat_ml, 1649, 31],
    _v_ = [0, cst_camlinternalFormat_ml, 1650, 31],
    cst_Printf_bad_conversion$0 = "Printf: bad conversion %_",
    _w_ = [0, cst_camlinternalFormat_ml, 1830, 8],
    _x_ = [0, 0, 4],
    _y_ =
      [0,
       [11, "invalid box description ", [3, 0, 0]],
       "invalid box description %S"],
    _z_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]]],
       "invalid format %S: at character number %d, %s"],
    cst_non_zero_widths_are_unsupp =
      "non-zero widths are unsupported for %c conversions",
    _A_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]]]],
       "invalid format %S: at character number %d, '%c' without %s"],
    _B_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]]]],
       "invalid format %S: at character number %d, %s expected, read %C"],
    _C_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]]]],
       "invalid format %S: at character number %d, duplicate flag %C"],
    cst_padding = "padding",
    _D_ = [0, 1, 0],
    cst_0 = cst_0$3,
    _E_ = [0, 0],
    cst_precision = cst_precision$3,
    _F_ = [1, 0],
    _G_ = [1, 1],
    cst_precision$0 = cst_precision$3,
    _H_ = [1, 1],
    cst_precision$1 = cst_precision$3,
    cst_0$0 = cst_0$3,
    _I_ = [1, 1],
    cst_0$1 = cst_0$3,
    cst_0$2 = "'0'",
    _J_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]]]]],
       'invalid format %S: at character number %d, invalid conversion "%%%c"'],
    _K_ = [0, 0],
    cst_padding$0 = "`padding'",
    _L_ = [0, 0],
    cst_precision$2 = "`precision'",
    _M_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            ", flag ",
            [1,
             [11,
              " is only allowed after the '",
              [12, 37, [11, "', before padding and precision", 0]]]]]]]]],
       "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"],
    _N_ = [0, [12, 64, 0]],
    _O_ = [0, "@ ", 1, 0],
    _P_ = [0, "@,", 0, 0],
    _Q_ = [2, 60],
    _R_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": '",
          [12,
           37,
           [11,
            "' alone is not accepted in character sets, use ",
            [12,
             37,
             [12,
              37,
              [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]]]]]]]],
       "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."],
    _S_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ": integer ",
          [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]]]],
       "invalid format %S: integer %d is greater than the limit %d"],
    _T_ = [0, cst_camlinternalFormat_ml, 2837, 11],
    cst_digit = "digit",
    _U_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          ': unclosed sub-format, expected "',
          [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]]]],
       'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'],
    cst_character = "character ')'",
    cst_character$0 = "character '}'",
    _V_ = [0, cst_camlinternalFormat_ml, 2899, 34],
    _W_ = [0, cst_camlinternalFormat_ml, 2935, 28],
    _X_ = [0, cst_camlinternalFormat_ml, 2957, 11],
    _Y_ =
      [0,
       [11,
        cst_invalid_format,
        [3,
         0,
         [11,
          cst_at_character_number,
          [4,
           0,
           0,
           0,
           [11,
            cst$44,
            [2,
             0,
             [11,
              " is incompatible with '",
              [0, [11, "' in sub-format ", [3, 0, 0]]]]]]]]]],
       "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"],
    _Z_ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0],
    ___ =
      [0,
       [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
       cst_bad_input_format_type_mism$0];
   function type_padding(pad, fmtty){
    if(typeof pad === "number") return [0, 0, fmtty];
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     return [0, [0, padty, w], fmtty];
    }
    if(typeof fmtty !== "number" && 2 === fmtty[0]){
     var rest = fmtty[1], padty$0 = pad[1];
     return [0, [1, padty$0], rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_padprec(pad, prec, fmtty){
    var match = type_padding(pad, fmtty);
    if(typeof prec !== "number"){
     var rest$1 = match[2], pad$2 = match[1], p = prec[1];
     return [0, pad$2, [0, p], rest$1];
    }
    if(! prec){
     var rest$0 = match[2], pad$1 = match[1];
     return [0, pad$1, 0, rest$0];
    }
    var match$0 = match[2];
    if(typeof match$0 !== "number" && 2 === match$0[0]){
     var rest = match$0[1], pad$0 = match[1];
     return [0, pad$0, 1, rest];
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_format(fmt, fmtty){
    var _cA_ = type_format_gen(fmt, fmtty);
    if(typeof _cA_[2] !== "number")
     throw caml_maybe_attach_backtrace(Type_mismatch, 1);
    var fmt$0 = _cA_[1];
    return fmt$0;
   }
   function type_format_gen(fmt, fmtty0){
    if(typeof fmt === "number") return [0, 0, fmtty0];
    switch(fmt[0]){
      case 0:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest = fmtty0[1],
         fmt_rest = fmt[1],
         match = type_format_gen(fmt_rest, fmtty_rest),
         fmtty = match[2],
         fmt$0 = match[1];
        return [0, [0, fmt$0], fmtty];
       }
       break;
      case 1:
       if(typeof fmtty0 !== "number" && 0 === fmtty0[0]){
        var
         fmtty_rest$0 = fmtty0[1],
         fmt_rest$0 = fmt[1],
         match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0),
         fmtty$0 = match$0[2],
         fmt$1 = match$0[1];
        return [0, [1, fmt$1], fmtty$0];
       }
       break;
      case 2:
       var
        fmt_rest$1 = fmt[2],
        pad = fmt[1],
        match$1 = type_padding(pad, fmtty0),
        pad$0 = match$1[1],
        match$2 = match$1[2];
       if(typeof match$2 !== "number" && 1 === match$2[0]){
        var
         fmtty_rest$1 = match$2[1],
         match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1),
         fmtty$1 = match$3[2],
         fmt$2 = match$3[1];
        return [0, [2, pad$0, fmt$2], fmtty$1];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 3:
       var
        fmt_rest$2 = fmt[2],
        pad$1 = fmt[1],
        match$4 = type_padding(pad$1, fmtty0),
        pad$2 = match$4[1],
        match$5 = match$4[2];
       if(typeof match$5 !== "number" && 1 === match$5[0]){
        var
         fmtty_rest$2 = match$5[1],
         match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2),
         fmtty$2 = match$6[2],
         fmt$3 = match$6[1];
        return [0, [3, pad$2, fmt$3], fmtty$2];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 4:
       var
        fmt_rest$3 = fmt[4],
        prec = fmt[3],
        pad$3 = fmt[2],
        iconv = fmt[1],
        match$7 = type_padprec(pad$3, prec, fmtty0),
        pad$4 = match$7[1],
        match$8 = match$7[3];
       if(typeof match$8 !== "number" && 2 === match$8[0]){
        var
         fmtty_rest$3 = match$8[1],
         prec$0 = match$7[2],
         match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3),
         fmtty$3 = match$9[2],
         fmt$4 = match$9[1];
        return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 5:
       var
        fmt_rest$4 = fmt[4],
        prec$1 = fmt[3],
        pad$5 = fmt[2],
        iconv$0 = fmt[1],
        match$10 = type_padprec(pad$5, prec$1, fmtty0),
        pad$6 = match$10[1],
        match$11 = match$10[3];
       if(typeof match$11 !== "number" && 3 === match$11[0]){
        var
         fmtty_rest$4 = match$11[1],
         prec$2 = match$10[2],
         match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4),
         fmtty$4 = match$12[2],
         fmt$5 = match$12[1];
        return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 6:
       var
        fmt_rest$5 = fmt[4],
        prec$3 = fmt[3],
        pad$7 = fmt[2],
        iconv$1 = fmt[1],
        match$13 = type_padprec(pad$7, prec$3, fmtty0),
        pad$8 = match$13[1],
        match$14 = match$13[3];
       if(typeof match$14 !== "number" && 4 === match$14[0]){
        var
         fmtty_rest$5 = match$14[1],
         prec$4 = match$13[2],
         match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5),
         fmtty$5 = match$15[2],
         fmt$6 = match$15[1];
        return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 7:
       var
        fmt_rest$6 = fmt[4],
        prec$5 = fmt[3],
        pad$9 = fmt[2],
        iconv$2 = fmt[1],
        match$16 = type_padprec(pad$9, prec$5, fmtty0),
        pad$10 = match$16[1],
        match$17 = match$16[3];
       if(typeof match$17 !== "number" && 5 === match$17[0]){
        var
         fmtty_rest$6 = match$17[1],
         prec$6 = match$16[2],
         match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6),
         fmtty$6 = match$18[2],
         fmt$7 = match$18[1];
        return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 8:
       var
        fmt_rest$7 = fmt[4],
        prec$7 = fmt[3],
        pad$11 = fmt[2],
        fconv = fmt[1],
        match$19 = type_padprec(pad$11, prec$7, fmtty0),
        pad$12 = match$19[1],
        match$20 = match$19[3];
       if(typeof match$20 !== "number" && 6 === match$20[0]){
        var
         fmtty_rest$7 = match$20[1],
         prec$8 = match$19[2],
         match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7),
         fmtty$7 = match$21[2],
         fmt$8 = match$21[1];
        return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 9:
       var
        fmt_rest$8 = fmt[2],
        pad$13 = fmt[1],
        match$22 = type_padding(pad$13, fmtty0),
        pad$14 = match$22[1],
        match$23 = match$22[2];
       if(typeof match$23 !== "number" && 7 === match$23[0]){
        var
         fmtty_rest$8 = match$23[1],
         match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8),
         fmtty$8 = match$24[2],
         fmt$9 = match$24[1];
        return [0, [9, pad$14, fmt$9], fmtty$8];
       }
       throw caml_maybe_attach_backtrace(Type_mismatch, 1);
      case 10:
       var
        fmt_rest$9 = fmt[1],
        match$25 = type_format_gen(fmt_rest$9, fmtty0),
        fmtty$9 = match$25[2],
        fmt$10 = match$25[1];
       return [0, [10, fmt$10], fmtty$9];
      case 11:
       var
        fmt_rest$10 = fmt[2],
        str = fmt[1],
        match$26 = type_format_gen(fmt_rest$10, fmtty0),
        fmtty$10 = match$26[2],
        fmt$11 = match$26[1];
       return [0, [11, str, fmt$11], fmtty$10];
      case 12:
       var
        fmt_rest$11 = fmt[2],
        chr = fmt[1],
        match$27 = type_format_gen(fmt_rest$11, fmtty0),
        fmtty$11 = match$27[2],
        fmt$12 = match$27[1];
       return [0, [12, chr, fmt$12], fmtty$11];
      case 13:
       if(typeof fmtty0 !== "number" && 8 === fmtty0[0]){
        var
         fmtty_rest$9 = fmtty0[2],
         sub_fmtty = fmtty0[1],
         fmt_rest$12 = fmt[3],
         sub_fmtty$0 = fmt[2],
         pad_opt = fmt[1];
        if(caml_notequal([0, sub_fmtty$0], [0, sub_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9),
         fmtty$12 = match$28[2],
         fmt$13 = match$28[1];
        return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
       }
       break;
      case 14:
       if(typeof fmtty0 !== "number" && 9 === fmtty0[0]){
        var
         fmtty_rest$10 = fmtty0[3],
         sub_fmtty1 = fmtty0[1],
         fmt_rest$13 = fmt[3],
         sub_fmtty$1 = fmt[2],
         pad_opt$0 = fmt[1],
         _cy_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _cy_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$29 =
           type_format_gen
            (fmt_rest$13,
             caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)),
         fmtty$13 = match$29[2],
         fmt$14 = match$29[1];
        return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
       }
       break;
      case 15:
       if(typeof fmtty0 !== "number" && 10 === fmtty0[0]){
        var
         fmtty_rest$11 = fmtty0[1],
         fmt_rest$14 = fmt[1],
         match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11),
         fmtty$14 = match$30[2],
         fmt$15 = match$30[1];
        return [0, [15, fmt$15], fmtty$14];
       }
       break;
      case 16:
       if(typeof fmtty0 !== "number" && 11 === fmtty0[0]){
        var
         fmtty_rest$12 = fmtty0[1],
         fmt_rest$15 = fmt[1],
         match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12),
         fmtty$15 = match$31[2],
         fmt$16 = match$31[1];
        return [0, [16, fmt$16], fmtty$15];
       }
       break;
      case 17:
       var
        fmt_rest$16 = fmt[2],
        formatting_lit = fmt[1],
        match$32 = type_format_gen(fmt_rest$16, fmtty0),
        fmtty$16 = match$32[2],
        fmt$17 = match$32[1];
       return [0, [17, formatting_lit, fmt$17], fmtty$16];
      case 18:
       var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
       if(0 === formatting_gen[0]){
        var
         match$36 = formatting_gen[1],
         str$0 = match$36[2],
         fmt1 = match$36[1],
         match$37 = type_format_gen(fmt1, fmtty0),
         fmtty2 = match$37[2],
         fmt2 = match$37[1],
         match$38 = type_format_gen(fmt_rest$17, fmtty2),
         fmtty3 = match$38[2],
         fmt3 = match$38[1];
        return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
       }
       var
        match$39 = formatting_gen[1],
        str$1 = match$39[2],
        fmt1$0 = match$39[1],
        match$40 = type_format_gen(fmt1$0, fmtty0),
        fmtty2$0 = match$40[2],
        fmt2$0 = match$40[1],
        match$41 = type_format_gen(fmt_rest$17, fmtty2$0),
        fmtty3$0 = match$41[2],
        fmt3$0 = match$41[1];
       return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
      case 19:
       if(typeof fmtty0 !== "number" && 13 === fmtty0[0]){
        var
         fmtty_rest$13 = fmtty0[1],
         fmt_rest$18 = fmt[1],
         match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13),
         fmtty$17 = match$33[2],
         fmt$18 = match$33[1];
        return [0, [19, fmt$18], fmtty$17];
       }
       break;
      case 20:
       if(typeof fmtty0 !== "number" && 1 === fmtty0[0]){
        var
         fmtty_rest$14 = fmtty0[1],
         fmt_rest$19 = fmt[3],
         char_set = fmt[2],
         width_opt = fmt[1],
         match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14),
         fmtty$18 = match$34[2],
         fmt$19 = match$34[1];
        return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
       }
       break;
      case 21:
       if(typeof fmtty0 !== "number" && 2 === fmtty0[0]){
        var
         fmtty_rest$15 = fmtty0[1],
         fmt_rest$20 = fmt[2],
         counter = fmt[1],
         match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15),
         fmtty$19 = match$35[2],
         fmt$20 = match$35[1];
        return [0, [21, counter, fmt$20], fmtty$19];
       }
       break;
      case 23:
       var rest = fmt[2], ign = fmt[1];
       if(typeof ign !== "number")
        switch(ign[0]){
          case 0:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 1:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 2:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 3:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 4:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 5:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 6:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 7:
           return type_ignored_param_one(ign, rest, fmtty0);
          case 8:
           var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
           return type_ignored_param_one
                   ([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
          case 9:
           var
            sub_fmtty$3 = ign[2],
            pad_opt$2 = ign[1],
            _cz_ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0),
            match$43 = _cz_[2],
            fmtty$21 = match$43[2],
            fmt$22 = match$43[1],
            sub_fmtty$4 = _cz_[1];
           return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
          case 10:
           return type_ignored_param_one(ign, rest, fmtty0);
          default: return type_ignored_param_one(ign, rest, fmtty0);
        }
       switch(ign){
         case 0:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 1:
          return type_ignored_param_one(ign, rest, fmtty0);
         case 2:
          if(typeof fmtty0 !== "number" && 14 === fmtty0[0]){
           var
            fmtty_rest$16 = fmtty0[1],
            match$42 = type_format_gen(rest, fmtty_rest$16),
            fmtty$20 = match$42[2],
            fmt$21 = match$42[1];
           return [0, [23, 2, fmt$21], fmtty$20];
          }
          throw caml_maybe_attach_backtrace(Type_mismatch, 1);
         default: return type_ignored_param_one(ign, rest, fmtty0);
       }
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function type_ignored_param_one(ign, fmt, fmtty){
    var
     match = type_format_gen(fmt, fmtty),
     fmtty$0 = match[2],
     fmt$0 = match[1];
    return [0, [23, ign, fmt$0], fmtty$0];
   }
   function type_ignored_format_substituti(sub_fmtty, fmt, fmtty){
    if(typeof sub_fmtty === "number")
     return [0, 0, type_format_gen(fmt, fmtty)];
    switch(sub_fmtty[0]){
      case 0:
       if(typeof fmtty !== "number" && 0 === fmtty[0]){
        var
         fmtty_rest = fmtty[1],
         sub_fmtty_rest = sub_fmtty[1],
         match =
           type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest),
         fmt$0 = match[2],
         sub_fmtty_rest$0 = match[1];
        return [0, [0, sub_fmtty_rest$0], fmt$0];
       }
       break;
      case 1:
       if(typeof fmtty !== "number" && 1 === fmtty[0]){
        var
         fmtty_rest$0 = fmtty[1],
         sub_fmtty_rest$1 = sub_fmtty[1],
         match$0 =
           type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0),
         fmt$1 = match$0[2],
         sub_fmtty_rest$2 = match$0[1];
        return [0, [1, sub_fmtty_rest$2], fmt$1];
       }
       break;
      case 2:
       if(typeof fmtty !== "number" && 2 === fmtty[0]){
        var
         fmtty_rest$1 = fmtty[1],
         sub_fmtty_rest$3 = sub_fmtty[1],
         match$1 =
           type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1),
         fmt$2 = match$1[2],
         sub_fmtty_rest$4 = match$1[1];
        return [0, [2, sub_fmtty_rest$4], fmt$2];
       }
       break;
      case 3:
       if(typeof fmtty !== "number" && 3 === fmtty[0]){
        var
         fmtty_rest$2 = fmtty[1],
         sub_fmtty_rest$5 = sub_fmtty[1],
         match$2 =
           type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2),
         fmt$3 = match$2[2],
         sub_fmtty_rest$6 = match$2[1];
        return [0, [3, sub_fmtty_rest$6], fmt$3];
       }
       break;
      case 4:
       if(typeof fmtty !== "number" && 4 === fmtty[0]){
        var
         fmtty_rest$3 = fmtty[1],
         sub_fmtty_rest$7 = sub_fmtty[1],
         match$3 =
           type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3),
         fmt$4 = match$3[2],
         sub_fmtty_rest$8 = match$3[1];
        return [0, [4, sub_fmtty_rest$8], fmt$4];
       }
       break;
      case 5:
       if(typeof fmtty !== "number" && 5 === fmtty[0]){
        var
         fmtty_rest$4 = fmtty[1],
         sub_fmtty_rest$9 = sub_fmtty[1],
         match$4 =
           type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4),
         fmt$5 = match$4[2],
         sub_fmtty_rest$10 = match$4[1];
        return [0, [5, sub_fmtty_rest$10], fmt$5];
       }
       break;
      case 6:
       if(typeof fmtty !== "number" && 6 === fmtty[0]){
        var
         fmtty_rest$5 = fmtty[1],
         sub_fmtty_rest$11 = sub_fmtty[1],
         match$5 =
           type_ignored_format_substituti
            (sub_fmtty_rest$11, fmt, fmtty_rest$5),
         fmt$6 = match$5[2],
         sub_fmtty_rest$12 = match$5[1];
        return [0, [6, sub_fmtty_rest$12], fmt$6];
       }
       break;
      case 7:
       if(typeof fmtty !== "number" && 7 === fmtty[0]){
        var
         fmtty_rest$6 = fmtty[1],
         sub_fmtty_rest$13 = sub_fmtty[1],
         match$6 =
           type_ignored_format_substituti
            (sub_fmtty_rest$13, fmt, fmtty_rest$6),
         fmt$7 = match$6[2],
         sub_fmtty_rest$14 = match$6[1];
        return [0, [7, sub_fmtty_rest$14], fmt$7];
       }
       break;
      case 8:
       if(typeof fmtty !== "number" && 8 === fmtty[0]){
        var
         fmtty_rest$7 = fmtty[2],
         sub2_fmtty = fmtty[1],
         sub_fmtty_rest$15 = sub_fmtty[2],
         sub2_fmtty$0 = sub_fmtty[1];
        if(caml_notequal([0, sub2_fmtty$0], [0, sub2_fmtty]))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         match$7 =
           type_ignored_format_substituti
            (sub_fmtty_rest$15, fmt, fmtty_rest$7),
         fmt$8 = match$7[2],
         sub_fmtty_rest$16 = match$7[1];
        return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
       }
       break;
      case 9:
       if(typeof fmtty !== "number" && 9 === fmtty[0]){
        var
         fmtty_rest$8 = fmtty[3],
         sub2_fmtty$1 = fmtty[2],
         sub1_fmtty = fmtty[1],
         sub_fmtty_rest$17 = sub_fmtty[3],
         sub2_fmtty$2 = sub_fmtty[2],
         sub1_fmtty$0 = sub_fmtty[1],
         _cw_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _cw_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var _cx_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
        if
         (caml_notequal
           ([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _cx_))
         throw caml_maybe_attach_backtrace(Type_mismatch, 1);
        var
         sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1),
         match$8 = fmtty_rel_det(sub_fmtty$0),
         f4 = match$8[4],
         f2 = match$8[2];
        f2(0);
        f4(0);
        var
         match$9 =
           type_ignored_format_substituti
            (caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
             fmt,
             fmtty_rest$8),
         fmt$9 = match$9[2],
         sub_fmtty_rest$18 = match$9[1];
        return [0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9];
       }
       break;
      case 10:
       if(typeof fmtty !== "number" && 10 === fmtty[0]){
        var
         fmtty_rest$9 = fmtty[1],
         sub_fmtty_rest$19 = sub_fmtty[1],
         match$10 =
           type_ignored_format_substituti
            (sub_fmtty_rest$19, fmt, fmtty_rest$9),
         fmt$10 = match$10[2],
         sub_fmtty_rest$20 = match$10[1];
        return [0, [10, sub_fmtty_rest$20], fmt$10];
       }
       break;
      case 11:
       if(typeof fmtty !== "number" && 11 === fmtty[0]){
        var
         fmtty_rest$10 = fmtty[1],
         sub_fmtty_rest$21 = sub_fmtty[1],
         match$11 =
           type_ignored_format_substituti
            (sub_fmtty_rest$21, fmt, fmtty_rest$10),
         fmt$11 = match$11[2],
         sub_fmtty_rest$22 = match$11[1];
        return [0, [11, sub_fmtty_rest$22], fmt$11];
       }
       break;
      case 13:
       if(typeof fmtty !== "number" && 13 === fmtty[0]){
        var
         fmtty_rest$11 = fmtty[1],
         sub_fmtty_rest$23 = sub_fmtty[1],
         match$12 =
           type_ignored_format_substituti
            (sub_fmtty_rest$23, fmt, fmtty_rest$11),
         fmt$12 = match$12[2],
         sub_fmtty_rest$24 = match$12[1];
        return [0, [13, sub_fmtty_rest$24], fmt$12];
       }
       break;
      case 14:
       if(typeof fmtty !== "number" && 14 === fmtty[0]){
        var
         fmtty_rest$12 = fmtty[1],
         sub_fmtty_rest$25 = sub_fmtty[1],
         match$13 =
           type_ignored_format_substituti
            (sub_fmtty_rest$25, fmt, fmtty_rest$12),
         fmt$13 = match$13[2],
         sub_fmtty_rest$26 = match$13[1];
        return [0, [14, sub_fmtty_rest$26], fmt$13];
       }
       break;
    }
    throw caml_maybe_attach_backtrace(Type_mismatch, 1);
   }
   function recast(fmt, fmtty){
    var _cv_ = symm(fmtty);
    return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _cv_));
   }
   function fix_padding(padty, width, str){
    var
     len = caml_ml_string_length(str),
     padty$0 = 0 <= width ? padty : 0,
     width$0 = caml_call1(Stdlib[18], width);
    if(width$0 <= len) return str;
    var
     _cu_ = 2 === padty$0 ? 48 : 32,
     res = caml_call2(Stdlib_Bytes[1], width$0, _cu_);
    switch(padty$0){
      case 0:
       caml_call5(Stdlib_String[6], str, 0, res, 0, len); break;
      case 1:
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
       break;
      default:
       a:
       if(0 < len){
        if
         (43 !== caml_string_get(str, 0)
          && 45 !== caml_string_get(str, 0) && 32 !== caml_string_get(str, 0))
         break a;
        caml_bytes_set(res, 0, caml_string_get(str, 0));
        caml_call5
         (Stdlib_String[6],
          str,
          1,
          res,
          (width$0 - len | 0) + 1 | 0,
          len - 1 | 0);
        break;
       }
       a:
       if(1 < len && 48 === caml_string_get(str, 0)){
        if(120 !== caml_string_get(str, 1) && 88 !== caml_string_get(str, 1))
         break a;
        caml_bytes_set(res, 1, caml_string_get(str, 1));
        caml_call5
         (Stdlib_String[6],
          str,
          2,
          res,
          (width$0 - len | 0) + 2 | 0,
          len - 2 | 0);
        break;
       }
       caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
    }
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function fix_int_precision(prec, str){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     len = caml_ml_string_length(str),
     c = caml_string_get(str, 0);
    a:
    {
     b:
     {
      if(58 > c){
       if(32 !== c){
        if(43 > c) break a;
        switch(c - 43 | 0){
          case 5:
           c:
           if(len < (prec$0 + 2 | 0) && 1 < len){
            if
             (120 !== caml_string_get(str, 1)
              && 88 !== caml_string_get(str, 1))
             break c;
            var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
            caml_bytes_set(res$1, 1, caml_string_get(str, 1));
            caml_call5
             (Stdlib_String[6],
              str,
              2,
              res$1,
              (prec$0 - len | 0) + 4 | 0,
              len - 2 | 0);
            return caml_call1(Stdlib_Bytes[44], res$1);
           }
           break b;
          case 0:
          case 2: break;
          case 1:
          case 3:
          case 4:
           break a;
          default: break b;
        }
       }
       if(len >= (prec$0 + 1 | 0)) break a;
       var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
       caml_bytes_set(res$0, 0, c);
       caml_call5
        (Stdlib_String[6],
         str,
         1,
         res$0,
         (prec$0 - len | 0) + 2 | 0,
         len - 1 | 0);
       return caml_call1(Stdlib_Bytes[44], res$0);
      }
      if(71 <= c){if(5 < c - 97 >>> 0) break a;} else if(65 > c) break a;
     }
     if(len < prec$0){
      var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
      caml_call5(Stdlib_String[6], str, 0, res, prec$0 - len | 0, len);
      return caml_call1(Stdlib_Bytes[44], res);
     }
    }
    return str;
   }
   function string_to_caml_string(str){
    var
     str$0 = caml_call1(Stdlib_String[25], str),
     l = caml_ml_string_length(str$0),
     res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
    caml_blit_string(str$0, 0, res, 1, l);
    return caml_call1(Stdlib_Bytes[44], res);
   }
   function format_of_fconv(fconv, prec){
    var
     prec$0 = caml_call1(Stdlib[18], prec),
     symb = char_of_fconv(_r_, fconv),
     buf = buffer_create(16);
    buffer_add_char(buf, 37);
    bprint_fconv_flag(buf, fconv);
    buffer_add_char(buf, 46);
    buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
    buffer_add_char(buf, symb);
    return buffer_contents(buf);
   }
   function transform_int_alt(iconv, s){
    if(13 > iconv) return s;
    var n = [0, 0], _cp_ = caml_ml_string_length(s) - 1 | 0, _co_ = 0;
    if(_cp_ >= 0){
     var i$0 = _co_;
     for(;;){
      if(9 >= caml_string_unsafe_get(s, i$0) - 48 >>> 0) n[1]++;
      var _ct_ = i$0 + 1 | 0;
      if(_cp_ === i$0) break;
      i$0 = _ct_;
     }
    }
    var
     digits = n[1],
     buf =
       caml_create_bytes
        (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
     pos = [0, 0];
    function put(c){caml_bytes_set(buf, pos[1], c); pos[1]++; return;}
    var
     left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0],
     _cr_ = caml_ml_string_length(s) - 1 | 0,
     _cq_ = 0;
    if(_cr_ >= 0){
     var i = _cq_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      if(9 < c - 48 >>> 0)
       put(c);
      else{if(0 === left[1]){put(95); left[1] = 3;} left[1]--; put(c);}
      var _cs_ = i + 1 | 0;
      if(_cr_ === i) break;
      i = _cs_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], buf);
   }
   function convert_int(iconv, n){
    switch(iconv){
      case 1:
       var _cn_ = cst_d$0; break;
      case 2:
       var _cn_ = cst_d$1; break;
      case 4:
       var _cn_ = cst_i$1; break;
      case 5:
       var _cn_ = cst_i$2; break;
      case 6:
       var _cn_ = cst_x; break;
      case 7:
       var _cn_ = cst_x$0; break;
      case 8:
       var _cn_ = cst_X; break;
      case 9:
       var _cn_ = cst_X$0; break;
      case 10:
       var _cn_ = cst_o; break;
      case 11:
       var _cn_ = cst_o$0; break;
      case 0:
      case 13:
       var _cn_ = cst_d; break;
      case 3:
      case 14:
       var _cn_ = cst_i$0; break;
      default: var _cn_ = cst_u;
    }
    return transform_int_alt(iconv, caml_format_int(_cn_, n));
   }
   function convert_int32(iconv, n){
    switch(iconv){
      case 1:
       var _cm_ = cst_ld$0; break;
      case 2:
       var _cm_ = cst_ld$1; break;
      case 4:
       var _cm_ = cst_li$1; break;
      case 5:
       var _cm_ = cst_li$2; break;
      case 6:
       var _cm_ = cst_lx; break;
      case 7:
       var _cm_ = cst_lx$0; break;
      case 8:
       var _cm_ = cst_lX; break;
      case 9:
       var _cm_ = cst_lX$0; break;
      case 10:
       var _cm_ = cst_lo; break;
      case 11:
       var _cm_ = cst_lo$0; break;
      case 0:
      case 13:
       var _cm_ = cst_ld; break;
      case 3:
      case 14:
       var _cm_ = cst_li$0; break;
      default: var _cm_ = cst_lu;
    }
    return transform_int_alt(iconv, caml_format_int(_cm_, n));
   }
   function convert_nativeint(iconv, n){
    switch(iconv){
      case 1:
       var _cl_ = cst_nd$0; break;
      case 2:
       var _cl_ = cst_nd$1; break;
      case 4:
       var _cl_ = cst_ni$1; break;
      case 5:
       var _cl_ = cst_ni$2; break;
      case 6:
       var _cl_ = cst_nx; break;
      case 7:
       var _cl_ = cst_nx$0; break;
      case 8:
       var _cl_ = cst_nX; break;
      case 9:
       var _cl_ = cst_nX$0; break;
      case 10:
       var _cl_ = cst_no; break;
      case 11:
       var _cl_ = cst_no$0; break;
      case 0:
      case 13:
       var _cl_ = cst_nd; break;
      case 3:
      case 14:
       var _cl_ = cst_ni$0; break;
      default: var _cl_ = cst_nu;
    }
    return transform_int_alt(iconv, caml_format_int(_cl_, n));
   }
   function convert_int64(iconv, n){
    switch(iconv){
      case 1:
       var _ck_ = cst_Ld$0; break;
      case 2:
       var _ck_ = cst_Ld$1; break;
      case 4:
       var _ck_ = cst_Li$1; break;
      case 5:
       var _ck_ = cst_Li$2; break;
      case 6:
       var _ck_ = cst_Lx; break;
      case 7:
       var _ck_ = cst_Lx$0; break;
      case 8:
       var _ck_ = cst_LX; break;
      case 9:
       var _ck_ = cst_LX$0; break;
      case 10:
       var _ck_ = cst_Lo; break;
      case 11:
       var _ck_ = cst_Lo$0; break;
      case 0:
      case 13:
       var _ck_ = cst_Ld; break;
      case 3:
      case 14:
       var _ck_ = cst_Li$0; break;
      default: var _ck_ = cst_Lu;
    }
    return transform_int_alt(iconv, runtime.caml_int64_format(_ck_, n));
   }
   function convert_float(fconv, prec, x){
    function hex(param){
     switch(fconv[1]){
       case 0:
        var sign = 45; break;
       case 1:
        var sign = 43; break;
       default: var sign = 32;
     }
     return runtime.caml_hexstring_of_float(x, prec, sign);
    }
    function caml_special_val(str){
     var match = runtime.caml_classify_float(x);
     return 3 === match
             ? x < 0. ? cst_neg_infinity : cst_infinity
             : 4 <= match ? cst_nan : str;
    }
    switch(fconv[2]){
      case 5:
       var
        str = caml_format_float(format_of_fconv(fconv, prec), x),
        len = caml_ml_string_length(str),
        i = 0;
       for(;;){
        if(i === len)
         var _ch_ = 0;
        else{
         var _cg_ = caml_string_get(str, i) - 46 | 0;
         a:
         {
          if(23 < _cg_ >>> 0){
           if(55 === _cg_) break a;
          }
          else if(21 < _cg_ - 1 >>> 0) break a;
          var i$0 = i + 1 | 0;
          i = i$0;
          continue;
         }
         var _ch_ = 1;
        }
        var _ci_ = _ch_ ? str : caml_call2(Stdlib[28], str, cst$17);
        return caml_special_val(_ci_);
       }
      case 6:
       return hex(0);
      case 7:
       var _cj_ = hex(0); return caml_call1(Stdlib_String[26], _cj_);
      case 8:
       return caml_special_val(hex(0));
      default: return caml_format_float(format_of_fconv(fconv, prec), x);
    }
   }
   function string_of_fmtty(fmtty){
    var buf = buffer_create(16);
    bprint_fmtty(buf, fmtty);
    return buffer_contents(buf);
   }
   function make_printf$0(counter, k, acc, fmt){
    var k$0 = k, acc$0 = acc, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, acc$0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest);};
       case 1:
        var rest$0 = fmt$0[1];
        return function(c){
         var
          str = caml_call1(Stdlib_Char[2], c),
          l = caml_ml_string_length(str),
          res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
         caml_blit_string(str, 0, res, 1, l);
         var new_acc = [4, acc$0, caml_call1(Stdlib_Bytes[44], res)];
         return make_printf(k$0, new_acc, rest$0);};
       case 2:
        var rest$1 = fmt$0[2], pad = fmt$0[1];
        return make_padding
                (k$0, acc$0, rest$1, pad, function(str){return str;});
       case 3:
        var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
       case 4:
        var
         rest$3 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
       case 5:
        var
         rest$4 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
       case 6:
        var
         rest$5 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1];
        return make_int_padding_precision
                (k$0,
                 acc$0,
                 rest$5,
                 pad$3,
                 prec$1,
                 convert_nativeint,
                 iconv$1);
       case 7:
        var
         rest$6 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1];
        return make_int_padding_precision
                (k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
       case 8:
        var
         rest$7 = fmt$0[4],
         prec$3 = fmt$0[3],
         pad$5 = fmt$0[2],
         fconv = fmt$0[1];
        if(typeof pad$5 === "number"){
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = convert_float(fconv, p, x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x);
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   };
         var p = prec$3[1];
         return function(x){
          var str = convert_float(fconv, p, x);
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        if(0 === pad$5[0]){
         var w = pad$5[2], padty = pad$5[1];
         if(typeof prec$3 === "number")
          return prec$3
                  ? function
                   (p, x){
                    var str = fix_padding(padty, w, convert_float(fconv, p, x));
                    return make_printf(k$0, [4, acc$0, str], rest$7);
                   }
                  : function
                   (x){
                    var
                     str =
                       convert_float(fconv, default_float_precision(fconv), x),
                     str$0 = fix_padding(padty, w, str);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                   };
         var p$0 = prec$3[1];
         return function(x){
          var str = fix_padding(padty, w, convert_float(fconv, p$0, x));
          return make_printf(k$0, [4, acc$0, str], rest$7);};
        }
        var padty$0 = pad$5[1];
        if(typeof prec$3 === "number")
         return prec$3
                 ? function
                  (w, p, x){
                   var
                    str = fix_padding(padty$0, w, convert_float(fconv, p, x));
                   return make_printf(k$0, [4, acc$0, str], rest$7);
                  }
                 : function
                  (w, x){
                   var
                    str =
                      convert_float(fconv, default_float_precision(fconv), x),
                    str$0 = fix_padding(padty$0, w, str);
                   return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
        var p$1 = prec$3[1];
        return function(w, x){
         var str = fix_padding(padty$0, w, convert_float(fconv, p$1, x));
         return make_printf(k$0, [4, acc$0, str], rest$7);};
       case 9:
        var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
        return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
       case 10:
        var rest$9 = fmt$0[1], acc$1 = [7, acc$0];
        acc$0 = acc$1;
        fmt$0 = rest$9;
        break;
       case 11:
        var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str];
        acc$0 = acc$2;
        fmt$0 = rest$10;
        break;
       case 12:
        var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr];
        acc$0 = acc$3;
        fmt$0 = rest$11;
        break;
       case 13:
        var
         rest$12 = fmt$0[3],
         sub_fmtty = fmt$0[2],
         ty = string_of_fmtty(sub_fmtty);
        return function(str){
         return make_printf(k$0, [4, acc$0, ty], rest$12);};
       case 14:
        var rest$13 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _cf_ = recast(fmt, fmtty);
         return make_printf
                 (k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cf_, rest$13));};
       case 15:
        var rest$14 = fmt$0[1];
        return function(f, x){
         return make_printf
                 (k$0,
                  [6, acc$0, function(o){return caml_call2(f, o, x);}],
                  rest$14);};
       case 16:
        var rest$15 = fmt$0[1];
        return function(f){return make_printf(k$0, [6, acc$0, f], rest$15);};
       case 17:
        var
         rest$16 = fmt$0[2],
         fmting_lit = fmt$0[1],
         acc$4 = [0, acc$0, fmting_lit];
        acc$0 = acc$4;
        fmt$0 = rest$16;
        break;
       case 18:
        var _cd_ = fmt$0[1];
        if(0 === _cd_[0]){
         var rest$17 = fmt$0[2], fmt$1 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$17;
         var
          k$1 =
            function(kacc){return make_printf(k, [1, acc, [0, kacc]], rest);};
         k$0 = k$1;
         acc$0 = 0;
         fmt$0 = fmt$1;
        }
        else{
         var rest$18 = fmt$0[2], fmt$2 = _cd_[1][1];
         let acc = acc$0, k = k$0, rest = rest$18;
         var
          k$2 =
            function(kacc){return make_printf(k, [1, acc, [1, kacc]], rest);};
         k$0 = k$2;
         acc$0 = 0;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
       case 20:
        var
         rest$19 = fmt$0[3],
         new_acc = [8, acc$0, cst_Printf_bad_conversion];
        return function(param){return make_printf(k$0, new_acc, rest$19);};
       case 21:
        var rest$20 = fmt$0[2];
        return function(n){
         var new_acc = [4, acc$0, caml_format_int(cst_u$0, n)];
         return make_printf(k$0, new_acc, rest$20);};
       case 22:
        var rest$21 = fmt$0[1];
        return function(c){
         var new_acc = [5, acc$0, c];
         return make_printf(k$0, new_acc, rest$21);};
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
        var counter$1 = counter + 1 | 0;
        return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
       default:
        var
         rest$23 = fmt$0[3],
         f = fmt$0[2],
         arity = fmt$0[1],
         _ce_ = caml_call1(f, 0);
        if(counter >= 50)
         return caml_trampoline_return
                 (make_custom$0, [0, k$0, acc$0, rest$23, arity, _ce_]);
        var counter$0 = counter + 1 | 0;
        return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _ce_);
     }
    }
   }
   function make_printf(k, acc, fmt){
    return caml_trampoline(make_printf$0(0, k, acc, fmt));
   }
   function make_ignored_param$0(counter, k, acc, ign, fmt){
    if(typeof ign === "number")
     switch(ign){
       case 0:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
       case 1:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$1 = counter + 1 | 0;
        return make_invalid_arg(counter$1, k, acc, fmt);
       case 2:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
       default:
        if(counter >= 50)
         return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
        var counter$2 = counter + 1 | 0;
        return make_invalid_arg(counter$2, k, acc, fmt);
     }
    switch(ign[0]){
      case 0:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$3 = counter + 1 | 0;
       return make_invalid_arg(counter$3, k, acc, fmt);
      case 1:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$4 = counter + 1 | 0;
       return make_invalid_arg(counter$4, k, acc, fmt);
      case 2:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$5 = counter + 1 | 0;
       return make_invalid_arg(counter$5, k, acc, fmt);
      case 3:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$6 = counter + 1 | 0;
       return make_invalid_arg(counter$6, k, acc, fmt);
      case 4:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$7 = counter + 1 | 0;
       return make_invalid_arg(counter$7, k, acc, fmt);
      case 5:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$8 = counter + 1 | 0;
       return make_invalid_arg(counter$8, k, acc, fmt);
      case 6:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$9 = counter + 1 | 0;
       return make_invalid_arg(counter$9, k, acc, fmt);
      case 7:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$10 = counter + 1 | 0;
       return make_invalid_arg(counter$10, k, acc, fmt);
      case 8:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$11 = counter + 1 | 0;
       return make_invalid_arg(counter$11, k, acc, fmt);
      case 9:
       var fmtty = ign[2];
       if(counter >= 50)
        return caml_trampoline_return
                (make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
       var counter$14 = counter + 1 | 0;
       return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
      case 10:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$12 = counter + 1 | 0;
       return make_invalid_arg(counter$12, k, acc, fmt);
      default:
       if(counter >= 50)
        return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
       var counter$13 = counter + 1 | 0;
       return make_invalid_arg(counter$13, k, acc, fmt);
    }
   }
   function make_ignored_param(k, acc, ign, fmt){
    return caml_trampoline(make_ignored_param$0(0, k, acc, ign, fmt));
   }
   function make_from_fmtty$0(counter, k, acc, fmtty, fmt){
    if(typeof fmtty !== "number")
     switch(fmtty[0]){
       case 0:
        var rest = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest, fmt);};
       case 1:
        var rest$0 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$0, fmt);};
       case 2:
        var rest$1 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$1, fmt);};
       case 3:
        var rest$2 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$2, fmt);};
       case 4:
        var rest$3 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$3, fmt);};
       case 5:
        var rest$4 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$4, fmt);};
       case 6:
        var rest$5 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$5, fmt);};
       case 7:
        var rest$6 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$6, fmt);};
       case 8:
        var rest$7 = fmtty[2];
        return function(param){return make_from_fmtty(k, acc, rest$7, fmt);};
       case 9:
        var
         rest$8 = fmtty[3],
         ty2 = fmtty[2],
         ty1 = fmtty[1],
         ty = trans(symm(ty1), ty2);
        return function(param){
         return make_from_fmtty
                 (k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt);};
       case 10:
        var rest$9 = fmtty[1];
        return function(_cc_, param){
         return make_from_fmtty(k, acc, rest$9, fmt);};
       case 11:
        var rest$10 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$10, fmt);};
       case 12:
        var rest$11 = fmtty[1];
        return function(param){return make_from_fmtty(k, acc, rest$11, fmt);};
       case 13:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
     }
    if(counter >= 50)
     return caml_trampoline_return(make_invalid_arg, [0, k, acc, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_invalid_arg(counter$0, k, acc, fmt);
   }
   function make_from_fmtty(k, acc, fmtty, fmt){
    return caml_trampoline(make_from_fmtty$0(0, k, acc, fmtty, fmt));
   }
   function make_invalid_arg(counter, k, acc, fmt){
    var _cb_ = [8, acc, cst_Printf_bad_conversion$0];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _cb_, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _cb_, fmt);
   }
   function make_padding(k, acc, fmt, pad, trans){
    if(typeof pad === "number")
     return function(x){
      var new_acc = [4, acc, caml_call1(trans, x)];
      return make_printf(k, new_acc, fmt);};
    if(0 === pad[0]){
     var width = pad[2], padty = pad[1];
     return function(x){
      var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans, x))];
      return make_printf(k, new_acc, fmt);};
    }
    var padty$0 = pad[1];
    return function(w, x){
     var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans, x))];
     return make_printf(k, new_acc, fmt);};
   }
   function make_int_padding_precision(k, acc, fmt, pad, prec, trans, iconv){
    if(typeof pad === "number"){
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var str = fix_int_precision(p, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = caml_call2(trans, iconv, x);
                return make_printf(k, [4, acc, str], fmt);
               };
     var p = prec[1];
     return function(x){
      var str = fix_int_precision(p, caml_call2(trans, iconv, x));
      return make_printf(k, [4, acc, str], fmt);};
    }
    if(0 === pad[0]){
     var w = pad[2], padty = pad[1];
     if(typeof prec === "number")
      return prec
              ? function
               (p, x){
                var
                 str =
                   fix_padding
                    (padty,
                     w,
                     fix_int_precision(p, caml_call2(trans, iconv, x)));
                return make_printf(k, [4, acc, str], fmt);
               }
              : function
               (x){
                var str = fix_padding(padty, w, caml_call2(trans, iconv, x));
                return make_printf(k, [4, acc, str], fmt);
               };
     var p$0 = prec[1];
     return function(x){
      var
       str =
         fix_padding
          (padty, w, fix_int_precision(p$0, caml_call2(trans, iconv, x)));
      return make_printf(k, [4, acc, str], fmt);};
    }
    var padty$0 = pad[1];
    if(typeof prec === "number")
     return prec
             ? function
              (w, p, x){
               var
                str =
                  fix_padding
                   (padty$0,
                    w,
                    fix_int_precision(p, caml_call2(trans, iconv, x)));
               return make_printf(k, [4, acc, str], fmt);
              }
             : function
              (w, x){
               var str = fix_padding(padty$0, w, caml_call2(trans, iconv, x));
               return make_printf(k, [4, acc, str], fmt);
              };
    var p$1 = prec[1];
    return function(w, x){
     var
      str =
        fix_padding
         (padty$0, w, fix_int_precision(p$1, caml_call2(trans, iconv, x)));
     return make_printf(k, [4, acc, str], fmt);};
   }
   function make_custom$0(counter, k, acc, rest, arity, f){
    if(arity){
     var arity$0 = arity[1];
     return function(x){
      return make_custom(k, acc, rest, arity$0, caml_call1(f, x));};
    }
    var _ca_ = [4, acc, f];
    if(counter >= 50)
     return caml_trampoline_return(make_printf$0, [0, k, _ca_, rest]);
    var counter$0 = counter + 1 | 0;
    return make_printf$0(counter$0, k, _ca_, rest);
   }
   function make_custom(k, acc, rest, arity, f){
    return caml_trampoline(make_custom$0(0, k, acc, rest, arity, f));
   }
   function make_iprintf$0(counter, k, o, fmt){
    var k$0 = k, fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k$0, o);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1], x = make_iprintf(k$0, o, rest);
        return function(_b$_){return x;};
       case 1:
        var rest$0 = fmt$0[1], x$0 = make_iprintf(k$0, o, rest$0);
        return function(_b__){return x$0;};
       case 2:
        var _bM_ = fmt$0[1];
        if(typeof _bM_ === "number"){
         var rest$1 = fmt$0[2], x$1 = make_iprintf(k$0, o, rest$1);
         return function(_b9_){return x$1;};
        }
        if(0 === _bM_[0]){
         var rest$2 = fmt$0[2], x$2 = make_iprintf(k$0, o, rest$2);
         return function(_b8_){return x$2;};
        }
        var
         rest$3 = fmt$0[2],
         x$3 = make_iprintf(k$0, o, rest$3),
         x$4 = function(_b7_){return x$3;};
        return function(_b6_){return x$4;};
       case 3:
        var _bN_ = fmt$0[1];
        if(typeof _bN_ === "number"){
         var rest$4 = fmt$0[2], x$5 = make_iprintf(k$0, o, rest$4);
         return function(_b5_){return x$5;};
        }
        if(0 === _bN_[0]){
         var rest$5 = fmt$0[2], x$6 = make_iprintf(k$0, o, rest$5);
         return function(_b4_){return x$6;};
        }
        var
         rest$6 = fmt$0[2],
         x$7 = make_iprintf(k$0, o, rest$6),
         x$8 = function(_b3_){return x$7;};
        return function(_b2_){return x$8;};
       case 4:
        var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
       case 5:
        var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
       case 6:
        var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
       case 7:
        var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
       case 8:
        var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
        return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
       case 9:
        var _bO_ = fmt$0[1];
        if(typeof _bO_ === "number"){
         var rest$12 = fmt$0[2], x$9 = make_iprintf(k$0, o, rest$12);
         return function(_b1_){return x$9;};
        }
        if(0 === _bO_[0]){
         var rest$13 = fmt$0[2], x$10 = make_iprintf(k$0, o, rest$13);
         return function(_b0_){return x$10;};
        }
        var
         rest$14 = fmt$0[2],
         x$11 = make_iprintf(k$0, o, rest$14),
         x$12 = function(_bZ_){return x$11;};
        return function(_bY_){return x$12;};
       case 10:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 11:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 12:
        var rest$17 = fmt$0[2]; fmt$0 = rest$17; break;
       case 13:
        var rest$18 = fmt$0[3], x$13 = make_iprintf(k$0, o, rest$18);
        return function(_bX_){return x$13;};
       case 14:
        var rest$19 = fmt$0[3], fmtty = fmt$0[2];
        return function(param){
         var fmt = param[1], _bW_ = recast(fmt, fmtty);
         return make_iprintf
                 (k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _bW_, rest$19));};
       case 15:
        var
         rest$20 = fmt$0[1],
         x$14 = make_iprintf(k$0, o, rest$20),
         x$15 = function(_bV_){return x$14;};
        return function(_bU_){return x$15;};
       case 16:
        var rest$21 = fmt$0[1], x$16 = make_iprintf(k$0, o, rest$21);
        return function(_bT_){return x$16;};
       case 17:
        var rest$22 = fmt$0[2]; fmt$0 = rest$22; break;
       case 18:
        var _bP_ = fmt$0[1];
        if(0 === _bP_[0]){
         var rest$23 = fmt$0[2], fmt$1 = _bP_[1][1];
         let k = k$0, rest = rest$23;
         var k$1 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$1;
         fmt$0 = fmt$1;
        }
        else{
         var rest$24 = fmt$0[2], fmt$2 = _bP_[1][1];
         let k = k$0, rest = rest$24;
         var k$2 = function(koc){return make_iprintf(k, koc, rest);};
         k$0 = k$2;
         fmt$0 = fmt$2;
        }
        break;
       case 19:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
       case 20:
        var rest$25 = fmt$0[3], x$17 = make_iprintf(k$0, o, rest$25);
        return function(_bS_){return x$17;};
       case 21:
        var rest$26 = fmt$0[2], x$18 = make_iprintf(k$0, o, rest$26);
        return function(_bR_){return x$18;};
       case 22:
        var rest$27 = fmt$0[1], x$19 = make_iprintf(k$0, o, rest$27);
        return function(_bQ_){return x$19;};
       case 23:
        var rest$28 = fmt$0[2], ign = fmt$0[1];
        return make_ignored_param
                (function(param){return caml_call1(k$0, o);}, 0, ign, rest$28);
       default:
        var rest$29 = fmt$0[3], arity = fmt$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
        var counter$0 = counter + 1 | 0;
        return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
     }
    }
   }
   function make_iprintf(k, o, fmt){
    return caml_trampoline(make_iprintf$0(0, k, o, fmt));
   }
   function fn_of_padding_precision(k, o, fmt, pad, prec){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var x$2 = make_iprintf(k, o, fmt);
      return function(_bL_){return x$2;};
     }
     if(prec){
      var x = make_iprintf(k, o, fmt), x$0 = function(_bK_){return x;};
      return function(_bJ_){return x$0;};
     }
     var x$1 = make_iprintf(k, o, fmt);
     return function(_bI_){return x$1;};
    }
    if(0 === pad[0]){
     if(typeof prec !== "number"){
      var x$6 = make_iprintf(k, o, fmt);
      return function(_bH_){return x$6;};
     }
     if(prec){
      var x$3 = make_iprintf(k, o, fmt), x$4 = function(_bG_){return x$3;};
      return function(_bF_){return x$4;};
     }
     var x$5 = make_iprintf(k, o, fmt);
     return function(_bE_){return x$5;};
    }
    if(typeof prec !== "number"){
     var x$12 = make_iprintf(k, o, fmt), x$13 = function(_bD_){return x$12;};
     return function(_bC_){return x$13;};
    }
    if(prec){
     var
      x$7 = make_iprintf(k, o, fmt),
      x$8 = function(_bB_){return x$7;},
      x$9 = function(_bA_){return x$8;};
     return function(_bz_){return x$9;};
    }
    var x$10 = make_iprintf(k, o, fmt);
    function x$11(_by_){return x$10;}
    return function(_bx_){return x$11;};
   }
   function fn_of_custom_arity$0(counter, k, o, fmt, param){
    if(param){
     var arity = param[1], x = fn_of_custom_arity(k, o, fmt, arity);
     return function(_bw_){return x;};
    }
    if(counter >= 50)
     return caml_trampoline_return(make_iprintf$0, [0, k, o, fmt]);
    var counter$0 = counter + 1 | 0;
    return make_iprintf$0(counter$0, k, o, fmt);
   }
   function fn_of_custom_arity(k, o, fmt, param){
    return caml_trampoline(fn_of_custom_arity$0(0, k, o, fmt, param));
   }
   function output_acc(o, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        output_acc(o, p);
        return caml_call2(Stdlib[66], o, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$18);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         output_acc(o, p$0);
         caml_call2(Stdlib[66], o, cst$19);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        output_acc(o, p$3);
        return caml_call1(f, o);
       case 7:
        var p$4 = acc$0[1];
        output_acc(o, p$4);
        return caml_call1(Stdlib[63], o);
       case 8:
        var msg = acc$0[2], p$5 = acc$0[1];
        output_acc(o, p$5);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        output_acc(o, p$1);
        return caml_call2(Stdlib[66], o, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        output_acc(o, p$2);
        return caml_call2(Stdlib[65], o, c);
     }
    }
   }
   function bufput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        bufput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$20);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         bufput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$21);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        bufput_acc(b, p$3);
        return caml_call1(f, b);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        bufput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        bufput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        bufput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function strput_acc(b, acc){
    var acc$0 = acc;
    for(;;){
     if(typeof acc$0 === "number") return 0;
     switch(acc$0[0]){
       case 0:
        var
         fmting_lit = acc$0[2],
         p = acc$0[1],
         s = string_of_formatting_lit(fmting_lit);
        strput_acc(b, p);
        return caml_call2(Stdlib_Buffer[16], b, s);
       case 1:
        var match = acc$0[2], p$0 = acc$0[1];
        if(0 === match[0]){
         var acc$1 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$22);
         acc$0 = acc$1;
        }
        else{
         var acc$2 = match[1];
         strput_acc(b, p$0);
         caml_call2(Stdlib_Buffer[16], b, cst$23);
         acc$0 = acc$2;
        }
        break;
       case 6:
        var f = acc$0[2], p$3 = acc$0[1];
        strput_acc(b, p$3);
        var _bv_ = caml_call1(f, 0);
        return caml_call2(Stdlib_Buffer[16], b, _bv_);
       case 7:
        var acc$3 = acc$0[1]; acc$0 = acc$3; break;
       case 8:
        var msg = acc$0[2], p$4 = acc$0[1];
        strput_acc(b, p$4);
        return caml_call1(Stdlib[1], msg);
       case 2:
       case 4:
        var s$0 = acc$0[2], p$1 = acc$0[1];
        strput_acc(b, p$1);
        return caml_call2(Stdlib_Buffer[16], b, s$0);
       default:
        var c = acc$0[2], p$2 = acc$0[1];
        strput_acc(b, p$2);
        return caml_call2(Stdlib_Buffer[12], b, c);
     }
    }
   }
   function failwith_message(param){
    var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
    function k(acc){
     strput_acc(buf, acc);
     var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
     return caml_call1(Stdlib[2], _bu_);
    }
    return make_printf(k, 0, fmt);
   }
   function open_box_of_string(str){
    if(str == cst$43) return _x_;
    var len = caml_ml_string_length(str);
    function invalid_box(param){
     return caml_call1(failwith_message(_y_), str);
    }
    function parse_spaces(i){
     var i$0 = i;
     for(;;){
      if(i$0 === len) return i$0;
      var match = caml_string_get(str, i$0);
      if(9 !== match && 32 !== match) return i$0;
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    var wstart = parse_spaces(0);
    a:
    b:
    {
     var wend = wstart;
     for(;;){
      if(wend === len) break b;
      if(25 < caml_string_get(str, wend) - 97 >>> 0) break;
      var j = wend + 1 | 0;
      wend = j;
     }
     break a;
    }
    var
     box_name = caml_call3(Stdlib_String[16], str, wstart, wend - wstart | 0),
     nstart = parse_spaces(wend);
    a:
    b:
    {
     var nend = nstart;
     for(;;){
      if(nend === len) break b;
      var match = caml_string_get(str, nend);
      if(48 <= match){if(58 <= match) break;} else if(45 !== match) break;
      var j$0 = nend + 1 | 0;
      nend = j$0;
     }
     break a;
    }
    if(nstart === nend)
     var indent = 0;
    else
     try{
      var
       _bs_ =
         runtime.caml_int_of_string
          (caml_call3(Stdlib_String[16], str, nstart, nend - nstart | 0)),
       indent = _bs_;
     }
     catch(_bt_){
      var _br_ = caml_wrap_exception(_bt_);
      if(_br_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_br_, 0);
      var indent = invalid_box(0);
     }
    var exp_end = parse_spaces(nend);
    if(exp_end !== len) invalid_box(0);
    a:
    {
     if(box_name !== cst$43 && box_name !== "b"){
      if(box_name === "h"){var box_type = 0; break a;}
      if(box_name === "hov"){var box_type = 3; break a;}
      if(box_name === "hv"){var box_type = 2; break a;}
      if(box_name !== "v"){var box_type = invalid_box(0); break a;}
      var box_type = 1;
      break a;
     }
     var box_type = 4;
    }
    return [0, indent, box_type];
   }
   function make_padding_fmt_ebb(pad, fmt){
    if(typeof pad === "number") return [0, 0, fmt];
    if(0 === pad[0]){var w = pad[2], s = pad[1]; return [0, [0, s, w], fmt];}
    var s$0 = pad[1];
    return [0, [1, s$0], fmt];
   }
   function make_padprec_fmt_ebb(pad, prec, fmt){
    if(typeof prec === "number")
     var match = prec ? [0, 1] : [0, 0];
    else
     var p = prec[1], match = [0, [0, p]];
    var prec$0 = match[1];
    if(typeof pad === "number") return [0, 0, prec$0, fmt];
    if(0 === pad[0]){
     var w = pad[2], s = pad[1];
     return [0, [0, s, w], prec$0, fmt];
    }
    var s$0 = pad[1];
    return [0, [1, s$0], prec$0, fmt];
   }
   function fmt_ebb_of_string(legacy_behavior, str){
    if(legacy_behavior)
     var flag = legacy_behavior[1], legacy_behavior$0 = flag;
    else
     var legacy_behavior$0 = 1;
    function invalid_format_message(str_ind, msg){
     return caml_call3(failwith_message(_z_), str, str_ind, msg);
    }
    function invalid_format_without(str_ind, c, s){
     return caml_call4(failwith_message(_A_), str, str_ind, c, s);
    }
    function expected_character(str_ind, expected, read){
     return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
    }
    function parse(lit_start, end_ind){
     a:
     {
      var str_ind = lit_start;
      for(;;){
       if(str_ind === end_ind) return add_literal(lit_start, str_ind, 0);
       var match = caml_string_get(str, str_ind);
       if(37 === match) break;
       if(64 === match) break a;
       var str_ind$1 = str_ind + 1 | 0;
       str_ind = str_ind$1;
      }
      var str_ind$2 = str_ind + 1 | 0;
      if(str_ind$2 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var
       match$1 =
         95 === caml_string_get(str, str_ind$2)
          ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1)
          : parse_flags(str_ind, str_ind$2, end_ind, 0),
       fmt_rest = match$1[1];
      return add_literal(lit_start, str_ind, fmt_rest);
     }
     var str_ind$0 = str_ind + 1 | 0;
     a:
     if(str_ind$0 === end_ind)
      var match$0 = _N_;
     else{
      var c = caml_string_get(str, str_ind$0);
      if(65 <= c){
       if(94 <= c){
        var switcher = c - 123 | 0;
        if(2 >= switcher >>> 0)
         switch(switcher){
           case 0:
            var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind); break a;
           case 1: break;
           default:
            var
             fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1],
             match$0 = [0, [17, 1, fmt_rest$2]];
            break a;
         }
       }
       else if(91 <= c)
        switch(c - 91 | 0){
          case 0:
           var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind); break a;
          case 1: break;
          default:
           var
            fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 0, fmt_rest$3]];
           break a;
        }
      }
      else{
       if(10 === c){
        var
         fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1],
         match$0 = [0, [17, 3, fmt_rest$4]];
        break a;
       }
       if(32 <= c)
        switch(c - 32 | 0){
          case 0:
           var
            fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _O_, fmt_rest$5]];
           break a;
          case 5:
           if
            ((str_ind$0 + 1 | 0) < end_ind
             && 37 === caml_string_get(str, str_ind$0 + 1 | 0)){
            var
             fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1],
             match$0 = [0, [17, 6, fmt_rest$6]];
            break a;
           }
           var
            fmt_rest$7 = parse(str_ind$0, end_ind)[1],
            match$0 = [0, [12, 64, fmt_rest$7]];
           break a;
          case 12:
           var
            fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, _P_, fmt_rest$8]];
           break a;
          case 14:
           var
            fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 4, fmt_rest$9]];
           break a;
          case 27:
           var str_ind$3 = str_ind$0 + 1 | 0;
           b:
           try{
            var
             _bg_ = str_ind$3 === end_ind ? 1 : 0,
             _bh_ = _bg_ || (60 !== caml_string_get(str, str_ind$3) ? 1 : 0);
            if(_bh_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            var
             str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind),
             match$2 = caml_string_get(str, str_ind_1);
            c:
            {
             if(48 <= match$2){
              if(58 > match$2) break c;
             }
             else if(45 === match$2) break c;
             throw caml_maybe_attach_backtrace(Stdlib[8], 1);
            }
            var
             match$3 = parse_integer(str_ind_1, end_ind),
             width = match$3[2],
             str_ind_2 = match$3[1],
             str_ind_3 = parse_spaces(str_ind_2, end_ind),
             switcher$0 = caml_string_get(str, str_ind_3) - 45 | 0;
            if(12 < switcher$0 >>> 0){
             if(17 === switcher$0){
              var
               s =
                 caml_call3
                  (Stdlib_String[16],
                   str,
                   str_ind$3 - 2 | 0,
                   (str_ind_3 - str_ind$3 | 0) + 3 | 0),
               _bi_ = [0, s, width, 0],
               _bj_ = str_ind_3 + 1 | 0,
               formatting_lit$0 = _bi_,
               next_ind = _bj_;
              break b;
             }
            }
            else if(1 < switcher$0 - 1 >>> 0){
             var
              match$4 = parse_integer(str_ind_3, end_ind),
              offset = match$4[2],
              str_ind_4 = match$4[1],
              str_ind_5 = parse_spaces(str_ind_4, end_ind);
             if(62 !== caml_string_get(str, str_ind_5))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$0 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$3 - 2 | 0,
                  (str_ind_5 - str_ind$3 | 0) + 3 | 0),
              _bk_ = [0, s$0, width, offset],
              _bl_ = str_ind_5 + 1 | 0,
              formatting_lit$0 = _bk_,
              next_ind = _bl_;
             break b;
            }
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           }
           catch(_bq_){
            var _bf_ = caml_wrap_exception(_bq_);
            if(_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bf_, 0);
            var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
           }
           var
            fmt_rest$12 = parse(next_ind, end_ind)[1],
            match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
           break a;
          case 28:
           var str_ind$4 = str_ind$0 + 1 | 0;
           try{
            var
             str_ind_1$0 = parse_spaces(str_ind$4, end_ind),
             match$6 = caml_string_get(str, str_ind_1$0);
            b:
            {
             c:
             {
              if(48 <= match$6){
               if(58 > match$6) break c;
              }
              else if(45 === match$6) break c;
              var _bo_ = 0;
              break b;
             }
             var
              match$7 = parse_integer(str_ind_1$0, end_ind),
              size = match$7[2],
              str_ind_2$0 = match$7[1],
              str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
             if(62 !== caml_string_get(str, str_ind_3$0))
              throw caml_maybe_attach_backtrace(Stdlib[8], 1);
             var
              s$1 =
                caml_call3
                 (Stdlib_String[16],
                  str,
                  str_ind$4 - 2 | 0,
                  (str_ind_3$0 - str_ind$4 | 0) + 3 | 0),
              _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
            }
            var _bn_ = _bo_;
           }
           catch(_bp_){
            var _bm_ = caml_wrap_exception(_bp_);
            if(_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
             throw caml_maybe_attach_backtrace(_bm_, 0);
            var _bn_ = 0;
           }
           if(_bn_)
            var
             match$5 = _bn_[1],
             formatting_lit$1 = match$5[2],
             next_ind$0 = match$5[1],
             fmt_rest$13 = parse(next_ind$0, end_ind)[1],
             _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
           else
            var
             fmt_rest$14 = parse(str_ind$4, end_ind)[1],
             _be_ = [0, [17, _Q_, fmt_rest$14]];
           var match$0 = _be_;
           break a;
          case 31:
           var
            fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 2, fmt_rest$10]];
           break a;
          case 32:
           var
            fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1],
            match$0 = [0, [17, 5, fmt_rest$11]];
           break a;
        }
      }
      var
       fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1],
       match$0 = [0, [17, [2, c], fmt_rest$1]];
     }
     var fmt_rest$0 = match$0[1];
     return add_literal(lit_start, str_ind, fmt_rest$0);
    }
    function parse_flags(pct_ind, str_ind, end_ind, ign){
     var
      zero = [0, 0],
      minus = [0, 0],
      plus = [0, 0],
      space = [0, 0],
      hash = [0, 0];
     function set_flag(str_ind, flag){
      var _bb_ = flag[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
      if(_bc_){
       var _bd_ = caml_string_get(str, str_ind);
       caml_call3(failwith_message(_C_), str, str_ind, _bd_);
      }
      flag[1] = 1;
      return;
     }
     a:
     b:
     {
      var str_ind$0 = str_ind;
      c:
      for(;;){
       if(str_ind$0 === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       var switcher = caml_string_get(str, str_ind$0) - 32 | 0;
       if(16 < switcher >>> 0) break b;
       switch(switcher){
         case 0:
          set_flag(str_ind$0, space);
          var str_ind$1 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$1;
          break;
         case 3:
          set_flag(str_ind$0, hash);
          var str_ind$2 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$2;
          break;
         case 11:
          set_flag(str_ind$0, plus);
          var str_ind$3 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$3;
          break;
         case 13:
          set_flag(str_ind$0, minus);
          var str_ind$4 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$4;
          break;
         case 16:
          set_flag(str_ind$0, zero);
          var str_ind$5 = str_ind$0 + 1 | 0;
          str_ind$0 = str_ind$5;
          break;
         default: break c;
       }
      }
      break a;
     }
     var
      space$0 = space[1],
      hash$0 = hash[1],
      plus$0 = plus[1],
      minus$0 = minus[1],
      zero$0 = zero[1];
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var
      padty =
        zero$0
         ? minus$0
           ? legacy_behavior$0
             ? 0
             : incompatible_flag(pct_ind, str_ind$0, 45, cst_0)
           : 2
         : minus$0 ? 0 : 1,
      match = caml_string_get(str, str_ind$0);
     if(48 <= match){
      if(58 > match){
       var
        match$0 = parse_positive(str_ind$0, end_ind, 0),
        width = match$0[2],
        new_ind = match$0[1];
       return parse_after_padding
               (pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]);
      }
     }
     else if(42 === match)
      return parse_after_padding
              (pct_ind,
               str_ind$0 + 1 | 0,
               end_ind,
               minus$0,
               plus$0,
               hash$0,
               space$0,
               ign,
               [1, padty]);
     switch(padty){
       case 0:
        if(1 - legacy_behavior$0)
         invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       case 1:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 0);
       default:
        return parse_after_padding
                (pct_ind,
                 str_ind$0,
                 end_ind,
                 minus$0,
                 plus$0,
                 hash$0,
                 space$0,
                 ign,
                 _D_);
     }
    }
    function parse_after_padding
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var symb = caml_string_get(str, str_ind);
     if(46 !== symb)
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               0,
               pad,
               symb);
     var str_ind$0 = str_ind + 1 | 0;
     if(str_ind$0 === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_literal(minus, str_ind){
      var
       match = parse_positive(str_ind, end_ind, 0),
       prec = match[2],
       new_ind = match[1];
      return parse_after_precision
              (pct_ind,
               new_ind,
               end_ind,
               minus,
               plus,
               hash,
               space,
               ign,
               pad,
               [0, prec]);
     }
     var symb$0 = caml_string_get(str, str_ind$0);
     if(48 <= symb$0){
      if(58 > symb$0) return parse_literal(minus, str_ind$0);
     }
     else if(42 <= symb$0)
      switch(symb$0 - 42 | 0){
        case 0:
         return parse_after_precision
                 (pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1);
        case 1:
        case 3:
         if(legacy_behavior$0){
          var
           _ba_ = str_ind$0 + 1 | 0,
           minus$0 = minus || (45 === symb$0 ? 1 : 0);
          return parse_literal(minus$0, _ba_);
         }
         break;
      }
     return legacy_behavior$0
             ? parse_after_precision
               (pct_ind,
                str_ind$0,
                end_ind,
                minus,
                plus,
                hash,
                space,
                ign,
                pad,
                _E_)
             : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
    }
    function parse_after_precision
    (pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     function parse_conv(padprec){
      return parse_conversion
              (pct_ind,
               str_ind + 1 | 0,
               end_ind,
               plus,
               hash,
               space,
               ign,
               pad,
               prec,
               padprec,
               caml_string_get(str, str_ind));
     }
     if(typeof pad !== "number") return parse_conv(pad);
     if(typeof prec === "number" && ! prec) return parse_conv(0);
     if(minus){
      if(typeof prec === "number") return parse_conv(_F_);
      var n = prec[1];
      return parse_conv([0, 0, n]);
     }
     if(typeof prec === "number") return parse_conv(_G_);
     var n$0 = prec[1];
     return parse_conv([0, 1, n$0]);
    }
    function parse_conversion
    (pct_ind,
     str_ind,
     end_ind,
     plus,
     hash,
     space,
     ign,
     pad,
     prec,
     padprec,
     symb){
     var
      plus_used = [0, 0],
      hash_used = [0, 0],
      space_used = [0, 0],
      ign_used = [0, 0],
      pad_used = [0, 0],
      prec_used = [0, 0];
     function get_plus(param){plus_used[1] = 1; return plus;}
     function get_hash(param){hash_used[1] = 1; return hash;}
     function get_space(param){space_used[1] = 1; return space;}
     function get_ign(param){ign_used[1] = 1; return ign;}
     function get_pad(param){pad_used[1] = 1; return pad;}
     function get_prec(param){prec_used[1] = 1; return prec;}
     function get_padprec(param){pad_used[1] = 1; return padprec;}
     function get_int_pad(param){
      var pad = get_pad(0), match = get_prec(0);
      if(typeof match === "number" && ! match) return pad;
      if(typeof pad === "number") return 0;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _H_
                 : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1)
               : pad;
      if(2 > pad[1]) return pad;
      var n = pad[2];
      return legacy_behavior$0
              ? [0, 1, n]
              : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
     }
     function check_no_0(symb, pad){
      if(typeof pad === "number") return pad;
      if(0 !== pad[0])
       return 2 <= pad[1]
               ? legacy_behavior$0
                 ? _I_
                 : incompatible_flag(pct_ind, str_ind, symb, cst_0$1)
               : pad;
      if(2 > pad[1]) return pad;
      var width = pad[2];
      return legacy_behavior$0
              ? [0, 1, width]
              : incompatible_flag(pct_ind, str_ind, symb, cst_0$0);
     }
     function opt_of_pad(c, pad){
      if(typeof pad === "number") return 0;
      if(0 === pad[0])
       switch(pad[1]){
         case 0:
          var width = pad[2];
          return legacy_behavior$0
                  ? [0, width]
                  : incompatible_flag(pct_ind, str_ind, c, cst$24);
         case 1:
          var width$0 = pad[2]; return [0, width$0];
         default:
          var width$1 = pad[2];
          return legacy_behavior$0
                  ? [0, width$1]
                  : incompatible_flag(pct_ind, str_ind, c, cst_0$2);
       }
      return incompatible_flag(pct_ind, str_ind, c, cst$25);
     }
     function get_pad_opt(c){return opt_of_pad(c, get_pad(0));}
     function get_padprec_opt(c){return opt_of_pad(c, get_padprec(0));}
     a:
     {
      if(124 > symb)
       switch(symb){
         case 33:
          var
           fmt_rest$5 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [10, fmt_rest$5]];
          break a;
         case 40:
          var
           sub_end = search_subformat_end(str_ind, end_ind, 41),
           fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1],
           sub_fmt = parse(str_ind, sub_end)[1],
           sub_fmtty = fmtty_of_fmt(sub_fmt);
          if(get_ign(0))
           var
            ignored$2 = [9, get_pad_opt(95), sub_fmtty],
            _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
          else
           var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
          var fmt_result = _aJ_;
          break a;
         case 44:
          var fmt_result = parse(str_ind, end_ind); break a;
         case 67:
          var
           fmt_rest$10 = parse(str_ind, end_ind)[1],
           _aL_ =
             get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]],
           fmt_result = _aL_;
          break a;
         case 78:
          var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
          if(get_ign(0))
           var
            ignored$6 = [11, counter$0],
            _aR_ = [0, [23, ignored$6, fmt_rest$14]];
          else
           var _aR_ = [0, [21, counter$0, fmt_rest$14]];
          var fmt_result = _aR_;
          break a;
         case 83:
          var
           pad$6 = check_no_0(symb, get_padprec(0)),
           fmt_rest$15 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$7 = [1, get_padprec_opt(95)],
            _aS_ = [0, [23, ignored$7, fmt_rest$15]];
          else
           var
            match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15),
            fmt_rest$16 = match$5[2],
            pad$7 = match$5[1],
            _aS_ = [0, [3, pad$7, fmt_rest$16]];
          var fmt_result = _aS_;
          break a;
         case 91:
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           char_set = create_char_set(0),
           add_range =
             function(c$0, c){
              if(c >= c$0){
               var i = c$0;
               for(;;){
                add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                var _a$_ = i + 1 | 0;
                if(c === i) break;
                i = _a$_;
               }
              }
              return;
             },
           fail_single_percent =
             function(str_ind){
              return caml_call2(failwith_message(_R_), str, str_ind);
             },
           parse_char_set_content =
             function(counter, str_ind, end_ind){
              var str_ind$0 = str_ind;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c = caml_string_get(str, str_ind$0);
               if(45 !== c){
                if(93 === c) return str_ind$0 + 1 | 0;
                var _a__ = str_ind$0 + 1 | 0;
                if(counter >= 50)
                 return caml_trampoline_return
                         (parse_char_set_after_char$0, [0, _a__, end_ind, c]);
                var counter$0 = counter + 1 | 0;
                return parse_char_set_after_char$0
                        (counter$0, _a__, end_ind, c);
               }
               add_in_char_set(char_set, 45);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
              }
             },
           parse_char_set_after_char$0 =
             function(counter, str_ind, end_ind, c){
              var str_ind$0 = str_ind, c$0 = c;
              for(;;){
               if(str_ind$0 === end_ind)
                invalid_format_message(end_ind, cst_unexpected_end_of_format);
               var c$1 = caml_string_get(str, str_ind$0);
               a:
               {
                if(46 <= c$1){
                 if(64 !== c$1){
                  if(93 !== c$1) break a;
                  add_in_char_set(char_set, c$0);
                  return str_ind$0 + 1 | 0;
                 }
                }
                else if(37 !== c$1){
                 if(45 > c$1) break a;
                 var str_ind$2 = str_ind$0 + 1 | 0;
                 if(str_ind$2 === end_ind)
                  invalid_format_message
                   (end_ind, cst_unexpected_end_of_format);
                 var c$2 = caml_string_get(str, str_ind$2);
                 if(37 === c$2){
                  if((str_ind$2 + 1 | 0) === end_ind)
                   invalid_format_message
                    (end_ind, cst_unexpected_end_of_format);
                  var c$3 = caml_string_get(str, str_ind$2 + 1 | 0);
                  if(37 !== c$3 && 64 !== c$3)
                   return fail_single_percent(str_ind$2);
                  add_range(c$0, c$3);
                  var _a8_ = str_ind$2 + 2 | 0;
                  if(counter >= 50)
                   return caml_trampoline_return
                           (parse_char_set_content, [0, _a8_, end_ind]);
                  var counter$1 = counter + 1 | 0;
                  return parse_char_set_content(counter$1, _a8_, end_ind);
                 }
                 if(93 === c$2){
                  add_in_char_set(char_set, c$0);
                  add_in_char_set(char_set, 45);
                  return str_ind$2 + 1 | 0;
                 }
                 add_range(c$0, c$2);
                 var _a9_ = str_ind$2 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a9_, end_ind]);
                 var counter$0 = counter + 1 | 0;
                 return parse_char_set_content(counter$0, _a9_, end_ind);
                }
                if(37 === c$0){
                 add_in_char_set(char_set, c$1);
                 var _a7_ = str_ind$0 + 1 | 0;
                 if(counter >= 50)
                  return caml_trampoline_return
                          (parse_char_set_content, [0, _a7_, end_ind]);
                 var counter$2 = counter + 1 | 0;
                 return parse_char_set_content(counter$2, _a7_, end_ind);
                }
               }
               if(37 === c$0) fail_single_percent(str_ind$0);
               add_in_char_set(char_set, c$0);
               var str_ind$1 = str_ind$0 + 1 | 0;
               str_ind$0 = str_ind$1;
               c$0 = c$1;
              }
             },
           parse_char_set_after_char =
             function(str_ind, end_ind, c){
              return caml_trampoline
                      (parse_char_set_after_char$0(0, str_ind, end_ind, c));
             };
          if(str_ind === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          if(94 === caml_string_get(str, str_ind))
           var
            str_ind$0 = str_ind + 1 | 0,
            reverse = 1,
            str_ind$1 = str_ind$0;
          else
           var reverse = 0, str_ind$1 = str_ind;
          if(str_ind$1 === end_ind)
           invalid_format_message(end_ind, cst_unexpected_end_of_format);
          var
           c = caml_string_get(str, str_ind$1),
           next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c),
           char_set$0 = freeze_char_set(char_set),
           char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0,
           fmt_rest$19 = parse(next_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$9 = [10, get_pad_opt(95), char_set$1],
            _aX_ = [0, [23, ignored$9, fmt_rest$19]];
          else
           var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
          var fmt_result = _aX_;
          break a;
         case 97:
          var
           fmt_rest$20 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [15, fmt_rest$20]];
          break a;
         case 99:
          var
           char_format =
             function(fmt_rest){
              return get_ign(0) ? [0, [23, 0, fmt_rest]] : [0, [0, fmt_rest]];
             },
           fmt_rest$21 = parse(str_ind, end_ind)[1],
           match$7 = get_pad_opt(99);
          if(match$7){
           if(0 === match$7[1])
            var
             _aY_ =
               get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]],
             _aZ_ = _aY_;
           else
            var
             _aZ_ =
               legacy_behavior$0
                ? char_format(fmt_rest$21)
                : invalid_format_message
                  (str_ind, cst_non_zero_widths_are_unsupp);
           var _a0_ = _aZ_;
          }
          else
           var _a0_ = char_format(fmt_rest$21);
          var fmt_result = _a0_;
          break a;
         case 114:
          var
           fmt_rest$22 = parse(str_ind, end_ind)[1],
           _a1_ =
             get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]],
           fmt_result = _a1_;
          break a;
         case 115:
          var
           pad$9 = check_no_0(symb, get_padprec(0)),
           fmt_rest$23 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$10 = [0, get_padprec_opt(95)],
            _a2_ = [0, [23, ignored$10, fmt_rest$23]];
          else
           var
            match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23),
            fmt_rest$24 = match$8[2],
            pad$10 = match$8[1],
            _a2_ = [0, [2, pad$10, fmt_rest$24]];
          var fmt_result = _a2_;
          break a;
         case 116:
          var
           fmt_rest$25 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [16, fmt_rest$25]];
          break a;
         case 123:
          var
           sub_end$0 = search_subformat_end(str_ind, end_ind, 125),
           sub_fmt$0 = parse(str_ind, sub_end$0)[1],
           fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1],
           sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
          if(get_ign(0))
           var
            ignored$11 = [8, get_pad_opt(95), sub_fmtty$0],
            _a3_ = [0, [23, ignored$11, fmt_rest$26]];
          else
           var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
          var fmt_result = _a3_;
          break a;
         case 66:
         case 98:
          var
           pad$3 = check_no_0(symb, get_padprec(0)),
           fmt_rest$8 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$3 = [7, get_padprec_opt(95)],
            _aK_ = [0, [23, ignored$3, fmt_rest$8]];
          else
           var
            match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8),
            fmt_rest$9 = match$3[2],
            pad$4 = match$3[1],
            _aK_ = [0, [9, pad$4, fmt_rest$9]];
          var fmt_result = _aK_;
          break a;
         case 37:
         case 64:
          var
           fmt_rest$6 = parse(str_ind, end_ind)[1],
           fmt_result = [0, [12, symb, fmt_rest$6]];
          break a;
         case 76:
         case 108:
         case 110:
          if(str_ind !== end_ind){
           var symb$0 = caml_string_get(str, str_ind), _a4_ = symb$0 - 88 | 0;
           b:
           {
            if(32 >= _a4_ >>> 0)
             switch(_a4_){
               case 0:
               case 12:
               case 17:
               case 23:
               case 29:
               case 32:
                var _aQ_ = 1; break b;
             }
            var _aQ_ = 0;
           }
           if(_aQ_) break;
          }
          var fmt_rest$13 = parse(str_ind, end_ind)[1];
          b:
          {
           if(108 <= symb){
            if(111 > symb)
             switch(symb - 108 | 0){
               case 0:
                var counter = 0; break b;
               case 1: break;
               default: var counter = 1; break b;
             }
           }
           else if(76 === symb){var counter = 2; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
          }
          if(get_ign(0))
           var
            ignored$5 = [11, counter],
            _aP_ = [0, [23, ignored$5, fmt_rest$13]];
          else
           var _aP_ = [0, [21, counter, fmt_rest$13]];
          var fmt_result = _aP_;
          break a;
         case 32:
         case 35:
         case 43:
         case 45:
         case 95:
          var
           fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
          break a;
         case 88:
         case 100:
         case 105:
         case 111:
         case 117:
         case 120:
          var
           _aT_ = get_space(0),
           _aU_ = get_hash(0),
           iconv$2 =
             compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb),
           fmt_rest$17 = parse(str_ind, end_ind)[1];
          if(get_ign(0))
           var
            ignored$8 = [2, iconv$2, get_pad_opt(95)],
            _aV_ = [0, [23, ignored$8, fmt_rest$17]];
          else
           var
            _aW_ = get_prec(0),
            match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17),
            fmt_rest$18 = match$6[3],
            prec$4 = match$6[2],
            pad$8 = match$6[1],
            _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
          var fmt_result = _aV_;
          break a;
         case 69:
         case 70:
         case 71:
         case 72:
         case 101:
         case 102:
         case 103:
         case 104:
          var
           space$1 = get_space(0),
           hash$1 = get_hash(0),
           plus$2 = get_plus(0),
           flag =
             plus$2
              ? space$1
                ? legacy_behavior$0
                  ? 1
                  : incompatible_flag(pct_ind, str_ind, 32, cst$36)
                : 1
              : space$1 ? 2 : 0;
          b:
          {
           c:
           if(73 <= symb){
            var switcher = symb - 101 | 0;
            if(3 >= switcher >>> 0){
             switch(switcher){
               case 0:
                var _a5_ = 1; break;
               case 1:
                var _a5_ = 0; break;
               case 2:
                var _a5_ = 3; break;
               default: var _a5_ = 6;
             }
             var kind = _a5_;
             break b;
            }
           }
           else if(69 <= symb){
            switch(symb - 69 | 0){
              case 0:
               var _a6_ = 2; break;
              case 1:
               break c;
              case 2:
               var _a6_ = 4; break;
              default: var _a6_ = 7;
            }
            var kind = _a6_;
            break b;
           }
           if(hash$1){
            if(70 === symb){var kind = 8; break b;}
           }
           else if(70 === symb){var kind = 5; break b;}
           throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
          }
          var
           fconv = [0, flag, kind],
           fmt_rest$11 = parse(str_ind, end_ind)[1];
          if(get_ign(0)){
           var match = get_prec(0);
           if(typeof match === "number")
            var
             _aM_ =
               match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
           else
            var ndec = match[1], _aM_ = [0, ndec];
           var
            ignored$4 = [6, get_pad_opt(95), _aM_],
            _aN_ = [0, [23, ignored$4, fmt_rest$11]];
          }
          else
           var
            _aO_ = get_prec(0),
            match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11),
            fmt_rest$12 = match$4[3],
            prec$3 = match$4[2],
            pad$5 = match$4[1],
            _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
          var fmt_result = _aN_;
          break a;
       }
      b:
      if(108 <= symb){
       if(111 > symb){
        switch(symb - 108 | 0){
          case 0:
           var
            _at_ = caml_string_get(str, str_ind),
            _au_ = get_space(0),
            _av_ = get_hash(0),
            iconv =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_),
            fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored = [3, iconv, get_pad_opt(95)],
             _aw_ = [0, [23, ignored, fmt_rest]];
           else
            var
             _ay_ = get_prec(0),
             match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest),
             fmt_rest$0 = match$0[3],
             prec$0 = match$0[2],
             pad$0 = match$0[1],
             _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
           var _ax_ = _aw_;
           break;
          case 1:
           break b;
          default:
           var
            _az_ = caml_string_get(str, str_ind),
            _aA_ = get_space(0),
            _aB_ = get_hash(0),
            iconv$0 =
              compute_int_conv
               (pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_),
            fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
           if(get_ign(0))
            var
             ignored$0 = [4, iconv$0, get_pad_opt(95)],
             _aC_ = [0, [23, ignored$0, fmt_rest$1]];
           else
            var
             _aD_ = get_prec(0),
             match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1),
             fmt_rest$2 = match$1[3],
             prec$1 = match$1[2],
             pad$1 = match$1[1],
             _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
           var _ax_ = _aC_;
        }
        var fmt_result = _ax_;
        break a;
       }
      }
      else if(76 === symb){
       var
        _aE_ = caml_string_get(str, str_ind),
        _aF_ = get_space(0),
        _aG_ = get_hash(0),
        iconv$1 =
          compute_int_conv
           (pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_),
        fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
       if(get_ign(0))
        var
         ignored$1 = [5, iconv$1, get_pad_opt(95)],
         _aH_ = [0, [23, ignored$1, fmt_rest$3]];
       else
        var
         _aI_ = get_prec(0),
         match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3),
         fmt_rest$4 = match$2[3],
         prec$2 = match$2[2],
         pad$2 = match$2[1],
         _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
       var fmt_result = _aH_;
       break a;
      }
      var
       fmt_result =
         caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
     }
     if(1 - legacy_behavior$0){
      var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
      if(plus$0) incompatible_flag(pct_ind, str_ind, symb, cst$27);
      var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
      if(hash$0) incompatible_flag(pct_ind, str_ind, symb, cst$28);
      var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
      if(space$0) incompatible_flag(pct_ind, str_ind, symb, cst$29);
      var
       _an_ = 1 - pad_used[1],
       _ao_ = _an_ ? caml_notequal([0, pad], _K_) : _an_;
      if(_ao_) incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
      var
       _ap_ = 1 - prec_used[1],
       _aq_ = _ap_ ? caml_notequal([0, prec], _L_) : _ap_;
      if(_aq_){
       var _ar_ = ign ? 95 : symb;
       incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
      }
      var plus$1 = ign ? plus : ign;
      if(plus$1) incompatible_flag(pct_ind, str_ind, 95, cst$30);
     }
     var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
     a:
     if(ign$0){
      b:
      {
       if(38 <= symb){
        if(44 !== symb && 64 !== symb) break b;
       }
       else if(33 !== symb && 37 > symb) break b;
       if(legacy_behavior$0) break a;
      }
      incompatible_flag(pct_ind, str_ind, symb, cst$31);
     }
     return fmt_result;
    }
    function parse_tag(is_open_tag, str_ind, end_ind){
     try{
      if(str_ind === end_ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      if(60 !== caml_string_get(str, str_ind))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var ind = caml_call3(Stdlib_String[32], str, str_ind + 1 | 0, 62);
      if(end_ind <= ind) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       sub_str =
         caml_call3
          (Stdlib_String[16], str, str_ind, (ind - str_ind | 0) + 1 | 0),
       fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1],
       sub_fmt = parse(str_ind, ind + 1 | 0)[1],
       sub_format$0 = [0, sub_fmt, sub_str],
       formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0],
       _ai_ = [0, [18, formatting$0, fmt_rest$0]];
      return _ai_;
     }
     catch(_aj_){
      var _ah_ = caml_wrap_exception(_aj_);
      if(_ah_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ah_, 0);
      var
       fmt_rest = parse(str_ind, end_ind)[1],
       formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
      return [0, [18, formatting, fmt_rest]];
     }
    }
    function parse_spaces(str_ind, end_ind){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      if(32 !== caml_string_get(str, str_ind$0)) return str_ind$0;
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
     }
    }
    function parse_positive(str_ind, end_ind, acc){
     var str_ind$0 = str_ind, acc$0 = acc;
     for(;;){
      if(str_ind$0 === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind$0);
      if(9 < c - 48 >>> 0) return [0, str_ind$0, acc$0];
      var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
      if(Stdlib_Sys[12] < new_acc){
       var _ag_ = Stdlib_Sys[12];
       return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
      }
      var str_ind$1 = str_ind$0 + 1 | 0;
      str_ind$0 = str_ind$1;
      acc$0 = new_acc;
     }
    }
    function parse_integer(str_ind, end_ind){
     if(str_ind === end_ind)
      invalid_format_message(end_ind, cst_unexpected_end_of_format);
     var match = caml_string_get(str, str_ind);
     if(48 <= match){
      if(58 > match) return parse_positive(str_ind, end_ind, 0);
     }
     else if(45 === match){
      if((str_ind + 1 | 0) === end_ind)
       invalid_format_message(end_ind, cst_unexpected_end_of_format);
      var c = caml_string_get(str, str_ind + 1 | 0);
      if(9 < c - 48 >>> 0)
       return expected_character(str_ind + 1 | 0, cst_digit, c);
      var
       match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0),
       n = match$0[2],
       next_ind = match$0[1];
      return [0, next_ind, - n | 0];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    }
    function add_literal(lit_start, str_ind, fmt){
     var size = str_ind - lit_start | 0;
     return 0 === size
             ? [0, fmt]
             : 1
               === size
               ? [0, [12, caml_string_get(str, lit_start), fmt]]
               : [0,
                 [11,
                  caml_call3(Stdlib_String[16], str, lit_start, size),
                  fmt]];
    }
    function search_subformat_end(str_ind, end_ind, c){
     var str_ind$0 = str_ind;
     for(;;){
      if(str_ind$0 === end_ind)
       caml_call3(failwith_message(_U_), str, c, end_ind);
      if(37 === caml_string_get(str, str_ind$0)){
       if((str_ind$0 + 1 | 0) === end_ind)
        invalid_format_message(end_ind, cst_unexpected_end_of_format);
       if(caml_string_get(str, str_ind$0 + 1 | 0) === c) return str_ind$0;
       var match = caml_string_get(str, str_ind$0 + 1 | 0);
       if(95 <= match){
        if(123 <= match){
         if(126 > match)
          switch(match - 123 | 0){
            case 0:
             var
              sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125),
              str_ind$2 = sub_end + 2 | 0;
             str_ind$0 = str_ind$2;
             continue;
            case 1: break;
            default:
             return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
          }
        }
        else if(96 > match){
         if((str_ind$0 + 2 | 0) === end_ind)
          invalid_format_message(end_ind, cst_unexpected_end_of_format);
         var match$0 = caml_string_get(str, str_ind$0 + 2 | 0);
         if(40 === match$0){
          var
           sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41),
           str_ind$3 = sub_end$0 + 2 | 0;
          str_ind$0 = str_ind$3;
          continue;
         }
         if(123 === match$0){
          var
           sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125),
           str_ind$4 = sub_end$1 + 2 | 0;
          str_ind$0 = str_ind$4;
          continue;
         }
         var str_ind$5 = str_ind$0 + 3 | 0;
         str_ind$0 = str_ind$5;
         continue;
        }
       }
       else{
        if(40 === match){
         var
          sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41),
          str_ind$6 = sub_end$2 + 2 | 0;
         str_ind$0 = str_ind$6;
         continue;
        }
        if(41 === match)
         return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
       }
       var str_ind$1 = str_ind$0 + 2 | 0;
       str_ind$0 = str_ind$1;
      }
      else{var str_ind$7 = str_ind$0 + 1 | 0; str_ind$0 = str_ind$7;}
     }
    }
    function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb){
     var plus$0 = plus, hash$0 = hash, space$0 = space;
     for(;;){
      a:
      {
       if(plus$0){
        if(! hash$0){
         if(space$0) break a;
         if(100 === symb) return 1;
         if(105 === symb) return 4;
         break a;
        }
       }
       else{
        if(! hash$0){
         if(space$0){
          if(100 === symb) return 2;
          if(105 === symb) return 5;
          break a;
         }
         var switcher$1 = symb - 88 | 0;
         if(32 < switcher$1 >>> 0) break a;
         switch(switcher$1){
           case 0:
            return 8;
           case 12:
            return 0;
           case 17:
            return 3;
           case 23:
            return 10;
           case 29:
            return 12;
           case 32:
            return 6;
           default: break a;
         }
        }
        if(! space$0){
         var switcher$0 = symb - 88 | 0;
         if(32 >= switcher$0 >>> 0)
          switch(switcher$0){
            case 0:
             return 9;
            case 12:
             return 13;
            case 17:
             return 14;
            case 23:
             return 11;
            case 29:
             return 15;
            case 32:
             return 7;
          }
        }
       }
       var switcher = symb - 88 | 0;
       if(32 >= switcher >>> 0)
        switch(switcher){
          case 0:
           if(legacy_behavior$0) return 9; break;
          case 23:
           if(legacy_behavior$0) return 11; break;
          case 32:
           if(legacy_behavior$0) return 7; break;
          case 12:
          case 17:
          case 29:
           if(! legacy_behavior$0)
            return incompatible_flag(pct_ind, str_ind, symb, cst$35);
           hash$0 = 0;
           continue;
        }
      }
      if(plus$0)
       if(space$0){
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, 32, cst$32);
        space$0 = 0;
       }
       else{
        if(! legacy_behavior$0)
         return incompatible_flag(pct_ind, str_ind, symb, cst$33);
        plus$0 = 0;
       }
      else{
       if(! space$0)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
       if(! legacy_behavior$0)
        return incompatible_flag(pct_ind, str_ind, symb, cst$34);
       space$0 = 0;
      }
     }
    }
    function incompatible_flag(pct_ind, str_ind, symb, option){
     var
      subfmt =
        caml_call3(Stdlib_String[16], str, pct_ind, str_ind - pct_ind | 0);
     return caml_call5
             (failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
    }
    return parse(0, caml_ml_string_length(str));
   }
   function format_of_string_fmtty(str, fmtty){
    var fmt = fmt_ebb_of_string(0, str)[1];
    try{var _ae_ = [0, type_format(fmt, fmtty), str]; return _ae_;}
    catch(_af_){
     var _ac_ = caml_wrap_exception(_af_);
     if(_ac_ !== Type_mismatch) throw caml_maybe_attach_backtrace(_ac_, 0);
     var _ad_ = string_of_fmtty(fmtty);
     return caml_call2(failwith_message(_Z_), str, _ad_);
    }
   }
   function format_of_string_format(str, param){
    var
     str$0 = param[2],
     fmt = param[1],
     fmt$0 = fmt_ebb_of_string(0, str)[1];
    try{
     var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
     return _aa_;
    }
    catch(_ab_){
     var _$_ = caml_wrap_exception(_ab_);
     if(_$_ === Type_mismatch)
      return caml_call2(failwith_message(___), str, str$0);
     throw caml_maybe_attach_backtrace(_$_, 0);
    }
   }
   var
    CamlinternalFormat =
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
   runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printf
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib;
   function kfprintf(k, o, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[9], o, acc);
              return caml_call1(k, o);
             },
             0,
             fmt);
   }
   function kbprintf(k, b, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              caml_call2(CamlinternalFormat[10], b, acc);
              return caml_call1(k, b);
             },
             0,
             fmt);
   }
   function ikfprintf(k, oc, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, oc, fmt);
   }
   function fprintf(oc, fmt){
    return kfprintf(function(_d_){return 0;}, oc, fmt);
   }
   function bprintf(b, fmt){
    return kbprintf(function(_c_){return 0;}, b, fmt);
   }
   function ifprintf(oc, fmt){
    return ikfprintf(function(_b_){return 0;}, oc, fmt);
   }
   function ibprintf(b, fmt){
    return ikfprintf(function(_a_){return 0;}, b, fmt);
   }
   function printf(fmt){return fprintf(Stdlib[39], fmt);}
   function eprintf(fmt){return fprintf(Stdlib[40], fmt);}
   function ksprintf(k, param){
    var fmt = param[1];
    function k$0(acc){
     var buf = caml_call1(Stdlib_Buffer[1], 64);
     caml_call2(CamlinternalFormat[11], buf, acc);
     return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(function(s){return s;}, fmt);}
   var
    Stdlib_Printf =
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
   runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Dynarray
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Printf, Stdlib__Seq, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_requested = " requested",
    cst_index = ": index ",
    cst_Dynarray = "Dynarray.",
    cst_append$1 = "append",
    cst_dynarray_ml = "dynarray.ml",
    cst_ensure_capacity$0 = "ensure_capacity",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    f$0 = cst_ensure_capacity$0,
    f = "get_last",
    invalid_state_description =
      "Invalid dynarray (unsynchronized concurrent length change)",
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11,
          cst_index,
          [4, 0, 0, 0, [11, " out of bounds (empty dynarray)", 0]]]]],
       "Dynarray.%s: index %d out of bounds (empty dynarray)"],
    _b_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11,
          cst_index,
          [4, 0, 0, 0, [11, " out of bounds (0..", [4, 0, 0, 0, [12, 41, 0]]]]]]],
       "Dynarray.%s: index %d out of bounds (0..%d)"],
    _c_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11, ": negative length ", [4, 0, 0, 0, [11, cst_requested, 0]]]]],
       "Dynarray.%s: negative length %d requested"],
    _d_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11, ": negative capacity ", [4, 0, 0, 0, [11, cst_requested, 0]]]]],
       "Dynarray.%s: negative capacity %d requested"],
    _e_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11,
          ": cannot grow to requested length ",
          [4,
           0,
           0,
           0,
           [11, " (max_array_length is ", [4, 0, 0, 0, [12, 41, 0]]]]]]],
       "Dynarray.%s: cannot grow to requested length %d (max_array_length is %d)"],
    _f_ =
      [0,
       [2,
        0,
        [11,
         ": missing element at position ",
         [4, 0, 0, 0, [11, " < length ", [4, 0, 0, 0, 0]]]]],
       "%s: missing element at position %d < length %d"],
    _g_ =
      [0,
       [2,
        0,
        [11, ": length ", [4, 0, 0, 0, [11, " > capacity ", [4, 0, 0, 0, 0]]]]],
       "%s: length %d > capacity %d"],
    _h_ =
      [0,
       [11,
        cst_Dynarray,
        [2,
         0,
         [11,
          ": a length change from ",
          [4,
           0,
           0,
           0,
           [11, " to ", [4, 0, 0, 0, [11, " occurred during iteration", 0]]]]]]],
       "Dynarray.%s: a length change from %d to %d occurred during iteration"],
    _i_ =
      [0,
       [11, cst_Dynarray, [2, 0, [11, ": empty array", 0]]],
       "Dynarray.%s: empty array"],
    cst_make = "make",
    cst_init = "init",
    cst_get = "get",
    cst_set = "set",
    cst_truncate = "truncate",
    _j_ = [0, cst_dynarray_ml, 381, 4],
    _k_ = [0, cst_dynarray_ml, 380, 4],
    cst_ensure_capacity = cst_ensure_capacity$0,
    cst_set_capacity = "set_capacity",
    cst_append = cst_append$1,
    cst_append$0 = cst_append$1,
    cst_iter = "iter",
    cst_iteri = "iteri",
    cst_map = "map",
    cst_mapi = "mapi",
    cst_fold_left = "fold_left",
    cst_fold_right = "fold_right",
    cst_exists = "exists",
    cst_for_all = "for_all",
    cst_filter = "filter",
    cst_filter_map = "filter_map",
    cst_to_array = "to_array",
    cst_to_list = "to_list",
    cst_to_seq = "to_seq",
    cst_to_seq_rev = "to_seq_rev";
   function negative_length_requested(f, n){
    return caml_call4(Stdlib_Printf[10], Stdlib[1], _c_, f, n);
   }
   function negative_capacity_requested(f, n){
    return caml_call4(Stdlib_Printf[10], Stdlib[1], _d_, f, n);
   }
   function missing_element(i, length){
    return caml_call5
            (Stdlib_Printf[10],
             Stdlib[1],
             _f_,
             invalid_state_description,
             i,
             length);
   }
   function unexpected_empty_element(f, i, length){
    return i < length
            ? missing_element(i, length)
            : 0
              === length
              ? caml_call4(Stdlib_Printf[10], Stdlib[1], _a_, f, i)
              : caml_call5
                (Stdlib_Printf[10], Stdlib[1], _b_, f, i, length - 1 | 0);
   }
   function check_same_length(f, a, expected){
    var length_a = a[1], _W_ = expected !== length_a ? 1 : 0;
    return _W_
            ? caml_call5
              (Stdlib_Printf[10], Stdlib[1], _h_, f, expected, length_a)
            : _W_;
   }
   function check_valid_length(length, arr){
    var capacity = arr.length - 1, _V_ = capacity < length ? 1 : 0;
    return _V_
            ? caml_call5
              (Stdlib_Printf[10],
               Stdlib[1],
               _g_,
               invalid_state_description,
               length,
               capacity)
            : _V_;
   }
   function unsafe_get(arr, i, length){
    var match = arr[1 + i];
    if(! match) return missing_element(i, length);
    var v = match[1];
    return v;
   }
   function create(param){return [0, 0, [0]];}
   function make(n, x){
    if(n < 0) negative_length_requested(cst_make, n);
    return [0,
            n,
            caml_call2(Stdlib_Array[1], n, function(param){return [0, x];})];
   }
   function init(n, f){
    if(n < 0) negative_length_requested(cst_init, n);
    return [0,
            n,
            caml_call2
             (Stdlib_Array[1], n, function(i){return [0, caml_call1(f, i)];})];
   }
   function get(a, i){
    var match = caml_check_bound(a[2], i)[1 + i];
    return match ? match[1] : unexpected_empty_element(cst_get, i, a[1]);
   }
   function set(a, i, x){
    var match = caml_check_bound(a[2], i)[1 + i];
    return match
            ? (match[1] = x, 0)
            : unexpected_empty_element(cst_set, i, a[1]);
   }
   function length(a){return a[1];}
   function is_empty(a){return 0 === a[1] ? 1 : 0;}
   function copy(param){
    var length = param[1], arr = param[2];
    check_valid_length(length, arr);
    return [0,
            length,
            caml_call2
             (Stdlib_Array[1],
              length,
              function(i){var v = unsafe_get(arr, i, length); return [0, v];})];
   }
   function get_last(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    if(0 === length) caml_call3(Stdlib_Printf[10], Stdlib[1], _i_, f);
    return unsafe_get(arr, length - 1 | 0, length);
   }
   function find_last(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    return 0 === length ? 0 : [0, unsafe_get(arr, length - 1 | 0, length)];
   }
   function pop_last(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    if(0 === length) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var last = length - 1 | 0, match = arr[1 + last];
    return match
            ? (arr[1 + last] = 0, a[1] = last, match[1])
            : missing_element(last, length);
   }
   function pop_last_opt(a){
    try{var x = pop_last(a);}
    catch(_U_){
     var _T_ = caml_wrap_exception(_U_);
     if(_T_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_T_, 0);
    }
    return [0, x];
   }
   function remove_last(a){
    var
     last = a[1] - 1 | 0,
     _R_ = 0 <= last ? 1 : 0,
     _S_ =
       _R_
        ? (a[1] = last, caml_check_bound(a[2], last)[1 + last] = 0, 0)
        : _R_;
    return _S_;
   }
   function truncate(a, n){
    if(n < 0) negative_length_requested(cst_truncate, n);
    var length = a[1], arr = a[2];
    return length <= n
            ? 0
            : (a
               [1]
              = n,
              caml_call4(Stdlib_Array[8], arr, n, length - n | 0, 0));
   }
   function clear(a){return truncate(a, 0);}
   function capacity(a){return a[2].length - 1;}
   function ensure_capacity(a, capacity_request){
    var arr = a[2], cur_capacity = arr.length - 1;
    if(0 > capacity_request)
     return negative_capacity_requested(cst_ensure_capacity, capacity_request);
    if(capacity_request <= cur_capacity) return 0;
    if(Stdlib_Sys[13] < capacity_request)
     caml_call5
      (Stdlib_Printf[10],
       Stdlib[1],
       _e_,
       f$0,
       capacity_request,
       Stdlib_Sys[13]);
    var
     n =
       512 < cur_capacity
        ? cur_capacity + (cur_capacity / 2 | 0) | 0
        : cur_capacity * 2 | 0,
     _O_ = Stdlib_Sys[13],
     _P_ = caml_call2(Stdlib[17], 8, n),
     _Q_ = caml_call2(Stdlib[16], _P_, _O_),
     new_capacity = caml_call2(Stdlib[17], _Q_, capacity_request),
     new_arr = caml_make_vect(new_capacity, 0);
    caml_call5(Stdlib_Array[9], arr, 0, new_arr, 0, a[1]);
    a[2] = new_arr;
    if(0 > capacity_request)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(capacity_request <= new_arr.length - 1) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function ensure_extra_capacity(a, extra_capacity_request){
    return ensure_capacity(a, a[1] + extra_capacity_request | 0);
   }
   function fit_capacity(a){
    var _N_ = a[1];
    return capacity(a) === _N_
            ? 0
            : (a[2] = caml_call3(Stdlib_Array[6], a[2], 0, a[1]), 0);
   }
   function set_capacity(a, n){
    if(n < 0) negative_capacity_requested(cst_set_capacity, n);
    var arr = a[2], cur_capacity = arr.length - 1;
    if(n < cur_capacity){
     a[1] = caml_call2(Stdlib[16], a[1], n);
     a[2] = caml_call3(Stdlib_Array[6], arr, 0, n);
     return 0;
    }
    var _L_ = cur_capacity < n ? 1 : 0;
    if(_L_){
     var new_arr = caml_make_vect(n, 0);
     caml_call5(Stdlib_Array[9], arr, 0, new_arr, 0, a[1]);
     a[2] = new_arr;
     var _M_ = 0;
    }
    else
     var _M_ = _L_;
    return _M_;
   }
   function reset(a){a[1] = 0; a[2] = [0]; return 0;}
   function add_last_if_room(a, elem){
    var length = a[1], arr = a[2];
    return arr.length - 1 <= length
            ? 0
            : (a[1] = length + 1 | 0, arr[1 + length] = elem, 1);
   }
   function add_last(a, x){
    var elem = [0, x];
    if(add_last_if_room(a, elem)) return 0;
    for(;;){
     ensure_extra_capacity(a, 1);
     var _K_ = 1 - add_last_if_room(a, elem);
     if(! _K_) return _K_;
    }
   }
   function append_list(a, li){
    var li$0 = li;
    for(;;){
     if(! li$0) return 0;
     var xs = li$0[2], x = li$0[1];
     add_last(a, x);
     li$0 = xs;
    }
   }
   function append_iter(a, iter, b){
    return caml_call2(iter, function(x){return add_last(a, x);}, b);
   }
   function append_seq(a, seq){
    return caml_call2(Stdlib_Seq[4], function(x){return add_last(a, x);}, seq);
   }
   function append_array_if_room(a, b){
    var length_a = a[1], arr = a[2], length_b = b.length - 1;
    if(arr.length - 1 < (length_a + length_b | 0)) return 0;
    a[1] = length_a + length_b | 0;
    var _I_ = length_b - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var x = b[1 + i];
      arr[1 + (length_a + i | 0)] = [0, x];
      var _J_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _J_;
     }
    }
    return 1;
   }
   function append_array(a, b){
    if(append_array_if_room(a, b)) return 0;
    for(;;){
     ensure_extra_capacity(a, b.length - 1);
     var _G_ = 1 - append_array_if_room(a, b);
     if(! _G_) return _G_;
    }
   }
   function append_if_room(a, b, length_b){
    var length_a = a[1], arr_a = a[2];
    if(arr_a.length - 1 < (length_a + length_b | 0)) return 0;
    a[1] = length_a + length_b | 0;
    var arr_b = b[2];
    check_valid_length(length_b, arr_b);
    var _E_ = length_b - 1 | 0, _D_ = 0;
    if(_E_ >= 0){
     var i = _D_;
     for(;;){
      var x = unsafe_get(arr_b, i, length_b);
      arr_a[1 + (length_a + i | 0)] = [0, x];
      var _F_ = i + 1 | 0;
      if(_E_ === i) break;
      i = _F_;
     }
    }
    check_same_length(cst_append, b, length_b);
    return 1;
   }
   function append(a, b){
    var length_b = b[1];
    if(append_if_room(a, b, length_b)) return 0;
    for(;;){
     ensure_extra_capacity(a, length_b);
     check_same_length(cst_append$0, b, length_b);
     var _C_ = 1 - append_if_room(a, b, length_b);
     if(! _C_) return _C_;
    }
   }
   function iter(f, k, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var _A_ = length - 1 | 0, _z_ = 0;
    if(_A_ >= 0){
     var i = _z_;
     for(;;){
      caml_call1(k, unsafe_get(arr, i, length));
      var _B_ = i + 1 | 0;
      if(_A_ === i) break;
      i = _B_;
     }
    }
    return check_same_length(f, a, length);
   }
   function iter$0(k, a){return iter(cst_iter, k, a);}
   function iteri(k, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var _x_ = length - 1 | 0, _w_ = 0;
    if(_x_ >= 0){
     var i = _w_;
     for(;;){
      caml_call2(k, i, unsafe_get(arr, i, length));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return check_same_length(cst_iteri, a, length);
   }
   function map(f, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var
     res =
       [0,
        length,
        caml_call2
         (Stdlib_Array[1],
          length,
          function(i){return [0, caml_call1(f, unsafe_get(arr, i, length))];})];
    check_same_length(cst_map, a, length);
    return res;
   }
   function mapi(f, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var
     res =
       [0,
        length,
        caml_call2
         (Stdlib_Array[1],
          length,
          function(i){
           return [0, caml_call2(f, i, unsafe_get(arr, i, length))];
          })];
    check_same_length(cst_mapi, a, length);
    return res;
   }
   function fold_left(f, acc, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var r = [0, acc], _u_ = length - 1 | 0, _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      var v = unsafe_get(arr, i, length);
      r[1] = caml_call2(f, r[1], v);
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    check_same_length(cst_fold_left, a, length);
    return r[1];
   }
   function fold_right(f, a, acc){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var r = [0, acc], _r_ = length - 1 | 0;
    if(_r_ >= 0){
     var i = _r_;
     for(;;){
      var v = unsafe_get(arr, i, length);
      r[1] = caml_call2(f, v, r[1]);
      var _s_ = i - 1 | 0;
      if(0 === i) break;
      i = _s_;
     }
    }
    check_same_length(cst_fold_right, a, length);
    return r[1];
   }
   function exists(p, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var i = 0;
    for(;;){
     if(i === length)
      var res = 0;
     else{
      var _q_ = caml_call1(p, unsafe_get(arr, i, length));
      if(! _q_){var i$0 = i + 1 | 0; i = i$0; continue;}
      var res = _q_;
     }
     check_same_length(cst_exists, a, length);
     return res;
    }
   }
   function for_all(p, a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var i = 0;
    for(;;){
     if(i === length)
      var res = 1;
     else{
      var _p_ = caml_call1(p, unsafe_get(arr, i, length));
      if(_p_){var i$0 = i + 1 | 0; i = i$0; continue;}
      var res = _p_;
     }
     check_same_length(cst_for_all, a, length);
     return res;
    }
   }
   function filter(f, a){
    var b = create(0);
    iter
     (cst_filter,
      function(x){
       var _o_ = caml_call1(f, x);
       return _o_ ? add_last(b, x) : _o_;
      },
      a);
    return b;
   }
   function filter_map(f, a){
    var b = create(0);
    iter
     (cst_filter_map,
      function(x){
       var match = caml_call1(f, x);
       if(! match) return 0;
       var y = match[1];
       return add_last(b, y);
      },
      a);
    return b;
   }
   function of_array(a){
    var length = a.length - 1;
    return [0,
            length,
            caml_call2
             (Stdlib_Array[1], length, function(i){return [0, a[1 + i]];})];
   }
   function to_array(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var
     res =
       caml_call2
        (Stdlib_Array[1],
         length,
         function(i){return unsafe_get(arr, i, length);});
    check_same_length(cst_to_array, a, length);
    return res;
   }
   function of_list(li){
    var a = create(0);
    caml_call2(Stdlib_List[18], function(x){return add_last(a, x);}, li);
    return a;
   }
   function to_list(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    var l = [0, 0], _l_ = length - 1 | 0;
    if(_l_ >= 0){
     var i = _l_;
     for(;;){
      var _m_ = l[1];
      l[1] = [0, unsafe_get(arr, i, length), _m_];
      var _n_ = i - 1 | 0;
      if(0 === i) break;
      i = _n_;
     }
    }
    check_same_length(cst_to_list, a, length);
    return l[1];
   }
   function of_seq(seq){
    var init = create(0);
    append_seq(init, seq);
    return init;
   }
   function to_seq(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    function aux(i){
     return function(param){
      check_same_length(cst_to_seq, a, length);
      if(length <= i) return 0;
      var v = unsafe_get(arr, i, length);
      return [0, v, aux(i + 1 | 0)];};
    }
    return aux(0);
   }
   function to_seq_reentrant(a){
    function aux(i){
     return function(param){
      if(a[1] <= i) return 0;
      var v = get(a, i);
      return [0, v, aux(i + 1 | 0)];};
    }
    return aux(0);
   }
   function to_seq_rev(a){
    var length = a[1], arr = a[2];
    check_valid_length(length, arr);
    function aux(i){
     return function(param){
      check_same_length(cst_to_seq_rev, a, length);
      if(0 > i) return 0;
      var v = unsafe_get(arr, i, length);
      return [0, v, aux(i - 1 | 0)];};
    }
    return aux(length - 1 | 0);
   }
   function to_seq_rev_reentrant(a){
    function aux(i){
     return function(param){
      if(0 > i) return 0;
      if(a[1] <= i) return aux(a[1] - 1 | 0)(0);
      var v = get(a, i);
      return [0, v, aux(i - 1 | 0)];};
    }
    return aux(a[1] - 1 | 0);
   }
   var
    Stdlib_Dynarray =
      [0,
       create,
       make,
       init,
       get,
       set,
       length,
       is_empty,
       get_last,
       find_last,
       copy,
       add_last,
       append_array,
       append_list,
       append,
       append_seq,
       append_iter,
       pop_last_opt,
       pop_last,
       remove_last,
       truncate,
       clear,
       iter$0,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       exists,
       for_all,
       filter,
       filter_map,
       of_array,
       to_array,
       of_list,
       to_list,
       of_seq,
       to_seq,
       to_seq_reentrant,
       to_seq_rev,
       to_seq_rev_reentrant,
       capacity,
       ensure_capacity,
       ensure_extra_capacity,
       fit_capacity,
       set_capacity,
       reset];
   runtime.caml_register_global(44, Stdlib_Dynarray, "Stdlib__Dynarray");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Arg
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Int, Stdlib__List, Stdlib__Printf, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$8 = "",
    cst$10 = "  ",
    cst_Display_this_list_of_optio$1 = " Display this list of options",
    cst_s = "%s",
    cst_help$4 = "--help",
    cst_help$3 = "-help",
    cst$9 = ".\n",
    cst_a_float$1 = "a float",
    cst_an_integer$1 = "an integer",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$7 = "\n",
    cst$4 = cst$8,
    cst$5 = " ",
    cst$6 = cst$8,
    cst$2 = "(?)",
    cst$3 = "-",
    cst = "}",
    cst$0 = "|",
    cst$1 = "{",
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Int = global_data.Stdlib__Int,
    Bad = [248, "Stdlib.Arg.Bad", caml_fresh_oo_id(0)],
    Help = [248, "Stdlib.Arg.Help", caml_fresh_oo_id(0)],
    Stop = [248, "Stdlib.Arg.Stop", caml_fresh_oo_id(0)],
    cst_none = "<none>",
    _a_ =
      [0, [11, cst$10, [2, 0, [12, 32, [2, 0, [12, 10, 0]]]]], "  %s %s\n"],
    _b_ =
      [0,
       [11, cst$10, [2, 0, [12, 32, [2, 0, [2, 0, [12, 10, 0]]]]]],
       "  %s %s%s\n"],
    _c_ = [0, cst_help$3],
    cst_Display_this_list_of_optio = cst_Display_this_list_of_optio$1,
    cst_help = cst_help$3,
    cst_Display_this_list_of_optio$0 = cst_Display_this_list_of_optio$1,
    cst_help$0 = cst_help$4,
    cst_help$1 = cst_help$4,
    cst_help$2 = cst_help$3,
    _d_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _e_ = [0, [2, 0, 0], cst_s];
   function assoc3(x, l){
    var l$0 = l;
    for(;;){
     if(! l$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = l$0[1], y2 = match[2], y1 = match[1];
     if(caml_equal(y1, x)) return y2;
     var t = l$0[2];
     l$0 = t;
    }
   }
   function make_symlist(prefix, sep, suffix, l){
    if(! l) return cst_none;
    var
     t = l[2],
     h = l[1],
     _az_ = caml_call2(Stdlib[28], prefix, h),
     _aA_ =
       caml_call3
        (Stdlib_List[26],
         function(x, y){
          var _aB_ = caml_call2(Stdlib[28], sep, y);
          return caml_call2(Stdlib[28], x, _aB_);
         },
         _az_,
         t);
    return caml_call2(Stdlib[28], _aA_, suffix);
   }
   function help_action(param){
    throw caml_maybe_attach_backtrace([0, Stop, _c_], 1);
   }
   function add_help(speclist){
    try{assoc3(cst_help$2, speclist); var _aw_ = 0, add1 = _aw_;}
    catch(_ay_){
     var _as_ = caml_wrap_exception(_ay_);
     if(_as_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_as_, 0);
     var
      add1 =
        [0,
         [0, cst_help, [0, help_action], cst_Display_this_list_of_optio],
         0];
    }
    try{assoc3(cst_help$1, speclist); var _av_ = 0, add2 = _av_;}
    catch(_ax_){
     var _at_ = caml_wrap_exception(_ax_);
     if(_at_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_at_, 0);
     var
      add2 =
        [0,
         [0, cst_help$0, [0, help_action], cst_Display_this_list_of_optio$0],
         0];
    }
    var _au_ = caml_call2(Stdlib[37], add1, add2);
    return caml_call2(Stdlib[37], speclist, _au_);
   }
   function usage_b(buf, speclist, errmsg){
    caml_call3(Stdlib_Printf[5], buf, _d_, errmsg);
    var _ap_ = add_help(speclist);
    return caml_call2
            (Stdlib_List[18],
             function(param){
              var
               doc = param[3],
               spec = param[2],
               key = param[1],
               _aq_ = 0 < caml_ml_string_length(doc) ? 1 : 0;
              if(! _aq_) return _aq_;
              if(11 !== spec[0])
               return caml_call4(Stdlib_Printf[5], buf, _a_, key, doc);
              var l = spec[1], _ar_ = make_symlist(cst$1, cst$0, cst, l);
              return caml_call5(Stdlib_Printf[5], buf, _b_, key, _ar_, doc);
             },
             _ap_);
   }
   function usage_string(speclist, errmsg){
    var b = caml_call1(Stdlib_Buffer[1], 200);
    usage_b(b, speclist, errmsg);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function usage(speclist, errmsg){
    var _ao_ = usage_string(speclist, errmsg);
    return caml_call2(Stdlib_Printf[3], _e_, _ao_);
   }
   var
    current = [0, 0],
    _f_ =
      [0,
       [2, 0, [11, ": unknown option '", [2, 0, [11, "'.\n", 0]]]],
       "%s: unknown option '%s'.\n"],
    _g_ = [0, cst_help$3],
    _h_ = [0, cst_help$4],
    _i_ =
      [0,
       [2,
        0,
        [11,
         ": wrong argument '",
         [2,
          0,
          [11,
           "'; option '",
           [2, 0, [11, "' expects ", [2, 0, [11, cst$9, 0]]]]]]]],
       "%s: wrong argument '%s'; option '%s' expects %s.\n"],
    _j_ =
      [0,
       [2, 0, [11, ": option '", [2, 0, [11, "' needs an argument.\n", 0]]]],
       "%s: option '%s' needs an argument.\n"],
    _k_ = [0, [2, 0, [11, ": ", [2, 0, [11, cst$9, 0]]]], "%s: %s.\n"],
    cst_no_argument = "no argument",
    cst_a_boolean = "a boolean",
    cst_an_integer = cst_an_integer$1,
    cst_an_integer$0 = cst_an_integer$1,
    cst_a_float = cst_a_float$1,
    cst_a_float$0 = cst_a_float$1,
    cst_one_of = "one of: ",
    cst_Arg_Expand_is_is_only_allo =
      "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic",
    _l_ = [0, [2, 0, 0], cst_s],
    _m_ = [0, [2, 0, 0], cst_s],
    _n_ = [0, [2, 0, 0], cst_s],
    _o_ = [0, [2, 0, 0], cst_s],
    _p_ = [0, [2, 0, 0], cst_s],
    _q_ = [0, [2, 0, 0], cst_s];
   function int_of_string_opt(x){
    try{var _am_ = [0, runtime.caml_int_of_string(x)]; return _am_;}
    catch(_an_){
     var _al_ = caml_wrap_exception(_an_);
     if(_al_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_al_, 0);
    }
   }
   function float_of_string_opt(x){
    try{var _aj_ = [0, runtime.caml_float_of_string(x)]; return _aj_;}
    catch(_ak_){
     var _ai_ = caml_wrap_exception(_ak_);
     if(_ai_[1] === Stdlib[7]) return 0;
     throw caml_maybe_attach_backtrace(_ai_, 0);
    }
   }
   function parse_and_expand_argv_dynamic_
   (allow_expand, current, argv, speclist, anonfun, errmsg){
    var initpos = current[1];
    function convert_error(error){
     var
      b = caml_call1(Stdlib_Buffer[1], 200),
      progname =
        initpos < argv[1].length - 1
         ? caml_check_bound(argv[1], initpos)[1 + initpos]
         : cst$2;
     switch(error[0]){
       case 0:
        var s = error[1];
        if(s !== cst_help$4 && s !== cst_help$3)
         caml_call4(Stdlib_Printf[5], b, _f_, progname, s);
        break;
       case 1:
        var expected = error[3], arg = error[2], opt = error[1];
        caml_call6(Stdlib_Printf[5], b, _i_, progname, arg, opt, expected);
        break;
       case 2:
        var s$0 = error[1];
        caml_call4(Stdlib_Printf[5], b, _j_, progname, s$0);
        break;
       default:
        var s$1 = error[1];
        caml_call4(Stdlib_Printf[5], b, _k_, progname, s$1);
     }
     usage_b(b, speclist[1], errmsg);
     if(! caml_equal(error, _g_) && ! caml_equal(error, _h_))
      return [0, Bad, caml_call1(Stdlib_Buffer[2], b)];
     return [0, Help, caml_call1(Stdlib_Buffer[2], b)];
    }
    current[1]++;
    for(;;){
     if(current[1] >= argv[1].length - 1) return 0;
     try{
      var _V_ = current[1], s = caml_check_bound(argv[1], _V_)[1 + _V_];
      if(caml_call2(Stdlib_String[11], cst$3, s)){
       try{
        var
         follow$1 = 0,
         _Z_ = assoc3(s, speclist[1]),
         follow$0 = follow$1,
         action = _Z_;
       }
       catch(_ag_){
        var _W_ = caml_wrap_exception(_ag_);
        if(_W_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_W_, 0);
        try{
         var
          i = caml_call2(Stdlib_String[36], s, 61),
          len = caml_ml_string_length(s),
          arg =
            caml_call3(Stdlib_String[16], s, i + 1 | 0, len - (i + 1 | 0) | 0),
          keyword = caml_call3(Stdlib_String[16], s, 0, i),
          follow = [0, arg],
          _Y_ = assoc3(keyword, speclist[1]),
          follow$0 = follow,
          action = _Y_;
        }
        catch(_ah_){
         var _X_ = caml_wrap_exception(_ah_);
         if(_X_ === Stdlib[8])
          throw caml_maybe_attach_backtrace([0, Stop, [0, s]], 1);
         throw caml_maybe_attach_backtrace(_X_, 0);
        }
       }
       let s$0 = s, follow$2 = follow$0;
       var
        no_arg =
          function(param){
           if(! follow$2) return;
           var arg = follow$2[1];
           throw caml_maybe_attach_backtrace
                  ([0, Stop, [1, s$0, arg, cst_no_argument]], 1);
          },
        get_arg =
          function(param){
           if(follow$2){var arg = follow$2[1]; return arg;}
           if((current[1] + 1 | 0) >= argv[1].length - 1)
            throw caml_maybe_attach_backtrace([0, Stop, [2, s$0]], 1);
           var _af_ = current[1] + 1 | 0;
           return caml_check_bound(argv[1], _af_)[1 + _af_];
          },
        consume_arg =
          function(param){return follow$2 ? 0 : (current[1]++, 0);},
        treat_action =
          function(param){
           switch(param[0]){
             case 0:
              var f = param[1]; no_arg$0(0); return caml_call1(f, 0);
             case 1:
              var f$0 = param[1], arg = get_arg$0(0);
              try{var _$_ = [0, caml_call1(Stdlib[32], arg)], match = _$_;}
              catch(_ae_){
               var ___ = caml_wrap_exception(_ae_);
               if(___[1] !== Stdlib[6])
                throw caml_maybe_attach_backtrace(___, 0);
               var match = 0;
              }
              if(! match)
               throw caml_maybe_attach_backtrace
                      ([0, Stop, [1, s$0, arg, cst_a_boolean]], 1);
              var s = match[1];
              caml_call1(f$0, s);
              return consume_arg$0(0);
             case 2:
              var r = param[1]; no_arg$0(0); r[1] = 1; return 0;
             case 3:
              var r$0 = param[1]; no_arg$0(0); r$0[1] = 0; return 0;
             case 4:
              var f$1 = param[1], arg$0 = get_arg$0(0);
              caml_call1(f$1, arg$0);
              return consume_arg$0(0);
             case 5:
              var r$1 = param[1];
              r$1[1] = get_arg$0(0);
              return consume_arg$0(0);
             case 6:
              var
               f$2 = param[1],
               arg$1 = get_arg$0(0),
               match$0 = int_of_string_opt(arg$1);
              if(! match$0)
               throw caml_maybe_attach_backtrace
                      ([0, Stop, [1, s$0, arg$1, cst_an_integer]], 1);
              var x = match$0[1];
              caml_call1(f$2, x);
              return consume_arg$0(0);
             case 7:
              var
               r$2 = param[1],
               arg$2 = get_arg$0(0),
               match$1 = int_of_string_opt(arg$2);
              if(! match$1)
               throw caml_maybe_attach_backtrace
                      ([0, Stop, [1, s$0, arg$2, cst_an_integer$0]], 1);
              var x$0 = match$1[1];
              r$2[1] = x$0;
              return consume_arg$0(0);
             case 8:
              var
               f$3 = param[1],
               arg$3 = get_arg$0(0),
               match$2 = float_of_string_opt(arg$3);
              if(! match$2)
               throw caml_maybe_attach_backtrace
                      ([0, Stop, [1, s$0, arg$3, cst_a_float]], 1);
              var x$1 = match$2[1];
              caml_call1(f$3, x$1);
              return consume_arg$0(0);
             case 9:
              var
               r$3 = param[1],
               arg$4 = get_arg$0(0),
               match$3 = float_of_string_opt(arg$4);
              if(! match$3)
               throw caml_maybe_attach_backtrace
                      ([0, Stop, [1, s$0, arg$4, cst_a_float$0]], 1);
              var x$2 = match$3[1];
              r$3[1] = x$2;
              return consume_arg$0(0);
             case 10:
              var specs = param[1];
              no_arg$0(0);
              return caml_call2(Stdlib_List[18], treat_action$0, specs);
             case 11:
              var f$4 = param[2], symb = param[1], arg$5 = get_arg$0(0);
              if(caml_call2(Stdlib_List[37], arg$5, symb)){
               caml_call1(f$4, arg$5);
               return consume_arg$0(0);
              }
              var _aa_ = make_symlist(cst$6, cst$5, cst$4, symb);
              throw caml_maybe_attach_backtrace
                     ([0,
                       Stop,
                       [1, s$0, arg$5, caml_call2(Stdlib[28], cst_one_of, _aa_)]],
                      1);
             case 12:
              var f$5 = param[1];
              no_arg$0(0);
              for(;;){
               if(current[1] >= (argv[1].length - 2 | 0)) return 0;
               var _ab_ = current[1] + 1 | 0;
               caml_call1(f$5, caml_check_bound(argv[1], _ab_)[1 + _ab_]);
               consume_arg$0(0);
              }
              break;
             case 13:
              var f$6 = param[1];
              no_arg$0(0);
              var acc = [0, 0];
              for(;;){
               if(current[1] >= (argv[1].length - 2 | 0))
                return caml_call1(f$6, caml_call1(Stdlib_List[10], acc[1]));
               var _ad_ = current[1] + 1 | 0, _ac_ = acc[1];
               acc[1] = [0, caml_check_bound(argv[1], _ad_)[1 + _ad_], _ac_];
               consume_arg$0(0);
              }
              break;
             default:
              var f$7 = param[1];
              if(1 - allow_expand)
               throw caml_maybe_attach_backtrace
                      ([0, Stdlib[6], cst_Arg_Expand_is_is_only_allo], 1);
              var arg$6 = get_arg$0(0), newarg = caml_call1(f$7, arg$6);
              consume_arg$0(0);
              var
               before =
                 caml_call3(Stdlib_Array[6], argv[1], 0, current[1] + 1 | 0),
               after =
                 caml_call3
                  (Stdlib_Array[6],
                   argv[1],
                   current[1] + 1 | 0,
                   (argv[1].length - 1 - current[1] | 0) - 1 | 0);
              argv[1] =
               caml_call1
                (Stdlib_Array[5], [0, before, [0, newarg, [0, after, 0]]]);
              return 0;
           }
          };
       let
        no_arg$0 = no_arg,
        get_arg$0 = get_arg,
        consume_arg$0 = consume_arg,
        treat_action$0 = treat_action;
       treat_action(action);
      }
      else
       caml_call1(anonfun, s);
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] === Bad){
       var m = exn[2];
       throw caml_maybe_attach_backtrace(convert_error([3, m]), 1);
      }
      if(exn[1] !== Stop) throw caml_maybe_attach_backtrace(exn, 0);
      var e = exn[2];
      throw caml_maybe_attach_backtrace(convert_error(e), 1);
     }
     current[1]++;
    }
   }
   function parse_and_expand_argv_dynamic
   (current, argv, speclist, anonfun, errmsg){
    return parse_and_expand_argv_dynamic_
            (1, current, argv, speclist, anonfun, errmsg);
   }
   function parse_argv_dynamic(opt, argv, speclist, anonfun, errmsg){
    var current$0 = opt ? opt[1] : current;
    return parse_and_expand_argv_dynamic_
            (0, current$0, [0, argv], speclist, anonfun, errmsg);
   }
   function parse_argv(opt, argv, speclist, anonfun, errmsg){
    var current$0 = opt ? opt[1] : current;
    return parse_argv_dynamic
            ([0, current$0], argv, [0, speclist], anonfun, errmsg);
   }
   function parse(l, f, msg){
    try{var _U_ = parse_argv(0, caml_sys_argv(0), l, f, msg); return _U_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _l_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _m_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function parse_dynamic(l, f, msg){
    try{
     var _T_ = parse_argv_dynamic(0, caml_sys_argv(0), l, f, msg);
     return _T_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _n_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _o_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function parse_expand(l, f, msg){
    try{
     var
      argv = [0, caml_sys_argv(0)],
      spec = [0, l],
      current$0 = [0, current[1]],
      _S_ = parse_and_expand_argv_dynamic(current$0, argv, spec, f, msg);
     return _S_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] === Bad){
      var msg$0 = exn[2];
      caml_call2(Stdlib_Printf[3], _p_, msg$0);
      return caml_call1(Stdlib[99], 2);
     }
     if(exn[1] !== Help) throw caml_maybe_attach_backtrace(exn, 0);
     var msg$1 = exn[2];
     caml_call2(Stdlib_Printf[2], _q_, msg$1);
     return caml_call1(Stdlib[99], 0);
    }
   }
   function second_word(s){
    var len = caml_ml_string_length(s);
    function loop(n){
     var n$0 = n;
     for(;;){
      if(len <= n$0) return len;
      if(32 !== caml_string_get(s, n$0)) return n$0;
      var n$1 = n$0 + 1 | 0;
      n$0 = n$1;
     }
    }
    try{var n$0 = caml_call2(Stdlib_String[36], s, 9);}
    catch(_Q_){
     var _O_ = caml_wrap_exception(_Q_);
     if(_O_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_O_, 0);
     try{var n = caml_call2(Stdlib_String[36], s, 32);}
     catch(_R_){
      var _P_ = caml_wrap_exception(_R_);
      if(_P_ === Stdlib[8]) return len;
      throw caml_maybe_attach_backtrace(_P_, 0);
     }
     return loop(n + 1 | 0);
    }
    return loop(n$0 + 1 | 0);
   }
   function max_arg_len(cur, param){
    var doc = param[3], spec = param[2], kwd = param[1];
    if(11 === spec[0])
     return caml_call2(Stdlib_Int[11], cur, caml_ml_string_length(kwd));
    var _N_ = caml_ml_string_length(kwd) + second_word(doc) | 0;
    return caml_call2(Stdlib_Int[11], cur, _N_);
   }
   function replace_leading_tab(s){
    var seen = [0, 0];
    return caml_call2
            (Stdlib_String[18],
             function(c){
              if(9 === c && ! seen[1]){seen[1] = 1; return 32;}
              return c;
             },
             s);
   }
   function align(opt, speclist){
    var
     limit = opt ? opt[1] : Stdlib[19],
     completed = add_help(speclist),
     len = caml_call3(Stdlib_List[26], max_arg_len, 0, completed),
     len$0 = caml_call2(Stdlib_Int[10], len, limit);
    return caml_call2
            (Stdlib_List[20],
             function(ksd){
              var kwd = ksd[1], spec = ksd[2];
              if(ksd[3] === cst$8) return ksd;
              if(11 === spec[0]){
               var
                msg$0 = ksd[3],
                cutcol$0 = second_word(msg$0),
                _K_ =
                  caml_call2(Stdlib_Int[11], 0, len$0 - cutcol$0 | 0) + 3 | 0,
                spaces$0 = caml_call2(Stdlib_String[1], _K_, 32),
                _L_ = replace_leading_tab(msg$0),
                _M_ = caml_call2(Stdlib[28], spaces$0, _L_);
               return [0, kwd, spec, caml_call2(Stdlib[28], cst$7, _M_)];
              }
              var
               msg = ksd[3],
               spec$0 = ksd[2],
               cutcol = second_word(msg),
               kwd_len = caml_ml_string_length(kwd),
               diff = (len$0 - kwd_len | 0) - cutcol | 0;
              if(0 >= diff) return [0, kwd, spec$0, replace_leading_tab(msg)];
              var
               spaces = caml_call2(Stdlib_String[1], diff, 32),
               _I_ = replace_leading_tab(msg),
               prefix = caml_call3(Stdlib_String[16], _I_, 0, cutcol),
               suffix =
                 caml_call3
                  (Stdlib_String[16],
                   msg,
                   cutcol,
                   caml_ml_string_length(msg) - cutcol | 0),
               _J_ = caml_call2(Stdlib[28], spaces, suffix);
              return [0, kwd, spec$0, caml_call2(Stdlib[28], prefix, _J_)];
             },
             completed);
   }
   function read_aux(trim, sep, file){
    var
     ic = caml_call1(Stdlib[80], file),
     buf = caml_call1(Stdlib_Buffer[1], 200),
     words = [0, 0];
    function stash(param){
     var word = caml_call1(Stdlib_Buffer[2], buf);
     if(trim){
      var len = caml_ml_string_length(word);
      a:
      {
       if(0 < len && 13 === caml_string_get(word, len - 1 | 0)){
        var _H_ = caml_call3(Stdlib_String[16], word, 0, len - 1 | 0);
        break a;
       }
       var _H_ = word;
      }
      var word$0 = _H_;
     }
     else
      var word$0 = word;
     words[1] = [0, word$0, words[1]];
     return caml_call1(Stdlib_Buffer[8], buf);
    }
    try{
     for(;;){
      var c = caml_call1(Stdlib[82], ic);
      if(c === sep) stash(0); else caml_call2(Stdlib_Buffer[12], buf, c);
     }
    }
    catch(_G_){
     var _E_ = caml_wrap_exception(_G_);
     if(_E_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_E_, 0);
     if(0 < caml_call1(Stdlib_Buffer[7], buf)) stash(0);
     caml_call1(Stdlib[93], ic);
     var _F_ = caml_call1(Stdlib_List[10], words[1]);
     return caml_call1(Stdlib_Array[11], _F_);
    }
   }
   var _r_ = 10, _s_ = 1;
   function read_arg(_D_){return read_aux(_s_, _r_, _D_);}
   var _t_ = 0, _u_ = 0, _v_ = [0, [2, 0, [0, 0]], "%s%c"];
   function read_arg0(_C_){return read_aux(_u_, _t_, _C_);}
   function write_aux(sep, file, args){
    var oc = caml_call1(Stdlib[61], file);
    caml_call2
     (Stdlib_Array[12],
      function(s){return caml_call4(Stdlib_Printf[1], oc, _v_, s, sep);},
      args);
    return caml_call1(Stdlib[76], oc);
   }
   var _w_ = 10;
   function write_arg(_A_, _B_){return write_aux(_w_, _A_, _B_);}
   var _x_ = 0;
   function write_arg0(_y_, _z_){return write_aux(_x_, _y_, _z_);}
   var
    Stdlib_Arg =
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
   runtime.caml_register_global(55, Stdlib_Arg, "Stdlib__Arg");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Printexc
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Buffer, Stdlib__Obj, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_s = "%s\n",
    cst_Program_not_linked_with_g_$0 =
      "(Program not linked with -g, cannot print stack backtrace)\n",
    cst_characters = ", characters ",
    cst_Fatal_error_exception = "Fatal error: exception ",
    cst_Fatal_error_exception_s = "Fatal error: exception %s\n",
    cst_Uncaught_exception = "Uncaught exception: ",
    cst_Uncaught_exception_s = "Uncaught exception: %s\n",
    caml_check_bound = runtime.caml_check_bound,
    caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$4,
    cst$3 = cst$4,
    partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]],
    cst$1 = cst$4,
    cst$2 = cst$4,
    cst = "_",
    locfmt =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            cst_characters,
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]]]]]],
       'File "%s", line %d, characters %d-%d: %s'],
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Obj = global_data.Stdlib__Obj,
    printers = caml_call1(Stdlib_Atomic[1], 0),
    _a_ = [0, [3, 0, 0], "%S"],
    _b_ = [0, [4, 0, 0, 0, 0], "%d"],
    _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"],
    _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"],
    _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"],
    cst_Out_of_memory = "Out of memory",
    cst_Stack_overflow = "Stack overflow",
    cst_Pattern_matching_failed = "Pattern matching failed",
    cst_Assertion_failed = "Assertion failed",
    cst_Undefined_recursive_module = "Undefined recursive module",
    _f_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    _g_ =
      [0,
       [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
       cst_Uncaught_exception_s],
    cst_Raised_at = "Raised at",
    cst_Re_raised_at = "Re-raised at",
    cst_Raised_by_primitive_operat = "Raised by primitive operation at",
    cst_Called_from = "Called from",
    _h_ = [0, [12, 32, [4, 0, 0, 0, 0]], " %d"],
    cst_inlined = " (inlined)",
    _i_ =
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           ' in file "',
           [2,
            0,
            [12,
             34,
             [2, 0, [11, ", line", [2, 0, [11, cst_characters, partial]]]]]]]]]],
       '%s %s in file "%s"%s, line%s, characters %d-%d'],
    _j_ = [0, [11, "s ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]], "s %d-%d"],
    _k_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"],
    _l_ = [0, [2, 0, [12, 10, 0]], cst_s],
    _m_ =
      [0,
       [11, cst_Program_not_linked_with_g_$0, 0],
       cst_Program_not_linked_with_g_$0],
    _n_ = [0, [2, 0, [12, 10, 0]], cst_s],
    cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
   function field(x, i){
    var f = x[1 + i];
    if(! caml_call1(Stdlib_Obj[1], f))
     return caml_call2(Stdlib_Printf[4], _b_, f);
    var _ah_ = Stdlib_Obj[15];
    if(caml_obj_tag(f) === _ah_) return caml_call2(Stdlib_Printf[4], _a_, f);
    var _ai_ = Stdlib_Obj[16];
    return caml_obj_tag(f) === _ai_ ? caml_call1(Stdlib[35], f) : cst;
   }
   function other_fields(x, i){
    if(x.length - 1 <= i) return cst$0;
    var _af_ = other_fields(x, i + 1 | 0), _ag_ = field(x, i);
    return caml_call3(Stdlib_Printf[4], _c_, _ag_, _af_);
   }
   function use_printers(x){
    var param = caml_call1(Stdlib_Atomic[3], printers);
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     a:
     {
      try{var val = caml_call1(hd, x);}catch(_ae_){break a;}
      if(val){var s = val[1]; return [0, s];}
     }
     param = tl;
    }
   }
   function string_of_extension_constructo(t){
    if(0 === caml_obj_tag(t)){
     var constructor = t[1][1], match = t.length - 1;
     if(2 < match >>> 0)
      var
       _aa_ = other_fields(t, 2),
       _ab_ = field(t, 1),
       _ad_ = caml_call3(Stdlib_Printf[4], _d_, _ab_, _aa_);
     else
      switch(match){
        case 0:
         var _ad_ = cst$1; break;
        case 1:
         var _ad_ = cst$2; break;
        default:
         var
          _ac_ = field(t, 1),
          _ad_ = caml_call2(Stdlib_Printf[4], _e_, _ac_);
      }
     var match$0 = [0, constructor, [0, _ad_]];
    }
    else
     var match$0 = [0, t[1], 0];
    var fields_opt = match$0[2], constructor$0 = match$0[1];
    if(! fields_opt) return constructor$0;
    var f = fields_opt[1];
    return caml_call2(Stdlib[28], constructor$0, f);
   }
   function to_string_default(x){
    if(x === Stdlib[9]) return cst_Out_of_memory;
    if(x === Stdlib[10]) return cst_Stack_overflow;
    if(x[1] === Stdlib[4]){
     var match = x[2], char$0 = match[3], line = match[2], file = match[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file,
              line,
              char$0,
              char$0 + 5 | 0,
              cst_Pattern_matching_failed);
    }
    if(x[1] === Stdlib[5]){
     var
      match$0 = x[2],
      char$1 = match$0[3],
      line$0 = match$0[2],
      file$0 = match$0[1];
     return caml_call6
             (Stdlib_Printf[4],
              locfmt,
              file$0,
              line$0,
              char$1,
              char$1 + 6 | 0,
              cst_Assertion_failed);
    }
    if(x[1] !== Stdlib[15]) return string_of_extension_constructo(x);
    var
     match$1 = x[2],
     char$2 = match$1[3],
     line$1 = match$1[2],
     file$1 = match$1[1];
    return caml_call6
            (Stdlib_Printf[4],
             locfmt,
             file$1,
             line$1,
             char$2,
             char$2 + 6 | 0,
             cst_Undefined_recursive_module);
   }
   function to_string(e){
    var match = use_printers(e);
    if(! match) return to_string_default(e);
    var s = match[1];
    return s;
   }
   function print(fct, arg){
    try{var _$_ = caml_call1(fct, arg); return _$_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0), ___ = to_string(x);
     caml_call2(Stdlib_Printf[3], _f_, ___);
     caml_call1(Stdlib[63], Stdlib[40]);
     throw caml_maybe_attach_backtrace(x, 0);
    }
   }
   function catch$0(fct, arg){
    try{var _Z_ = caml_call1(fct, arg); return _Z_;}
    catch(x$0){
     var x = caml_wrap_exception(x$0);
     caml_call1(Stdlib[63], Stdlib[39]);
     var _Y_ = to_string(x);
     caml_call2(Stdlib_Printf[3], _g_, _Y_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   function raw_backtrace_entries(bt){return bt;}
   function convert_raw_backtrace(bt){
    return [0, runtime.caml_convert_raw_backtrace(bt)];
   }
   function format_backtrace_slot(pos, slot){
    function info(is_raise){
     return is_raise
             ? 0 === pos ? cst_Raised_at : cst_Re_raised_at
             : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
    }
    if(0 === slot[0]){
     var
      lines =
        slot[3] === slot[6]
         ? caml_call2(Stdlib_Printf[4], _h_, slot[3])
         : caml_call3(Stdlib_Printf[4], _j_, slot[3], slot[6]),
      _R_ = slot[7],
      _S_ = slot[4],
      _T_ = slot[8] ? cst_inlined : cst$3,
      _U_ = slot[2],
      _V_ = slot[9],
      _W_ = info(slot[1]);
     return [0,
             caml_call8
              (Stdlib_Printf[4], _i_, _W_, _V_, _U_, _T_, lines, _S_, _R_)];
    }
    if(slot[1]) return 0;
    var _X_ = info(0);
    return [0, caml_call2(Stdlib_Printf[4], _k_, _X_)];
   }
   function print_raw_backtrace(outchan, raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return caml_call2(Stdlib_Printf[1], outchan, _m_);
    var a = backtrace[1], _P_ = a.length - 2 | 0, _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[1], outchan, _l_, str);
      }
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      i = _Q_;
     }
    }
    return 0;
   }
   function print_backtrace(outchan){
    return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
   }
   function raw_backtrace_to_string(raw_backtrace){
    var backtrace = convert_raw_backtrace(raw_backtrace);
    if(! backtrace) return cst_Program_not_linked_with_g_;
    var
     a = backtrace[1],
     b = caml_call1(Stdlib_Buffer[1], 1024),
     _M_ = a.length - 2 | 0,
     _L_ = 0;
    if(_M_ >= 0){
     var i = _L_;
     for(;;){
      var match = format_backtrace_slot(i, caml_check_bound(a, i)[1 + i]);
      if(match){
       var str = match[1];
       caml_call3(Stdlib_Printf[5], b, _n_, str);
      }
      var _N_ = i + 1 | 0;
      if(_M_ === i) break;
      i = _N_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function backtrace_slot_is_raise(param){
    return 0 === param[0] ? param[1] : param[1];
   }
   function backtrace_slot_is_inline(param){return 0 === param[0] ? param[8] : 0;
   }
   function backtrace_slot_location(param){
    return 0 === param[0]
            ? [0,
              [0, param[2], param[3], param[4], param[5], param[6], param[7]]]
            : 0;
   }
   function backtrace_slot_defname(param){
    if(0 === param[0] && param[9] !== cst$4) return [0, param[9]];
    return 0;
   }
   function backtrace_slots(raw_backtrace){
    var match = convert_raw_backtrace(raw_backtrace);
    if(! match) return 0;
    var backtrace = match[1], i$1 = backtrace.length - 2 | 0, i = i$1;
    for(;;){
     if(-1 === i)
      var _K_ = 0;
     else{
      var _J_ = 0 === caml_check_bound(backtrace, i)[1 + i][0] ? 1 : 0;
      if(! _J_){var i$0 = i - 1 | 0; i = i$0; continue;}
      var _K_ = _J_;
     }
     return _K_ ? [0, backtrace] : 0;
    }
   }
   function backtrace_slots_of_raw_entry(entry){return backtrace_slots([0, entry]);
   }
   function raw_backtrace_length(bt){return bt.length - 1;}
   function get_backtrace(param){
    return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
   }
   function register_printer(fn){
    for(;;){
     var
      old_printers = caml_call1(Stdlib_Atomic[3], printers),
      new_printers = [0, fn, old_printers],
      success =
        caml_call3(Stdlib_Atomic[6], printers, old_printers, new_printers),
      _I_ = 1 - success;
     if(! _I_) return _I_;
    }
   }
   function exn_slot(x){return 0 === caml_obj_tag(x) ? x[1] : x;}
   function exn_slot_id(x){var slot = exn_slot(x); return slot[2];}
   function exn_slot_name(x){var slot = exn_slot(x); return slot[1];}
   var
    errors =
      [0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"].slice
       (),
    _o_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s];
   function default_uncaught_exception_han(exn, raw_backtrace){
    var _F_ = to_string(exn);
    caml_call2(Stdlib_Printf[3], _o_, _F_);
    print_raw_backtrace(Stdlib[40], raw_backtrace);
    var status = runtime.caml_ml_debug_info_status(0);
    if(status < 0){
     var
      _G_ = caml_call1(Stdlib[18], status),
      _H_ = caml_check_bound(errors, _G_)[1 + _G_];
     caml_call1(Stdlib[53], _H_);
    }
    return caml_call1(Stdlib[63], Stdlib[40]);
   }
   var uncaught_exception_handler = [0, default_uncaught_exception_han];
   function set_uncaught_exception_handler(fn){
    uncaught_exception_handler[1] = fn;
    return 0;
   }
   var
    empty_backtrace = [0],
    cst_Fatal_error_out_of_memory_ =
      "Fatal error: out of memory in uncaught exception handler",
    _p_ =
      [0,
       [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
       cst_Fatal_error_exception_s],
    _q_ =
      [0,
       [11,
        "Fatal error in uncaught exception handler: exception ",
        [2, 0, [12, 10, 0]]],
       "Fatal error in uncaught exception handler: exception %s\n"];
   function handle_uncaught_exception(exn$0, debugger_in_use){
    try{
     try{
      var
       raw_backtrace =
         debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
      try{caml_call1(Stdlib[103], 0);}catch(_E_){}
      try{
       var
        _A_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace),
        _z_ = _A_;
      }
      catch(exn$1){
       var
        exn = caml_wrap_exception(exn$1),
        raw_backtrace$0 = caml_get_exception_raw_backtra(0),
        _x_ = to_string(exn$0);
       caml_call2(Stdlib_Printf[3], _p_, _x_);
       print_raw_backtrace(Stdlib[40], raw_backtrace);
       var _y_ = to_string(exn);
       caml_call2(Stdlib_Printf[3], _q_, _y_);
       print_raw_backtrace(Stdlib[40], raw_backtrace$0);
       var _z_ = caml_call1(Stdlib[63], Stdlib[40]);
      }
      var _B_ = _z_;
     }
     catch(_D_){
      var _w_ = caml_wrap_exception(_D_);
      if(_w_ !== Stdlib[9]) throw caml_maybe_attach_backtrace(_w_, 0);
      var _B_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
     }
     return _B_;
    }
    catch(_C_){return 0;}
   }
   runtime.caml_register_named_value
    ("Printexc.handle_uncaught_exception", handle_uncaught_exception);
   var
    Stdlib_Printexc =
      [0,
       to_string,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       runtime.caml_record_backtrace,
       runtime.caml_backtrace_status,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       function(_v_){return caml_get_exception_raw_backtra(_v_);},
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       [0,
        backtrace_slot_is_raise,
        backtrace_slot_is_inline,
        backtrace_slot_location,
        backtrace_slot_defname,
        format_backtrace_slot],
       raw_backtrace_length,
       function(_u_, _t_){return runtime.caml_raw_backtrace_slot(_u_, _t_);},
       function(_s_){return runtime.caml_convert_raw_backtrace_slot(_s_);},
       function(_r_){return runtime.caml_raw_backtrace_next_slot(_r_);},
       exn_slot_id,
       exn_slot_name,
       string_of_extension_constructo];
   runtime.caml_register_global(43, Stdlib_Printexc, "Stdlib__Printexc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Fun
//# unitInfo: Requires: Stdlib, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib = global_data.Stdlib;
   function const$0(c, param){return c;}
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function negate(p, v){return 1 - caml_call1(p, v);}
   var
    Finally_raised =
      [248, "Stdlib.Fun.Finally_raised", runtime.caml_fresh_oo_id(0)],
    cst_Fun_Finally_raised = "Fun.Finally_raised: ";
   caml_call1
    (Stdlib_Printexc[9],
     function(param){
      if(param[1] !== Finally_raised) return 0;
      var exn = param[2], _a_ = caml_call1(Stdlib_Printexc[1], exn);
      return [0, caml_call2(Stdlib[28], cst_Fun_Finally_raised, _a_)];
     });
   function protect(finally$0, work){
    function finally_no_exn(param){
     try{caml_call1(finally$0, 0); return;}
     catch(e$0){
      var
       e = caml_wrap_exception(e$0),
       bt = caml_call1(Stdlib_Printexc[12], 0),
       exn = [0, Finally_raised, e];
      caml_restore_raw_backtrace(exn, bt);
      throw caml_maybe_attach_backtrace(exn, 0);
     }
    }
    try{var result = caml_call1(work, 0);}
    catch(work_exn$0){
     var
      work_exn = caml_wrap_exception(work_exn$0),
      work_bt = caml_call1(Stdlib_Printexc[12], 0);
     finally_no_exn(0);
     caml_restore_raw_backtrace(work_exn, work_bt);
     throw caml_maybe_attach_backtrace(work_exn, 0);
    }
    finally_no_exn(0);
    return result;
   }
   var
    Stdlib_Fun = [0, const$0, compose, flip, negate, protect, Finally_raised];
   runtime.caml_register_global(4, Stdlib_Fun, "Stdlib__Fun");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Gc
//# unitInfo: Requires: Stdlib, Stdlib__Atomic, Stdlib__Domain, Stdlib__Fun, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "\n",
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Atomic = global_data.Stdlib__Atomic;
   global_data.Stdlib__Fun;
   var
    Stdlib = global_data.Stdlib,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ =
      [0,
       [11, "minor_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "minor_collections:      %d\n"],
    _b_ =
      [0,
       [11, "major_collections:      ", [4, 0, 0, 0, [12, 10, 0]]],
       "major_collections:      %d\n"],
    _c_ =
      [0,
       [11, "compactions:            ", [4, 0, 0, 0, [12, 10, 0]]],
       "compactions:            %d\n"],
    _d_ =
      [0,
       [11, "forced_major_collections: ", [4, 0, 0, 0, [12, 10, 0]]],
       "forced_major_collections: %d\n"],
    _e_ = [0, [12, 10, 0], cst],
    _f_ = [0, [8, [0, 0, 0], 0, [0, 0], 0], "%.0f"],
    _g_ =
      [0,
       [11, "minor_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "minor_words:    %*.0f\n"],
    _h_ =
      [0,
       [11, "promoted_words: ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "promoted_words: %*.0f\n"],
    _i_ =
      [0,
       [11, "major_words:    ", [8, [0, 0, 0], [1, 1], [0, 0], [12, 10, 0]]],
       "major_words:    %*.0f\n"],
    _j_ = [0, [12, 10, 0], cst],
    _k_ = [0, [4, 0, 0, 0, 0], "%d"],
    _l_ =
      [0,
       [11, "top_heap_words: ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "top_heap_words: %*d\n"],
    _m_ =
      [0,
       [11, "heap_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "heap_words:     %*d\n"],
    _n_ =
      [0,
       [11, "live_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "live_words:     %*d\n"],
    _o_ =
      [0,
       [11, "free_words:     ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "free_words:     %*d\n"],
    _p_ =
      [0,
       [11, "largest_free:   ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "largest_free:   %*d\n"],
    _q_ =
      [0,
       [11, "fragments:      ", [4, 0, [1, 1], 0, [12, 10, 0]]],
       "fragments:      %*d\n"],
    _r_ = [0, [12, 10, 0], cst],
    _s_ =
      [0,
       [11, "live_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "live_blocks: %d\n"],
    _t_ =
      [0,
       [11, "free_blocks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "free_blocks: %d\n"],
    _u_ =
      [0,
       [11, "heap_chunks: ", [4, 0, 0, 0, [12, 10, 0]]],
       "heap_chunks: %d\n"];
   function eventlog_pause(param){return 0;}
   function eventlog_resume(param){return 0;}
   function print_stat(c){
    var st = runtime.caml_gc_stat(0);
    caml_call3(Stdlib_Printf[1], c, _a_, st[4]);
    caml_call3(Stdlib_Printf[1], c, _b_, st[5]);
    caml_call3(Stdlib_Printf[1], c, _c_, st[14]);
    caml_call3(Stdlib_Printf[1], c, _d_, st[17]);
    caml_call2(Stdlib_Printf[1], c, _e_);
    var l1 = caml_ml_string_length(caml_call2(Stdlib_Printf[4], _f_, st[1]));
    caml_call4(Stdlib_Printf[1], c, _g_, l1, st[1]);
    caml_call4(Stdlib_Printf[1], c, _h_, l1, st[2]);
    caml_call4(Stdlib_Printf[1], c, _i_, l1, st[3]);
    caml_call2(Stdlib_Printf[1], c, _j_);
    var l2 = caml_ml_string_length(caml_call2(Stdlib_Printf[4], _k_, st[15]));
    caml_call4(Stdlib_Printf[1], c, _l_, l2, st[15]);
    caml_call4(Stdlib_Printf[1], c, _m_, l2, st[6]);
    caml_call4(Stdlib_Printf[1], c, _n_, l2, st[8]);
    caml_call4(Stdlib_Printf[1], c, _o_, l2, st[10]);
    caml_call4(Stdlib_Printf[1], c, _p_, l2, st[12]);
    caml_call4(Stdlib_Printf[1], c, _q_, l2, st[13]);
    caml_call2(Stdlib_Printf[1], c, _r_);
    caml_call3(Stdlib_Printf[1], c, _s_, st[9]);
    caml_call3(Stdlib_Printf[1], c, _t_, st[11]);
    return caml_call3(Stdlib_Printf[1], c, _u_, st[7]);
   }
   function allocated_bytes(param){
    var
     match = runtime.caml_gc_counters(0),
     ma = match[3],
     pro = match[2],
     mi = match[1];
    return (mi + ma - pro) * (Stdlib_Sys[9] / 8 | 0);
   }
   function delete_alarm(a){return caml_call2(Stdlib_Atomic[4], a, 0);}
   function create_alarm(f){
    var _y_ = caml_call1(Stdlib_Atomic[1], 1);
    caml_call1(Stdlib_Domain[6], function(param){return delete_alarm(_y_);});
    return _y_;
   }
   var
    null_tracker =
      [0,
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;},
       function(param){return 0;}];
   function start(sampling_rate, opt, tracker){
    var callstack_size = opt ? opt[1] : Stdlib[19];
    return runtime.caml_memprof_start(sampling_rate, callstack_size, tracker);
   }
   var
    Stdlib_Gc =
      [0,
       print_stat,
       allocated_bytes,
       function(_x_, _w_){return runtime.caml_final_register(_x_, _w_);},
       runtime.caml_final_register_called_without_value,
       function(_v_){return runtime.caml_final_release(_v_);},
       create_alarm,
       delete_alarm,
       eventlog_pause,
       eventlog_resume,
       [0,
        null_tracker,
        start,
        runtime.caml_memprof_stop,
        runtime.caml_memprof_discard]];
   runtime.caml_register_global(27, Stdlib_Gc, "Stdlib__Gc");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__In_channel
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Fun, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_input_bigarray = runtime.caml_ml_input_bigarray,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdin = Stdlib[38],
    open_bin = Stdlib[80],
    open_text = Stdlib[79],
    open_gen = Stdlib[81];
   function with_open(openfun, s, f){
    var ic = caml_call1(openfun, s);
    return caml_call2
            (Stdlib_Fun[5],
             function(param){return caml_call1(Stdlib[94], ic);},
             function(param){return caml_call1(f, ic);});
   }
   function with_open_bin(s, f){return with_open(Stdlib[80], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[79], s, f);}
   function with_open_gen(flags, perm, s, f){
    return with_open(caml_call2(Stdlib[81], flags, perm), s, f);
   }
   var
    seek = Stdlib[96][4],
    pos = Stdlib[96][5],
    length = Stdlib[96][6],
    close = Stdlib[93],
    close_noerr = Stdlib[94];
   function input_char(ic){
    try{var c = caml_call1(Stdlib[82], ic);}
    catch(_x_){
     var _w_ = caml_wrap_exception(_x_);
     if(_w_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_w_, 0);
    }
    return [0, c];
   }
   function input_byte(ic){
    try{var n = caml_call1(Stdlib[87], ic);}
    catch(_v_){
     var _u_ = caml_wrap_exception(_v_);
     if(_u_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_u_, 0);
    }
    return [0, n];
   }
   function input_line(ic){
    try{var s = caml_call1(Stdlib[83], ic);}
    catch(_t_){
     var _s_ = caml_wrap_exception(_t_);
     if(_s_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_s_, 0);
    }
    return [0, s];
   }
   var
    input = Stdlib[84],
    cst_input_bigarray = "input_bigarray",
    _a_ = [0, 0],
    _b_ = [0, 0],
    cst_really_input_bigarray = "really_input_bigarray",
    cst_In_channel_input_all_chann =
      "In_channel.input_all: channel content is larger than maximum string length";
   function input_bigarray(ic, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ba_dim_1(buf) - len | 0) >= ofs)
     return caml_ml_input_bigarray(ic, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_input_bigarray);
   }
   function really_input(ic, buf, pos, len){
    try{caml_call4(Stdlib[85], ic, buf, pos, len); return _a_;}
    catch(_r_){
     var _q_ = caml_wrap_exception(_r_);
     if(_q_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function really_input_bigarray(ic, buf, ofs$1, len$1){
    if(0 <= ofs$1 && 0 <= len$1 && (caml_ba_dim_1(buf) - len$1 | 0) >= ofs$1){
     var ofs = ofs$1, len = len$1;
     for(;;){
      if(0 >= len) return _b_;
      var r = caml_ml_input_bigarray(ic, buf, ofs, len);
      if(0 === r) return 0;
      var len$0 = len - r | 0, ofs$0 = ofs + r | 0;
      ofs = ofs$0;
      len = len$0;
     }
    }
    return caml_call1(Stdlib[1], cst_really_input_bigarray);
   }
   function really_input_string(ic, len){
    try{var s = caml_call2(Stdlib[86], ic, len);}
    catch(_p_){
     var _o_ = caml_wrap_exception(_p_);
     if(_o_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_o_, 0);
    }
    return [0, s];
   }
   function read_upto(ic, buf, ofs, len){
    var ofs$0 = ofs, len$0 = len;
    for(;;){
     if(0 !== len$0){
      var r = caml_call4(Stdlib[84], ic, buf, ofs$0, len$0);
      if(0 !== r){
       var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0;
       ofs$0 = ofs$1;
       len$0 = len$1;
       continue;
      }
     }
     return ofs$0 - ofs | 0;
    }
   }
   function ensure(buf, ofs, n){
    var len = caml_ml_bytes_length(buf);
    if((ofs + n | 0) <= len) return buf;
    var new_len = [0, len];
    for(;;){
     if(new_len[1] >= (ofs + n | 0)) break;
     new_len[1] = (2 * new_len[1] | 0) + 1 | 0;
    }
    var
     new_len$0 = new_len[1],
     new_len$1 =
       new_len$0 <= Stdlib_Sys[12]
        ? new_len$0
        : ofs
          < Stdlib_Sys[12]
          ? Stdlib_Sys[12]
          : caml_call1(Stdlib[2], cst_In_channel_input_all_chann),
     new_buf = caml_create_bytes(new_len$1);
    caml_call5(Stdlib_Bytes[11], buf, 0, new_buf, 0, ofs);
    return new_buf;
   }
   function input_all(ic){
    var chunk_size = 65536;
    try{
     var
      _k_ = caml_call1(Stdlib[91], ic),
      _l_ = caml_call1(Stdlib[92], ic) - _k_ | 0,
      initial_size = _l_;
    }
    catch(_n_){
     var _i_ = caml_wrap_exception(_n_);
     if(_i_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_i_, 0);
     var initial_size = -1;
    }
    var
     initial_size$0 = 0 <= initial_size ? initial_size : chunk_size,
     initial_size$1 =
       initial_size$0 <= Stdlib_Sys[12] ? initial_size$0 : Stdlib_Sys[12],
     buf = caml_create_bytes(initial_size$1),
     nread = read_upto(ic, buf, 0, initial_size$1);
    if(nread < initial_size$1)
     return caml_call3(Stdlib_Bytes[8], buf, 0, nread);
    try{var c = caml_call1(Stdlib[82], ic);}
    catch(_m_){
     var _j_ = caml_wrap_exception(_m_);
     if(_j_ === Stdlib[12]) return caml_call1(Stdlib_Bytes[44], buf);
     throw caml_maybe_attach_backtrace(_j_, 0);
    }
    var buf$2 = ensure(buf, nread, 65537);
    runtime.caml_bytes_set(buf$2, nread, c);
    var ofs$1 = nread + 1 | 0, buf$0 = buf$2, ofs = ofs$1;
    for(;;){
     var
      buf$1 = ensure(buf$0, ofs, chunk_size),
      rem = caml_ml_bytes_length(buf$1) - ofs | 0,
      r = read_upto(ic, buf$1, ofs, rem);
     if(r < rem) return caml_call3(Stdlib_Bytes[8], buf$1, 0, ofs + r | 0);
     var ofs$0 = ofs + rem | 0;
     buf$0 = buf$1;
     ofs = ofs$0;
    }
   }
   function input_lines(ic){
    try{var line = caml_call1(Stdlib[83], ic);}
    catch(_h_){
     var _e_ = caml_wrap_exception(_h_);
     if(_e_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
    var block = [0, line, 24029], dst = block, offset = 1;
    for(;;){
     try{var line$0 = caml_call1(Stdlib[83], ic);}
     catch(_g_){
      var _f_ = caml_wrap_exception(_g_);
      if(_f_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_f_, 0);
      dst[1 + offset] = 0;
      return block;
     }
     var dst$0 = [0, line$0, 24029];
     dst[1 + offset] = dst$0;
     dst = dst$0;
     offset = 1;
    }
   }
   function fold_lines(f, accu, ic){
    var accu$0 = accu;
    for(;;){
     try{var line = caml_call1(Stdlib[83], ic);}
     catch(_d_){
      var _c_ = caml_wrap_exception(_d_);
      if(_c_ === Stdlib[12]) return accu$0;
      throw caml_maybe_attach_backtrace(_c_, 0);
     }
     var accu$1 = caml_call2(f, accu$0, line);
     accu$0 = accu$1;
    }
   }
   var
    set_binary_mode = Stdlib[95],
    Stdlib_In_channel =
      [0,
       stdin,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       close,
       close_noerr,
       input_char,
       input_byte,
       input_line,
       really_input_string,
       input_all,
       input_lines,
       input,
       input_bigarray,
       really_input,
       really_input_bigarray,
       fold_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       runtime.caml_ml_is_binary_mode,
       runtime.caml_sys_isatty];
   runtime.caml_register_global(9, Stdlib_In_channel, "Stdlib__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Out_channel
//# unitInfo: Requires: Stdlib, Stdlib__Fun
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Fun = global_data.Stdlib__Fun,
    stdout = Stdlib[39],
    stderr = Stdlib[40],
    open_bin = Stdlib[61],
    open_text = Stdlib[60],
    open_gen = Stdlib[62];
   function with_open(openfun, s, f){
    var oc = caml_call1(openfun, s);
    return caml_call2
            (Stdlib_Fun[5],
             function(param){return caml_call1(Stdlib[77], oc);},
             function(param){return caml_call1(f, oc);});
   }
   function with_open_bin(s, f){return with_open(Stdlib[61], s, f);}
   function with_open_text(s, f){return with_open(Stdlib[60], s, f);}
   function with_open_gen(flags, perm, s, f){
    return with_open(caml_call2(Stdlib[62], flags, perm), s, f);
   }
   var
    seek = Stdlib[96][1],
    pos = Stdlib[96][2],
    length = Stdlib[96][3],
    close = Stdlib[76],
    close_noerr = Stdlib[77],
    flush = Stdlib[63],
    flush_all = Stdlib[64],
    output_char = Stdlib[65],
    output_byte = Stdlib[70],
    output_string = Stdlib[66],
    output_bytes = Stdlib[67],
    output = Stdlib[68],
    output_substring = Stdlib[69],
    cst_output_bigarray = "output_bigarray";
   function output_bigarray(oc, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (runtime.caml_ba_dim_1(buf) - len | 0) >= ofs)
     return runtime.caml_ml_output_bigarray(oc, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_output_bigarray);
   }
   var
    set_binary_mode = Stdlib[78],
    Stdlib_Out_channel =
      [0,
       stdout,
       stderr,
       open_bin,
       open_text,
       open_gen,
       with_open_bin,
       with_open_text,
       with_open_gen,
       close,
       close_noerr,
       output_char,
       output_byte,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_bigarray,
       flush,
       flush_all,
       seek,
       pos,
       length,
       set_binary_mode,
       runtime.caml_ml_is_binary_mode,
       runtime.caml_ml_set_buffered,
       runtime.caml_ml_is_buffered,
       runtime.caml_sys_isatty];
   runtime.caml_register_global(3, Stdlib_Out_channel, "Stdlib__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Digest
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char, Stdlib__In_channel, Stdlib__Int, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    cst_Digest_of_hex$1 = "Digest.of_hex",
    cst_Digest_substring$1 = "Digest.substring",
    cst_Digest_to_hex$1 = "Digest.to_hex",
    caml_blake2_final = runtime.caml_blake2_final,
    caml_blake2_string = runtime.caml_blake2_string,
    caml_blake2_update = runtime.caml_blake2_update,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_md5_chan = runtime.caml_md5_chan,
    caml_md5_string = runtime.caml_md5_string,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_In_channel = global_data.Stdlib__In_channel,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_Digest_of_hex = cst_Digest_of_hex$1,
    cst_Digest_BLAKE2_wrong_hash_s = "Digest.BLAKE2: wrong hash size",
    cst_Digest_substring = cst_Digest_substring$1,
    cst_Digest_to_hex = cst_Digest_to_hex$1,
    cst_Digest_of_hex$0 = cst_Digest_of_hex$1;
   function hex_of_string(d){
    function char_hex(n){
     var _l_ = 10 <= n ? (97 + n | 0) - 10 | 0 : 48 + n | 0;
     return caml_call1(Stdlib_Char[1], _l_);
    }
    var
     len = caml_ml_string_length(d),
     result = caml_create_bytes(len * 2 | 0),
     _j_ = len - 1 | 0,
     _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      var x = caml_string_get(d, i);
      caml_bytes_unsafe_set(result, i * 2 | 0, char_hex(x >>> 4 | 0));
      caml_bytes_unsafe_set(result, (i * 2 | 0) + 1 | 0, char_hex(x & 15));
      var _k_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _k_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], result);
   }
   function string_of_hex(s){
    function digit(c){
     if(65 <= c){
      if(97 <= c){
       if(103 > c) return (c - 97 | 0) + 10 | 0;
      }
      else if(71 > c) return (c - 65 | 0) + 10 | 0;
     }
     else if(9 >= c - 48 >>> 0) return c - 48 | 0;
     return caml_call1(Stdlib[1], cst_Digest_of_hex);
    }
    return caml_call2
            (Stdlib_String[2],
             caml_ml_string_length(s) / 2 | 0,
             function(i){
              var
               i$0 = 2 * i | 0,
               _g_ = digit(caml_string_get(s, i$0 + 1 | 0)),
               _h_ = (digit(caml_string_get(s, i$0)) << 4) + _g_ | 0;
              return caml_call1(Stdlib_Char[1], _h_);
             });
   }
   function BLAKE2(X){
    var _a_ = X[1] < 1 ? 1 : 0, _b_ = _a_ || (64 < X[1] ? 1 : 0);
    if(_b_) caml_call1(Stdlib[1], cst_Digest_BLAKE2_wrong_hash_s);
    var
     hash_length = X[1],
     compare = Stdlib_String[10],
     equal = Stdlib_String[9];
    function string(str){
     return caml_blake2_string
             (hash_length, cst, str, 0, caml_ml_string_length(str));
    }
    function bytes(b){return string(caml_call1(Stdlib_Bytes[44], b));}
    function substring(str, ofs, len){
     var _d_ = ofs < 0 ? 1 : 0;
     if(_d_)
      var _e_ = _d_;
     else
      var
       _f_ = len < 0 ? 1 : 0,
       _e_ = _f_ || ((caml_ml_string_length(str) - len | 0) < ofs ? 1 : 0);
     if(_e_) caml_call1(Stdlib[1], cst_Digest_substring);
     return caml_blake2_string(hash_length, cst, str, ofs, len);
    }
    function subbytes(b, ofs, len){
     return substring(caml_call1(Stdlib_Bytes[44], b), ofs, len);
    }
    function channel(ic, toread){
     var
      buf_size = 4096,
      buf = caml_create_bytes(4096),
      ctx = runtime.caml_blake2_create(hash_length, cst);
     if(0 <= toread){
      var toread$0 = toread;
      for(;;){
       if(0 === toread$0) return caml_blake2_final(ctx, hash_length);
       var
        _c_ = caml_call2(Stdlib_Int[10], buf_size, toread$0),
        n = caml_call4(Stdlib_In_channel[16], ic, buf, 0, _c_);
       if(0 === n) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
       caml_blake2_update(ctx, caml_call1(Stdlib_Bytes[44], buf), 0, n);
       var toread$1 = toread$0 - n | 0;
       toread$0 = toread$1;
      }
     }
     else
      for(;;){
       var n$0 = caml_call4(Stdlib_In_channel[16], ic, buf, 0, buf_size);
       if(0 === n$0) return caml_blake2_final(ctx, hash_length);
       caml_blake2_update(ctx, caml_call1(Stdlib_Bytes[44], buf), 0, n$0);
      }
    }
    function file(filename){
     return caml_call2
             (Stdlib_In_channel[5],
              filename,
              function(ic){return channel(ic, -1);});
    }
    function output(chan, digest){
     return caml_call2(Stdlib[66], chan, digest);
    }
    function input(chan){return caml_call2(Stdlib[86], chan, hash_length);}
    function to_hex(d){
     if(caml_ml_string_length(d) !== hash_length)
      caml_call1(Stdlib[1], cst_Digest_to_hex);
     return hex_of_string(d);
    }
    function of_hex(s){
     if(caml_ml_string_length(s) !== (hash_length * 2 | 0))
      caml_call1(Stdlib[1], cst_Digest_of_hex$0);
     return string_of_hex(s);
    }
    return [0,
            hash_length,
            compare,
            equal,
            string,
            bytes,
            substring,
            subbytes,
            channel,
            file,
            output,
            input,
            to_hex,
            of_hex];
   }
   var
    BLAKE128 = BLAKE2([0, 16]),
    BLAKE256 = BLAKE2([0, 32]),
    BLAKE512 = BLAKE2([0, 64]),
    compare = Stdlib_String[10],
    equal = Stdlib_String[9],
    cst_Digest_substring$0 = cst_Digest_substring$1,
    cst_Digest_to_hex$0 = cst_Digest_to_hex$1,
    cst_Digest_from_hex = "Digest.from_hex";
   function string(str){
    return caml_md5_string(str, 0, caml_ml_string_length(str));
   }
   function bytes(b){return string(caml_call1(Stdlib_Bytes[44], b));}
   function substring(str, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_string_length(str) - len | 0) >= ofs)
     return caml_md5_string(str, ofs, len);
    return caml_call1(Stdlib[1], cst_Digest_substring$0);
   }
   function subbytes(b, ofs, len){
    return substring(caml_call1(Stdlib_Bytes[44], b), ofs, len);
   }
   function file(filename){
    return caml_call2
            (Stdlib_In_channel[5],
             filename,
             function(ic){return caml_md5_chan(ic, -1);});
   }
   function output(chan, digest){return caml_call2(Stdlib[66], chan, digest);}
   function input(chan){return caml_call2(Stdlib[86], chan, 16);}
   function to_hex(d){
    if(16 !== caml_ml_string_length(d))
     caml_call1(Stdlib[1], cst_Digest_to_hex$0);
    return hex_of_string(d);
   }
   function of_hex(s){
    if(32 !== caml_ml_string_length(s))
     caml_call1(Stdlib[1], cst_Digest_from_hex);
    return string_of_hex(s);
   }
   var
    Stdlib_Digest =
      [0,
       compare,
       equal,
       string,
       bytes,
       substring,
       subbytes,
       caml_md5_chan,
       file,
       output,
       input,
       to_hex,
       of_hex,
       of_hex,
       BLAKE128,
       BLAKE256,
       BLAKE512,
       [0,
        16,
        compare,
        equal,
        string,
        bytes,
        substring,
        subbytes,
        caml_md5_chan,
        file,
        output,
        input,
        to_hex,
        of_hex]];
   runtime.caml_register_global(17, Stdlib_Digest, "Stdlib__Digest");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Bigarray
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Bigarray_Array3_of_array_n$1 =
      "Bigarray.Array3.of_array: non-cubic data",
    caml_ba_change_layout = runtime.caml_ba_change_layout,
    caml_ba_create = runtime.caml_ba_create,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_num_dims = runtime.caml_ba_num_dims,
    caml_ba_reshape = runtime.caml_ba_reshape,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_ba_set_2 = runtime.caml_ba_set_2,
    caml_ba_set_3 = runtime.caml_ba_set_3,
    caml_ba_set_generic = runtime.caml_ba_set_generic,
    caml_ba_slice = runtime.caml_ba_slice,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function kind_size_in_bytes(param){
    switch(param){
      case 0:
       return 4;
      case 1:
       return 8;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 2;
      case 6:
       return 4;
      case 7:
       return 8;
      case 8:
       return Stdlib_Sys[9] / 8 | 0;
      case 9:
       return Stdlib_Sys[9] / 8 | 0;
      case 10:
       return 8;
      case 11:
       return 16;
      case 12:
       return 1;
      default: return 2;
    }
   }
   var
    cst_Bigarray_Array2_of_array_n =
      "Bigarray.Array2.of_array: non-rectangular data",
    cst_Bigarray_Array3_of_array_n = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_Array3_of_array_n$0 = cst_Bigarray_Array3_of_array_n$1,
    cst_Bigarray_array0_of_genarra = "Bigarray.array0_of_genarray",
    cst_Bigarray_array1_of_genarra = "Bigarray.array1_of_genarray",
    cst_Bigarray_array2_of_genarra = "Bigarray.array2_of_genarray",
    cst_Bigarray_array3_of_genarra = "Bigarray.array3_of_genarray";
   function cloop(arr, idx, f, col, max){
    if(col === idx.length - 1){
     caml_ba_set_generic(arr, idx, caml_call1(f, idx));
     return;
    }
    var _am_ = caml_check_bound(max, col)[1 + col] - 1 | 0, _al_ = 0;
    if(_am_ >= 0){
     var j = _al_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      cloop(arr, idx, f, col + 1 | 0, max);
      var _an_ = j + 1 | 0;
      if(_am_ === j) break;
      j = _an_;
     }
    }
    return;
   }
   function floop(arr, idx, f, col, max){
    if(0 > col){caml_ba_set_generic(arr, idx, caml_call1(f, idx)); return;}
    var _aj_ = caml_check_bound(max, col)[1 + col], _ai_ = 1;
    if(_aj_ >= 1){
     var j = _ai_;
     for(;;){
      caml_check_bound(idx, col)[1 + col] = j;
      floop(arr, idx, f, col - 1 | 0, max);
      var _ak_ = j + 1 | 0;
      if(_aj_ === j) break;
      j = _ak_;
     }
    }
    return;
   }
   function init(kind, layout, dims, f){
    var arr = caml_ba_create(kind, layout, dims), dlen = dims.length - 1;
    return layout
            ? (floop
               (arr, caml_make_vect(dlen, 1), f, dlen - 1 | 0, dims),
              arr)
            : (cloop(arr, caml_make_vect(dlen, 0), f, 0, dims), arr);
   }
   function dims(a){
    var
     n = caml_ba_num_dims(a),
     d = caml_make_vect(n, 0),
     _af_ = n - 1 | 0,
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var _ag_ = runtime.caml_ba_dim(a, i);
      caml_check_bound(d, i)[1 + i] = _ag_;
      var _ah_ = i + 1 | 0;
      if(_af_ === i) break;
      i = _ah_;
     }
    }
    return d;
   }
   function size_in_bytes(arr){
    var
     _ac_ = dims(arr),
     _ad_ = caml_call3(Stdlib_Array[18], caml_mul, 1, _ac_);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _ad_);
   }
   function create(kind, layout){return caml_ba_create(kind, layout, [0]);}
   function get(arr){return runtime.caml_ba_get_generic(arr, [0]);}
   function set(arr){
    var _aa_ = [0];
    return function(_ab_){return caml_ba_set_generic(arr, _aa_, _ab_);};
   }
   function size_in_bytes$0(arr){
    return kind_size_in_bytes(caml_ba_kind(arr));
   }
   function of_value(kind, layout, v){
    var a = create(kind, layout);
    set(a)(v);
    return a;
   }
   function create$0(kind, layout, dim){
    return caml_ba_create(kind, layout, [0, dim]);
   }
   function size_in_bytes$1(arr){
    var _$_ = caml_ba_dim_1(arr);
    return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _$_);
   }
   function slice(a, n){
    return runtime.caml_ba_layout(a)
            ? caml_ba_slice(a, [0, n])
            : caml_ba_slice(a, [0, n]);
   }
   function init$0(kind, layout, dim, f){
    var arr = create$0(kind, layout, dim);
    if(layout){
     var _Z_ = 1;
     if(dim >= 1){
      var i$0 = _Z_;
      for(;;){
       caml_ba_set_1(arr, i$0, caml_call1(f, i$0));
       var ___ = i$0 + 1 | 0;
       if(dim === i$0) break;
       i$0 = ___;
      }
     }
     return arr;
    }
    var _X_ = dim - 1 | 0, _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      caml_ba_set_1(arr, i, caml_call1(f, i));
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return arr;
   }
   function of_array(kind, layout, data){
    var
     ba = create$0(kind, layout, data.length - 1),
     ofs = layout ? 1 : 0,
     _U_ = data.length - 2 | 0,
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      caml_ba_set_1(ba, i + ofs | 0, caml_check_bound(data, i)[1 + i]);
      var _V_ = i + 1 | 0;
      if(_U_ === i) break;
      i = _V_;
     }
    }
    return ba;
   }
   function create$1(kind, layout, dim1, dim2){
    return caml_ba_create(kind, layout, [0, dim1, dim2]);
   }
   function size_in_bytes$2(arr){
    var _R_ = caml_ba_dim_2(arr), _S_ = caml_ba_dim_1(arr);
    return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _S_), _R_);
   }
   function slice_left(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right(a, n){return caml_ba_slice(a, [0, n]);}
   function init$1(kind, layout, dim1, dim2, f){
    var arr = create$1(kind, layout, dim1, dim2);
    if(layout){
     var _N_ = 1;
     if(dim2 >= 1){
      var j$0 = _N_;
      for(;;){
       var _O_ = 1;
       if(dim1 >= 1){
        var i$0 = _O_;
        for(;;){
         caml_ba_set_2(arr, i$0, j$0, caml_call2(f, i$0, j$0));
         var _Q_ = i$0 + 1 | 0;
         if(dim1 === i$0) break;
         i$0 = _Q_;
        }
       }
       var _P_ = j$0 + 1 | 0;
       if(dim2 === j$0) break;
       j$0 = _P_;
      }
     }
     return arr;
    }
    var _I_ = dim1 - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      var _K_ = dim2 - 1 | 0, _J_ = 0;
      if(_K_ >= 0){
       var j = _J_;
       for(;;){
        caml_ba_set_2(arr, i, j, caml_call2(f, i, j));
        var _M_ = j + 1 | 0;
        if(_K_ === j) break;
        j = _M_;
       }
      }
      var _L_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _L_;
     }
    }
    return arr;
   }
   function of_array$0(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     ba = create$1(kind, layout, dim1, dim2),
     ofs = layout ? 1 : 0,
     _C_ = dim1 - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array2_of_array_n);
      var _E_ = dim2 - 1 | 0, _D_ = 0;
      if(_E_ >= 0){
       var j = _D_;
       for(;;){
        caml_ba_set_2
         (ba, i + ofs | 0, j + ofs | 0, caml_check_bound(row, j)[1 + j]);
        var _G_ = j + 1 | 0;
        if(_E_ === j) break;
        j = _G_;
       }
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return ba;
   }
   function create$2(kind, layout, dim1, dim2, dim3){
    return caml_ba_create(kind, layout, [0, dim1, dim2, dim3]);
   }
   function size_in_bytes$3(arr){
    var
     _y_ = runtime.caml_ba_dim_3(arr),
     _z_ = caml_ba_dim_2(arr),
     _A_ = caml_ba_dim_1(arr);
    return caml_mul
            (caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)), _A_), _z_),
             _y_);
   }
   function slice_left_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_right_1(a, n, m){return caml_ba_slice(a, [0, n, m]);}
   function slice_left_2(a, n){return caml_ba_slice(a, [0, n]);}
   function slice_right_2(a, n){return caml_ba_slice(a, [0, n]);}
   function init$2(kind, layout, dim1, dim2, dim3, f){
    var arr = create$2(kind, layout, dim1, dim2, dim3);
    if(layout){
     var _s_ = 1;
     if(dim3 >= 1){
      var k$0 = _s_;
      for(;;){
       var _t_ = 1;
       if(dim2 >= 1){
        var j$0 = _t_;
        for(;;){
         var _v_ = 1;
         if(dim1 >= 1){
          var i$0 = _v_;
          for(;;){
           caml_ba_set_3(arr, i$0, j$0, k$0, caml_call3(f, i$0, j$0, k$0));
           var _x_ = i$0 + 1 | 0;
           if(dim1 === i$0) break;
           i$0 = _x_;
          }
         }
         var _w_ = j$0 + 1 | 0;
         if(dim2 === j$0) break;
         j$0 = _w_;
        }
       }
       var _u_ = k$0 + 1 | 0;
       if(dim3 === k$0) break;
       k$0 = _u_;
      }
     }
     return arr;
    }
    var _k_ = dim1 - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _m_ = dim2 - 1 | 0, _l_ = 0;
      if(_m_ >= 0){
       var j = _l_;
       for(;;){
        var _p_ = dim3 - 1 | 0, _o_ = 0;
        if(_p_ >= 0){
         var k = _o_;
         for(;;){
          caml_ba_set_3(arr, i, j, k, caml_call3(f, i, j, k));
          var _r_ = k + 1 | 0;
          if(_p_ === k) break;
          k = _r_;
         }
        }
        var _q_ = j + 1 | 0;
        if(_m_ === j) break;
        j = _q_;
       }
      }
      var _n_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _n_;
     }
    }
    return arr;
   }
   function of_array$1(kind, layout, data){
    var
     dim1 = data.length - 1,
     dim2 = 0 === dim1 ? 0 : caml_check_bound(data, 0)[1].length - 1,
     dim3 =
       0 === dim2
        ? 0
        : caml_check_bound(caml_check_bound(data, 0)[1], 0)[1].length - 1,
     ba = create$2(kind, layout, dim1, dim2, dim3),
     ofs = layout ? 1 : 0,
     _b_ = dim1 - 1 | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var row = caml_check_bound(data, i)[1 + i];
      if(row.length - 1 !== dim2)
       caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n);
      var _d_ = dim2 - 1 | 0, _c_ = 0;
      if(_d_ >= 0){
       var j = _c_;
       for(;;){
        var col = caml_check_bound(row, j)[1 + j];
        if(col.length - 1 !== dim3)
         caml_call1(Stdlib[1], cst_Bigarray_Array3_of_array_n$0);
        var _g_ = dim3 - 1 | 0, _f_ = 0;
        if(_g_ >= 0){
         var k = _f_;
         for(;;){
          caml_ba_set_3
           (ba,
            i + ofs | 0,
            j + ofs | 0,
            k + ofs | 0,
            caml_check_bound(col, k)[1 + k]);
          var _i_ = k + 1 | 0;
          if(_g_ === k) break;
          k = _i_;
         }
        }
        var _h_ = j + 1 | 0;
        if(_d_ === j) break;
        j = _h_;
       }
      }
      var _e_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _e_;
     }
    }
    return ba;
   }
   function array0_of_genarray(a){
    return 0 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array0_of_genarra);
   }
   function array1_of_genarray(a){
    return 1 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array1_of_genarra);
   }
   function array2_of_genarray(a){
    return 2 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array2_of_genarra);
   }
   function array3_of_genarray(a){
    return 3 === caml_ba_num_dims(a)
            ? a
            : caml_call1(Stdlib[1], cst_Bigarray_array3_of_genarra);
   }
   function reshape_0(a){return caml_ba_reshape(a, [0]);}
   function reshape_1(a, dim1){return caml_ba_reshape(a, [0, dim1]);}
   function reshape_2(a, dim1, dim2){
    return caml_ba_reshape(a, [0, dim1, dim2]);
   }
   function reshape_3(a, dim1, dim2, dim3){
    return caml_ba_reshape(a, [0, dim1, dim2, dim3]);
   }
   var
    Stdlib_Bigarray =
      [0,
       13,
       0,
       1,
       10,
       11,
       2,
       3,
       4,
       5,
       8,
       6,
       7,
       9,
       12,
       kind_size_in_bytes,
       0,
       1,
       [0, init, dims, size_in_bytes],
       [0,
        create,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get,
        set,
        of_value],
       [0,
        create$0,
        init$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$1,
        init$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$2,
        init$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
   runtime.caml_register_global(10, Stdlib_Bigarray, "Stdlib__Bigarray");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Random
//# unitInfo: Requires: Stdlib, Stdlib__Bigarray, Stdlib__Bytes, Stdlib__Digest, Stdlib__Domain, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_blit = runtime.caml_ba_blit,
    caml_ba_set_1 = runtime.caml_ba_set_1,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_lxm_next = runtime.caml_lxm_next,
    caml_mod = runtime.caml_mod,
    caml_notequal = runtime.caml_notequal,
    caml_sys_random_seed = runtime.caml_sys_random_seed;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    serialization_prefix = "lxm1:",
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib = global_data.Stdlib,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Digest = global_data.Stdlib__Digest,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function create(param){return caml_call3(Stdlib_Bigarray[20][1], 7, 0, 4);}
   function set(s, i1, i2, i3, i4){
    caml_ba_set_1(s, 0, runtime.caml_int64_or(i1, _a_));
    caml_ba_set_1(s, 1, i2);
    var i3$0 = caml_notequal(i3, _b_) ? i3 : _e_;
    caml_ba_set_1(s, 2, i3$0);
    var i4$0 = caml_notequal(i4, _c_) ? i4 : _d_;
    return caml_ba_set_1(s, 3, i4$0);
   }
   function mk(i1, i2, i3, i4){
    var s = create(0);
    set(s, i1, i2, i3, i4);
    return s;
   }
   var
    serialization_prefix_len = 5,
    cst_Random_State_of_binary_str =
      "Random.State.of_binary_string: expected a format compatible with OCaml ";
   function to_binary_string(s){
    var buf = caml_create_bytes(37);
    caml_call5
     (Stdlib_Bytes[12],
      serialization_prefix,
      0,
      buf,
      0,
      serialization_prefix_len);
    var i = 0;
    for(;;){
     var _y_ = runtime.caml_ba_get_1(s, i);
     caml_call3(Stdlib_Bytes[86], buf, 5 + (i * 8 | 0) | 0, _y_);
     var _z_ = i + 1 | 0;
     if(3 === i) return caml_call1(Stdlib_Bytes[44], buf);
     i = _z_;
    }
   }
   function of_binary_string(buf){
    var
     _v_ = runtime.caml_ml_string_length(buf) !== 37 ? 1 : 0,
     _w_ = _v_ || 1 - caml_call2(Stdlib_String[11], serialization_prefix, buf);
    if(_w_){
     var
      _x_ =
        caml_call2(Stdlib[28], cst_Random_State_of_binary_str, Stdlib_Sys[46]);
     caml_call1(Stdlib[2], _x_);
    }
    var
     i1 = caml_call2(Stdlib_String[64], buf, 5),
     i2 = caml_call2(Stdlib_String[64], buf, 13),
     i3 = caml_call2(Stdlib_String[64], buf, 21),
     i4 = caml_call2(Stdlib_String[64], buf, 29);
    return mk(i1, i2, i3, i4);
   }
   function copy(src){
    var dst = create(0);
    caml_ba_blit(src, dst);
    return dst;
   }
   function reinit(s, seed){
    var
     n = seed.length - 1,
     b = caml_create_bytes((n * 8 | 0) + 1 | 0),
     _p_ = n - 1 | 0,
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var _t_ = caml_int64_of_int32(runtime.caml_check_bound(seed, i)[1 + i]);
      caml_call3(Stdlib_Bytes[86], b, i * 8 | 0, _t_);
      var _u_ = i + 1 | 0;
      if(_p_ === i) break;
      i = _u_;
     }
    }
    caml_bytes_set(b, n * 8 | 0, 1);
    var d1 = caml_call1(Stdlib_Digest[4], b);
    caml_bytes_set(b, n * 8 | 0, 2);
    var
     d2 = caml_call1(Stdlib_Digest[4], b),
     _q_ = caml_call2(Stdlib_String[64], d2, 8),
     _r_ = caml_call2(Stdlib_String[64], d2, 0),
     _s_ = caml_call2(Stdlib_String[64], d1, 8);
    return set(s, caml_call2(Stdlib_String[64], d1, 0), _s_, _r_, _q_);
   }
   function make(seed){var s = create(0); reinit(s, seed); return s;}
   function make_self_init(param){return make(caml_sys_random_seed(0));}
   var
    max_int31 = 1073741823,
    max_int32 = 2147483647,
    cst_Random_int = "Random.int",
    cst_Random_full_int = "Random.full_int",
    cst_Random_int_in_range = "Random.int_in_range",
    cst_Random_int32 = "Random.int32",
    cst_Random_int32_in_range = "Random.int32_in_range";
   function bits(s){
    return caml_int64_to_int32(caml_lxm_next(s)) & 1073741823;
   }
   function int_aux(s, n, mask){
    for(;;){
     var r = caml_int64_to_int32(caml_lxm_next(s)) & mask, v = caml_mod(r, n);
     if(((mask - n | 0) + 1 | 0) >= (r - v | 0)) return v;
    }
   }
   function int$0(s, bound){
    if(1073741823 >= bound && 0 < bound) return int_aux(s, bound, max_int31);
    return caml_call1(Stdlib[1], cst_Random_int);
   }
   function full_int(s, bound){
    if(0 >= bound) return caml_call1(Stdlib[1], cst_Random_full_int);
    var
     _n_ =
       bound <= 1073741823
        ? max_int31
        : bound <= 2147483647 ? max_int32 : Stdlib[19];
    return int_aux(s, bound, _n_);
   }
   function int_in_range_aux(s, min, max, mask, nbits){
    var span = (max - min | 0) + 1 | 0;
    if(span <= mask && 0 < span) return min + int_aux(s, span, mask) | 0;
    for(;;){
     var
      drop = Stdlib_Sys[10] - nbits | 0,
      r = caml_int64_to_int32(caml_lxm_next(s)) << drop >> drop;
     if(r >= min && max >= r) return r;
    }
   }
   function int_in_range(s, min, max){
    if(max < min) caml_call1(Stdlib[1], cst_Random_int_in_range);
    if(-1073741824 <= min && max <= 1073741823)
     return int_in_range_aux(s, min, max, max_int31, 31);
    if(-2147483648 <= min && max <= 2147483647)
     return int_in_range_aux(s, min, max, max_int32, 32);
    return int_in_range_aux(s, min, max, Stdlib[19], Stdlib_Sys[10]);
   }
   function bits32(s){return caml_int64_to_int32(caml_lxm_next(s));}
   function int32aux(s, n){
    for(;;){
     var r = bits32(s) >>> 1 | 0, v = caml_mod(r, n);
     if(! caml_greaterthan(r - v | 0, (Stdlib_Int32[9] - n | 0) + 1 | 0))
      return v;
    }
   }
   function int32(s, bound){
    return caml_lessequal(bound, 0)
            ? caml_call1(Stdlib[1], cst_Random_int32)
            : int32aux(s, bound);
   }
   function int32_in_range(s, min, max){
    if(caml_greaterthan(min, max))
     return caml_call1(Stdlib[1], cst_Random_int32_in_range);
    var span = caml_call1(Stdlib_Int32[6], max - min | 0);
    if(! caml_lessequal(span, Stdlib_Int32[1]))
     return min + int32aux(s, span) | 0;
    for(;;){
     var r = caml_int64_to_int32(caml_lxm_next(s));
     if(! caml_lessthan(r, min) && ! caml_greaterthan(r, max)) return r;
    }
   }
   var
    bits64 = caml_lxm_next,
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Random_int64 = "Random.int64",
    cst_Random_int64_in_range = "Random.int64_in_range";
   function int64aux(s, n){
    for(;;){
     var
      r = caml_int64_shift_right_unsigne(caml_lxm_next(s), 1),
      v = runtime.caml_int64_mod(r, n);
     if
      (!
       caml_greaterthan
        (caml_int64_sub(r, v),
         caml_int64_add(caml_int64_sub(Stdlib_Int64[9], n), _f_)))
      return v;
    }
   }
   function int64(s, bound){
    return caml_lessequal(bound, _g_)
            ? caml_call1(Stdlib[1], cst_Random_int64)
            : int64aux(s, bound);
   }
   function int64_in_range(s, min, max){
    if(caml_greaterthan(min, max))
     return caml_call1(Stdlib[1], cst_Random_int64_in_range);
    var span = caml_call1(Stdlib_Int64[6], caml_int64_sub(max, min));
    if(! caml_lessequal(span, Stdlib_Int64[1]))
     return caml_int64_add(min, int64aux(s, span));
    for(;;){
     var r = caml_lxm_next(s);
     if(! caml_lessthan(r, min) && ! caml_greaterthan(r, max)) return r;
    }
   }
   var
    _j_ = runtime.caml_int64_create_lo_mi_hi(14371852, 15349651, 22696),
    _k_ = runtime.caml_int64_create_lo_mi_hi(12230193, 11438743, 35013),
    _l_ = runtime.caml_int64_create_lo_mi_hi(1424933, 15549263, 2083),
    _m_ = runtime.caml_int64_create_lo_mi_hi(9492471, 4696708, 43520),
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    nativebits =
      32 === Stdlib_Nativeint[9]
       ? function(s){return bits32(s);}
       : function(s){return caml_int64_to_int32(caml_lxm_next(s));},
    nativeint =
      32 === Stdlib_Nativeint[9]
       ? function(s, bound){return int32(s, bound);}
       : function
        (s, bound){
         return caml_int64_to_int32(int64(s, caml_int64_of_int32(bound)));
        },
    nativeint_in_range =
      32 === Stdlib_Nativeint[9]
       ? function(s, min, max){return int32_in_range(s, min, max);}
       : function
        (s, min, max){
         return caml_int64_to_int32
                 (int64_in_range
                   (s, caml_int64_of_int32(min), caml_int64_of_int32(max)));
        };
   function float$0(s, bound){
    for(;;){
     var b = caml_lxm_next(s), n = caml_int64_shift_right_unsigne(b, 11);
     if(caml_notequal(n, _h_))
      return runtime.caml_int64_to_float(n) * 1.1102230246251565e-16 * bound;
    }
   }
   function bool(s){return caml_lessthan(caml_lxm_next(s), _i_);}
   function split(s){
    var
     i1 = caml_lxm_next(s),
     i2 = caml_lxm_next(s),
     i3 = caml_lxm_next(s),
     i4 = caml_lxm_next(s);
    return mk(i1, i2, i3, i4);
   }
   function mk_default(param){return mk(_m_, _l_, _k_, _j_);}
   var random_key = caml_call2(Stdlib_Domain[10][1], [0, split], mk_default);
   function bits$0(param){
    return bits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function int$1(bound){
    return int$0(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function full_int$0(bound){
    return full_int(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int_in_range$0(min, max){
    return int_in_range
            (caml_call1(Stdlib_Domain[10][2], random_key), min, max);
   }
   function int32$0(bound){
    return int32(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int32_in_range$0(min, max){
    return int32_in_range
            (caml_call1(Stdlib_Domain[10][2], random_key), min, max);
   }
   function nativeint$0(bound){
    return nativeint(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function nativeint_in_range$0(min, max){
    return nativeint_in_range
            (caml_call1(Stdlib_Domain[10][2], random_key), min, max);
   }
   function int64$0(bound){
    return int64(caml_call1(Stdlib_Domain[10][2], random_key), bound);
   }
   function int64_in_range$0(min, max){
    return int64_in_range
            (caml_call1(Stdlib_Domain[10][2], random_key), min, max);
   }
   function float$1(scale){
    return float$0(caml_call1(Stdlib_Domain[10][2], random_key), scale);
   }
   function bool$0(param){
    return bool(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits32$0(param){
    return bits32(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function bits64$0(param){
    var s = caml_call1(Stdlib_Domain[10][2], random_key);
    return caml_lxm_next(s);
   }
   function nativebits$0(param){
    return nativebits(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function full_init(seed){
    return reinit(caml_call1(Stdlib_Domain[10][2], random_key), seed);
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(param){return full_init(caml_sys_random_seed(0));}
   function split$0(param){
    return split(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function get_state(param){
    return copy(caml_call1(Stdlib_Domain[10][2], random_key));
   }
   function set_state(src){
    var dst = caml_call1(Stdlib_Domain[10][2], random_key);
    return caml_ba_blit(src, dst);
   }
   var
    Stdlib_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$0,
       int$1,
       full_int$0,
       int_in_range$0,
       int32$0,
       int32_in_range$0,
       nativeint$0,
       nativeint_in_range$0,
       int64$0,
       int64_in_range$0,
       float$1,
       bool$0,
       bits32$0,
       bits64$0,
       nativebits$0,
       [0,
        make,
        make_self_init,
        copy,
        bits,
        int$0,
        full_int,
        int_in_range,
        int32,
        int32_in_range,
        nativeint,
        nativeint_in_range,
        int64,
        int64_in_range,
        float$0,
        bool,
        bits32,
        bits64,
        nativebits,
        split,
        to_binary_string,
        of_binary_string],
       get_state,
       set_state,
       split$0];
   runtime.caml_register_global(35, Stdlib_Random, "Stdlib__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Hashtbl
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Atomic, Stdlib__Domain, Stdlib__Int, Stdlib__Random, Stdlib__Seq, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_hash = runtime.caml_hash,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _d_ = [0, 0],
    cst = "",
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib = global_data.Stdlib,
    Stdlib_Atomic = global_data.Stdlib__Atomic,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array;
   global_data.Assert_failure;
   var Stdlib_String = global_data.Stdlib__String;
   function ongoing_traversal(h){
    var _an_ = h.length - 1 < 4 ? 1 : 0, _ao_ = _an_ || (h[4] < 0 ? 1 : 0);
    return _ao_;
   }
   function flip_ongoing_traversal(h){h[4] = - h[4] | 0; return 0;}
   var
    cst_Hashtbl_unsupported_hash_t = "Hashtbl: unsupported hash table format";
   try{var _f_ = caml_sys_getenv("OCAMLRUNPARAM"), params = _f_;}
   catch(_al_){
    var _a_ = caml_wrap_exception(_al_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    try{var _e_ = caml_sys_getenv("CAMLRUNPARAM"), _c_ = _e_;}
    catch(_am_){
     var _b_ = caml_wrap_exception(_am_);
     if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
     var _c_ = cst;
    }
    var params = _c_;
   }
   var
    randomized_default = caml_call2(Stdlib_String[15], params, 82),
    randomized = caml_call1(Stdlib_Atomic[1], randomized_default);
   function randomize(param){
    return caml_call2(Stdlib_Atomic[4], randomized, 1);
   }
   function is_randomized(param){
    return caml_call1(Stdlib_Atomic[3], randomized);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[19][2]);
   function power_2_above(x, n){
    var x$0 = x;
    for(;;){
     if(n <= x$0) return x$0;
     if(Stdlib_Sys[13] < (x$0 * 2 | 0)) return x$0;
     var x$1 = x$0 * 2 | 0;
     x$0 = x$1;
    }
   }
   function create(opt, initial_size){
    var
     random = opt ? opt[1] : caml_call1(Stdlib_Atomic[3], randomized),
     s = power_2_above(16, initial_size);
    if(random)
     var
      _ak_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[19][4], _ak_);
    else
     var seed = 0;
    return [0, 0, caml_make_vect(s, 0), seed, s];
   }
   function clear(h){
    var _aj_ = 0 < h[1] ? 1 : 0;
    return _aj_
            ? (h
               [1]
              = 0,
              caml_call4(Stdlib_Array[8], h[2], 0, h[2].length - 1, 0))
            : _aj_;
   }
   function reset(h){
    var len = h[2].length - 1;
    if(4 <= h.length - 1 && len !== caml_call1(Stdlib[18], h[4])){
     h[1] = 0;
     h[2] = caml_make_vect(caml_call1(Stdlib[18], h[4]), 0);
     return 0;
    }
    return clear(h);
   }
   function copy_bucketlist(param){
    if(! param) return 0;
    var
     key = param[1],
     data = param[2],
     next = param[3],
     prec$1 = [0, key, data, next],
     prec = prec$1,
     param$0 = next;
    for(;;){
     if(! param$0) return prec$1;
     var
      key$0 = param$0[1],
      data$0 = param$0[2],
      next$0 = param$0[3],
      prec$0 = [0, key$0, data$0, next$0];
     prec[3] = prec$0;
     prec = prec$0;
     param$0 = next$0;
    }
   }
   function copy(h){
    var
     _ag_ = h[4],
     _ah_ = h[3],
     _ai_ = caml_call2(Stdlib_Array[14], copy_bucketlist, h[2]);
    return [0, h[1], _ai_, _ah_, _ag_];
   }
   function length(h){return h[1];}
   function insert_all_buckets(indexfun, inplace, odata, ndata){
    var
     nsize = ndata.length - 1,
     ndata_tail = caml_make_vect(nsize, 0),
     _aa_ = odata.length - 2 | 0,
     _$_ = 0;
    if(_aa_ >= 0){
     var i$0 = _$_;
     for(;;){
      var cell$1 = caml_check_bound(odata, i$0)[1 + i$0], cell = cell$1;
      for(;;){
       if(! cell) break;
       var
        key = cell[1],
        data = cell[2],
        next = cell[3],
        cell$0 = inplace ? cell : [0, key, data, 0],
        nidx = caml_call1(indexfun, key),
        match = caml_check_bound(ndata_tail, nidx)[1 + nidx];
       if(match)
        match[3] = cell$0;
       else
        caml_check_bound(ndata, nidx)[1 + nidx] = cell$0;
       caml_check_bound(ndata_tail, nidx)[1 + nidx] = cell$0;
       cell = next;
      }
      var _af_ = i$0 + 1 | 0;
      if(_aa_ === i$0) break;
      i$0 = _af_;
     }
    }
    if(inplace){
     var _ac_ = nsize - 1 | 0, _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var match$0 = caml_check_bound(ndata_tail, i)[1 + i];
       if(match$0) match$0[3] = 0;
       var _ae_ = i + 1 | 0;
       if(_ac_ === i) break;
       i = _ae_;
      }
     }
     var _ad_ = 0;
    }
    else
     var _ad_ = inplace;
    return _ad_;
   }
   function resize(indexfun, h){
    var
     odata = h[2],
     osize = odata.length - 1,
     nsize = osize * 2 | 0,
     ___ = nsize < Stdlib_Sys[13] ? 1 : 0;
    if(! ___) return ___;
    var ndata = caml_make_vect(nsize, 0), inplace = 1 - ongoing_traversal(h);
    h[2] = ndata;
    return insert_all_buckets(caml_call1(indexfun, h), inplace, odata, ndata);
   }
   function iter(f, h){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], _W_ = d.length - 2 | 0, _V_ = 0;
     if(_W_ >= 0){
      var i = _V_;
      for(;;){
       var param = caml_check_bound(d, i)[1 + i];
       for(;;){
        if(! param) break;
        var key = param[1], data = param[2], next = param[3];
        caml_call2(f, key, data);
        param = next;
       }
       var _Z_ = i + 1 | 0;
       if(_W_ === i) break;
       i = _Z_;
      }
     }
     var _X_ = 1 - old_trav, _Y_ = _X_ ? flip_ongoing_traversal(h) : _X_;
     return _Y_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function filter_map_inplace(f, h){
    var d = h[2], old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var _R_ = d.length - 2 | 0, _Q_ = 0;
     if(_R_ >= 0){
      var i = _Q_;
      for(;;){
       var slot$0 = caml_check_bound(h[2], i)[1 + i], prec = 0, slot = slot$0;
       for(;;){
        if(! slot) break;
        var
         key = slot[1],
         data = slot[2],
         next = slot[3],
         match = caml_call2(f, key, data);
        if(match){
         var data$0 = match[1];
         if(prec)
          prec[3] = slot;
         else
          caml_check_bound(h[2], i)[1 + i] = slot;
         slot[2] = data$0;
         prec = slot;
         slot = next;
        }
        else{h[1] = h[1] - 1 | 0; slot = next;}
       }
       if(prec) prec[3] = 0; else caml_check_bound(h[2], i)[1 + i] = 0;
       var _U_ = i + 1 | 0;
       if(_R_ === i) break;
       i = _U_;
      }
     }
     var _S_ = 1 - old_trav, _T_ = _S_ ? flip_ongoing_traversal(h) : _S_;
     return _T_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function fold(f, h, init){
    var old_trav = ongoing_traversal(h);
    if(1 - old_trav) flip_ongoing_traversal(h);
    try{
     var d = h[2], accu$1 = [0, init], _N_ = d.length - 2 | 0, _M_ = 0;
     if(_N_ >= 0){
      var i = _M_;
      for(;;){
       var
        accu$2 = accu$1[1],
        b$0 = caml_check_bound(d, i)[1 + i],
        b = b$0,
        accu = accu$2;
       for(;;){
        if(! b) break;
        var
         key = b[1],
         data = b[2],
         next = b[3],
         accu$0 = caml_call3(f, key, data, accu);
        b = next;
        accu = accu$0;
       }
       accu$1[1] = accu;
       var _P_ = i + 1 | 0;
       if(_N_ === i) break;
       i = _P_;
      }
     }
     if(1 - old_trav) flip_ongoing_traversal(h);
     var _O_ = accu$1[1];
     return _O_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(old_trav) throw caml_maybe_attach_backtrace(exn, 0);
     flip_ongoing_traversal(h);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function bucket_length(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(! param$0) return accu$0;
     var next = param$0[3], accu$1 = accu$0 + 1 | 0;
     accu$0 = accu$1;
     param$0 = next;
    }
   }
   function stats(h){
    var
     mbl =
       caml_call3
        (Stdlib_Array[18],
         function(m, b){
          var _L_ = bucket_length(0, b);
          return caml_call2(Stdlib_Int[11], m, _L_);
         },
         0,
         h[2]),
     histo = caml_make_vect(mbl + 1 | 0, 0);
    caml_call2
     (Stdlib_Array[12],
      function(b){
       var l = bucket_length(0, b);
       histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
       return 0;
      },
      h[2]);
    return [0, h[1], h[2].length - 1, mbl, histo];
   }
   function to_seq(tbl){
    var tbl_data = tbl[2];
    function aux(i, buck, param){
     var i$0 = i, buck$0 = buck;
     for(;;){
      if(buck$0){
       var key = buck$0[1], data = buck$0[2], next = buck$0[3];
       return [0, [0, key, data], function(_K_){return aux(i$0, next, _K_);}];
      }
      if(i$0 === tbl_data.length - 1) return 0;
      var
       buck$1 = caml_check_bound(tbl_data, i$0)[1 + i$0],
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      buck$0 = buck$1;
     }
    }
    var _H_ = 0, _I_ = 0;
    return function(_J_){return aux(_I_, _H_, _J_);};
   }
   function to_seq_keys(m){
    var _F_ = to_seq(m);
    return caml_call2(Stdlib_Seq[29], function(_G_){return _G_[1];}, _F_);
   }
   function to_seq_values(m){
    var _D_ = to_seq(m);
    return caml_call2(Stdlib_Seq[29], function(_E_){return _E_[2];}, _D_);
   }
   function MakeSeeded(H){
    function key_index(h, key){
     var _C_ = h[2].length - 2 | 0;
     return caml_call2(H[2], h[3], key) & _C_;
    }
    function add(h, key, data){
     var
      i = key_index(h, key),
      bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _B_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _B_ ? resize(key_index, h) : _B_;
    }
    function remove(h, key){
     var
      i = key_index(h, key),
      c = caml_check_bound(h[2], i)[1 + i],
      prec$0 = 0,
      prec = c;
     for(;;){
      if(! prec) return 0;
      var k = prec[1], next = prec[3];
      if(caml_call2(H[1], k, key)){
       h[1] = h[1] - 1 | 0;
       return prec$0
               ? (prec$0[3] = next, 0)
               : (caml_check_bound(h[2], i)[1 + i] = next, 0);
      }
      prec$0 = prec;
      prec = next;
     }
    }
    function find(h, key){
     var
      _A_ = key_index(h, key),
      match = caml_check_bound(h[2], _A_)[1 + _A_];
     if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return d1;
     if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return d2;
     if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return d3;
     var param = next3;
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return data;
      param = next;
     }
    }
    function find_opt(h, key){
     var
      _z_ = key_index(h, key),
      match = caml_check_bound(h[2], _z_)[1 + _z_];
     if(! match) return 0;
     var k1 = match[1], d1 = match[2], next1 = match[3];
     if(caml_call2(H[1], key, k1)) return [0, d1];
     if(! next1) return 0;
     var k2 = next1[1], d2 = next1[2], next2 = next1[3];
     if(caml_call2(H[1], key, k2)) return [0, d2];
     if(! next2) return 0;
     var k3 = next2[1], d3 = next2[2], next3 = next2[3];
     if(caml_call2(H[1], key, k3)) return [0, d3];
     var param = next3;
     for(;;){
      if(! param) return 0;
      var k = param[1], data = param[2], next = param[3];
      if(caml_call2(H[1], key, k)) return [0, data];
      param = next;
     }
    }
    function find_all(h, key){
     var
      _y_ = key_index(h, key),
      param = caml_check_bound(h[2], _y_)[1 + _y_];
     for(;;){
      if(! param) return 0;
      var k = param[1], d = param[2], next = param[3];
      if(caml_call2(H[1], k, key)) break;
      param = next;
     }
     var block = [0, d, 24029], dst = block, offset = 1, param$0 = next;
     for(;;){
      if(! param$0){dst[1 + offset] = 0; return block;}
      var k$0 = param$0[1], d$0 = param$0[2], next$0 = param$0[3];
      if(caml_call2(H[1], k$0, key)){
       var dst$0 = [0, d$0, 24029];
       dst[1 + offset] = dst$0;
       dst = dst$0;
       offset = 1;
       param$0 = next$0;
      }
      else
       param$0 = next$0;
     }
    }
    function replace(h, key, data){
     var
      i = key_index(h, key),
      l = caml_check_bound(h[2], i)[1 + i],
      slot = l;
     for(;;){
      if(slot){
       var k = slot[1], next = slot[3];
       if(! caml_call2(H[1], k, key)){slot = next; continue;}
       slot[1] = key;
       slot[2] = data;
       var _v_ = 0;
      }
      else
       var _v_ = 1;
      if(_v_){
       caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
       h[1] = h[1] + 1 | 0;
       var _w_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
       if(_w_) return resize(key_index, h);
       var _x_ = _w_;
      }
      else
       var _x_ = _v_;
      return _x_;
     }
    }
    function mem(h, key){
     var
      _u_ = key_index(h, key),
      param = caml_check_bound(h[2], _u_)[1 + _u_];
     for(;;){
      if(! param) return 0;
      var k = param[1], next = param[3], _t_ = caml_call2(H[1], k, key);
      if(_t_) return _t_;
      param = next;
     }
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function Make(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded([0, equal, seeded_hash]),
     _s_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     iter = include[12],
     filter_map_inplace = include[13],
     fold = include[14],
     length = include[15],
     stats = include[16],
     to_seq = include[17],
     to_seq_keys = include[18],
     to_seq_values = include[19],
     add_seq = include[20],
     replace_seq = include[21];
    function create(sz){return caml_call2(_s_, _d_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_s_, _d_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            iter,
            filter_map_inplace,
            fold,
            length,
            stats,
            to_seq,
            to_seq_keys,
            to_seq_values,
            add_seq,
            replace_seq,
            of_seq];
   }
   function hash(x){return caml_hash(10, 100, 0, x);}
   function hash_param(n1, n2, x){return caml_hash(n1, n2, 0, x);}
   function seeded_hash(seed, x){return caml_hash(10, 100, seed, x);}
   function key_index(h, key){
    return 4 <= h.length - 1
            ? caml_hash(10, 100, h[3], key) & (h[2].length - 2 | 0)
            : caml_call1(Stdlib[1], cst_Hashtbl_unsupported_hash_t);
   }
   function add(h, key, data){
    var
     i = key_index(h, key),
     bucket = [0, key, data, caml_check_bound(h[2], i)[1 + i]];
    caml_check_bound(h[2], i)[1 + i] = bucket;
    h[1] = h[1] + 1 | 0;
    var _r_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
    return _r_ ? resize(key_index, h) : _r_;
   }
   function remove(h, key){
    var
     i = key_index(h, key),
     c = caml_check_bound(h[2], i)[1 + i],
     prec$0 = 0,
     prec = c;
    for(;;){
     if(! prec) return 0;
     var k = prec[1], next = prec[3];
     if(0 === caml_compare(k, key)){
      h[1] = h[1] - 1 | 0;
      return prec$0
              ? (prec$0[3] = next, 0)
              : (caml_check_bound(h[2], i)[1 + i] = next, 0);
     }
     prec$0 = prec;
     prec = next;
    }
   }
   function find(h, key){
    var _q_ = key_index(h, key), match = caml_check_bound(h[2], _q_)[1 + _q_];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return d1;
    if(! next1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return d2;
    if(! next2) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return d3;
    var param = next3;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return data;
     param = next;
    }
   }
   function find_opt(h, key){
    var _p_ = key_index(h, key), match = caml_check_bound(h[2], _p_)[1 + _p_];
    if(! match) return 0;
    var k1 = match[1], d1 = match[2], next1 = match[3];
    if(0 === caml_compare(key, k1)) return [0, d1];
    if(! next1) return 0;
    var k2 = next1[1], d2 = next1[2], next2 = next1[3];
    if(0 === caml_compare(key, k2)) return [0, d2];
    if(! next2) return 0;
    var k3 = next2[1], d3 = next2[2], next3 = next2[3];
    if(0 === caml_compare(key, k3)) return [0, d3];
    var param = next3;
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(key, k)) return [0, data];
     param = next;
    }
   }
   function find_all(h, key){
    var _o_ = key_index(h, key), param = caml_check_bound(h[2], _o_)[1 + _o_];
    for(;;){
     if(! param) return 0;
     var k = param[1], data = param[2], next = param[3];
     if(0 === caml_compare(k, key)) break;
     param = next;
    }
    var block = [0, data, 24029], dst = block, offset = 1, param$0 = next;
    for(;;){
     if(! param$0){dst[1 + offset] = 0; return block;}
     var k$0 = param$0[1], data$0 = param$0[2], next$0 = param$0[3];
     if(0 === caml_compare(k$0, key)){
      var dst$0 = [0, data$0, 24029];
      dst[1 + offset] = dst$0;
      dst = dst$0;
      offset = 1;
      param$0 = next$0;
     }
     else
      param$0 = next$0;
    }
   }
   function replace(h, key, data){
    var i = key_index(h, key), l = caml_check_bound(h[2], i)[1 + i], slot = l;
    for(;;){
     if(slot){
      var k = slot[1], next = slot[3];
      if(0 !== caml_compare(k, key)){slot = next; continue;}
      slot[1] = key;
      slot[2] = data;
      var _l_ = 0;
     }
     else
      var _l_ = 1;
     if(_l_){
      caml_check_bound(h[2], i)[1 + i] = [0, key, data, l];
      h[1] = h[1] + 1 | 0;
      var _m_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      if(_m_) return resize(key_index, h);
      var _n_ = _m_;
     }
     else
      var _n_ = _l_;
     return _n_;
    }
   }
   function mem(h, key){
    var _k_ = key_index(h, key), param = caml_check_bound(h[2], _k_)[1 + _k_];
    for(;;){
     if(! param) return 0;
     var
      k = param[1],
      next = param[3],
      _j_ = 0 === caml_compare(k, key) ? 1 : 0;
     if(_j_) return _j_;
     param = next;
    }
   }
   function add_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return add(tbl, k, v);
             },
             i);
   }
   function replace_seq(tbl, i){
    return caml_call2
            (Stdlib_Seq[4],
             function(param){
              var v = param[2], k = param[1];
              return replace(tbl, k, v);
             },
             i);
   }
   function of_seq(i){
    var tbl = create(0, 16);
    replace_seq(tbl, i);
    return tbl;
   }
   function rebuild(opt, h){
    var
     random = opt ? opt[1] : caml_call1(Stdlib_Atomic[3], randomized),
     s = power_2_above(16, h[2].length - 1);
    if(random)
     var
      _g_ = caml_call1(Stdlib_Domain[10][2], prng_key),
      seed = caml_call1(Stdlib_Random[19][4], _g_);
    else
     var seed = 4 <= h.length - 1 ? h[3] : 0;
    var
     _h_ = 4 <= h.length - 1 ? h[4] : s,
     h$0 = [0, h[1], caml_make_vect(s, 0), seed, _h_];
    insert_all_buckets
     (function(_i_){return key_index(h$0, _i_);}, 0, h[2], h$0[2]);
    return h$0;
   }
   var
    Stdlib_Hashtbl =
      [0,
       create,
       clear,
       reset,
       copy,
       add,
       find,
       find_opt,
       find_all,
       mem,
       remove,
       replace,
       iter,
       filter_map_inplace,
       fold,
       length,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq,
       to_seq_keys,
       to_seq_values,
       add_seq,
       replace_seq,
       of_seq,
       Make,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       caml_hash];
   runtime.caml_register_global(16, Stdlib_Hashtbl, "Stdlib__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Weak
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Int, Stdlib__Obj, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mod = runtime.caml_mod;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Obj = global_data.Stdlib__Obj,
    cst_Weak_create = "Weak.create",
    cst_Weak_set = "Weak.set",
    cst_Weak_get = "Weak.get",
    cst_Weak_get_copy = "Weak.get_copy",
    cst_Weak_check = "Weak.check",
    cst_Weak_blit = "Weak.blit",
    cst_Weak_fill = "Weak.fill",
    cst_Weak_Make_hash_bucket_cann = "Weak.Make: hash bucket cannot grow more";
   function create(l){
    var
     _J_ = 0 <= l ? 1 : 0,
     _K_ = _J_ ? l <= Stdlib_Obj[23][15] ? 1 : 0 : _J_;
    if(1 - _K_) caml_call1(Stdlib[1], cst_Weak_create);
    return runtime.caml_weak_create(l);
   }
   function length(x){return x.length - 3 | 0;}
   function raise_if_invalid_offset(e, o, msg){
    var
     _G_ = 0 <= o ? 1 : 0,
     _H_ = _G_ ? o < length(e) ? 1 : 0 : _G_,
     _I_ = 1 - _H_;
    return _I_ ? caml_call1(Stdlib[1], msg) : _I_;
   }
   function set(e, o, x){
    raise_if_invalid_offset(e, o, cst_Weak_set);
    if(! x) return runtime.caml_ephe_unset_key(e, o);
    var x$0 = x[1];
    return runtime.caml_ephe_set_key(e, o, x$0);
   }
   function get(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get);
    return runtime.caml_ephe_get_key(e, o);
   }
   function get_copy(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_get_copy);
    return runtime.caml_ephe_get_key_copy(e, o);
   }
   function check(e, o){
    raise_if_invalid_offset(e, o, cst_Weak_check);
    return runtime.caml_ephe_check_key(e, o);
   }
   function blit(e1, o1, e2, o2, l){
    if
     (0 <= l
      &&
       0 <= o1
       && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2){
     var
      _E_ = 0 !== l ? 1 : 0,
      _F_ = _E_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _E_;
     return _F_;
    }
    return caml_call1(Stdlib[1], cst_Weak_blit);
   }
   function fill(ar, ofs, len, x){
    if(0 <= ofs && 0 <= len && (length(ar) - len | 0) >= ofs){
     var _C_ = (ofs + len | 0) - 1 | 0;
     if(_C_ >= ofs){
      var i = ofs;
      for(;;){
       set(ar, i, x);
       var _D_ = i + 1 | 0;
       if(_C_ === i) break;
       i = _D_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Weak_fill], 1);
   }
   function Make(H){
    var emptybucket = create(0);
    function get_index(t, h){
     return caml_mod(h & Stdlib[19], t[1].length - 1);
    }
    var limit = 7;
    function create$0(sz){
     var
      sz$0 = 7 <= sz ? sz : 7,
      sz$1 = Stdlib_Sys[13] < sz$0 ? Stdlib_Sys[13] : sz$0;
     return [0,
             caml_make_vect(sz$1, emptybucket),
             caml_make_vect(sz$1, [0]),
             limit,
             0,
             0];
    }
    function clear(t){
     var _A_ = t[1].length - 2 | 0, _z_ = 0;
     if(_A_ >= 0){
      var i = _z_;
      for(;;){
       caml_check_bound(t[1], i)[1 + i] = emptybucket;
       caml_check_bound(t[2], i)[1 + i] = [0];
       var _B_ = i + 1 | 0;
       if(_A_ === i) break;
       i = _B_;
      }
     }
     t[3] = limit;
     t[4] = 0;
     return 0;
    }
    function fold(f, t, init){
     var i = 0;
     return caml_call3
             (Stdlib_Array[20],
              function(b, accu$1){
               var i$0 = i, accu = accu$1;
               for(;;){
                if(length(b) <= i$0) return accu;
                var match = get(b, i$0);
                if(match){
                 var
                  v = match[1],
                  accu$0 = caml_call2(f, v, accu),
                  i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                 accu = accu$0;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1],
              init);
    }
    function iter(f, t){
     var i = 0;
     return caml_call2
             (Stdlib_Array[12],
              function(b){
               var i$0 = i;
               for(;;){
                if(length(b) <= i$0) return 0;
                var match = get(b, i$0);
                if(match){
                 var v = match[1];
                 caml_call1(f, v);
                 var i$1 = i$0 + 1 | 0;
                 i$0 = i$1;
                }
                else{var i$2 = i$0 + 1 | 0; i$0 = i$2;}
               }
              },
              t[1]);
    }
    function count_bucket(i, b, accu){
     var i$0 = i, accu$0 = accu;
     for(;;){
      if(length(b) <= i$0) return accu$0;
      var
       _y_ = check(b, i$0) ? 1 : 0,
       accu$1 = accu$0 + _y_ | 0,
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      accu$0 = accu$1;
     }
    }
    function count(t){
     var _v_ = 0;
     return caml_call3
             (Stdlib_Array[20],
              function(_w_, _x_){return count_bucket(_v_, _w_, _x_);},
              t[1],
              0);
    }
    function add_aux(t, setter, d, h, index){
     var
      bucket$0 = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket$0),
      i$3 = 0;
     for(;;){
      if(sz <= i$3) break;
      if(! check(bucket$0, i$3)){
       caml_call3(setter, bucket$0, i$3, d);
       caml_check_bound(hashes, i$3)[1 + i$3] = h;
       return 0;
      }
      var i$5 = i$3 + 1 | 0;
      i$3 = i$5;
     }
     var
      newsz =
        caml_call2
         (Stdlib_Int[10],
          ((3 * sz | 0) / 2 | 0) + 3 | 0,
          Stdlib_Sys[13] - 2 | 0);
     if(newsz <= sz) caml_call1(Stdlib[2], cst_Weak_Make_hash_bucket_cann);
     var newbucket$0 = create(newsz), newhashes = caml_make_vect(newsz, 0);
     blit(bucket$0, 0, newbucket$0, 0, sz);
     caml_call5(Stdlib_Array[9], hashes, 0, newhashes, 0, sz);
     caml_call3(setter, newbucket$0, sz, d);
     caml_check_bound(newhashes, sz)[1 + sz] = h;
     caml_check_bound(t[1], index)[1 + index] = newbucket$0;
     caml_check_bound(t[2], index)[1 + index] = newhashes;
     var _r_ = sz <= t[3] ? 1 : 0, _s_ = _r_ ? t[3] < newsz ? 1 : 0 : _r_;
     if(_s_){
      t[4] = t[4] + 1 | 0;
      var i$4 = 0;
      for(;;){
       var
        _h_ = t[5],
        bucket = caml_check_bound(t[1], _h_)[1 + _h_],
        _i_ = t[5],
        hbucket = caml_check_bound(t[2], _i_)[1 + _i_],
        len = length(bucket),
        prev_len = (((len - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
        live = count_bucket(0, bucket, 0);
       if(live <= prev_len){
        var j$2 = length(bucket) - 1 | 0, i$0 = 0, j = j$2;
        for(;;){
         if(prev_len > j) break;
         if(check(bucket, i$0)){
          var i$1 = i$0 + 1 | 0;
          i$0 = i$1;
         }
         else if(check(bucket, j)){
          blit(bucket, j, bucket, i$0, 1);
          var _j_ = caml_check_bound(hbucket, j)[1 + j];
          caml_check_bound(hbucket, i$0)[1 + i$0] = _j_;
          var j$0 = j - 1 | 0, i$2 = i$0 + 1 | 0;
          i$0 = i$2;
          j = j$0;
         }
         else{var j$1 = j - 1 | 0; j = j$1;}
        }
        if(0 === prev_len){
         var _k_ = t[5];
         caml_check_bound(t[1], _k_)[1 + _k_] = emptybucket;
         var _l_ = t[5];
         caml_check_bound(t[2], _l_)[1 + _l_] = [0];
        }
        else{
         var newbucket = create(prev_len);
         blit(bucket, 0, newbucket, 0, prev_len);
         var _o_ = t[5];
         caml_check_bound(t[1], _o_)[1 + _o_] = newbucket;
         var
          _p_ = caml_call3(Stdlib_Array[6], hbucket, 0, prev_len),
          _q_ = t[5];
         caml_check_bound(t[2], _q_)[1 + _q_] = _p_;
        }
        var
         _m_ = t[3] < len ? 1 : 0,
         _n_ = _m_ ? prev_len <= t[3] ? 1 : 0 : _m_;
        if(_n_) t[4] = t[4] - 1 | 0;
       }
       t[5] = caml_mod(t[5] + 1 | 0, t[1].length - 1);
       var _u_ = i$4 + 1 | 0;
       if(2 === i$4) break;
       i$4 = _u_;
      }
     }
     var _t_ = ((t[1].length - 1) / 2 | 0) < t[4] ? 1 : 0;
     if(! _t_) return _t_;
     var
      oldlen = t[1].length - 1,
      newlen =
        caml_call2
         (Stdlib_Int[10], ((3 * oldlen | 0) / 2 | 0) + 3 | 0, Stdlib_Sys[13]);
     if(oldlen < newlen){
      var newt = create$0(newlen), i = 0;
      caml_call2
       (Stdlib_Array[13],
        function(j, ob){
         var oi = i;
         for(;;){
          if(length(ob) <= oi) return 0;
          if(check(ob, oi)){
           var oh = caml_check_bound(t[2], j)[1 + j];
           let oi$0 = oi;
           var
            setter =
              function(nb, ni, param){return blit(ob, oi$0, nb, ni, 1);},
            h = caml_check_bound(oh, oi)[1 + oi];
           add_aux(newt, setter, 0, h, get_index(newt, h));
           var i$0 = oi + 1 | 0;
           oi = i$0;
          }
          else{var i$1 = oi + 1 | 0; oi = i$1;}
         }
        },
        t[1]);
      t[1] = newt[1];
      t[2] = newt[2];
      t[3] = newt[3];
      t[4] = newt[4];
      t[5] = caml_mod(t[5], newt[1].length - 1);
      return 0;
     }
     t[3] = Stdlib[19];
     t[4] = 0;
     return 0;
    }
    function add(t, d){
     var h = caml_call1(H[2], d);
     return add_aux(t, set, [0, d], h, get_index(t, h));
    }
    function find_aux(t, d, found, notfound){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0;
     for(;;){
      if(sz <= i) return caml_call2(notfound, h, index);
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var opt = get(bucket, i);
       if(opt){
        var v = opt[1];
        if(caml_call2(H[1], v, d))
         return caml_call4(found, bucket, i, opt, v);
       }
       var i$0 = i + 1 | 0;
       i = i$0;
      }
      else{var i$1 = i + 1 | 0; i = i$1;}
     }
    }
    function find_opt(t, d){
     return find_aux
             (t,
              d,
              function(b, i, o, v){return o;},
              function(h, i){return 0;});
    }
    function merge(t, d){
     return find_aux
             (t,
              d,
              function(b, i, o, v){return v;},
              function(h, i){add_aux(t, set, [0, d], h, i); return d;});
    }
    function find(t, d){
     return find_aux
             (t,
              d,
              function(b, i, o, v){return v;},
              function(h, i){throw caml_maybe_attach_backtrace(Stdlib[8], 1);});
    }
    function remove(t, d){
     return find_aux
             (t,
              d,
              function(b, i, o, v){return set(b, i, 0);},
              function(h, i){return 0;});
    }
    function mem(t, d){
     return find_aux
             (t,
              d,
              function(b, i, o, v){return 1;},
              function(h, i){return 0;});
    }
    function find_all(t, d){
     var
      h = caml_call1(H[2], d),
      index = get_index(t, h),
      bucket = caml_check_bound(t[1], index)[1 + index],
      hashes = caml_check_bound(t[2], index)[1 + index],
      sz = length(bucket),
      i = 0,
      accu = 0;
     for(;;){
      if(sz <= i) return accu;
      if(h === caml_check_bound(hashes, i)[1 + i]){
       var match = get(bucket, i);
       if(match){
        var v = match[1];
        if(caml_call2(H[1], v, d)){
         var accu$0 = [0, v, accu], i$0 = i + 1 | 0;
         i = i$0;
         accu = accu$0;
         continue;
        }
       }
       var i$1 = i + 1 | 0;
       i = i$1;
      }
      else{var i$2 = i + 1 | 0; i = i$2;}
     }
    }
    function stats(t){
     var
      len = t[1].length - 1,
      lens = caml_call2(Stdlib_Array[14], length, t[1]);
     caml_call2(Stdlib_Array[35], runtime.caml_int_compare, lens);
     var
      totlen =
        caml_call3
         (Stdlib_Array[18],
          function(_g_, _f_){return _g_ + _f_ | 0;},
          0,
          lens),
      _a_ = len - 1 | 0,
      _c_ = len / 2 | 0,
      _b_ = caml_check_bound(lens, _a_)[1 + _a_],
      _d_ = caml_check_bound(lens, _c_)[1 + _c_],
      _e_ = caml_check_bound(lens, 0)[1];
     return [0, len, count(t), totlen, _e_, _d_, _b_];
    }
    return [0,
            create$0,
            clear,
            merge,
            add,
            remove,
            find,
            find_opt,
            find_all,
            mem,
            iter,
            fold,
            count,
            stats];
   }
   var
    Stdlib_Weak =
      [0, create, length, set, get, get_copy, check, fill, blit, Make];
   runtime.caml_register_global(13, Stdlib_Weak, "Stdlib__Weak");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Format
//# unitInfo: Requires: CamlinternalFormat, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Domain, Stdlib__Int, Stdlib__List, Stdlib__Queue, Stdlib__Seq, Stdlib__Stack, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$16 = "",
    cst$15 = ">",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$14 = ".",
    cst$11 = cst$15,
    cst$12 = "<\/",
    cst$13 = cst$16,
    cst$8 = cst$15,
    cst$9 = "<",
    cst$10 = cst$16,
    cst$7 = "\n",
    cst$3 = cst$16,
    cst$4 = cst$16,
    cst$5 = cst$16,
    cst$6 = cst$16,
    cst = cst$16,
    cst$0 = cst$16,
    cst$1 = cst$16,
    cst$2 = cst$16,
    _a_ = [0, cst$16, 0, cst$16],
    Stdlib_Queue = global_data.Stdlib__Queue,
    CamlinternalFormat = global_data.CamlinternalFormat,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function id(x){return x;}
   var
    zero = 0,
    unknown = -1,
    String_tag =
      [248, "Stdlib.Format.String_tag", runtime.caml_fresh_oo_id(0)];
   function pp_enqueue(state, token){
    state[13] = state[13] + token[3] | 0;
    return caml_call2(Stdlib_Queue[3], token, state[28]);
   }
   var
    pp_infinity = 1000000010,
    _b_ = [0, cst$16],
    _c_ = [1, "margin <= max_indent"],
    _d_ = [1, "margin >= pp_infinity"],
    _e_ = [0, 0],
    _f_ = [1, "max_indent < 2"],
    cst_Format_pp_set_geometry = "Format.pp_set_geometry: ";
   function pp_output_string(state, s){
    return caml_call3(state[17], s, 0, caml_ml_string_length(s));
   }
   function pp_output_newline(state){return caml_call1(state[19], 0);}
   function format_pp_text(state, size, text){
    state[9] = state[9] - size | 0;
    pp_output_string(state, text);
    state[11] = 0;
    return;
   }
   function format_string(state, s){
    var _a__ = s !== cst$16 ? 1 : 0;
    return _a__ ? format_pp_text(state, caml_ml_string_length(s), s) : _a__;
   }
   function break_new_line(state, param, width){
    var after = param[3], offset = param[2], before = param[1];
    format_string(state, before);
    pp_output_newline(state);
    state[11] = 1;
    var
     indent = (state[6] - width | 0) + offset | 0,
     real_indent = caml_call2(Stdlib_Int[10], state[8], indent);
    state[10] = real_indent;
    state[9] = state[6] - state[10] | 0;
    var n = state[10];
    caml_call1(state[21], n);
    return format_string(state, after);
   }
   function break_same_line(state, param){
    var after = param[3], width = param[2], before = param[1];
    format_string(state, before);
    state[9] = state[9] - width | 0;
    caml_call1(state[20], width);
    return format_string(state, after);
   }
   function format_pp_token(state, size$0, param){
    if(typeof param === "number")
     switch(param){
       case 0:
        var match$3 = caml_call1(Stdlib_Stack[8], state[3]);
        if(! match$3) return;
        var
         tabs = match$3[1][1],
         add_tab =
           function(n, ls){
            if(! ls) return [0, n, 0];
            var l = ls[2], x = ls[1];
            return runtime.caml_lessthan(n, x)
                    ? [0, n, ls]
                    : [0, x, add_tab(n, l)];
           };
        tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
        return;
       case 1:
        caml_call1(Stdlib_Stack[5], state[2]); return;
       case 2:
        caml_call1(Stdlib_Stack[5], state[3]); return;
       case 3:
        var match$4 = caml_call1(Stdlib_Stack[8], state[2]);
        if(! match$4) return pp_output_newline(state);
        var width$0 = match$4[1][2];
        return break_new_line(state, _a_, width$0);
       case 4:
        var _a8_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
        if(! _a8_) return _a8_;
        var match$1 = caml_call1(Stdlib_Queue[6], state[28]);
        if(! match$1) return;
        var match$2 = match$1[1], size = match$2[1], length = match$2[3];
        state[12] = state[12] - length | 0;
        state[9] = state[9] + size | 0;
        return;
       default:
        var match$5 = caml_call1(Stdlib_Stack[5], state[5]);
        if(! match$5) return;
        var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
        return pp_output_string(state, marker);
     }
    switch(param[0]){
      case 0:
       var s = param[1]; return format_pp_text(state, size$0, s);
      case 1:
       var
        breaks = param[2],
        fits = param[1],
        off = breaks[2],
        before = breaks[1],
        match$6 = caml_call1(Stdlib_Stack[8], state[2]);
       if(! match$6) return;
       var
        match$7 = match$6[1],
        width$1 = match$7[2],
        box_type$0 = match$7[1];
       switch(box_type$0){
         case 0:
          return break_same_line(state, fits);
         case 1:
          return break_new_line(state, breaks, width$1);
         case 2:
          return break_new_line(state, breaks, width$1);
         case 3:
          return state[9] < (size$0 + caml_ml_string_length(before) | 0)
                  ? break_new_line(state, breaks, width$1)
                  : break_same_line(state, fits);
         case 4:
          return state[11]
                  ? break_same_line(state, fits)
                  : state
                     [9]
                    < (size$0 + caml_ml_string_length(before) | 0)
                    ? break_new_line(state, breaks, width$1)
                    : ((state
                       [6]
                      - width$1
                      | 0)
                      + off
                      | 0)
                      < state[10]
                      ? break_new_line(state, breaks, width$1)
                      : break_same_line(state, fits);
         default: return break_same_line(state, fits);
       }
      case 2:
       var
        off$0 = param[2],
        n = param[1],
        insertion_point = state[6] - state[9] | 0,
        match$8 = caml_call1(Stdlib_Stack[8], state[3]);
       if(! match$8) return;
       var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
       if(match$9){
        var first = match$9[1], param$0 = tabs$0[1];
        for(;;){
         if(param$0){
          var tail = param$0[2], head = param$0[1];
          if(insertion_point > head){param$0 = tail; continue;}
          var _a9_ = head;
         }
         else
          var _a9_ = first;
         var tab = _a9_;
         break;
        }
       }
       else
        var tab = insertion_point;
       var offset = tab - insertion_point | 0;
       return 0 <= offset
               ? break_same_line(state, [0, cst$0, offset + n | 0, cst])
               : break_new_line
                 (state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
      case 3:
       var
        ty = param[2],
        off$1 = param[1],
        insertion_point$0 = state[6] - state[9] | 0;
       if(state[8] < insertion_point$0){
        var match = caml_call1(Stdlib_Stack[8], state[2]);
        if(match){
         var match$0 = match[1], width = match$0[2], box_type = match$0[1];
         if(state[9] < width && 3 >= box_type - 1 >>> 0)
          break_new_line(state, _a_, width);
        }
        else
         pp_output_newline(state);
       }
       var
        width$2 = state[9] - off$1 | 0,
        box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
       return caml_call2(Stdlib_Stack[3], [0, box_type$1, width$2], state[2]);
      case 4:
       var tbox = param[1];
       return caml_call2(Stdlib_Stack[3], tbox, state[3]);
      default:
       var
        tag_name$0 = param[1],
        marker$0 = caml_call1(state[24], tag_name$0);
       pp_output_string(state, marker$0);
       return caml_call2(Stdlib_Stack[3], tag_name$0, state[5]);
    }
   }
   function advance_left(state){
    for(;;){
     var match = caml_call1(Stdlib_Queue[9], state[28]);
     if(! match) return 0;
     var
      match$0 = match[1],
      size = match$0[1],
      length = match$0[3],
      token = match$0[2],
      pending_count = state[13] - state[12] | 0,
      _a6_ = 0 <= size ? 1 : 0,
      _a7_ = _a6_ || (state[9] <= pending_count ? 1 : 0);
     if(! _a7_) return _a7_;
     caml_call1(Stdlib_Queue[5], state[28]);
     var size$0 = 0 <= size ? size : pp_infinity;
     format_pp_token(state, size$0, token);
     state[12] = length + state[12] | 0;
    }
   }
   function enqueue_advance(state, tok){
    pp_enqueue(state, tok);
    return advance_left(state);
   }
   function enqueue_string_as(state, size, s){
    return enqueue_advance(state, [0, size, [0, s], size]);
   }
   function initialize_scan_stack(stack){
    caml_call1(Stdlib_Stack[9], stack);
    var queue_elem = [0, unknown, _b_, 0];
    return caml_call2(Stdlib_Stack[3], [0, -1, queue_elem], stack);
   }
   function set_size(state, ty){
    var match = caml_call1(Stdlib_Stack[8], state[1]);
    if(! match) return;
    var
     match$0 = match[1],
     queue_elem = match$0[2],
     left_total = match$0[1],
     size = queue_elem[1];
    if(left_total < state[12]) return initialize_scan_stack(state[1]);
    var _a5_ = queue_elem[2];
    if(typeof _a5_ !== "number")
     switch(_a5_[0]){
       case 3:
        if(1 - ty){
         var x$0 = state[13] + size | 0;
         queue_elem[1] = x$0;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
       case 1:
       case 2:
        if(ty){
         var x = state[13] + size | 0;
         queue_elem[1] = x;
         caml_call1(Stdlib_Stack[5], state[1]);
        }
        return;
     }
    return;
   }
   function scan_push(state, b, token){
    pp_enqueue(state, token);
    if(b) set_size(state, 1);
    var elem = [0, state[13], token];
    return caml_call2(Stdlib_Stack[3], elem, state[1]);
   }
   function pp_open_box_gen(state, indent, br_ty){
    state[14] = state[14] + 1 | 0;
    if(state[14] < state[15]){
     var size = - state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
     return scan_push(state, 0, elem);
    }
    var _a4_ = state[14] === state[15] ? 1 : 0;
    if(! _a4_) return _a4_;
    var s = state[16], x = caml_ml_string_length(s);
    return enqueue_string_as(state, x, s);
   }
   function pp_close_box(state, param){
    var _a2_ = 1 < state[14] ? 1 : 0;
    if(_a2_){
     if(state[14] < state[15]){
      pp_enqueue(state, [0, zero, 1, 0]);
      set_size(state, 1);
      set_size(state, 0);
     }
     state[14] = state[14] - 1 | 0;
     var _a3_ = 0;
    }
    else
     var _a3_ = _a2_;
    return _a3_;
   }
   function pp_open_stag(state, tag_name){
    if(state[22]){
     caml_call2(Stdlib_Stack[3], tag_name, state[4]);
     caml_call1(state[26], tag_name);
    }
    var _a1_ = state[23];
    if(! _a1_) return _a1_;
    var token = [5, tag_name];
    return pp_enqueue(state, [0, zero, token, 0]);
   }
   function pp_close_stag(state, param){
    if(state[23]) pp_enqueue(state, [0, zero, 5, 0]);
    var _aZ_ = state[22];
    if(_aZ_){
     var match = caml_call1(Stdlib_Stack[5], state[4]);
     if(match){
      var tag_name = match[1];
      return caml_call1(state[27], tag_name);
     }
     var _a0_ = 0;
    }
    else
     var _a0_ = _aZ_;
    return _a0_;
   }
   function pp_set_print_tags(state, b){state[22] = b; return 0;}
   function pp_set_mark_tags(state, b){state[23] = b; return 0;}
   function pp_get_print_tags(state, param){return state[22];}
   function pp_get_mark_tags(state, param){return state[23];}
   function pp_set_tags(state, b){
    pp_set_print_tags(state, b);
    return pp_set_mark_tags(state, b);
   }
   function pp_get_formatter_stag_function(state, param){
    return [0, state[24], state[25], state[26], state[27]];
   }
   function pp_set_formatter_stag_function(state, param){
    var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
    state[24] = mot;
    state[25] = mct;
    state[26] = pot;
    state[27] = pct;
    return 0;
   }
   function pp_rinit(state){
    state[12] = 1;
    state[13] = 1;
    caml_call1(Stdlib_Queue[11], state[28]);
    initialize_scan_stack(state[1]);
    caml_call1(Stdlib_Stack[9], state[2]);
    caml_call1(Stdlib_Stack[9], state[3]);
    caml_call1(Stdlib_Stack[9], state[4]);
    caml_call1(Stdlib_Stack[9], state[5]);
    state[10] = 0;
    state[14] = 0;
    state[9] = state[6];
    return pp_open_box_gen(state, 0, 3);
   }
   function pp_flush_queue(state, end_with_newline){
    caml_call2
     (Stdlib_Stack[13],
      function(param){return pp_close_stag(state, 0);},
      state[4]);
    for(;;){
     if(1 >= state[14]){
      state[13] = pp_infinity;
      advance_left(state);
      if(end_with_newline) pp_output_newline(state);
      return pp_rinit(state);
     }
     pp_close_box(state, 0);
    }
   }
   function pp_print_as_size(state, size, s){
    var _aY_ = state[14] < state[15] ? 1 : 0;
    return _aY_ ? enqueue_string_as(state, size, s) : _aY_;
   }
   function pp_print_as(state, isize, s){
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_string(state, s){
    var isize = caml_ml_string_length(s);
    return pp_print_as_size(state, isize, s);
   }
   function pp_print_bytes(state, s){
    var
     s$0 = caml_call1(Stdlib_Bytes[6], s),
     isize = runtime.caml_ml_bytes_length(s);
    return pp_print_as_size(state, isize, s$0);
   }
   function pp_print_int(state, i){
    return pp_print_string(state, caml_call1(Stdlib_Int[12], i));
   }
   function pp_print_float(state, f){
    return pp_print_string(state, caml_call1(Stdlib[35], f));
   }
   function pp_print_bool(state, b){
    return pp_print_string(state, caml_call1(Stdlib[30], b));
   }
   function pp_print_char(state, c){
    var s = caml_call2(Stdlib_String[1], 1, c);
    return pp_print_as_size(state, 1, s);
   }
   function pp_print_nothing(state, param){return 0;}
   function pp_open_hbox(state, param){return pp_open_box_gen(state, 0, 0);}
   function pp_open_vbox(state, indent){
    return pp_open_box_gen(state, indent, 1);
   }
   function pp_open_hvbox(state, indent){
    return pp_open_box_gen(state, indent, 2);
   }
   function pp_open_hovbox(state, indent){
    return pp_open_box_gen(state, indent, 3);
   }
   function pp_open_box(state, indent){
    return pp_open_box_gen(state, indent, 4);
   }
   function pp_print_newline(state, param){
    pp_flush_queue(state, 1);
    return caml_call1(state[18], 0);
   }
   function pp_print_flush(state, param){
    pp_flush_queue(state, 0);
    return caml_call1(state[18], 0);
   }
   function pp_force_newline(state, param){
    var _aX_ = state[14] < state[15] ? 1 : 0;
    return _aX_ ? enqueue_advance(state, [0, zero, 3, 0]) : _aX_;
   }
   function pp_print_if_newline(state, param){
    var _aW_ = state[14] < state[15] ? 1 : 0;
    return _aW_ ? enqueue_advance(state, [0, zero, 4, 0]) : _aW_;
   }
   function pp_print_custom_break(state, fits, breaks){
    var
     after = fits[3],
     width = fits[2],
     before = fits[1],
     _aV_ = state[14] < state[15] ? 1 : 0;
    if(! _aV_) return _aV_;
    var
     size = - state[13] | 0,
     token = [1, fits, breaks],
     length =
       (caml_ml_string_length(before) + width | 0)
       + caml_ml_string_length(after)
       | 0,
     elem = [0, size, token, length];
    return scan_push(state, 1, elem);
   }
   function pp_print_break(state, width, offset){
    return pp_print_custom_break
            (state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
   }
   function pp_print_space(state, param){return pp_print_break(state, 1, 0);}
   function pp_print_cut(state, param){return pp_print_break(state, 0, 0);}
   function pp_open_tbox(state, param){
    state[14] = state[14] + 1 | 0;
    var _aU_ = state[14] < state[15] ? 1 : 0;
    if(! _aU_) return _aU_;
    var elem = [0, zero, [4, [0, [0, 0]]], 0];
    return enqueue_advance(state, elem);
   }
   function pp_close_tbox(state, param){
    var _aR_ = 1 < state[14] ? 1 : 0;
    if(_aR_){
     var _aS_ = state[14] < state[15] ? 1 : 0;
     if(_aS_){
      var elem = [0, zero, 2, 0];
      enqueue_advance(state, elem);
      state[14] = state[14] - 1 | 0;
      var _aT_ = 0;
     }
     else
      var _aT_ = _aS_;
    }
    else
     var _aT_ = _aR_;
    return _aT_;
   }
   function pp_print_tbreak(state, width, offset){
    var _aQ_ = state[14] < state[15] ? 1 : 0;
    if(! _aQ_) return _aQ_;
    var size = - state[13] | 0, elem = [0, size, [2, width, offset], width];
    return scan_push(state, 1, elem);
   }
   function pp_print_tab(state, param){return pp_print_tbreak(state, 0, 0);}
   function pp_set_tab(state, param){
    var _aP_ = state[14] < state[15] ? 1 : 0;
    if(! _aP_) return _aP_;
    var elem = [0, zero, 0, 0];
    return enqueue_advance(state, elem);
   }
   function pp_set_max_boxes(state, n){
    var _aN_ = 1 < n ? 1 : 0, _aO_ = _aN_ ? (state[15] = n, 0) : _aN_;
    return _aO_;
   }
   function pp_get_max_boxes(state, param){return state[15];}
   function pp_over_max_boxes(state, param){return state[14] === state[15] ? 1 : 0;
   }
   function pp_set_ellipsis_text(state, s){state[16] = s; return 0;}
   function pp_get_ellipsis_text(state, param){return state[16];}
   function pp_limit(n){return n < 1000000010 ? n : 1000000009;}
   function pp_set_max_indent(state, n$0){
    var _aM_ = 1 < n$0 ? 1 : 0;
    if(! _aM_) return _aM_;
    var n$1 = state[6] - n$0 | 0, _aL_ = 1 <= n$1 ? 1 : 0;
    if(! _aL_) return _aL_;
    var n = pp_limit(n$1);
    state[7] = n;
    state[8] = state[6] - state[7] | 0;
    return pp_rinit(state);
   }
   function pp_get_max_indent(state, param){return state[8];}
   function pp_set_margin(state, n){
    var _aJ_ = 1 <= n ? 1 : 0;
    if(! _aJ_) return _aJ_;
    var n$0 = pp_limit(n);
    state[6] = n$0;
    if(state[8] <= state[6])
     var new_max_indent = state[8];
    else
     var
      _aK_ =
        caml_call2(Stdlib_Int[11], state[6] - state[7] | 0, state[6] / 2 | 0),
      new_max_indent = caml_call2(Stdlib_Int[11], _aK_, 1);
    return pp_set_max_indent(state, new_max_indent);
   }
   function validate_geometry(param){
    var margin = param[2], max_indent = param[1];
    return 2 <= max_indent
            ? margin <= max_indent ? _c_ : 1000000010 <= margin ? _d_ : _e_
            : _f_;
   }
   function check_geometry(geometry){
    return 0 === validate_geometry(geometry)[0] ? 1 : 0;
   }
   function pp_get_margin(state, param){return state[6];}
   function pp_set_full_geometry(state, param){
    var margin = param[2], max_indent = param[1];
    pp_set_margin(state, margin);
    pp_set_max_indent(state, max_indent);
    return 0;
   }
   function pp_set_geometry(state, max_indent, margin){
    var
     geometry = [0, max_indent, margin],
     match = validate_geometry(geometry);
    if(0 === match[0]) return pp_set_full_geometry(state, geometry);
    var
     msg = match[1],
     _aI_ = caml_call2(Stdlib[28], cst_Format_pp_set_geometry, msg);
    throw caml_maybe_attach_backtrace([0, Stdlib[6], _aI_], 1);
   }
   function pp_safe_set_geometry(state, max_indent, margin){
    var geometry = [0, max_indent, margin];
    return 0 === validate_geometry(geometry)[0]
            ? pp_set_full_geometry(state, geometry)
            : 0;
   }
   function pp_get_geometry(state, param){return [0, state[8], state[6]];}
   function pp_update_geometry(state, update){
    var geometry = pp_get_geometry(state, 0);
    return pp_set_full_geometry(state, caml_call1(update, geometry));
   }
   function pp_set_formatter_out_functions(state, param){
    var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
    state[17] = f;
    state[18] = g;
    state[19] = h;
    state[20] = i;
    state[21] = j;
    return 0;
   }
   function pp_get_formatter_out_functions(state, param){
    return [0, state[17], state[18], state[19], state[20], state[21]];
   }
   function pp_set_formatter_output_functi(state, f, g){state[17] = f; state[18] = g; return 0;
   }
   function pp_get_formatter_output_functi(state, param){return [0, state[17], state[18]];
   }
   function display_newline(state, param){
    return caml_call3(state[17], cst$7, 0, 1);
   }
   var blank_line = caml_call2(Stdlib_String[1], 80, 32), _g_ = [3, 0, 3];
   function display_blanks(state, n){
    var n$0 = n;
    for(;;){
     var _aH_ = 0 < n$0 ? 1 : 0;
     if(! _aH_) return _aH_;
     if(80 >= n$0) return caml_call3(state[17], blank_line, 0, n$0);
     caml_call3(state[17], blank_line, 0, 80);
     var n$1 = n$0 - 80 | 0;
     n$0 = n$1;
    }
   }
   function pp_set_formatter_out_channel(state, oc){
    state[17] = caml_call1(Stdlib[69], oc);
    state[18] = function(param){return caml_call1(Stdlib[63], oc);};
    state[19] = function(_aG_){return display_newline(state, _aG_);};
    state[20] = function(_aF_){return display_blanks(state, _aF_);};
    state[21] = function(_aE_){return display_blanks(state, _aE_);};
    return 0;
   }
   function default_pp_mark_open_tag(param){
    if(param[1] !== String_tag) return cst$10;
    var s = param[2], _aD_ = caml_call2(Stdlib[28], s, cst$8);
    return caml_call2(Stdlib[28], cst$9, _aD_);
   }
   function default_pp_mark_close_tag(param){
    if(param[1] !== String_tag) return cst$13;
    var s = param[2], _aC_ = caml_call2(Stdlib[28], s, cst$11);
    return caml_call2(Stdlib[28], cst$12, _aC_);
   }
   function default_pp_print_open_tag(_aB_){return 0;}
   function default_pp_print_close_tag(_aA_){return 0;}
   function pp_make_formatter(f, g, h, i, j){
    var
     pp_queue = caml_call1(Stdlib_Queue[2], 0),
     sys_tok = [0, unknown, _g_, 0];
    caml_call2(Stdlib_Queue[3], sys_tok, pp_queue);
    var scan_stack = caml_call1(Stdlib_Stack[2], 0);
    initialize_scan_stack(scan_stack);
    caml_call2(Stdlib_Stack[3], [0, 1, sys_tok], scan_stack);
    var
     pp_margin = 78,
     _aw_ = Stdlib[19],
     _ax_ = caml_call1(Stdlib_Stack[2], 0),
     _ay_ = caml_call1(Stdlib_Stack[2], 0),
     _az_ = caml_call1(Stdlib_Stack[2], 0);
    return [0,
            scan_stack,
            caml_call1(Stdlib_Stack[2], 0),
            _az_,
            _ay_,
            _ax_,
            pp_margin,
            10,
            68,
            pp_margin,
            0,
            1,
            1,
            1,
            1,
            _aw_,
            cst$14,
            f,
            g,
            h,
            i,
            j,
            0,
            0,
            default_pp_mark_open_tag,
            default_pp_mark_close_tag,
            default_pp_print_open_tag,
            default_pp_print_close_tag,
            pp_queue];
   }
   function formatter_of_out_functions(out_funs){
    return pp_make_formatter
            (out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
   }
   function make_formatter(output, flush){
    var
     ppf =
       pp_make_formatter
        (output,
         flush,
         function(_av_){return 0;},
         function(_au_){return 0;},
         function(_at_){return 0;});
    ppf[19] = function(_as_){return display_newline(ppf, _as_);};
    ppf[20] = function(_ar_){return display_blanks(ppf, _ar_);};
    ppf[21] = function(_aq_){return display_blanks(ppf, _aq_);};
    return ppf;
   }
   function formatter_of_out_channel(oc){
    return make_formatter
            (caml_call1(Stdlib[69], oc),
             function(param){return caml_call1(Stdlib[63], oc);});
   }
   function formatter_of_buffer(b){
    return make_formatter
            (caml_call1(Stdlib_Buffer[18], b), function(_ap_){return 0;});
   }
   var pp_buffer_size = 512;
   function pp_make_buffer(param){
    return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
   }
   var
    stdbuf = pp_make_buffer(0),
    std_formatter = formatter_of_out_channel(Stdlib[39]),
    err_formatter = formatter_of_out_channel(Stdlib[40]),
    str_formatter = formatter_of_buffer(stdbuf),
    stdbuf_key = caml_call2(Stdlib_Domain[10][1], 0, pp_make_buffer);
   caml_call2(Stdlib_Domain[10][3], stdbuf_key, stdbuf);
   var
    str_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         return formatter_of_buffer
                 (caml_call1(Stdlib_Domain[10][2], stdbuf_key));
        });
   caml_call2(Stdlib_Domain[10][3], str_formatter_key, str_formatter);
   function buffered_out_string(key, str, ofs, len){
    var _ao_ = caml_call1(Stdlib_Domain[10][2], key);
    return caml_call4(Stdlib_Buffer[18], _ao_, str, ofs, len);
   }
   function buffered_out_flush(oc, key, param){
    var
     buf = caml_call1(Stdlib_Domain[10][2], key),
     len = caml_call1(Stdlib_Buffer[7], buf),
     str = caml_call1(Stdlib_Buffer[2], buf);
    caml_call4(Stdlib[69], oc, str, 0, len);
    caml_call1(Stdlib[63], oc);
    return caml_call1(Stdlib_Buffer[8], buf);
   }
   var
    std_buf_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}),
    err_buf_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){return caml_call1(Stdlib_Buffer[1], pp_buffer_size);}),
    std_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         var
          _ac_ = Stdlib[39],
          ppf =
            pp_make_formatter
             (function(_al_, _am_, _an_){
               return buffered_out_string(std_buf_key, _al_, _am_, _an_);
              },
              function(_ak_){
               return buffered_out_flush(_ac_, std_buf_key, _ak_);
              },
              function(_aj_){return 0;},
              function(_ai_){return 0;},
              function(_ah_){return 0;});
         ppf[19] = function(_ag_){return display_newline(ppf, _ag_);};
         ppf[20] = function(_af_){return display_blanks(ppf, _af_);};
         ppf[21] = function(_ae_){return display_blanks(ppf, _ae_);};
         caml_call1
          (Stdlib_Domain[6],
           function(_ad_){return pp_print_flush(ppf, _ad_);});
         return ppf;
        });
   caml_call2(Stdlib_Domain[10][3], std_formatter_key, std_formatter);
   var
    err_formatter_key =
      caml_call2
       (Stdlib_Domain[10][1],
        0,
        function(param){
         var
          _S_ = Stdlib[40],
          ppf =
            pp_make_formatter
             (function(_$_, _aa_, _ab_){
               return buffered_out_string(err_buf_key, _$_, _aa_, _ab_);
              },
              function(___){return buffered_out_flush(_S_, err_buf_key, ___);},
              function(_Z_){return 0;},
              function(_Y_){return 0;},
              function(_X_){return 0;});
         ppf[19] = function(_W_){return display_newline(ppf, _W_);};
         ppf[20] = function(_V_){return display_blanks(ppf, _V_);};
         ppf[21] = function(_U_){return display_blanks(ppf, _U_);};
         caml_call1
          (Stdlib_Domain[6], function(_T_){return pp_print_flush(ppf, _T_);});
         return ppf;
        });
   caml_call2(Stdlib_Domain[10][3], err_formatter_key, err_formatter);
   function get_std_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], std_formatter_key);
   }
   function get_err_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], err_formatter_key);
   }
   function get_str_formatter(param){
    return caml_call1(Stdlib_Domain[10][2], str_formatter_key);
   }
   function get_stdbuf(param){
    return caml_call1(Stdlib_Domain[10][2], stdbuf_key);
   }
   function flush_buffer_formatter(buf, ppf){
    pp_flush_queue(ppf, 0);
    var s = caml_call1(Stdlib_Buffer[2], buf);
    caml_call1(Stdlib_Buffer[9], buf);
    return s;
   }
   function flush_str_formatter(param){
    var
     stdbuf = caml_call1(Stdlib_Domain[10][2], stdbuf_key),
     str_formatter = caml_call1(Stdlib_Domain[10][2], str_formatter_key);
    return flush_buffer_formatter(stdbuf, str_formatter);
   }
   function make_synchronized_formatter(output, flush){
    return caml_call2
            (Stdlib_Domain[10][1],
             0,
             function(param){
              var
               buf = caml_call1(Stdlib_Buffer[1], pp_buffer_size),
               output$0 = caml_call1(Stdlib_Buffer[18], buf);
              function flush$0(param){
               var _R_ = caml_call1(Stdlib_Buffer[7], buf);
               caml_call3(output, caml_call1(Stdlib_Buffer[2], buf), 0, _R_);
               caml_call1(Stdlib_Buffer[8], buf);
               return caml_call1(flush, 0);
              }
              return make_formatter(output$0, flush$0);
             });
   }
   function synchronized_formatter_of_out_(oc){
    return make_synchronized_formatter
            (caml_call1(Stdlib[69], oc),
             function(param){return caml_call1(Stdlib[63], oc);});
   }
   function make_symbolic_output_buffer(param){return [0, 0];}
   function clear_symbolic_output_buffer(sob){sob[1] = 0; return 0;}
   function get_symbolic_output_buffer(sob){
    return caml_call1(Stdlib_List[10], sob[1]);
   }
   function flush_symbolic_output_buffer(sob){
    var items = get_symbolic_output_buffer(sob);
    clear_symbolic_output_buffer(sob);
    return items;
   }
   function add_symbolic_output_item(sob, item){sob[1] = [0, item, sob[1]]; return 0;
   }
   function formatter_of_symbolic_output_b(sob){
    function f(s, i, n){
     return add_symbolic_output_item
             (sob, [0, caml_call3(Stdlib_String[16], s, i, n)]);
    }
    function g(_Q_){return add_symbolic_output_item(sob, 0);}
    function h(_P_){return add_symbolic_output_item(sob, 1);}
    function i(n){return add_symbolic_output_item(sob, [1, n]);}
    function j(n){return add_symbolic_output_item(sob, [2, n]);}
    return pp_make_formatter(f, g, h, i, j);
   }
   function open_hbox(v){
    return pp_open_hbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_vbox(v){
    return pp_open_vbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hvbox(v){
    return pp_open_hvbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_hovbox(v){
    return pp_open_hovbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_box(v){
    return pp_open_box(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_box(v){
    return pp_close_box
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_stag(v){
    return pp_open_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_stag(v){
    return pp_close_stag
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_as(isize, w){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return pp_print_as_size(state, isize, w);
   }
   function print_string(v){
    return pp_print_string
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bytes(v){
    return pp_print_bytes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_int(v){
    return pp_print_int
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_float(v){
    return pp_print_float
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_char(v){
    return pp_print_char
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_bool(v){
    return pp_print_bool
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_break(v, w){
    return pp_print_break
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function print_cut(v){
    return pp_print_cut
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_space(v){
    return pp_print_space
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function force_newline(v){
    return pp_force_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_flush(v){
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_newline(v){
    return pp_print_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_if_newline(v){
    return pp_print_if_newline
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function open_tbox(v){
    return pp_open_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function close_tbox(v){
    return pp_close_tbox
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tbreak(v, w){
    return pp_print_tbreak
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function set_tab(v){
    return pp_set_tab(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function print_tab(v){
    return pp_print_tab
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_margin(v){
    return pp_set_margin
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_margin(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[6];
   }
   function set_max_indent(v){
    return pp_set_max_indent
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_indent(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[8];
   }
   function set_geometry(max_indent, margin){
    return pp_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function safe_set_geometry(max_indent, margin){
    return pp_safe_set_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key),
             max_indent,
             margin);
   }
   function get_geometry(v){
    return pp_get_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function update_geometry(v){
    return pp_update_geometry
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_max_boxes(v){
    return pp_set_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_max_boxes(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[15];
   }
   function over_max_boxes(v){
    return pp_over_max_boxes
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_ellipsis_text(v){
    return pp_set_ellipsis_text
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_ellipsis_text(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[16];
   }
   function set_formatter_out_channel(v){
    return pp_set_formatter_out_channel
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_out_functions(v){
    return pp_set_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_out_functions(v){
    return pp_get_formatter_out_functions
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_output_functions(v, w){
    return pp_set_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
   }
   function get_formatter_output_functions(v){
    return pp_get_formatter_output_functi
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_formatter_stag_functions(v){
    return pp_set_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_formatter_stag_functions(v){
    return pp_get_formatter_stag_function
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function set_print_tags(v){
    return pp_set_print_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_print_tags(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[22];
   }
   function set_mark_tags(v){
    return pp_set_mark_tags
            (caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function get_mark_tags(v){
    var state = caml_call1(Stdlib_Domain[10][2], std_formatter_key);
    return state[23];
   }
   function set_tags(v){
    return pp_set_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
   }
   function pp_print_iter(opt, iter, pp_v, ppf, v){
    var pp_sep = opt ? opt[1] : pp_print_cut, is_first = [0, 1];
    function pp_v$0(v){
     if(is_first[1]) is_first[1] = 0; else caml_call2(pp_sep, ppf, 0);
     return caml_call2(pp_v, ppf, v);
    }
    return caml_call2(iter, pp_v$0, v);
   }
   function pp_print_list(opt, pp_v, ppf, v){
    var pp_sep = opt ? opt[1] : pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_List[18], pp_v, ppf, v);
   }
   function pp_print_array(opt, pp_v, ppf, v){
    var pp_sep = opt ? opt[1] : pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Array[12], pp_v, ppf, v);
   }
   function pp_print_seq(opt, pp_v, ppf, seq){
    var pp_sep = opt ? opt[1] : pp_print_cut;
    return pp_print_iter([0, pp_sep], Stdlib_Seq[4], pp_v, ppf, seq);
   }
   function pp_print_text(ppf, s){
    var len = caml_ml_string_length(s), left = [0, 0], right = [0, 0];
    function flush(param){
     pp_print_string
      (ppf, caml_call3(Stdlib_String[16], s, left[1], right[1] - left[1] | 0));
     right[1]++;
     left[1] = right[1];
     return 0;
    }
    for(;;){
     if(right[1] === len){
      var _O_ = left[1] !== len ? 1 : 0;
      return _O_ ? flush(0) : _O_;
     }
     var match = runtime.caml_string_get(s, right[1]);
     if(10 === match){
      flush(0);
      pp_force_newline(ppf, 0);
     }
     else if(32 === match){flush(0); pp_print_space(ppf, 0);} else right[1]++;
    }
   }
   function pp_print_option(opt, pp_v, ppf, param){
    var none = opt ? opt[1] : function(_N_, param){return 0;};
    if(! param) return caml_call2(none, ppf, 0);
    var v = param[1];
    return caml_call2(pp_v, ppf, v);
   }
   function pp_print_result(ok, error, ppf, param){
    if(0 === param[0]){var v = param[1]; return caml_call2(ok, ppf, v);}
    var e = param[1];
    return caml_call2(error, ppf, e);
   }
   function pp_print_either(left, right, ppf, param){
    if(0 === param[0]){var l = param[1]; return caml_call2(left, ppf, l);}
    var r = param[1];
    return caml_call2(right, ppf, r);
   }
   function compute_tag(output, tag_acc){
    var
     buf = caml_call1(Stdlib_Buffer[1], 16),
     ppf = formatter_of_buffer(buf);
    caml_call2(output, ppf, tag_acc);
    pp_print_flush(ppf, 0);
    var len = caml_call1(Stdlib_Buffer[7], buf);
    return 2 <= len
            ? caml_call3(Stdlib_Buffer[4], buf, 1, len - 2 | 0)
            : caml_call1(Stdlib_Buffer[2], buf);
   }
   function output_formatting_lit(ppf, fmting_lit){
    if(typeof fmting_lit === "number")
     switch(fmting_lit){
       case 0:
        return pp_close_box(ppf, 0);
       case 1:
        return pp_close_stag(ppf, 0);
       case 2:
        return pp_print_flush(ppf, 0);
       case 3:
        return pp_force_newline(ppf, 0);
       case 4:
        return pp_print_newline(ppf, 0);
       case 5:
        return pp_print_char(ppf, 64);
       default: return pp_print_char(ppf, 37);
     }
    switch(fmting_lit[0]){
      case 0:
       var offset = fmting_lit[3], width = fmting_lit[2];
       return pp_print_break(ppf, width, offset);
      case 1:
       return 0;
      default:
       var c = fmting_lit[1];
       pp_print_char(ppf, 64);
       return pp_print_char(ppf, c);
    }
   }
   function output_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          output_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           output_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
          }
          var acc$1 = match[1];
          output_acc(ppf, p$0);
          var
           _E_ = compute_tag(output_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _E_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _F_ = acc[1];
          if(typeof _F_ !== "number" && 0 === _F_[0]){
           var _G_ = _F_[2];
           if(typeof _G_ !== "number" && 1 === _G_[0]){
            var s$0 = acc[2], size = _G_[2], p$2 = _F_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _F_;
          break a;
         case 3:
          var _H_ = acc[1];
          if(typeof _H_ !== "number" && 0 === _H_[0]){
           var _I_ = _H_[2];
           if(typeof _I_ !== "number" && 1 === _I_[0]){
            var c$0 = acc[2], size$0 = _I_[2], p$4 = _H_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _H_;
          break c;
         case 4:
          var _J_ = acc[1];
          if(typeof _J_ !== "number" && 0 === _J_[0]){
           var _K_ = _J_[2];
           if(typeof _K_ !== "number" && 1 === _K_[0]){
            var s$0 = acc[2], size = _K_[2], p$2 = _J_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _J_;
          break a;
         case 5:
          var _L_ = acc[1];
          if(typeof _L_ !== "number" && 0 === _L_[0]){
           var _M_ = _L_[2];
           if(typeof _M_ !== "number" && 1 === _M_[0]){
            var c$0 = acc[2], size$0 = _M_[2], p$4 = _L_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _L_;
          break c;
         case 6:
          var f$0 = acc[2], p$5 = acc[1];
          output_acc(ppf, p$5);
          return caml_call1(f$0, ppf);
         case 7:
          var p$6 = acc[1];
          output_acc(ppf, p$6);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$7 = acc[1];
          output_acc(ppf, p$7);
          return caml_call1(Stdlib[1], msg);
       }
       output_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      output_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     output_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    output_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function strput_acc(ppf, acc){
    if(typeof acc === "number") return 0;
    a:
    {
     b:
     {
      c:
      {
       switch(acc[0]){
         case 0:
          var f = acc[2], p = acc[1];
          strput_acc(ppf, p);
          return output_formatting_lit(ppf, f);
         case 1:
          var match = acc[2], p$0 = acc[1];
          if(0 === match[0]){
           var acc$0 = match[1];
           strput_acc(ppf, p$0);
           return pp_open_stag
                   (ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
          }
          var acc$1 = match[1];
          strput_acc(ppf, p$0);
          var
           _v_ = compute_tag(strput_acc, acc$1),
           match$0 = caml_call1(CamlinternalFormat[20], _v_),
           bty = match$0[2],
           indent = match$0[1];
          return pp_open_box_gen(ppf, indent, bty);
         case 2:
          var _w_ = acc[1];
          if(typeof _w_ !== "number" && 0 === _w_[0]){
           var _x_ = _w_[2];
           if(typeof _x_ !== "number" && 1 === _x_[0]){
            var s$0 = acc[2], size = _x_[2], p$2 = _w_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _w_;
          break a;
         case 3:
          var _y_ = acc[1];
          if(typeof _y_ !== "number" && 0 === _y_[0]){
           var _z_ = _y_[2];
           if(typeof _z_ !== "number" && 1 === _z_[0]){
            var c$0 = acc[2], size$0 = _z_[2], p$4 = _y_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _y_;
          break c;
         case 4:
          var _A_ = acc[1];
          if(typeof _A_ !== "number" && 0 === _A_[0]){
           var _B_ = _A_[2];
           if(typeof _B_ !== "number" && 1 === _B_[0]){
            var s$0 = acc[2], size = _B_[2], p$2 = _A_[1];
            break b;
           }
          }
          var s = acc[2], p$1 = _A_;
          break a;
         case 5:
          var _C_ = acc[1];
          if(typeof _C_ !== "number" && 0 === _C_[0]){
           var _D_ = _C_[2];
           if(typeof _D_ !== "number" && 1 === _D_[0]){
            var c$0 = acc[2], size$0 = _D_[2], p$4 = _C_[1];
            break;
           }
          }
          var c = acc[2], p$3 = _C_;
          break c;
         case 6:
          var p$5 = acc[1];
          if(typeof p$5 !== "number" && 0 === p$5[0]){
           var match$1 = p$5[2];
           if(typeof match$1 !== "number" && 1 === match$1[0]){
            var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
            strput_acc(ppf, p$6);
            return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
           }
          }
          var f$0 = acc[2];
          strput_acc(ppf, p$5);
          return pp_print_string(ppf, caml_call1(f$0, 0));
         case 7:
          var p$7 = acc[1];
          strput_acc(ppf, p$7);
          return pp_print_flush(ppf, 0);
         default:
          var msg = acc[2], p$8 = acc[1];
          strput_acc(ppf, p$8);
          return caml_call1(Stdlib[1], msg);
       }
       strput_acc(ppf, p$4);
       return pp_print_as_size
               (ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
      }
      strput_acc(ppf, p$3);
      return pp_print_char(ppf, c);
     }
     strput_acc(ppf, p$2);
     return pp_print_as_size(ppf, size, s$0);
    }
    strput_acc(ppf, p$1);
    return pp_print_string(ppf, s);
   }
   function kfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){output_acc(ppf, acc); return caml_call1(k, ppf);},
             0,
             fmt);
   }
   function ikfprintf(k, ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], k, ppf, fmt);
   }
   function ifprintf(ppf, param){
    var fmt = param[1];
    return caml_call3(CamlinternalFormat[8], function(_u_){return 0;}, 0, fmt);
   }
   function fprintf(ppf){
    function _r_(_t_){return 0;}
    return function(_s_){return kfprintf(_r_, ppf, _s_);};
   }
   function printf(param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return output_acc
                      (caml_call1(Stdlib_Domain[10][2], std_formatter_key), acc);
             },
             0,
             fmt);
   }
   function eprintf(param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return output_acc
                      (caml_call1(Stdlib_Domain[10][2], err_formatter_key), acc);
             },
             0,
             fmt);
   }
   function kdprintf(k, param){
    var fmt = param[1];
    return caml_call3
            (CamlinternalFormat[7],
             function(acc){
              return caml_call1
                      (k, function(ppf){return output_acc(ppf, acc);});
             },
             0,
             fmt);
   }
   function dprintf(fmt){return kdprintf(function(i){return i;}, fmt);}
   function ksprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     strput_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function sprintf(fmt){return ksprintf(id, fmt);}
   function kasprintf(k, param){
    var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
    function k$0(acc){
     output_acc(ppf, acc);
     return caml_call1(k, flush_buffer_formatter(b, ppf));
    }
    return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
   }
   function asprintf(fmt){return kasprintf(id, fmt);}
   function flush_standard_formatters(param){
    pp_print_flush(caml_call1(Stdlib_Domain[10][2], std_formatter_key), 0);
    return pp_print_flush
            (caml_call1(Stdlib_Domain[10][2], err_formatter_key), 0);
   }
   caml_call1(Stdlib[100], flush_standard_formatters);
   caml_call1
    (Stdlib_Domain[5],
     function(param){
      flush_standard_formatters(0);
      var
       fs = pp_get_formatter_out_functions(std_formatter, 0),
       _h_ = Stdlib[39];
      pp_set_formatter_out_functions
       (std_formatter,
        [0,
         function(_o_, _p_, _q_){
          return buffered_out_string(std_buf_key, _o_, _p_, _q_);
         },
         function(_n_){return buffered_out_flush(_h_, std_buf_key, _n_);},
         fs[3],
         fs[4],
         fs[5]]);
      var
       fs$0 = pp_get_formatter_out_functions(err_formatter, 0),
       _i_ = Stdlib[40];
      return pp_set_formatter_out_functions
              (err_formatter,
               [0,
                function(_k_, _l_, _m_){
                 return buffered_out_string(err_buf_key, _k_, _l_, _m_);
                },
                function(_j_){
                 return buffered_out_flush(_i_, err_buf_key, _j_);
                },
                fs$0[3],
                fs$0[4],
                fs$0[5]]);
     });
   var
    Stdlib_Format =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_nothing,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_infinity,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       synchronized_formatter_of_out_,
       std_formatter,
       get_std_formatter,
       err_formatter,
       get_err_formatter,
       formatter_of_buffer,
       stdbuf,
       get_stdbuf,
       str_formatter,
       get_str_formatter,
       flush_str_formatter,
       make_formatter,
       make_synchronized_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_iter,
       pp_print_list,
       pp_print_array,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf];
   runtime.caml_register_global(38, Stdlib_Format, "Stdlib__Format");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Scanf
//# unitInfo: Requires: CamlinternalFormat, CamlinternalFormatBasics, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Int, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = '"',
    cst$6 = "-",
    cst_character = "character ",
    cst_scanf_ml = "scanf.ml",
    cst_scanf_bad_conversion$3 = 'scanf: bad conversion "%*"',
    cst_scanning_of = "scanning of ",
    caml_bytes_get = runtime.caml_bytes_get,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$5,
    cst$4 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    cst$0 = cst$5,
    cst_not_a_valid_float_in_hexad =
      "not a valid float in hexadecimal notation",
    cst_no_dot_or_exponent_part_fo =
      "no dot or exponent part found in float token",
    cst = cst$6,
    cst_binary = "binary",
    cst_octal = "octal",
    cst_hexadecimal = "hexadecimal",
    cst_a_Char = "a Char",
    cst_a_String = "a String",
    CamlinternalFormat = global_data.CamlinternalFormat,
    CamlinternalFormatBasics = global_data.CamlinternalFormatBasics,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    null_char = 0,
    cst_unnamed_function = "unnamed function",
    cst_unnamed_character_string = "unnamed character string",
    cst_unnamed_Stdlib_input_chann = "unnamed Stdlib input channel";
   function next_char(ib){
    try{
     var c = caml_call1(ib[7], 0);
     ib[2] = c;
     ib[3] = 1;
     ib[4] = ib[4] + 1 | 0;
     if(10 === c) ib[5] = ib[5] + 1 | 0;
     return c;
    }
    catch(_aY_){
     var _aX_ = caml_wrap_exception(_aY_);
     if(_aX_ !== Stdlib[12]) throw caml_maybe_attach_backtrace(_aX_, 0);
     ib[2] = null_char;
     ib[3] = 0;
     ib[1] = 1;
     return null_char;
    }
   }
   function peek_char(ib){return ib[3] ? ib[2] : next_char(ib);}
   function checked_peek_char(ib){
    var c = peek_char(ib);
    if(ib[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
    return c;
   }
   function end_of_input(ib){peek_char(ib); return ib[1];}
   function beginning_of_input(ib){return 0 === ib[4] ? 1 : 0;}
   function name_of_input(ib){
    var match = ib[9];
    if(typeof match === "number")
     return 0 === match ? cst_unnamed_function : cst_unnamed_character_string;
    if(0 === match[0]) return cst_unnamed_Stdlib_input_chann;
    var fname = match[1];
    return fname;
   }
   function char_count(ib){return ib[3] ? ib[4] - 1 | 0 : ib[4];}
   function invalidate_current_char(ib){ib[3] = 0; return 0;}
   function token_string(ib){
    var
     token_buffer = ib[8],
     tok = caml_call1(Stdlib_Buffer[2], token_buffer);
    caml_call1(Stdlib_Buffer[8], token_buffer);
    ib[6] = ib[6] + 1 | 0;
    return tok;
   }
   function ignore_char(width, ib){
    var width$0 = width - 1 | 0;
    invalidate_current_char(ib);
    return width$0;
   }
   function store_char(width, ib, c){
    caml_call2(Stdlib_Buffer[12], ib[8], c);
    return ignore_char(width, ib);
   }
   var default_token_buffer_size = 1024;
   function create(iname, next){
    return [0,
            0,
            null_char,
            0,
            0,
            0,
            0,
            next,
            caml_call1(Stdlib_Buffer[1], default_token_buffer_size),
            iname];
   }
   function from_string(s){
    var i = [0, 0], len = caml_ml_string_length(s);
    function next(param){
     if(len <= i[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     var c = caml_string_get(s, i[1]);
     i[1]++;
     return c;
    }
    return create(1, next);
   }
   var _a_ = 0;
   function from_function(_aW_){return create(_a_, _aW_);}
   var len = 1024;
   function scan_close_at_end(ic){
    caml_call1(Stdlib[93], ic);
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function scan_raise_at_end(ic){
    throw caml_maybe_attach_backtrace(Stdlib[12], 1);
   }
   function from_ic(scan_close_ic, iname, ic){
    var
     buf = runtime.caml_create_bytes(1024),
     i = [0, 0],
     lim = [0, 0],
     eof = [0, 0];
    function next(param){
     if(i[1] < lim[1]){var c = caml_bytes_get(buf, i[1]); i[1]++; return c;}
     if(eof[1]) throw caml_maybe_attach_backtrace(Stdlib[12], 1);
     lim[1] = caml_call4(Stdlib[84], ic, buf, 0, len);
     return 0 === lim[1]
             ? (eof[1] = 1, caml_call1(scan_close_ic, ic))
             : (i[1] = 1, caml_bytes_get(buf, 0));
    }
    return create(iname, next);
   }
   var stdin = from_ic(scan_raise_at_end, [1, cst, Stdlib[38]], Stdlib[38]);
   function open_in_file(open_in, fname){
    if(fname === cst$6) return stdin;
    var ic = caml_call1(open_in, fname);
    return from_ic(scan_close_at_end, [1, fname, ic], ic);
   }
   var _b_ = Stdlib[79];
   function open_in(_aV_){return open_in_file(_b_, _aV_);}
   var _c_ = Stdlib[80];
   function open_in_bin(_aU_){return open_in_file(_c_, _aU_);}
   function from_channel(ic){return from_ic(scan_raise_at_end, [0, ic], ic);}
   function close_in(ib){
    var match = ib[9];
    if(typeof match === "number") return 0;
    if(0 === match[0]){var ic = match[1]; return caml_call1(Stdlib[93], ic);}
    var ic$0 = match[2];
    return caml_call1(Stdlib[93], ic$0);
   }
   var
    Scan_failure =
      [248, "Stdlib.Scanf.Scan_failure", runtime.caml_fresh_oo_id(0)],
    _d_ =
      [0,
       [11, "illegal escape character ", [1, 0]],
       "illegal escape character %C"],
    _e_ =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11, " failed: the specified length was too short for token", 0]]],
       "scanning of %s failed: the specified length was too short for token"],
    _f_ =
      [0,
       [11,
        cst_scanning_of,
        [2,
         0,
         [11,
          " failed: premature end of file occurred before end of token",
          0]]],
       "scanning of %s failed: premature end of file occurred before end of token"],
    _g_ =
      [0,
       [11, "looking for ", [1, [11, ", found ", [1, 0]]]],
       "looking for %C, found %C"],
    _h_ =
      [0,
       [11, "invalid boolean '", [2, 0, [12, 39, 0]]],
       "invalid boolean '%s'"],
    _i_ = [0, cst_scanf_ml, 516, 9],
    cst_0b = "0b",
    cst_0o = "0o",
    cst_0u = "0u",
    cst_0x = "0x",
    cst_decimal_digits = "decimal digits",
    _j_ =
      [0,
       [11, cst_character, [1, [11, " is not a decimal digit", 0]]],
       "character %C is not a decimal digit"],
    cst_digits = "digits",
    _k_ =
      [0,
       [11,
        cst_character,
        [1, [11, " is not a valid ", [2, 0, [11, " digit", 0]]]]],
       "character %C is not a valid %s digit"],
    cst_an = "an",
    cst_nfinity = "nfinity",
    cst_x = "x",
    _l_ =
      [0,
       [11, "bad character decimal encoding \\", [0, [0, [0, 0]]]],
       "bad character decimal encoding \\%c%c%c"],
    _m_ =
      [0,
       [11, "bad character hexadecimal encoding \\", [0, [0, 0]]],
       "bad character hexadecimal encoding \\%c%c"],
    _n_ =
      [0,
       [11, "the character ", [1, [11, " cannot start a boolean", 0]]],
       "the character %C cannot start a boolean"],
    _o_ =
      [0,
       [11,
        "scanf: bad input at char number ",
        [4, 3, 0, 0, [11, ": ", [2, 0, 0]]]],
       "scanf: bad input at char number %i: %s"],
    _p_ = [0, 37, ""],
    _q_ = [0, 123],
    _r_ = [0, 91],
    cst_end_of_input_not_found = "end of input not found",
    cst_scanf_bad_conversion_a = 'scanf: bad conversion "%a"',
    cst_scanf_bad_conversion_t = 'scanf: bad conversion "%t"',
    cst_scanf_missing_reader = "scanf: missing reader",
    _s_ = [0, cst_scanf_ml, 1414, 13],
    cst_scanf_bad_conversion_custo =
      'scanf: bad conversion "%?" (custom converter)',
    cst_scanf_bad_conversion = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$0 = cst_scanf_bad_conversion$3,
    cst_scanf_bad_conversion$1 = 'scanf: bad conversion "%-"',
    cst_scanf_bad_conversion$2 = cst_scanf_bad_conversion$3,
    cst_in_format = ' in format "',
    _t_ = [0, [3, 0, [10, 0]], "%S%!"];
   function bad_input(s){
    throw caml_maybe_attach_backtrace([0, Scan_failure, s], 1);
   }
   function bad_input_escape(c){
    return bad_input(caml_call2(Stdlib_Printf[4], _d_, c));
   }
   function bad_token_length(message){
    return bad_input(caml_call2(Stdlib_Printf[4], _e_, message));
   }
   function bad_hex_float(param){
    return bad_input(cst_not_a_valid_float_in_hexad);
   }
   function character_mismatch(c, ci){
    return bad_input(caml_call3(Stdlib_Printf[4], _g_, c, ci));
   }
   function check_char(ib, c$0){
    if(10 === c$0){
     var ci = checked_peek_char(ib);
     return 10 === ci
             ? invalidate_current_char(ib)
             : 13
               === ci
               ? (invalidate_current_char(ib), check_this_char(ib, 10))
               : character_mismatch(10, ci);
    }
    if(32 !== c$0) return check_this_char(ib, c$0);
    for(;;){
     var c = peek_char(ib), _aS_ = 1 - ib[1];
     if(! _aS_) return _aS_;
     var _aT_ = c - 9 | 0;
     a:
     {
      if(4 < _aT_ >>> 0){
       if(23 === _aT_) break a;
      }
      else if(1 < _aT_ - 2 >>> 0) break a;
      return 0;
     }
     invalidate_current_char(ib);
    }
   }
   function check_this_char(ib, c){
    var ci = checked_peek_char(ib);
    return ci === c ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function token_char(ib){return caml_string_get(token_string(ib), 0);}
   function token_bool(ib){
    var s = token_string(ib);
    return s !== "false"
            ? s
              !== "true"
              ? bad_input(caml_call2(Stdlib_Printf[4], _h_, s))
              : 1
            : 0;
   }
   function integer_conversion_of_char(param){
    var switcher = param - 88 | 0;
    if(32 >= switcher >>> 0)
     switch(switcher){
       case 10:
        return 0;
       case 12:
        return 1;
       case 17:
        return 2;
       case 23:
        return 3;
       case 29:
        return 4;
       case 0:
       case 32:
        return 5;
     }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   function token_int_literal(conv, ib){
    switch(conv){
      case 0:
       var
        _aO_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0b, _aO_);
       break;
      case 3:
       var
        _aP_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0o, _aP_);
       break;
      case 4:
       var
        _aQ_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0u, _aQ_);
       break;
      case 5:
       var
        _aR_ = token_string(ib),
        tok = caml_call2(Stdlib[28], cst_0x, _aR_);
       break;
      default: var tok = token_string(ib);
    }
    var l = caml_ml_string_length(tok);
    if(0 !== l && 43 === caml_string_get(tok, 0))
     return caml_call3(Stdlib_String[16], tok, 1, l - 1 | 0);
    return tok;
   }
   function token_float(ib){
    return runtime.caml_float_of_string(token_string(ib));
   }
   function scan_decimal_digit_star(width, ib){
    var width$0 = width;
    for(;;){
     if(0 === width$0) return width$0;
     var c = peek_char(ib);
     if(ib[1]) return width$0;
     if(58 <= c){
      if(95 === c){
       var width$1 = ignore_char(width$0, ib);
       width$0 = width$1;
       continue;
      }
     }
     else if(48 <= c){
      var width$2 = store_char(width$0, ib, c);
      width$0 = width$2;
      continue;
     }
     return width$0;
    }
   }
   function scan_decimal_digit_plus(width, ib){
    if(0 === width) return bad_token_length(cst_decimal_digits);
    var c = checked_peek_char(ib);
    if(9 < c - 48 >>> 0)
     return bad_input(caml_call2(Stdlib_Printf[4], _j_, c));
    var width$0 = store_char(width, ib, c);
    return scan_decimal_digit_star(width$0, ib);
   }
   function scan_digit_plus(basis, digitp, width$2, ib){
    if(0 === width$2) return bad_token_length(cst_digits);
    var c$0 = checked_peek_char(ib);
    if(! caml_call1(digitp, c$0))
     return bad_input(caml_call3(Stdlib_Printf[4], _k_, c$0, basis));
    var width$3 = store_char(width$2, ib, c$0), width = width$3;
    for(;;){
     if(0 === width) return width;
     var c = peek_char(ib);
     if(ib[1]) return width;
     if(caml_call1(digitp, c)){
      var width$0 = store_char(width, ib, c);
      width = width$0;
     }
     else{
      if(95 !== c) return width;
      var width$1 = ignore_char(width, ib);
      width = width$1;
     }
    }
   }
   function is_binary_digit(param){return 1 < param - 48 >>> 0 ? 0 : 1;}
   function is_octal_digit(param){return 7 < param - 48 >>> 0 ? 0 : 1;}
   function is_hexa_digit(param){
    var _aN_ = param - 48 | 0;
    a:
    {
     if(22 < _aN_ >>> 0){
      if(5 < _aN_ - 49 >>> 0) break a;
     }
     else if(6 >= _aN_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function scan_sign(width, ib){
    var c = checked_peek_char(ib), switcher = c - 43 | 0;
    if(2 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return store_char(width, ib, c);
       case 1: break;
       default: return store_char(width, ib, c);
     }
    return width;
   }
   function scan_optionally_signed_decimal(width, ib){
    var width$0 = scan_sign(width, ib);
    return scan_decimal_digit_plus(width$0, ib);
   }
   function scan_int_conversion(conv, width$1, ib){
    switch(conv){
      case 0:
       return scan_digit_plus(cst_binary, is_binary_digit, width$1, ib);
      case 1:
       return scan_optionally_signed_decimal(width$1, ib);
      case 2:
       var width$0 = scan_sign(width$1, ib), c = checked_peek_char(ib);
       if(48 !== c) return scan_decimal_digit_plus(width$0, ib);
       var width = store_char(width$0, ib, c);
       if(0 === width) return width;
       var c$0 = peek_char(ib);
       if(ib[1]) return width;
       a:
       {
        if(99 <= c$0){
         if(111 === c$0)
          return scan_digit_plus
                  (cst_octal, is_octal_digit, store_char(width, ib, c$0), ib);
         if(120 === c$0) break a;
        }
        else{
         if(88 === c$0) break a;
         if(98 <= c$0)
          return scan_digit_plus
                  (cst_binary,
                   is_binary_digit,
                   store_char(width, ib, c$0),
                   ib);
        }
        return scan_decimal_digit_star(width, ib);
       }
       return scan_digit_plus
               (cst_hexadecimal,
                is_hexa_digit,
                store_char(width, ib, c$0),
                ib);
      case 3:
       return scan_digit_plus(cst_octal, is_octal_digit, width$1, ib);
      case 4:
       return scan_decimal_digit_plus(width$1, ib);
      default:
       return scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$1, ib);
    }
   }
   function scan_fractional_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    return ib[1]
            ? width
            : 9
              < c - 48 >>> 0
              ? width
              : scan_decimal_digit_star(store_char(width, ib, c), ib);
   }
   function scan_exponent_part(width, ib){
    if(0 === width) return width;
    var c = peek_char(ib);
    if(ib[1]) return width;
    if(69 !== c && 101 !== c) return width;
    return scan_optionally_signed_decimal(store_char(width, ib, c), ib);
   }
   function scan_float(width$1, precision, ib){
    var
     width = scan_sign(width$1, ib),
     width$0 = scan_decimal_digit_star(width, ib);
    if(0 === width$0) return [0, width$0, precision];
    var c = peek_char(ib);
    if(ib[1]) return [0, width$0, precision];
    if(46 !== c) return [0, scan_exponent_part(width$0, ib), precision];
    var
     width$2 = store_char(width$0, ib, c),
     precision$0 = caml_call2(Stdlib_Int[10], width$2, precision),
     width$3 =
       width$2 - (precision$0 - scan_fractional_part(precision$0, ib) | 0) | 0;
    return [0, scan_exponent_part(width$3, ib), precision$0];
   }
   function check_case_insensitive_string(width, ib, error, str){
    function lowercase(c){
     return 25 < c - 65 >>> 0
             ? c
             : caml_call1(Stdlib[29], (c - 65 | 0) + 97 | 0);
    }
    var
     len = caml_ml_string_length(str),
     width$0 = [0, width],
     _aK_ = len - 1 | 0,
     _aJ_ = 0;
    if(_aK_ >= 0){
     var i = _aJ_;
     for(;;){
      var c = peek_char(ib), _aL_ = lowercase(caml_string_get(str, i));
      if(lowercase(c) !== _aL_) caml_call1(error, 0);
      if(0 === width$0[1]) caml_call1(error, 0);
      width$0[1] = store_char(width$0[1], ib, c);
      var _aM_ = i + 1 | 0;
      if(_aK_ === i) break;
      i = _aM_;
     }
    }
    return width$0[1];
   }
   function scan_hex_float(width, precision, ib){
    var _aw_ = 0 === width ? 1 : 0, _ax_ = _aw_ || end_of_input(ib);
    if(_ax_) bad_input(cst_not_a_valid_float_in_hexad);
    var
     width$0 = scan_sign(width, ib),
     _ay_ = 0 === width$0 ? 1 : 0,
     _az_ = _ay_ || end_of_input(ib);
    if(_az_) bad_input(cst_not_a_valid_float_in_hexad);
    var c = peek_char(ib);
    a:
    {
     if(78 <= c){
      var switcher = c - 79 | 0;
      if(30 < switcher >>> 0){
       if(32 <= switcher) break a;
       var
        width$1 = store_char(width$0, ib, c),
        _aA_ = 0 === width$1 ? 1 : 0,
        _aB_ = _aA_ || end_of_input(ib);
       if(_aB_) bad_input(cst_not_a_valid_float_in_hexad);
       return check_case_insensitive_string
               (width$1, ib, bad_hex_float, cst_an);
      }
      if(26 !== switcher) break a;
     }
     else{
      if(48 === c){
       var
        width$3 = store_char(width$0, ib, c),
        _aE_ = 0 === width$3 ? 1 : 0,
        _aF_ = _aE_ || end_of_input(ib);
       if(_aF_) bad_input(cst_not_a_valid_float_in_hexad);
       var
        width$4 =
          check_case_insensitive_string(width$3, ib, bad_hex_float, cst_x);
       if(0 !== width$4 && ! end_of_input(ib)){
        var _aG_ = peek_char(ib) - 46 | 0;
        b:
        {
         c:
         {
          if(34 < _aG_ >>> 0){
           if(66 === _aG_) break c;
          }
          else if(32 < _aG_ - 1 >>> 0) break c;
          var
           width$5 =
             scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$4, ib);
          break b;
         }
         var width$5 = width$4;
        }
        if(0 !== width$5 && ! end_of_input(ib)){
         var c$0 = peek_char(ib);
         if(46 === c$0){
          var width$6 = store_char(width$5, ib, c$0);
          b:
          {
           if(0 !== width$6 && ! end_of_input(ib)){
            var match = peek_char(ib);
            c:
            {
             if(80 !== match && 112 !== match){
              var
               precision$0 = caml_call2(Stdlib_Int[10], width$6, precision),
               width$10 =
                 width$6
                 -
                  (precision$0
                  -
                   scan_digit_plus
                    (cst_hexadecimal, is_hexa_digit, precision$0, ib)
                  | 0)
                 | 0;
              break c;
             }
             var width$10 = width$6;
            }
            var width$7 = width$10;
            break b;
           }
           var width$7 = width$6;
          }
          var width$8 = width$7;
         }
         else
          var width$8 = width$5;
         if(0 !== width$8 && ! end_of_input(ib)){
          var c$1 = peek_char(ib);
          if(80 !== c$1 && 112 !== c$1) return width$8;
          var
           width$9 = store_char(width$8, ib, c$1),
           _aH_ = 0 === width$9 ? 1 : 0,
           _aI_ = _aH_ || end_of_input(ib);
          if(_aI_) bad_input(cst_not_a_valid_float_in_hexad);
          return scan_optionally_signed_decimal(width$9, ib);
         }
         return width$8;
        }
        return width$5;
       }
       return width$4;
      }
      if(73 !== c) break a;
     }
     var
      width$2 = store_char(width$0, ib, c),
      _aC_ = 0 === width$2 ? 1 : 0,
      _aD_ = _aC_ || end_of_input(ib);
     if(_aD_) bad_input(cst_not_a_valid_float_in_hexad);
     return check_case_insensitive_string
             (width$2, ib, bad_hex_float, cst_nfinity);
    }
    return bad_input(cst_not_a_valid_float_in_hexad);
   }
   function scan_caml_float_rest(width, precision, ib){
    var _as_ = 0 === width ? 1 : 0, _at_ = _as_ || end_of_input(ib);
    if(_at_) bad_input(cst_no_dot_or_exponent_part_fo);
    var
     width$0 = scan_decimal_digit_star(width, ib),
     _au_ = 0 === width$0 ? 1 : 0,
     _av_ = _au_ || end_of_input(ib);
    if(_av_) bad_input(cst_no_dot_or_exponent_part_fo);
    var c = peek_char(ib), switcher = c - 69 | 0;
    if(32 < switcher >>> 0){
     if(-23 === switcher){
      var
       width$1 = store_char(width$0, ib, c),
       precision$0 = caml_call2(Stdlib_Int[10], width$1, precision),
       width_precision = scan_fractional_part(precision$0, ib),
       frac_width = precision$0 - width_precision | 0,
       width$2 = width$1 - frac_width | 0;
      return scan_exponent_part(width$2, ib);
     }
    }
    else if(30 < switcher - 1 >>> 0) return scan_exponent_part(width$0, ib);
    return bad_input(cst_no_dot_or_exponent_part_fo);
   }
   function scan_caml_float(width, precision, ib){
    var _ae_ = 0 === width ? 1 : 0, _af_ = _ae_ || end_of_input(ib);
    if(_af_) bad_input(cst_no_dot_or_exponent_part_fo);
    var
     width$0 = scan_sign(width, ib),
     _ag_ = 0 === width$0 ? 1 : 0,
     _ah_ = _ag_ || end_of_input(ib);
    if(_ah_) bad_input(cst_no_dot_or_exponent_part_fo);
    var c = peek_char(ib);
    if(49 <= c){
     if(58 > c){
      var
       width$1 = store_char(width$0, ib, c),
       _ai_ = 0 === width$1 ? 1 : 0,
       _aj_ = _ai_ || end_of_input(ib);
      if(_aj_) bad_input(cst_no_dot_or_exponent_part_fo);
      return scan_caml_float_rest(width$1, precision, ib);
     }
    }
    else if(48 <= c){
     var
      width$2 = store_char(width$0, ib, c),
      _ak_ = 0 === width$2 ? 1 : 0,
      _al_ = _ak_ || end_of_input(ib);
     if(_al_) bad_input(cst_no_dot_or_exponent_part_fo);
     var c$0 = peek_char(ib);
     if(88 !== c$0 && 120 !== c$0)
      return scan_caml_float_rest(width$2, precision, ib);
     var
      width$3 = store_char(width$2, ib, c$0),
      _am_ = 0 === width$3 ? 1 : 0,
      _an_ = _am_ || end_of_input(ib);
     if(_an_) bad_input(cst_no_dot_or_exponent_part_fo);
     var
      width$10 = scan_digit_plus(cst_hexadecimal, is_hexa_digit, width$3, ib),
      _ao_ = 0 === width$10 ? 1 : 0,
      _ap_ = _ao_ || end_of_input(ib);
     if(_ap_) bad_input(cst_no_dot_or_exponent_part_fo);
     var c$1 = peek_char(ib), switcher = c$1 - 80 | 0;
     a:
     {
      b:
      {
       if(32 < switcher >>> 0){
        if(-34 === switcher){
         var width$4 = store_char(width$10, ib, c$1);
         c:
         {
          if(0 !== width$4 && ! end_of_input(ib)){
           var match = peek_char(ib);
           d:
           {
            if(80 !== match && 112 !== match){
             var
              precision$0 = caml_call2(Stdlib_Int[10], width$4, precision),
              width$9 =
                width$4
                -
                 (precision$0
                 -
                  scan_digit_plus
                   (cst_hexadecimal, is_hexa_digit, precision$0, ib)
                 | 0)
                | 0;
             break d;
            }
            var width$9 = width$4;
           }
           var width$5 = width$9;
           break c;
          }
          var width$5 = width$4;
         }
         var width$6 = width$5;
         break b;
        }
       }
       else if(30 < switcher - 1 >>> 0){var width$6 = width$10; break b;}
       var width$7 = bad_input(cst_no_dot_or_exponent_part_fo);
       break a;
      }
      var width$7 = width$6;
     }
     if(0 !== width$7 && ! end_of_input(ib)){
      var c$2 = peek_char(ib);
      if(80 !== c$2 && 112 !== c$2) return width$7;
      var
       width$8 = store_char(width$7, ib, c$2),
       _aq_ = 0 === width$8 ? 1 : 0,
       _ar_ = _aq_ || end_of_input(ib);
      if(_ar_) bad_input(cst_not_a_valid_float_in_hexad);
      return scan_optionally_signed_decimal(width$8, ib);
     }
     return width$7;
    }
    return bad_input(cst_no_dot_or_exponent_part_fo);
   }
   function scan_string(stp, width, ib){
    var width$0 = width;
    for(;;){
     if(0 === width$0) return width$0;
     var c = peek_char(ib);
     if(ib[1]) return width$0;
     if(! stp){
      var _ad_ = c - 9 | 0;
      a:
      {
       if(4 < _ad_ >>> 0){
        if(23 === _ad_) break a;
       }
       else if(1 < _ad_ - 2 >>> 0) break a;
       var width$2 = store_char(width$0, ib, c);
       width$0 = width$2;
       continue;
      }
      return width$0;
     }
     var c$0 = stp[1];
     if(c === c$0){invalidate_current_char(ib); return width$0;}
     var width$1 = store_char(width$0, ib, c);
     width$0 = width$1;
    }
   }
   function hexadecimal_value_of_char(c){
    return 97 <= c ? c - 87 | 0 : 65 <= c ? c - 55 | 0 : c - 48 | 0;
   }
   function check_next_char(message, width, ib){
    if(0 === width) return bad_token_length(message);
    var c = peek_char(ib);
    return ib[1] ? bad_input(caml_call2(Stdlib_Printf[4], _f_, message)) : c;
   }
   function scan_backslash_char(width, ib){
    var c0 = check_next_char(cst_a_Char, width, ib);
    a:
    {
     if(40 <= c0){
      if(58 > c0){
       if(48 > c0) break a;
       var
        get_digit$0 =
          function(param){
           var c = next_char(ib);
           return 9 < c - 48 >>> 0 ? bad_input_escape(c) : c;
          },
        c1$0 = get_digit$0(0),
        c2$0 = get_digit$0(0),
        c =
          ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
          + (c2$0 - 48 | 0)
          | 0;
       b:
       {
        if(0 <= c && 255 >= c){var _ab_ = caml_call1(Stdlib[29], c); break b;}
        var
         _ab_ = bad_input(caml_call4(Stdlib_Printf[4], _l_, c0, c1$0, c2$0));
       }
       return store_char(width - 2 | 0, ib, _ab_);
      }
      var switcher = c0 - 92 | 0;
      if(28 < switcher >>> 0) break a;
      switch(switcher){
        case 28:
         var
          get_digit =
            function(param){
             var c = next_char(ib), _ac_ = c - 48 | 0;
             a:
             {
              if(22 < _ac_ >>> 0){
               if(5 < _ac_ - 49 >>> 0) break a;
              }
              else if(6 >= _ac_ - 10 >>> 0) break a;
              return c;
             }
             return bad_input_escape(c);
            },
          c1 = get_digit(0),
          c2 = get_digit(0),
          ___ = hexadecimal_value_of_char(c2),
          c$0 = (16 * hexadecimal_value_of_char(c1) | 0) + ___ | 0;
         b:
         {
          if(0 <= c$0 && 255 >= c$0){
           var _aa_ = caml_call1(Stdlib[29], c$0);
           break b;
          }
          var _aa_ = bad_input(caml_call3(Stdlib_Printf[4], _m_, c1, c2));
         }
         return store_char(width - 2 | 0, ib, _aa_);
        case 0:
        case 6:
        case 18:
        case 22:
        case 24: break;
        default: break a;
      }
     }
     else if(34 !== c0 && 39 > c0) break a;
     b:
     {
      if(110 <= c0){
       if(117 > c0)
        switch(c0 - 110 | 0){
          case 0:
           var _$_ = 10; break b;
          case 4:
           var _$_ = 13; break b;
          case 6:
           var _$_ = 9; break b;
        }
      }
      else if(98 === c0){var _$_ = 8; break b;}
      var _$_ = c0;
     }
     return store_char(width, ib, _$_);
    }
    return bad_input_escape(c0);
   }
   function scan_caml_string(width, ib){
    function find_stop$0(counter, width){
     var width$0 = width;
     for(;;){
      var c = check_next_char(cst_a_String, width$0, ib);
      if(34 === c) return ignore_char(width$0, ib);
      if(92 === c){
       var
        width$1 = ignore_char(width$0, ib),
        match = check_next_char(cst_a_String, width$1, ib);
       if(10 === match){
        var _Y_ = ignore_char(width$1, ib);
        if(counter >= 50)
         return caml_trampoline_return(skip_spaces, [0, _Y_]);
        var counter$0 = counter + 1 | 0;
        return skip_spaces(counter$0, _Y_);
       }
       if(13 === match){
        var width$3 = ignore_char(width$1, ib);
        if(10 === check_next_char(cst_a_String, width$3, ib)){
         var _Z_ = ignore_char(width$3, ib);
         if(counter >= 50)
          return caml_trampoline_return(skip_spaces, [0, _Z_]);
         var counter$1 = counter + 1 | 0;
         return skip_spaces(counter$1, _Z_);
        }
        var width$5 = store_char(width$3, ib, 13);
        width$0 = width$5;
       }
       else{var width$4 = scan_backslash_char(width$1, ib); width$0 = width$4;
       }
      }
      else{var width$2 = store_char(width$0, ib, c); width$0 = width$2;}
     }
    }
    function find_stop(width){return caml_trampoline(find_stop$0(0, width));}
    function skip_spaces(counter, width){
     var width$0 = width;
     for(;;){
      if(32 !== check_next_char(cst_a_String, width$0, ib)){
       if(counter >= 50)
        return caml_trampoline_return(find_stop$0, [0, width$0]);
       var counter$0 = counter + 1 | 0;
       return find_stop$0(counter$0, width$0);
      }
      var width$1 = ignore_char(width$0, ib);
      width$0 = width$1;
     }
    }
    var c = checked_peek_char(ib);
    return 34 === c
            ? find_stop(ignore_char(width, ib))
            : character_mismatch(34, c);
   }
   function scan_chars_in_char_set(char_set, scan_indic, width, ib){
    function scan_chars(i, stp){
     var i$0 = i;
     for(;;){
      var c = peek_char(ib), _U_ = 0 < i$0 ? 1 : 0;
      if(_U_){
       var _V_ = 1 - ib[1];
       if(_V_)
        var
         _W_ = caml_call2(CamlinternalFormat[1], char_set, c),
         _X_ = _W_ ? c !== stp ? 1 : 0 : _W_;
       else
        var _X_ = _V_;
      }
      else
       var _X_ = _U_;
      if(! _X_) return _X_;
      store_char(Stdlib[19], ib, c);
      var i$1 = i$0 - 1 | 0;
      i$0 = i$1;
     }
    }
    if(! scan_indic) return scan_chars(width, -1);
    var c = scan_indic[1];
    scan_chars(width, c);
    var _T_ = 1 - ib[1];
    if(! _T_) return _T_;
    var ci = peek_char(ib);
    return c === ci ? invalidate_current_char(ib) : character_mismatch(c, ci);
   }
   function scanf_bad_input(ib, x){
    if(x[1] === Scan_failure)
     var s = x[2];
    else{
     if(x[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(x, 1);
     var s = x[2];
    }
    var i = char_count(ib);
    return bad_input(caml_call3(Stdlib_Printf[4], _o_, i, s));
   }
   function width_of_pad_opt(pad_opt){
    if(! pad_opt) return Stdlib[19];
    var width = pad_opt[1];
    return width;
   }
   function stopper_of_formatting_lit(fmting){
    if(6 === fmting) return _p_;
    var
     str = caml_call1(CamlinternalFormat[17], fmting),
     stp = caml_string_get(str, 1),
     sub_str =
       caml_call3
        (Stdlib_String[16], str, 2, caml_ml_string_length(str) - 2 | 0);
    return [0, stp, sub_str];
   }
   function take_format_readers$0(counter, k, fmt){
    var fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return caml_call1(k, 0);
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1]; fmt$0 = rest; break;
       case 1:
        var rest$0 = fmt$0[1]; fmt$0 = rest$0; break;
       case 2:
        var rest$1 = fmt$0[2]; fmt$0 = rest$1; break;
       case 3:
        var rest$2 = fmt$0[2]; fmt$0 = rest$2; break;
       case 4:
        var rest$3 = fmt$0[4]; fmt$0 = rest$3; break;
       case 5:
        var rest$4 = fmt$0[4]; fmt$0 = rest$4; break;
       case 6:
        var rest$5 = fmt$0[4]; fmt$0 = rest$5; break;
       case 7:
        var rest$6 = fmt$0[4]; fmt$0 = rest$6; break;
       case 8:
        var rest$7 = fmt$0[4]; fmt$0 = rest$7; break;
       case 9:
        var rest$8 = fmt$0[2]; fmt$0 = rest$8; break;
       case 10:
        var rest$9 = fmt$0[1]; fmt$0 = rest$9; break;
       case 11:
        var rest$10 = fmt$0[2]; fmt$0 = rest$10; break;
       case 12:
        var rest$11 = fmt$0[2]; fmt$0 = rest$11; break;
       case 13:
        var rest$12 = fmt$0[3]; fmt$0 = rest$12; break;
       case 14:
        var
         rest$13 = fmt$0[3],
         fmtty = fmt$0[2],
         _Q_ = caml_call1(CamlinternalFormat[21], fmtty),
         _R_ = caml_call1(CamlinternalFormatBasics[2], _Q_);
        if(counter >= 50)
         return caml_trampoline_return
                 (take_fmtty_format_readers$0, [0, k, _R_, rest$13]);
        var counter$0 = counter + 1 | 0;
        return take_fmtty_format_readers$0(counter$0, k, _R_, rest$13);
       case 15:
        var rest$14 = fmt$0[1]; fmt$0 = rest$14; break;
       case 16:
        var rest$15 = fmt$0[1]; fmt$0 = rest$15; break;
       case 17:
        var rest$16 = fmt$0[2]; fmt$0 = rest$16; break;
       case 18:
        var _S_ = fmt$0[1];
        if(0 === _S_[0]){
         var
          rest$17 = fmt$0[2],
          fmt$1 = _S_[1][1],
          fmt$2 = caml_call2(CamlinternalFormatBasics[3], fmt$1, rest$17);
         fmt$0 = fmt$2;
        }
        else{
         var
          rest$18 = fmt$0[2],
          fmt$3 = _S_[1][1],
          fmt$4 = caml_call2(CamlinternalFormatBasics[3], fmt$3, rest$18);
         fmt$0 = fmt$4;
        }
        break;
       case 19:
        var fmt_rest = fmt$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_format_readers(new_k, fmt_rest);};
       case 20:
        var rest$19 = fmt$0[3]; fmt$0 = rest$19; break;
       case 21:
        var rest$20 = fmt$0[2]; fmt$0 = rest$20; break;
       case 22:
        var rest$21 = fmt$0[1]; fmt$0 = rest$21; break;
       case 23:
        var rest$22 = fmt$0[2], ign = fmt$0[1];
        if(typeof ign === "number")
         switch(ign){
           case 0:
            fmt$0 = rest$22; break;
           case 1:
            fmt$0 = rest$22; break;
           case 2:
            return function(reader){
             function new_k(readers_rest){
              return caml_call1(k, [0, reader, readers_rest]);
             }
             return take_format_readers(new_k, rest$22);};
           default: fmt$0 = rest$22;
         }
        else
         switch(ign[0]){
           case 0:
            fmt$0 = rest$22; break;
           case 1:
            fmt$0 = rest$22; break;
           case 2:
            fmt$0 = rest$22; break;
           case 3:
            fmt$0 = rest$22; break;
           case 4:
            fmt$0 = rest$22; break;
           case 5:
            fmt$0 = rest$22; break;
           case 6:
            fmt$0 = rest$22; break;
           case 7:
            fmt$0 = rest$22; break;
           case 8:
            fmt$0 = rest$22; break;
           case 9:
            var fmtty$0 = ign[2];
            if(counter >= 50)
             return caml_trampoline_return
                     (take_fmtty_format_readers$0, [0, k, fmtty$0, rest$22]);
            var counter$1 = counter + 1 | 0;
            return take_fmtty_format_readers$0(counter$1, k, fmtty$0, rest$22);
           case 10:
            fmt$0 = rest$22; break;
           default: fmt$0 = rest$22;
         }
        break;
       default: var rest$23 = fmt$0[3]; fmt$0 = rest$23;
     }
    }
   }
   function take_format_readers(k, fmt){
    return caml_trampoline(take_format_readers$0(0, k, fmt));
   }
   function take_fmtty_format_readers$0(counter, k, fmtty, fmt){
    var fmtty$0 = fmtty;
    for(;;){
     if(typeof fmtty$0 === "number"){
      if(counter >= 50)
       return caml_trampoline_return(take_format_readers$0, [0, k, fmt]);
      var counter$0 = counter + 1 | 0;
      return take_format_readers$0(counter$0, k, fmt);
     }
     switch(fmtty$0[0]){
       case 0:
        var fmtty$1 = fmtty$0[1]; fmtty$0 = fmtty$1; break;
       case 1:
        var fmtty$2 = fmtty$0[1]; fmtty$0 = fmtty$2; break;
       case 2:
        var fmtty$3 = fmtty$0[1]; fmtty$0 = fmtty$3; break;
       case 3:
        var fmtty$4 = fmtty$0[1]; fmtty$0 = fmtty$4; break;
       case 4:
        var fmtty$5 = fmtty$0[1]; fmtty$0 = fmtty$5; break;
       case 5:
        var fmtty$6 = fmtty$0[1]; fmtty$0 = fmtty$6; break;
       case 6:
        var fmtty$7 = fmtty$0[1]; fmtty$0 = fmtty$7; break;
       case 7:
        var fmtty$8 = fmtty$0[1]; fmtty$0 = fmtty$8; break;
       case 8:
        var fmtty$9 = fmtty$0[2]; fmtty$0 = fmtty$9; break;
       case 9:
        var
         rest = fmtty$0[3],
         ty2 = fmtty$0[2],
         ty1 = fmtty$0[1],
         _P_ = caml_call1(CamlinternalFormat[21], ty1),
         ty = caml_call2(CamlinternalFormat[22], _P_, ty2),
         fmtty$10 = caml_call2(CamlinternalFormatBasics[1], ty, rest);
        fmtty$0 = fmtty$10;
        break;
       case 10:
        var fmtty$11 = fmtty$0[1]; fmtty$0 = fmtty$11; break;
       case 11:
        var fmtty$12 = fmtty$0[1]; fmtty$0 = fmtty$12; break;
       case 12:
        var fmtty$13 = fmtty$0[1]; fmtty$0 = fmtty$13; break;
       case 13:
        var fmt_rest = fmtty$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_fmtty_format_readers(new_k, fmt_rest, fmt);};
       default:
        var fmt_rest$0 = fmtty$0[1];
        return function(reader){
         function new_k(readers_rest){
          return caml_call1(k, [0, reader, readers_rest]);
         }
         return take_fmtty_format_readers(new_k, fmt_rest$0, fmt);};
     }
    }
   }
   function take_fmtty_format_readers(k, fmtty, fmt){
    return caml_trampoline(take_fmtty_format_readers$0(0, k, fmtty, fmt));
   }
   function make_scanf(ib, fmt, readers){
    var fmt$0 = fmt;
    for(;;){
     if(typeof fmt$0 === "number") return 0;
     switch(fmt$0[0]){
       case 0:
        var rest = fmt$0[1];
        store_char(0, ib, checked_peek_char(ib));
        var c$0 = token_char(ib);
        return [0, c$0, make_scanf(ib, rest, readers)];
       case 1:
        var
         rest$0 = fmt$0[1],
         find_stop =
           function(width){
            var c = check_next_char(cst_a_Char, width, ib);
            return 39 === c
                    ? ignore_char(width, ib)
                    : character_mismatch(39, c);
           },
         c = checked_peek_char(ib),
         width$0 = 0;
        if(39 === c){
         var
          width = ignore_char(width$0, ib),
          c$3 = check_next_char(cst_a_Char, width, ib);
         if(92 === c$3)
          find_stop(scan_backslash_char(ignore_char(width, ib), ib));
         else
          find_stop(store_char(width, ib, c$3));
        }
        else
         character_mismatch(39, c);
        var c$1 = token_char(ib);
        return [0, c$1, make_scanf(ib, rest$0, readers)];
       case 2:
        var pad = fmt$0[1], match = fmt$0[2];
        if(typeof match !== "number")
         switch(match[0]){
           case 17:
            var
             rest$2 = match[2],
             fmting_lit = match[1],
             match$0 = stopper_of_formatting_lit(fmting_lit),
             str = match$0[2],
             stp = match$0[1],
             scan$0 =
               function(width, param, ib){
                return scan_string([0, stp], width, ib);
               },
             str_rest = [11, str, rest$2];
            return pad_prec_scanf
                    (ib, str_rest, readers, pad, 0, scan$0, token_string);
           case 18:
            var _D_ = match[1];
            if(0 === _D_[0]){
             var
              rest$3 = match[2],
              fmt$1 = _D_[1][1],
              scan$1 =
                function(width, param, ib){
                 return scan_string(_q_, width, ib);
                };
             return pad_prec_scanf
                     (ib,
                      caml_call2(CamlinternalFormatBasics[3], fmt$1, rest$3),
                      readers,
                      pad,
                      0,
                      scan$1,
                      token_string);
            }
            var
             rest$4 = match[2],
             fmt$2 = _D_[1][1],
             scan$2 =
               function(width, param, ib){return scan_string(_r_, width, ib);};
            return pad_prec_scanf
                    (ib,
                     caml_call2(CamlinternalFormatBasics[3], fmt$2, rest$4),
                     readers,
                     pad,
                     0,
                     scan$2,
                     token_string);
         }
        var
         rest$1 = fmt$0[2],
         scan = function(width, param, ib){return scan_string(0, width, ib);};
        return pad_prec_scanf(ib, rest$1, readers, pad, 0, scan, token_string);
       case 3:
        var
         rest$5 = fmt$0[2],
         pad$0 = fmt$0[1],
         scan$3 =
           function(width, param, ib){return scan_caml_string(width, ib);};
        return pad_prec_scanf
                (ib, rest$5, readers, pad$0, 0, scan$3, token_string);
       case 4:
        var
         rest$6 = fmt$0[4],
         prec = fmt$0[3],
         pad$1 = fmt$0[2],
         iconv = fmt$0[1],
         conv =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv)),
         scan$4 =
           function(width, param, ib){
            return scan_int_conversion(conv, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$6,
                 readers,
                 pad$1,
                 prec,
                 scan$4,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv, ib));
                 });
       case 5:
        var
         rest$7 = fmt$0[4],
         prec$0 = fmt$0[3],
         pad$2 = fmt$0[2],
         iconv$0 = fmt$0[1],
         conv$0 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$0)),
         scan$5 =
           function(width, param, ib){
            return scan_int_conversion(conv$0, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$7,
                 readers,
                 pad$2,
                 prec$0,
                 scan$5,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv$0, ib));
                 });
       case 6:
        var
         rest$8 = fmt$0[4],
         prec$1 = fmt$0[3],
         pad$3 = fmt$0[2],
         iconv$1 = fmt$0[1],
         conv$1 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$1)),
         scan$6 =
           function(width, param, ib){
            return scan_int_conversion(conv$1, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$8,
                 readers,
                 pad$3,
                 prec$1,
                 scan$6,
                 function(ib){
                  return caml_int_of_string(token_int_literal(conv$1, ib));
                 });
       case 7:
        var
         rest$9 = fmt$0[4],
         prec$2 = fmt$0[3],
         pad$4 = fmt$0[2],
         iconv$2 = fmt$0[1],
         conv$2 =
           integer_conversion_of_char
            (caml_call1(CamlinternalFormat[16], iconv$2)),
         scan$7 =
           function(width, param, ib){
            return scan_int_conversion(conv$2, width, ib);
           };
        return pad_prec_scanf
                (ib,
                 rest$9,
                 readers,
                 pad$4,
                 prec$2,
                 scan$7,
                 function(ib){
                  return runtime.caml_int64_of_string
                          (token_int_literal(conv$2, ib));
                 });
       case 8:
        switch(fmt$0[1][2]){
          case 5:
          case 8:
           var rest$11 = fmt$0[4], prec$4 = fmt$0[3], pad$6 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$11,
                    readers,
                    pad$6,
                    prec$4,
                    scan_caml_float,
                    token_float);
          case 6:
          case 7:
           var rest$12 = fmt$0[4], prec$5 = fmt$0[3], pad$7 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$12,
                    readers,
                    pad$7,
                    prec$5,
                    scan_hex_float,
                    token_float);
          default:
           var rest$10 = fmt$0[4], prec$3 = fmt$0[3], pad$5 = fmt$0[2];
           return pad_prec_scanf
                   (ib,
                    rest$10,
                    readers,
                    pad$5,
                    prec$3,
                    scan_float,
                    token_float);
        }
       case 9:
        var
         rest$13 = fmt$0[2],
         pad$8 = fmt$0[1],
         scan$8 =
           function(_O_, param, ib){
            var
             c = checked_peek_char(ib),
             m =
               102 === c
                ? 5
                : 116
                  === c
                  ? 4
                  : bad_input(caml_call2(Stdlib_Printf[4], _n_, c));
            return scan_string(0, m, ib);
           };
        return pad_prec_scanf
                (ib, rest$13, readers, pad$8, 0, scan$8, token_bool);
       case 10:
        var rest$14 = fmt$0[1];
        if(! end_of_input(ib)) return bad_input(cst_end_of_input_not_found);
        fmt$0 = rest$14;
        break;
       case 11:
        var rest$15 = fmt$0[2], str$0 = fmt$0[1];
        caml_call2
         (Stdlib_String[30],
          function(_N_){return check_char(ib, _N_);},
          str$0);
        fmt$0 = rest$15;
        break;
       case 12:
        var rest$16 = fmt$0[2], chr = fmt$0[1];
        check_char(ib, chr);
        fmt$0 = rest$16;
        break;
       case 13:
        var rest$17 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
        scan_caml_string(width_of_pad_opt(pad_opt), ib);
        var s = token_string(ib);
        try{
         var _E_ = caml_call2(CamlinternalFormat[14], s, fmtty), fmt$3 = _E_;
        }
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
         var msg = exn[2], fmt$3 = bad_input(msg);
        }
        return [0, fmt$3, make_scanf(ib, rest$17, readers)];
       case 14:
        var rest$18 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
        scan_caml_string(width_of_pad_opt(pad_opt$0), ib);
        var s$0 = token_string(ib);
        try{
         var
          fmt$6 = caml_call2(CamlinternalFormat[13], 0, s$0)[1],
          fmt$7 = caml_call2(CamlinternalFormat[13], 0, s$0)[1],
          _G_ = caml_call1(CamlinternalFormat[21], fmtty$0),
          _H_ = caml_call1(CamlinternalFormatBasics[2], _G_),
          fmt$8 = caml_call2(CamlinternalFormat[12], fmt$7, _H_),
          _I_ = caml_call1(CamlinternalFormatBasics[2], fmtty$0),
          _J_ = caml_call2(CamlinternalFormat[12], fmt$6, _I_),
          fmt$5 = fmt$8,
          fmt$4 = _J_;
        }
        catch(exn){
         var exn$0 = caml_wrap_exception(exn);
         if(exn$0[1] !== Stdlib[7])
          throw caml_maybe_attach_backtrace(exn$0, 0);
         var
          msg$0 = exn$0[2],
          _F_ = bad_input(msg$0),
          fmt$5 = _F_[2],
          fmt$4 = _F_[1];
        }
        return [0,
                [0, fmt$4, s$0],
                make_scanf
                 (ib,
                  caml_call2(CamlinternalFormatBasics[3], fmt$5, rest$18),
                  readers)];
       case 15:
        return caml_call1(Stdlib[1], cst_scanf_bad_conversion_a);
       case 16:
        return caml_call1(Stdlib[1], cst_scanf_bad_conversion_t);
       case 17:
        var
         rest$19 = fmt$0[2],
         formatting_lit = fmt$0[1],
         _K_ = caml_call1(CamlinternalFormat[17], formatting_lit);
        caml_call2
         (Stdlib_String[30], function(_M_){return check_char(ib, _M_);}, _K_);
        fmt$0 = rest$19;
        break;
       case 18:
        var _L_ = fmt$0[1];
        if(0 === _L_[0]){
         var rest$20 = fmt$0[2], fmt$9 = _L_[1][1];
         check_char(ib, 64);
         check_char(ib, 123);
         var fmt$10 = caml_call2(CamlinternalFormatBasics[3], fmt$9, rest$20);
         fmt$0 = fmt$10;
        }
        else{
         var rest$21 = fmt$0[2], fmt$11 = _L_[1][1];
         check_char(ib, 64);
         check_char(ib, 91);
         var
          fmt$12 = caml_call2(CamlinternalFormatBasics[3], fmt$11, rest$21);
         fmt$0 = fmt$12;
        }
        break;
       case 19:
        var fmt_rest = fmt$0[1];
        if(! readers) return caml_call1(Stdlib[1], cst_scanf_missing_reader);
        var
         readers_rest = readers[2],
         reader = readers[1],
         x = caml_call1(reader, ib);
        return [0, x, make_scanf(ib, fmt_rest, readers_rest)];
       case 20:
        var width_opt = fmt$0[1], match$1 = fmt$0[3];
        if(typeof match$1 !== "number" && 17 === match$1[0]){
         var
          rest$23 = match$1[2],
          fmting_lit$0 = match$1[1],
          char_set$0 = fmt$0[2],
          match$2 = stopper_of_formatting_lit(fmting_lit$0),
          str$1 = match$2[2],
          stp$0 = match$2[1],
          width$2 = width_of_pad_opt(width_opt);
         scan_chars_in_char_set(char_set$0, [0, stp$0], width$2, ib);
         var s$2 = token_string(ib), str_rest$0 = [11, str$1, rest$23];
         return [0, s$2, make_scanf(ib, str_rest$0, readers)];
        }
        var
         rest$22 = fmt$0[3],
         char_set = fmt$0[2],
         width$1 = width_of_pad_opt(width_opt);
        scan_chars_in_char_set(char_set, 0, width$1, ib);
        var s$1 = token_string(ib);
        return [0, s$1, make_scanf(ib, rest$22, readers)];
       case 21:
        var rest$24 = fmt$0[2], counter = fmt$0[1];
        switch(counter){
          case 0:
           var count = ib[5]; break;
          case 1:
           var count = char_count(ib); break;
          default: var count = ib[6];
        }
        return [0, count, make_scanf(ib, rest$24, readers)];
       case 22:
        var rest$25 = fmt$0[1], c$2 = checked_peek_char(ib);
        return [0, c$2, make_scanf(ib, rest$25, readers)];
       case 23:
        var
         rest$26 = fmt$0[2],
         ign = fmt$0[1],
         fmt$13 = caml_call2(CamlinternalFormat[6], ign, rest$26)[1],
         match$3 = make_scanf(ib, fmt$13, readers);
        if(! match$3)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
        var arg_rest = match$3[2];
        return arg_rest;
       default: return caml_call1(Stdlib[1], cst_scanf_bad_conversion_custo);
     }
    }
   }
   function pad_prec_scanf(ib, fmt, readers, pad, prec, scan, token){
    if(typeof pad === "number"){
     if(typeof prec !== "number"){
      var p = prec[1];
      caml_call3(scan, Stdlib[19], p, ib);
      var x$0 = caml_call1(token, ib);
      return [0, x$0, make_scanf(ib, fmt, readers)];
     }
     if(prec) return caml_call1(Stdlib[1], cst_scanf_bad_conversion);
     caml_call3(scan, Stdlib[19], Stdlib[19], ib);
     var x = caml_call1(token, ib);
     return [0, x, make_scanf(ib, fmt, readers)];
    }
    if(0 !== pad[0]) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$2);
    if(! pad[1]) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$1);
    var w = pad[2];
    if(typeof prec !== "number"){
     var p$0 = prec[1];
     caml_call3(scan, w, p$0, ib);
     var x$2 = caml_call1(token, ib);
     return [0, x$2, make_scanf(ib, fmt, readers)];
    }
    if(prec) return caml_call1(Stdlib[1], cst_scanf_bad_conversion$0);
    caml_call3(scan, w, Stdlib[19], ib);
    var x$1 = caml_call1(token, ib);
    return [0, x$1, make_scanf(ib, fmt, readers)];
   }
   function kscanf_gen(ib, ef, af, param){
    var str = param[2], fmt = param[1];
    function k(readers, f$1){
     caml_call1(Stdlib_Buffer[9], ib[8]);
     try{var args$1 = make_scanf(ib, fmt, readers);}
     catch(exc$0){
      var exc = caml_wrap_exception(exc$0);
      if
       (exc[1] !== Scan_failure && exc[1] !== Stdlib[7] && exc !== Stdlib[12]){
       if(exc[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exc, 0);
       var
        msg = exc[2],
        _z_ = caml_call1(Stdlib_String[25], str),
        _A_ = caml_call2(Stdlib[28], _z_, cst$0),
        _B_ = caml_call2(Stdlib[28], cst_in_format, _A_),
        _C_ = caml_call2(Stdlib[28], msg, _B_);
       return caml_call1(Stdlib[1], _C_);
      }
      return caml_call2(ef, ib, exc);
     }
     var f = f$1, args = args$1;
     for(;;){
      if(! args) return caml_call1(af, f);
      var args$0 = args[2], x = args[1], f$0 = caml_call1(f, x);
      f = f$0;
      args = args$0;
     }
    }
    return take_format_readers(k, fmt);
   }
   function kscanf(ib, ef, fmt){
    return kscanf_gen(ib, ef, function(x){return x;}, fmt);
   }
   function kscanf_opt(ib, fmt){
    return kscanf_gen
            (ib,
             function(_y_, param){return 0;},
             function(x){return [0, x];},
             fmt);
   }
   function bscanf(ib, fmt){return kscanf(ib, scanf_bad_input, fmt);}
   function bscanf_opt(ib, fmt){return kscanf_opt(ib, fmt);}
   function ksscanf(s, ef, fmt){return kscanf(from_string(s), ef, fmt);}
   function sscanf(s, fmt){
    return kscanf(from_string(s), scanf_bad_input, fmt);
   }
   function sscanf_opt(s, fmt){return kscanf_opt(from_string(s), fmt);}
   function scanf(fmt){return kscanf(stdin, scanf_bad_input, fmt);}
   function scanf_opt(fmt){return kscanf_opt(stdin, fmt);}
   function bscanf_format(ib, format, f){
    scan_caml_string(Stdlib[19], ib);
    var str = token_string(ib);
    try{var _x_ = caml_call2(CamlinternalFormat[15], str, format), fmt = _x_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2], fmt = bad_input(msg);
    }
    return caml_call1(f, fmt);
   }
   function sscanf_format(s, format, f){
    return bscanf_format(from_string(s), format, f);
   }
   function format_from_string(s, fmt){
    var
     _v_ = caml_call1(Stdlib_String[25], s),
     _w_ = caml_call2(Stdlib[28], _v_, cst$1);
    return sscanf_format
            (caml_call2(Stdlib[28], cst$2, _w_), fmt, function(x){return x;});
   }
   function unescaped(s){
    var _u_ = caml_call2(Stdlib[28], s, cst$3);
    return caml_call1
            (sscanf(caml_call2(Stdlib[28], cst$4, _u_), _t_),
             function(x){return x;});
   }
   var
    Stdlib_Scanf =
      [0,
       [0,
        stdin,
        open_in,
        open_in_bin,
        close_in,
        open_in,
        open_in_bin,
        from_string,
        from_function,
        from_channel,
        end_of_input,
        beginning_of_input,
        name_of_input],
       Scan_failure,
       bscanf,
       bscanf_opt,
       sscanf,
       sscanf_opt,
       scanf,
       scanf_opt,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped];
   runtime.caml_register_global(64, Stdlib_Scanf, "Stdlib__Scanf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Callback
//# unitInfo: Requires: Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_register_named_value = runtime.caml_register_named_value,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    register = caml_register_named_value;
   function register_exception(name, exn){
    var
     _a_ = Stdlib_Obj[10],
     slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
    return caml_register_named_value(name, slot);
   }
   var Stdlib_Callback = [0, register, register_exception];
   runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalOO
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Obj, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalOO_ml = "camlinternalOO.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_get_public_method = runtime.caml_get_public_method,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_block = runtime.caml_obj_block,
    caml_set_oo_id = runtime.caml_set_oo_id,
    caml_string_compare = runtime.caml_string_compare,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Map = global_data.Stdlib__Map;
   function copy(o){var o$0 = o.slice(); return caml_set_oo_id(o$0);}
   var params = [0, 1, 1, 1, 3, 16];
   function public_method_label(s){
    var
     accu = [0, 0],
     _al_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      var _am_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _am_ | 0;
      var _an_ = i + 1 | 0;
      if(_al_ === i) break;
      i = _an_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
    return tag;
   }
   var
    compare = caml_string_compare,
    Vars = caml_call1(Stdlib_Map[1], [0, compare]),
    compare$0 = caml_string_compare,
    Meths = caml_call1(Stdlib_Map[1], [0, compare$0]),
    compare$1 = runtime.caml_int_compare,
    Labs = caml_call1(Stdlib_Map[1], [0, compare$1]),
    dummy_table = [0, 0, [0, 0], Meths[1], Labs[1], 0, 0, Vars[1], 0],
    table_count = [0, 0],
    dummy_met = caml_obj_block(0, 0),
    initial_object_size = 2;
   function fit_size(n){
    return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
   }
   function new_table(pub_labels){
    table_count[1]++;
    var
     len = pub_labels.length - 1,
     methods = caml_make_vect((len * 2 | 0) + 2 | 0, dummy_met);
    caml_check_bound(methods, 0)[1] = len;
    var
     _ad_ = Stdlib_Sys[9],
     _ae_ = (runtime.caml_mul(fit_size(len), _ad_) / 8 | 0) - 1 | 0;
    caml_check_bound(methods, 1)[2] = _ae_;
    var _ag_ = len - 1 | 0, _af_ = 0;
    if(_ag_ >= 0){
     var i = _af_;
     for(;;){
      var
       _ai_ = (i * 2 | 0) + 3 | 0,
       _ah_ = caml_check_bound(pub_labels, i)[1 + i];
      caml_check_bound(methods, _ai_)[1 + _ai_] = _ah_;
      var _aj_ = i + 1 | 0;
      if(_ag_ === i) break;
      i = _aj_;
     }
    }
    return [0,
            initial_object_size,
            methods,
            Meths[1],
            Labs[1],
            0,
            0,
            Vars[1],
            0];
   }
   function resize(array, new_size){
    var old_size = array[2].length - 1, _ab_ = old_size < new_size ? 1 : 0;
    if(_ab_){
     var new_buck = caml_make_vect(new_size, dummy_met);
     caml_call5(Stdlib_Array[9], array[2], 0, new_buck, 0, old_size);
     array[2] = new_buck;
     var _ac_ = 0;
    }
    else
     var _ac_ = _ab_;
    return _ac_;
   }
   var
    method_count = [0, 0],
    inst_var_count = [0, 0],
    _a_ = [0, cst_camlinternalOO_ml, 279, 50],
    _b_ = [0, cst_camlinternalOO_ml, 407, 13],
    _c_ = [0, cst_camlinternalOO_ml, 410, 13],
    _d_ = [0, cst_camlinternalOO_ml, 413, 13],
    _e_ = [0, cst_camlinternalOO_ml, 416, 13],
    _f_ = [0, cst_camlinternalOO_ml, 419, 13],
    _g_ = [0, cst_camlinternalOO_ml, 437, 17];
   function new_method(table){
    var index = table[2].length - 1;
    resize(table, index + 1 | 0);
    return index;
   }
   function get_method_label(table, name){
    try{var _$_ = caml_call2(Meths[17], name, table[3]); return _$_;}
    catch(_aa_){
     var ___ = caml_wrap_exception(_aa_);
     if(___ !== Stdlib[8]) throw caml_maybe_attach_backtrace(___, 0);
     var label = new_method(table);
     table[3] = caml_call3(Meths[2], name, label, table[3]);
     table[4] = caml_call3(Labs[2], label, 1, table[4]);
     return label;
    }
   }
   function get_method_labels(table, names){
    return caml_call2
            (Stdlib_Array[14],
             function(_Z_){return get_method_label(table, _Z_);},
             names);
   }
   function set_method(table, label, element){
    method_count[1]++;
    return caml_call2(Labs[17], label, table[4])
            ? (resize
               (table, label + 1 | 0),
              caml_check_bound(table[2], label)[1 + label] = element,
              0)
            : (table[6] = [0, [0, label, element], table[6]], 0);
   }
   function get_method(table, label){
    try{var _X_ = caml_call2(Stdlib_List[49], label, table[6]); return _X_;}
    catch(_Y_){
     var _W_ = caml_wrap_exception(_Y_);
     if(_W_ === Stdlib[8])
      return caml_check_bound(table[2], label)[1 + label];
     throw caml_maybe_attach_backtrace(_W_, 0);
    }
   }
   function to_list(arr){
    return 0 === arr ? 0 : caml_call1(Stdlib_Array[10], arr);
   }
   function narrow(table, vars, virt_meths, concr_meths){
    var
     vars$0 = to_list(vars),
     virt_meths$0 = to_list(virt_meths),
     concr_meths$0 = to_list(concr_meths),
     virt_meth_labs =
       caml_call2
        (Stdlib_List[20],
         function(_V_){return get_method_label(table, _V_);},
         virt_meths$0),
     concr_meth_labs =
       caml_call2
        (Stdlib_List[20],
         function(_U_){return get_method_label(table, _U_);},
         concr_meths$0);
    table[5] =
     [0,
      [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
      table[5]];
    table[7] =
     caml_call3
      (Vars[24],
       function(lab, info, tvars){
        return caml_call2(Stdlib_List[37], lab, vars$0)
                ? caml_call3(Vars[2], lab, info, tvars)
                : tvars;
       },
       table[7],
       Vars[1]);
    var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
    caml_call3
     (Stdlib_List[28],
      function(met, label){
       by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
       var _P_ = by_label[1];
       try{var _S_ = caml_call2(Labs[17], label, table[4]), _R_ = _S_;}
       catch(_T_){
        var _Q_ = caml_wrap_exception(_T_);
        if(_Q_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_Q_, 0);
        var _R_ = 1;
       }
       by_label[1] = caml_call3(Labs[2], label, _R_, _P_);
       return 0;
      },
      concr_meths$0,
      concr_meth_labs);
    caml_call3
     (Stdlib_List[28],
      function(met, label){
       by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
       by_label[1] = caml_call3(Labs[2], label, 0, by_label[1]);
       return 0;
      },
      virt_meths$0,
      virt_meth_labs);
    table[3] = by_name[1];
    table[4] = by_label[1];
    table[6] =
     caml_call3
      (Stdlib_List[27],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[37], lab, virt_meth_labs)
                ? hm
                : [0, met, hm];
       },
       table[6],
       0);
    return 0;
   }
   function widen(table){
    var
     match = caml_call1(Stdlib_List[6], table[5]),
     vars = match[6],
     virt_meths = match[5],
     saved_vars = match[4],
     saved_hidden_meths = match[3],
     by_label = match[2],
     by_name = match[1];
    table[5] = caml_call1(Stdlib_List[7], table[5]);
    table[7] =
     caml_call3
      (Stdlib_List[26],
       function(s, v){
        var _O_ = caml_call2(Vars[17], v, table[7]);
        return caml_call3(Vars[2], v, _O_, s);
       },
       saved_vars,
       vars);
    table[3] = by_name;
    table[4] = by_label;
    table[6] =
     caml_call3
      (Stdlib_List[27],
       function(met, hm){
        var lab = met[1];
        return caml_call2(Stdlib_List[37], lab, virt_meths)
                ? hm
                : [0, met, hm];
       },
       table[6],
       saved_hidden_meths);
    return 0;
   }
   function new_variable(table, name){
    try{var _M_ = caml_call2(Vars[17], name, table[7]); return _M_;}
    catch(_N_){
     var _L_ = caml_wrap_exception(_N_);
     if(_L_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_L_, 0);
     var index = table[1];
     table[1] = index + 1 | 0;
     if(name !== "") table[7] = caml_call3(Vars[2], name, index, table[7]);
     return index;
    }
   }
   function to_array(arr){return runtime.caml_equal(arr, 0) ? [0] : arr;}
   function new_methods_variables(table, meths, vals){
    var
     meths$0 = to_array(meths),
     nmeths = meths$0.length - 1,
     nvals = vals.length - 1,
     res = caml_make_vect(nmeths + nvals | 0, 0),
     _D_ = nmeths - 1 | 0,
     _C_ = 0;
    if(_D_ >= 0){
     var i$0 = _C_;
     for(;;){
      var
       _J_ = get_method_label(table, caml_check_bound(meths$0, i$0)[1 + i$0]);
      caml_check_bound(res, i$0)[1 + i$0] = _J_;
      var _K_ = i$0 + 1 | 0;
      if(_D_ === i$0) break;
      i$0 = _K_;
     }
    }
    var _F_ = nvals - 1 | 0, _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      var
       _H_ = i + nmeths | 0,
       _G_ = new_variable(table, caml_check_bound(vals, i)[1 + i]);
      caml_check_bound(res, _H_)[1 + _H_] = _G_;
      var _I_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _I_;
     }
    }
    return res;
   }
   function get_variable(table, name){
    try{var _A_ = caml_call2(Vars[17], name, table[7]); return _A_;}
    catch(_B_){
     var _z_ = caml_wrap_exception(_B_);
     if(_z_ === Stdlib[8])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function get_variables(table, names){
    return caml_call2
            (Stdlib_Array[14],
             function(_y_){return get_variable(table, _y_);},
             names);
   }
   function add_initializer(table, f){table[8] = [0, f, table[8]]; return 0;}
   function create_table(public_methods){
    if(0 === public_methods) return new_table([0]);
    var
     tags = caml_call2(Stdlib_Array[14], public_method_label, public_methods),
     table = new_table(tags);
    caml_call2
     (Stdlib_Array[13],
      function(i, met){
       var lab = (i * 2 | 0) + 2 | 0;
       table[3] = caml_call3(Meths[2], met, lab, table[3]);
       table[4] = caml_call3(Labs[2], lab, 1, table[4]);
       return 0;
      },
      public_methods);
    return table;
   }
   function init_class(table){
    inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
    table[8] = caml_call1(Stdlib_List[10], table[8]);
    var _x_ = Stdlib_Sys[9];
    return resize
            (table,
             3 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _x_) | 0);
   }
   function inherits(cla, vals, virt_meths, concr_meths, param, top){
    var env = param[4], super$0 = param[2];
    narrow(cla, vals, virt_meths, concr_meths);
    var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
    widen(cla);
    var
     _s_ = to_array(concr_meths),
     _t_ =
       [0,
        caml_call2
         (Stdlib_Array[14],
          function(nm){return get_method(cla, get_method_label(cla, nm));},
          _s_),
        0],
     _u_ = to_array(vals),
     _v_ =
       [0,
        [0, init],
        [0,
         caml_call2
          (Stdlib_Array[14],
           function(_w_){return get_variable(cla, _w_);},
           _u_),
         _t_]];
    return caml_call1(Stdlib_Array[5], _v_);
   }
   function make_class(pub_meths, class_init){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    return [0, caml_call1(env_init, 0), class_init, env_init, 0];
   }
   function make_class_store(pub_meths, class_init, init_table){
    var
     table = create_table(pub_meths),
     env_init = caml_call1(class_init, table);
    init_class(table);
    init_table[2] = class_init;
    init_table[1] = env_init;
    return 0;
   }
   function dummy_class(loc){
    function undef(param){
     throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
    }
    return [0, undef, undef, undef, 0];
   }
   function create_object(table){
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function create_object_opt(obj_0, table){
    if(obj_0) return obj_0;
    var obj = caml_obj_block(Stdlib_Obj[10], table[1]);
    obj[1] = table[2];
    return caml_set_oo_id(obj);
   }
   function iter_f(obj, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var l = param$0[2], f = param$0[1];
     caml_call1(f, obj);
     param$0 = l;
    }
   }
   function run_initializers(obj, table){
    var inits = table[8], _r_ = 0 !== inits ? 1 : 0;
    return _r_ ? iter_f(obj, inits) : _r_;
   }
   function run_initializers_opt(obj_0, obj, table){
    if(obj_0) return obj;
    var inits = table[8];
    if(0 !== inits) iter_f(obj, inits);
    return obj;
   }
   function create_object_and_run_initiali(obj_0, table){
    if(obj_0) return obj_0;
    var obj = create_object(table);
    run_initializers(obj, table);
    return obj;
   }
   function get_data(param){
    if(param) return param[2];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function build_path(n, keys, tables){
    var res = [0, 0, 0, 0], r = [0, res], _o_ = 0;
    if(n >= 0){
     var i = _o_;
     for(;;){
      var _p_ = r[1];
      r[1] = [0, caml_check_bound(keys, i)[1 + i], _p_, 0];
      var _q_ = i + 1 | 0;
      if(n === i) break;
      i = _q_;
     }
    }
    var v = r[1];
    if(! tables)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    tables[2] = v;
    return res;
   }
   function lookup_tables(root, keys){
    var root_data = get_data(root);
    if(! root_data) return build_path(keys.length - 2 | 0, keys, root);
    var i$1 = keys.length - 2 | 0, i = i$1, tables$0 = root_data;
    for(;;){
     if(0 > i) return tables$0;
     var key = caml_check_bound(keys, i)[1 + i], tables$1 = tables$0;
     for(;;){
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      if(tables$1[1] === key) break;
      if(! tables$1)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
      var tables = tables$1[3];
      if(! tables){
       var next = [0, key, 0, 0];
       if(! tables$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       tables$1[3] = next;
       return build_path(i - 1 | 0, keys, next);
      }
      tables$1 = tables;
     }
     var tables_data = get_data(tables$1);
     if(! tables_data)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     var i$0 = i - 1 | 0;
     i = i$0;
     tables$0 = tables_data;
    }
   }
   function new_cache(table){
    var n = new_method(table);
    a:
    {
     if(0 !== (n % 2 | 0)){
      var _n_ = Stdlib_Sys[9];
      if
       ((2 + caml_div(caml_check_bound(table[2], 1)[2] * 16 | 0, _n_) | 0)
        >= n){
       var n$0 = new_method(table);
       break a;
      }
     }
     var n$0 = n;
    }
    caml_check_bound(table[2], n$0)[1 + n$0] = 0;
    return n$0;
   }
   function set_methods(table, methods){
    var len = methods.length - 1, i = [0, 0];
    for(;;){
     if(i[1] >= len) return 0;
     var
      _h_ = i[1],
      label = caml_check_bound(methods, _h_)[1 + _h_],
      next =
        function(param){
         i[1]++;
         var _m_ = i[1];
         return caml_check_bound(methods, _m_)[1 + _m_];
        },
      clo = next(0);
     if(typeof clo === "number")
      switch(clo){
        case 0:
         var x = next(0);
         let x$20 = x;
         var clo$0 = function(obj){return x$20;};
         break;
        case 1:
         var n = next(0);
         let n$38 = n;
         var clo$0 = function(obj){return obj[1 + n$38];};
         break;
        case 2:
         var e = next(0), n$0 = next(0);
         let e$10 = e, n$37 = n$0;
         var clo$0 = function(obj){return obj[1 + e$10][1 + n$37];};
         break;
        case 3:
         var n$1 = next(0);
         let n$36 = n$1;
         var clo$0 = function(obj){return caml_call1(obj[1][1 + n$36], obj);};
         break;
        case 4:
         var n$2 = next(0);
         let n$35 = n$2;
         var clo$0 = function(obj, x){obj[1 + n$35] = x; return 0;};
         break;
        case 5:
         var f = next(0), x$0 = next(0);
         let f$20 = f, x$19 = x$0;
         var clo$0 = function(obj){return caml_call1(f$20, x$19);};
         break;
        case 6:
         var f$0 = next(0), n$3 = next(0);
         let f$19 = f$0, n$34 = n$3;
         var clo$0 = function(obj){return caml_call1(f$19, obj[1 + n$34]);};
         break;
        case 7:
         var f$1 = next(0), e$0 = next(0), n$4 = next(0);
         let f$18 = f$1, e$9 = e$0, n$33 = n$4;
         var
          clo$0 =
            function(obj){return caml_call1(f$18, obj[1 + e$9][1 + n$33]);};
         break;
        case 8:
         var f$2 = next(0), n$5 = next(0);
         let f$17 = f$2, n$32 = n$5;
         var
          clo$0 =
            function(obj){
             return caml_call1(f$17, caml_call1(obj[1][1 + n$32], obj));
            };
         break;
        case 9:
         var f$3 = next(0), x$1 = next(0), y = next(0);
         let f$16 = f$3, x$18 = x$1, y$0 = y;
         var clo$0 = function(obj){return caml_call2(f$16, x$18, y$0);};
         break;
        case 10:
         var f$4 = next(0), x$2 = next(0), n$6 = next(0);
         let f$15 = f$4, x$17 = x$2, n$31 = n$6;
         var
          clo$0 = function(obj){return caml_call2(f$15, x$17, obj[1 + n$31]);};
         break;
        case 11:
         var f$5 = next(0), x$3 = next(0), e$1 = next(0), n$7 = next(0);
         let f$14 = f$5, x$16 = x$3, e$8 = e$1, n$30 = n$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$14, x$16, obj[1 + e$8][1 + n$30]);
            };
         break;
        case 12:
         var f$6 = next(0), x$4 = next(0), n$8 = next(0);
         let f$13 = f$6, x$15 = x$4, n$29 = n$8;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$13, x$15, caml_call1(obj[1][1 + n$29], obj));
            };
         break;
        case 13:
         var f$7 = next(0), n$9 = next(0), x$5 = next(0);
         let f$12 = f$7, n$28 = n$9, x$14 = x$5;
         var
          clo$0 = function(obj){return caml_call2(f$12, obj[1 + n$28], x$14);};
         break;
        case 14:
         var f$8 = next(0), e$2 = next(0), n$10 = next(0), x$6 = next(0);
         let f$11 = f$8, e$7 = e$2, n$27 = n$10, x$13 = x$6;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$11, obj[1 + e$7][1 + n$27], x$13);
            };
         break;
        case 15:
         var f$9 = next(0), n$11 = next(0), x$7 = next(0);
         let f$10 = f$9, n$26 = n$11, x$12 = x$7;
         var
          clo$0 =
            function(obj){
             return caml_call2(f$10, caml_call1(obj[1][1 + n$26], obj), x$12);
            };
         break;
        case 16:
         var n$12 = next(0), x$8 = next(0);
         let n$25 = n$12, x$11 = x$8;
         var
          clo$0 =
            function(obj){return caml_call2(obj[1][1 + n$25], obj, x$11);};
         break;
        case 17:
         var n$13 = next(0), m = next(0);
         let n$24 = n$13, m$12 = m;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$24], obj, obj[1 + m$12]);
            };
         break;
        case 18:
         var n$14 = next(0), e$3 = next(0), m$0 = next(0);
         let n$23 = n$14, e$6 = e$3, m$11 = m$0;
         var
          clo$0 =
            function(obj){
             return caml_call2(obj[1][1 + n$23], obj, obj[1 + e$6][1 + m$11]);
            };
         break;
        case 19:
         var n$15 = next(0), m$1 = next(0);
         let n$22 = n$15, m$10 = m$1;
         var
          clo$0 =
            function(obj){
             var _l_ = caml_call1(obj[1][1 + m$10], obj);
             return caml_call2(obj[1][1 + n$22], obj, _l_);
            };
         break;
        case 20:
         var m$2 = next(0), x$9 = next(0);
         new_cache(table);
         let m$9 = m$2, x$10 = x$9;
         var
          clo$0 =
            function(obj){
             return caml_call1(caml_get_public_method(x$10, m$9, 0), x$10);
            };
         break;
        case 21:
         var m$3 = next(0), n$16 = next(0);
         new_cache(table);
         let m$8 = m$3, n$21 = n$16;
         var
          clo$0 =
            function(obj){
             var _k_ = obj[1 + n$21];
             return caml_call1(caml_get_public_method(_k_, m$8, 0), _k_);
            };
         break;
        case 22:
         var m$4 = next(0), e$4 = next(0), n$17 = next(0);
         new_cache(table);
         let m$7 = m$4, e$5 = e$4, n$20 = n$17;
         var
          clo$0 =
            function(obj){
             var _j_ = obj[1 + e$5][1 + n$20];
             return caml_call1(caml_get_public_method(_j_, m$7, 0), _j_);
            };
         break;
        default:
         var m$5 = next(0), n$18 = next(0);
         new_cache(table);
         let m$6 = m$5, n$19 = n$18;
         var
          clo$0 =
            function(obj){
             var _i_ = caml_call1(obj[1][1 + n$19], obj);
             return caml_call1(caml_get_public_method(_i_, m$6, 0), _i_);
            };
      }
     else
      var clo$0 = clo;
     set_method(table, label, clo$0);
     i[1]++;
    }
   }
   function stats(param){
    return [0, table_count[1], method_count[1], inst_var_count[1]];
   }
   var
    CamlinternalOO =
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params,
       stats];
   runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Oo
//# unitInfo: Requires: CamlinternalOO
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    CamlinternalOO = global_data.CamlinternalOO,
    copy = CamlinternalOO[22],
    new_method = CamlinternalOO[1],
    public_method_label = CamlinternalOO[1],
    Stdlib_Oo = [0, copy, new_method, public_method_label];
   runtime.caml_register_global(1, Stdlib_Oo, "Stdlib__Oo");
   return;
  }
  (globalThis));

//# unitInfo: Provides: CamlinternalMod
//# unitInfo: Requires: CamlinternalLazy, CamlinternalOO, Stdlib, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_camlinternalMod_ml = "camlinternalMod.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    CamlinternalOO = global_data.CamlinternalOO,
    Assert_failure = global_data.Assert_failure,
    cst_CamlinternalMod_init_mod_n = "CamlinternalMod.init_mod: not a module",
    _a_ = [0, cst_camlinternalMod_ml, 72, 5],
    _b_ = [0, cst_camlinternalMod_ml, 81, 2],
    cst_CamlinternalMod_update_mod =
      "CamlinternalMod.update_mod: not a module";
   function init_mod_block(loc, comps$0){
    var
     length = comps$0.length - 1,
     modu = runtime.caml_obj_block(0, length),
     _h_ = length - 1 | 0,
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var shape = caml_check_bound(comps$0, i)[1 + i];
      if(typeof shape === "number")
       switch(shape){
         case 0:
          let i$1 = i;
          var
           fn =
             function(x){
              var fn = modu[1 + i$1];
              if(fn$0 === fn)
               throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
              return caml_call1(fn, x);
             };
          let fn$0 = fn;
          var init = fn;
          break;
         case 1:
          var l = [];
          let l$0 = l, i$0 = i;
          runtime.caml_update_dummy
           (l,
            [246,
             function(param){
              var l = modu[1 + i$0];
              if(l$0 === l)
               throw caml_maybe_attach_backtrace([0, Stdlib[15], loc], 1);
              var _j_ = caml_obj_tag(l);
              if(250 === _j_) return l[1];
              if(246 !== _j_ && 244 !== _j_) return l;
              return caml_call1(CamlinternalLazy[2], l);
             }]);
          var init = l;
          break;
         default: var init = caml_call1(CamlinternalOO[21], loc);
       }
      else if(0 === shape[0])
       var comps = shape[1], init = init_mod_block(loc, comps);
      else
       var v = shape[1], init = v;
      modu[1 + i] = init;
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      i = _i_;
     }
    }
    return modu;
   }
   function init_mod(loc, shape){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return init_mod_block(loc, comps);
    }
    return caml_call1(Stdlib[2], cst_CamlinternalMod_init_mod_n);
   }
   function update_mod_block(comps$0, modu, n){
    if(0 === caml_obj_tag(n) && comps$0.length - 1 <= n.length - 1){
     var _e_ = comps$0.length - 2 | 0, _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var n$0 = n[1 + i], shape = caml_check_bound(comps$0, i)[1 + i];
       a:
       if(typeof shape === "number"){
        if(2 === shape){
         if(0 === caml_obj_tag(n$0) && 4 === n$0.length - 1){
          var cl = modu[1 + i], j = 0;
          for(;;){
           cl[1 + j] = n$0[1 + j];
           var _c_ = j + 1 | 0;
           if(3 === j) break;
           j = _c_;
          }
          break a;
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        modu[1 + i] = n$0;
       }
       else if(0 === shape[0]){
        var comps = shape[1];
        update_mod_block(comps, modu[1 + i], n$0);
       }
       var _f_ = i + 1 | 0;
       if(_e_ === i) break;
       i = _f_;
      }
     }
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function update_mod(shape, o, n){
    if(typeof shape !== "number" && 0 === shape[0]){
     var comps = shape[1];
     return update_mod_block(comps, o, n);
    }
    return caml_call1(Stdlib[2], cst_CamlinternalMod_update_mod);
   }
   var CamlinternalMod = [0, init_mod, update_mod];
   runtime.caml_register_global(8, CamlinternalMod, "CamlinternalMod");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Ephemeron
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Obj, Stdlib__Random, Stdlib__Seq, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    _c_ = [0, 0],
    _b_ = [0, 0],
    _a_ = [0, 0],
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random;
   function MakeSeeded(H){
    var
     prng = [246, function(_at_){return caml_call1(Stdlib_Random[19][2], 0);}];
    function create(opt, initial_size){
     var random = opt ? opt[1] : caml_call1(Stdlib_Hashtbl[17], 0);
     a:
     b:
     {
      var x = 16;
      for(;;){
       if(initial_size <= x) break b;
       if(Stdlib_Sys[13] < (x * 2 | 0)) break;
       var x$0 = x * 2 | 0;
       x = x$0;
      }
      break a;
     }
     if(random){
      var _ar_ = runtime.caml_obj_tag(prng);
      a:
      if(250 === _ar_)
       var _as_ = prng[1];
      else{
       if(246 !== _ar_ && 244 !== _ar_){var _as_ = prng; break a;}
       var _as_ = caml_call1(CamlinternalLazy[2], prng);
      }
      var seed = caml_call1(Stdlib_Random[19][4], _as_);
     }
     else
      var seed = 0;
     return [0, 0, caml_make_vect(x, 0), seed, x];
    }
    function clear(h){
     h[1] = 0;
     var len = h[2].length - 1, _ap_ = len - 1 | 0, _ao_ = 0;
     if(_ap_ >= 0){
      var i = _ao_;
      for(;;){
       caml_check_bound(h[2], i)[1 + i] = 0;
       var _aq_ = i + 1 | 0;
       if(_ap_ === i) break;
       i = _aq_;
      }
     }
     return 0;
    }
    function reset(h){
     var len = h[2].length - 1;
     return len === h[4]
             ? clear(h)
             : (h[1] = 0, h[2] = caml_make_vect(h[4], 0), 0);
    }
    function copy(h){
     var _al_ = h[4], _am_ = h[3], _an_ = caml_call1(Stdlib_Array[7], h[2]);
     return [0, h[1], _an_, _am_, _al_];
    }
    function key_index(h, hkey){return hkey & (h[2].length - 2 | 0);}
    function clean(h){
     function do_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hkey = param$0[1], rest = param$0[3], c = param$0[2];
       if(caml_call1(H[6], c)){
        var rest$0 = param$0[3], c$0 = param$0[2];
        return [0, hkey, c$0, do_bucket(rest$0)];
       }
       h[1] = h[1] - 1 | 0;
       param$0 = rest;
      }
     }
     var d = h[2], _aj_ = d.length - 2 | 0, _ai_ = 0;
     if(_aj_ >= 0){
      var i = _ai_;
      for(;;){
       d[1 + i] = do_bucket(caml_check_bound(d, i)[1 + i]);
       var _ak_ = i + 1 | 0;
       if(_aj_ === i) break;
       i = _ak_;
      }
     }
     return 0;
    }
    function resize(h){
     var odata = h[2], osize = odata.length - 1, nsize = osize * 2 | 0;
     clean(h);
     var
      _ac_ = nsize < Stdlib_Sys[13] ? 1 : 0,
      _ad_ = _ac_ ? (osize >>> 1 | 0) <= h[1] ? 1 : 0 : _ac_;
     if(_ad_){
      var ndata = caml_make_vect(nsize, 0);
      h[2] = ndata;
      var
       insert_bucket =
         function(param){
          if(! param) return;
          var rest = param[3], data = param[2], hkey = param[1];
          insert_bucket(rest);
          var nidx = key_index(h, hkey);
          ndata[1 + nidx] =
           [0, hkey, data, caml_check_bound(ndata, nidx)[1 + nidx]];
          return;
         },
       _af_ = osize - 1 | 0,
       _ae_ = 0;
      if(_af_ >= 0){
       var i = _ae_;
       for(;;){
        insert_bucket(caml_check_bound(odata, i)[1 + i]);
        var _ah_ = i + 1 | 0;
        if(_af_ === i) break;
        i = _ah_;
       }
      }
      var _ag_ = 0;
     }
     else
      var _ag_ = _ad_;
     return _ag_;
    }
    function add(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      container = caml_call2(H[1], key, info),
      bucket = [0, hkey, container, caml_check_bound(h[2], i)[1 + i]];
     caml_check_bound(h[2], i)[1 + i] = bucket;
     h[1] = h[1] + 1 | 0;
     var _ab_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
     return _ab_ ? resize(h) : _ab_;
    }
    function remove(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function remove_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hk = param$0[1], next = param$0[3], c = param$0[2];
       if(hkey !== hk){
        var next$0 = param$0[3], c$0 = param$0[2];
        return [0, hk, c$0, remove_bucket(next$0)];
       }
       switch(caml_call2(H[3], c, key)){
         case 0:
          h[1] = h[1] - 1 | 0; return next;
         case 1:
          return [0, hk, c, remove_bucket(next)];
         default: h[1] = h[1] - 1 | 0; param$0 = next;
       }
      }
     }
     var
      i = key_index(h, hkey),
      _aa_ = remove_bucket(caml_check_bound(h[2], i)[1 + i]);
     caml_check_bound(h[2], i)[1 + i] = _aa_;
     return 0;
    }
    function find(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      _$_ = key_index(h, hkey),
      param = caml_check_bound(h[2], _$_)[1 + _$_];
     for(;;){
      if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       switch(caml_call2(H[3], c, key)){
         case 0:
          var match = caml_call1(H[4], c);
          if(match){var d = match[1]; return d;}
          param = rest;
          break;
         case 1:
          param = rest; break;
         default: param = rest;
       }
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function find_opt(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      ___ = key_index(h, hkey),
      param = caml_check_bound(h[2], ___)[1 + ___];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hkey === hk)
       switch(caml_call2(H[3], c, key)){
         case 0:
          var d = caml_call1(H[4], c); if(d) return d; param = rest; break;
         case 1:
          param = rest; break;
         default: param = rest;
       }
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function find_all(h, key){
     var hkey = caml_call2(H[2], h[3], key);
     function find_in_bucket(param){
      var param$0 = param;
      for(;;){
       if(! param$0) return 0;
       var hk = param$0[1], rest = param$0[3], c = param$0[2];
       if(hkey === hk)
        switch(caml_call2(H[3], c, key)){
          case 0:
           var match = caml_call1(H[4], c);
           if(match){var d = match[1]; return [0, d, find_in_bucket(rest)];}
           param$0 = rest;
           break;
          case 1:
           param$0 = rest; break;
          default: param$0 = rest;
        }
       else{var rest$0 = param$0[3]; param$0 = rest$0;}
      }
     }
     var _Z_ = key_index(h, hkey);
     return find_in_bucket(caml_check_bound(h[2], _Z_)[1 + _Z_]);
    }
    function replace(h, key, info){
     var
      hkey = caml_call2(H[2], h[3], key),
      i = key_index(h, hkey),
      l = caml_check_bound(h[2], i)[1 + i];
     try{
      var param = l;
      for(;;){
       if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var hk = param[1], next = param[3], c = param[2];
       if(hkey === hk){
        if(! caml_call2(H[3], c, key)){
         var _V_ = caml_call3(H[5], c, key, info);
         return _V_;
        }
        param = next;
       }
       else{var next$0 = param[3]; param = next$0;}
      }
     }
     catch(_Y_){
      var _W_ = caml_wrap_exception(_Y_);
      if(_W_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_W_, 0);
      var container = caml_call2(H[1], key, info);
      caml_check_bound(h[2], i)[1 + i] = [0, hkey, container, l];
      h[1] = h[1] + 1 | 0;
      var _X_ = h[2].length - 1 << 1 < h[1] ? 1 : 0;
      return _X_ ? resize(h) : _X_;
     }
    }
    function mem(h, key){
     var
      hkey = caml_call2(H[2], h[3], key),
      _U_ = key_index(h, hkey),
      param = caml_check_bound(h[2], _U_)[1 + _U_];
     for(;;){
      if(! param) return 0;
      var hk = param[1], rest = param[3], c = param[2];
      if(hk === hkey){
       if(! caml_call2(H[3], c, key)) return 1;
       param = rest;
      }
      else{var rest$0 = param[3]; param = rest$0;}
     }
    }
    function length(h){return h[1];}
    function bucket_length(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(! param$0) return accu$0;
      var rest = param$0[3], accu$1 = accu$0 + 1 | 0;
      accu$0 = accu$1;
      param$0 = rest;
     }
    }
    function stats(h){
     var
      mbl =
        caml_call3
         (Stdlib_Array[18],
          function(m, b){
           var _T_ = bucket_length(0, b);
           return caml_call2(Stdlib_Int[11], m, _T_);
          },
          0,
          h[2]),
      histo = caml_make_vect(mbl + 1 | 0, 0);
     caml_call2
      (Stdlib_Array[12],
       function(b){
        var l = bucket_length(0, b);
        histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
        return 0;
       },
       h[2]);
     return [0, h[1], h[2].length - 1, mbl, histo];
    }
    function bucket_length_alive(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(! param$0) return accu$0;
      var rest = param$0[3], c = param$0[2];
      if(caml_call1(H[6], c)){
       var accu$1 = accu$0 + 1 | 0;
       accu$0 = accu$1;
       param$0 = rest;
      }
      else{var rest$0 = param$0[3]; param$0 = rest$0;}
     }
    }
    function stats_alive(h){
     var
      size = [0, 0],
      mbl =
        caml_call3
         (Stdlib_Array[18],
          function(m, b){
           var _S_ = bucket_length_alive(0, b);
           return caml_call2(Stdlib_Int[11], m, _S_);
          },
          0,
          h[2]),
      histo = caml_make_vect(mbl + 1 | 0, 0);
     caml_call2
      (Stdlib_Array[12],
       function(b){
        var l = bucket_length_alive(0, b);
        size[1] = size[1] + l | 0;
        histo[1 + l] = caml_check_bound(histo, l)[1 + l] + 1 | 0;
        return 0;
       },
       h[2]);
     return [0, size[1], h[2].length - 1, mbl, histo];
    }
    function add_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return add(tbl, k, v);
              },
              i);
    }
    function replace_seq(tbl, i){
     return caml_call2
             (Stdlib_Seq[4],
              function(param){
               var v = param[2], k = param[1];
               return replace(tbl, k, v);
              },
              i);
    }
    function of_seq(i){
     var tbl = create(0, 16);
     replace_seq(tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function create(param){return caml_call1(Stdlib_Obj[23][1], 1);}
   function get_key(t){var x = caml_call2(Stdlib_Obj[23][3], t, 0); return x;}
   function set_key(t, k){return caml_call3(Stdlib_Obj[23][5], t, 0, k);}
   function check_key(t){return caml_call2(Stdlib_Obj[23][7], t, 0);}
   function get_data(t){var x = caml_call1(Stdlib_Obj[23][9], t); return x;}
   function set_data(t, d){return caml_call2(Stdlib_Obj[23][11], t, d);}
   function make(key, data){
    var eph = create(0);
    set_data(eph, data);
    set_key(eph, key);
    return eph;
   }
   function query(eph, key){
    var match = get_key(eph);
    if(! match) return 0;
    var k = match[1];
    return k === key ? get_data(eph) : 0;
   }
   function MakeSeeded$0(H){
    function create$0(k, d){
     var c = create(0);
     set_data(c, d);
     set_key(c, k);
     return c;
    }
    var seeded_hash = H[2];
    function equal(c, k){
     var match = get_key(c);
     if(! match) return 2;
     var k$0 = match[1];
     return caml_call2(H[1], k, k$0) ? 0 : 1;
    }
    function set_key_data(c, k, d){
     caml_call1(Stdlib_Obj[23][12], c);
     set_key(c, k);
     return set_data(c, d);
    }
    return MakeSeeded
            ([0,
              create$0,
              seeded_hash,
              equal,
              get_data,
              set_key_data,
              check_key]);
   }
   function Make(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$0([0, equal, seeded_hash]),
     _R_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18];
    function create(sz){return caml_call2(_R_, _a_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_R_, _a_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$0(param){return [0, 0];}
   function add(b, k, d){
    var _Q_ = b[1];
    b[1] = [0, make(k, d), _Q_];
    return 0;
   }
   function test_key(k, e){
    var match = get_key(e);
    if(match){var x = match[1]; if(x === k) return 1;}
    return 0;
   }
   function remove(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_key(k, h)){b[1] = caml_call2(Stdlib_List[13], acc, t); return 0;}
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find(b, k){
    var
     match =
       caml_call2
        (Stdlib_List[40], function(_P_){return test_key(k, _P_);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data(e);
   }
   function length(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear(b){b[1] = 0; return 0;}
   function create$0(param){return caml_call1(Stdlib_Obj[23][1], 2);}
   function get_key1(t){
    var x = caml_call2(Stdlib_Obj[23][3], t, 0);
    return x;
   }
   function set_key1(t, k){return caml_call3(Stdlib_Obj[23][5], t, 0, k);}
   function get_key2(t){
    var x = caml_call2(Stdlib_Obj[23][3], t, 1);
    return x;
   }
   function set_key2(t, k){return caml_call3(Stdlib_Obj[23][5], t, 1, k);}
   function get_data$0(t){var x = caml_call1(Stdlib_Obj[23][9], t); return x;}
   function set_data$0(t, d){return caml_call2(Stdlib_Obj[23][11], t, d);}
   function make$1(key1, key2, data){
    var eph = create$0(0);
    set_data$0(eph, data);
    set_key1(eph, key1);
    set_key2(eph, key2);
    return eph;
   }
   function query$0(eph, key1, key2){
    var match = get_key1(eph);
    if(! match) return 0;
    var k = match[1];
    if(k !== key1) return 0;
    var match$0 = get_key2(eph);
    if(! match$0) return 0;
    var k$0 = match$0[1];
    return k$0 === key2 ? get_data$0(eph) : 0;
   }
   function MakeSeeded$1(H1, H2){
    function create(param, d){
     var k2 = param[2], k1 = param[1], c = create$0(0);
     set_data$0(c, d);
     set_key1(c, k1);
     set_key2(c, k2);
     return c;
    }
    function seeded_hash(seed, param){
     var
      k2 = param[2],
      k1 = param[1],
      _O_ = caml_call2(H2[2], seed, k2) * 65599 | 0;
     return caml_call2(H1[2], seed, k1) + _O_ | 0;
    }
    function equal(c, param){
     var
      k2 = param[2],
      k1 = param[1],
      match = get_key1(c),
      match$0 = get_key2(c);
     if(match && match$0){
      var k2$0 = match$0[1], k1$0 = match[1];
      if(caml_call2(H1[1], k1, k1$0) && caml_call2(H2[1], k2, k2$0)) return 0;
      return 1;
     }
     return 2;
    }
    function set_key_data(c, param, d){
     var k2 = param[2], k1 = param[1];
     caml_call1(Stdlib_Obj[23][12], c);
     set_key1(c, k1);
     set_key2(c, k2);
     return set_data$0(c, d);
    }
    function check_key(c){
     var _N_ = caml_call2(Stdlib_Obj[23][7], c, 0);
     return _N_ ? caml_call2(Stdlib_Obj[23][7], c, 1) : _N_;
    }
    return MakeSeeded
            ([0,
              create,
              seeded_hash,
              equal,
              get_data$0,
              set_key_data,
              check_key]);
   }
   function Make$0(H1, H2){
    var equal = H2[1];
    function seeded_hash(seed, x){return caml_call1(H2[2], x);}
    var equal$0 = H1[1];
    function seeded_hash$0(seed, x){return caml_call1(H1[2], x);}
    var
     include =
       MakeSeeded$1([0, equal$0, seeded_hash$0], [0, equal, seeded_hash]),
     _M_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18];
    function create(sz){return caml_call2(_M_, _b_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_M_, _b_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$2(param){return [0, 0];}
   function add$0(b, k1, k2, d){
    var _L_ = b[1];
    b[1] = [0, make$1(k1, k2, d), _L_];
    return 0;
   }
   function test_keys(k1, k2, e){
    var match = get_key1(e), match$0 = get_key2(e);
    if(match && match$0){
     var x2 = match$0[1], x1 = match[1];
     if(x1 === k1 && x2 === k2) return 1;
    }
    return 0;
   }
   function remove$0(b, k1, k2){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys(k1, k2, h)){
      b[1] = caml_call2(Stdlib_List[13], acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find$0(b, k1, k2){
    var
     match =
       caml_call2
        (Stdlib_List[40], function(_K_){return test_keys(k1, k2, _K_);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data$0(e);
   }
   function length$0(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear$0(b){b[1] = 0; return 0;}
   function create$1(n){return caml_call1(Stdlib_Obj[23][1], n);}
   function length$1(k){return caml_call1(Stdlib_Obj[23][2], k);}
   function get_key$0(t, n){
    var x = caml_call2(Stdlib_Obj[23][3], t, n);
    return x;
   }
   function set_key$0(t, n, k){return caml_call3(Stdlib_Obj[23][5], t, n, k);}
   function get_data$1(t){var x = caml_call1(Stdlib_Obj[23][9], t); return x;}
   function set_data$1(t, d){return caml_call2(Stdlib_Obj[23][11], t, d);}
   function make$3(keys, data){
    var l = keys.length - 1, eph = create$1(l);
    set_data$1(eph, data);
    var _I_ = l - 1 | 0, _H_ = 0;
    if(_I_ >= 0){
     var i = _H_;
     for(;;){
      set_key$0(eph, i, caml_check_bound(keys, i)[1 + i]);
      var _J_ = i + 1 | 0;
      if(_I_ === i) break;
      i = _J_;
     }
    }
    return eph;
   }
   function query$1(eph, keys){
    var l = length$1(eph);
    try{
     if(l !== keys.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var _D_ = l - 1 | 0, _C_ = 0;
     if(_D_ >= 0){
      var i = _C_;
      for(;;){
       var match = get_key$0(eph, i);
       if(! match) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var k = match[1];
       if(k !== caml_check_bound(keys, i)[1 + i])
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var _F_ = i + 1 | 0;
       if(_D_ === i) break;
       i = _F_;
      }
     }
     var _E_ = get_data$1(eph);
     return _E_;
    }
    catch(_G_){
     var _B_ = caml_wrap_exception(_G_);
     if(_B_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_B_, 0);
    }
   }
   function MakeSeeded$2(H){
    function create(k, d){
     var c = create$1(k.length - 1);
     set_data$1(c, d);
     var _z_ = k.length - 2 | 0, _y_ = 0;
     if(_z_ >= 0){
      var i = _y_;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[1 + i]);
       var _A_ = i + 1 | 0;
       if(_z_ === i) break;
       i = _A_;
      }
     }
     return c;
    }
    function seeded_hash(seed, k){
     var h = [0, 0], _u_ = k.length - 2 | 0, _t_ = 0;
     if(_u_ >= 0){
      var i = _t_;
      for(;;){
       var _v_ = h[1], _w_ = caml_check_bound(k, i)[1 + i];
       h[1] = (caml_call2(H[2], seed, _w_) * 65599 | 0) + _v_ | 0;
       var _x_ = i + 1 | 0;
       if(_u_ === i) break;
       i = _x_;
      }
     }
     return h[1];
    }
    function equal(c, k){
     var len = k.length - 1, len$0 = length$1(c);
     if(len !== len$0) return 1;
     var i$1 = len - 1 | 0, i = i$1;
     for(;;){
      if(0 > i) return 0;
      var match = get_key$0(c, i);
      if(! match) return 2;
      var ki = match[1], _s_ = caml_check_bound(k, i)[1 + i];
      if(! caml_call2(H[1], _s_, ki)) return 1;
      var i$0 = i - 1 | 0;
      i = i$0;
     }
    }
    function set_key_data(c, k, d){
     caml_call1(Stdlib_Obj[23][12], c);
     var _q_ = k.length - 2 | 0, _p_ = 0;
     if(_q_ >= 0){
      var i = _p_;
      for(;;){
       set_key$0(c, i, caml_check_bound(k, i)[1 + i]);
       var _r_ = i + 1 | 0;
       if(_q_ === i) break;
       i = _r_;
      }
     }
     return set_data$1(c, d);
    }
    function check_key(c){
     var i$1 = length$1(c) - 1 | 0, i = i$1;
     for(;;){
      var _n_ = i < 0 ? 1 : 0;
      if(_n_)
       var _o_ = _n_;
      else{
       var _m_ = caml_call2(Stdlib_Obj[23][7], c, i);
       if(_m_){var i$0 = i - 1 | 0; i = i$0; continue;}
       var _o_ = _m_;
      }
      return _o_;
     }
    }
    return MakeSeeded
            ([0,
              create,
              seeded_hash,
              equal,
              get_data$1,
              set_key_data,
              check_key]);
   }
   function Make$1(H){
    var equal = H[1];
    function seeded_hash(seed, x){return caml_call1(H[2], x);}
    var
     include = MakeSeeded$2([0, equal, seeded_hash]),
     _l_ = include[1],
     clear = include[2],
     reset = include[3],
     copy = include[4],
     add = include[5],
     remove = include[6],
     find = include[7],
     find_opt = include[8],
     find_all = include[9],
     replace = include[10],
     mem = include[11],
     length = include[12],
     stats = include[13],
     add_seq = include[14],
     replace_seq = include[15],
     clean = include[17],
     stats_alive = include[18];
    function create(sz){return caml_call2(_l_, _c_, sz);}
    function of_seq(i){
     var tbl = caml_call2(_l_, _c_, 16);
     caml_call2(replace_seq, tbl, i);
     return tbl;
    }
    return [0,
            create,
            clear,
            reset,
            copy,
            add,
            remove,
            find,
            find_opt,
            find_all,
            replace,
            mem,
            length,
            stats,
            add_seq,
            replace_seq,
            of_seq,
            clean,
            stats_alive];
   }
   function make$4(param){return [0, 0];}
   function add$1(b, k, d){
    var _k_ = b[1];
    b[1] = [0, make$3(k, d), _k_];
    return 0;
   }
   function test_keys$0(k, e){
    try{
     if(length$1(e) !== k.length - 1)
      throw caml_maybe_attach_backtrace(Stdlib[3], 1);
     var _g_ = k.length - 2 | 0, _f_ = 0;
     if(_g_ >= 0){
      var i = _f_;
      for(;;){
       var match = get_key$0(e, i);
       if(match){
        var x = match[1];
        if(x === caml_check_bound(k, i)[1 + i]){
         var _i_ = i + 1 | 0;
         if(_g_ === i) break;
         i = _i_;
         continue;
        }
       }
       throw caml_maybe_attach_backtrace(Stdlib[3], 1);
      }
     }
     var _h_ = 1;
     return _h_;
    }
    catch(_j_){
     var _e_ = caml_wrap_exception(_j_);
     if(_e_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_e_, 0);
    }
   }
   function remove$1(b, k){
    var l$0 = b[1], l = l$0, acc = 0;
    for(;;){
     if(! l) return 0;
     var h = l[1], t = l[2];
     if(test_keys$0(k, h)){
      b[1] = caml_call2(Stdlib_List[13], acc, t);
      return 0;
     }
     var t$0 = l[2], acc$0 = [0, h, acc];
     l = t$0;
     acc = acc$0;
    }
   }
   function find$1(b, k){
    var
     match =
       caml_call2
        (Stdlib_List[40], function(_d_){return test_keys$0(k, _d_);}, b[1]);
    if(! match) return 0;
    var e = match[1];
    return get_data$1(e);
   }
   function length$2(b){return caml_call1(Stdlib_List[1], b[1]);}
   function clear$1(b){b[1] = 0; return 0;}
   var
    Stdlib_Ephemeron =
      [0,
       [0,
        make,
        query,
        Make,
        MakeSeeded$0,
        [0, make$0, add, remove, find, length, clear]],
       [0,
        make$1,
        query$0,
        Make$0,
        MakeSeeded$1,
        [0, make$2, add$0, remove$0, find$0, length$0, clear$0]],
       [0,
        make$3,
        query$1,
        Make$1,
        MakeSeeded$2,
        [0, make$4, add$1, remove$1, find$1, length$2, clear$1]]];
   runtime.caml_register_global(13, Stdlib_Ephemeron, "Stdlib__Ephemeron");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Filename
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Domain, Stdlib__List, Stdlib__Printf, Stdlib__Random, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$19 = "",
    cst$23 = " ",
    cst_2$1 = " 2>",
    cst_2_1$1 = " 2>&1",
    cst$22 = " <",
    cst$21 = " >",
    cst$20 = '"',
    cst$24 = ".",
    cst$25 = "..",
    cst$28 = "../",
    cst$27 = "./",
    cst$26 = "/",
    cst_dev_null = "/dev/null",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$18 = cst$19,
    cst$17 = cst$19,
    cst$16 = cst$19,
    cst$8 = cst$21,
    cst$15 = cst$19,
    cst$9 = cst$22,
    cst$14 = cst$19,
    cst$10 = cst$23,
    cst$11 = cst$23,
    cst$12 = cst$20,
    cst$13 = cst$19,
    cst$6 = cst$20,
    cst$7 = cst$19,
    cst$4 = cst$19,
    cst = cst$21,
    cst$3 = cst$19,
    cst$0 = cst$22,
    cst$2 = cst$19,
    cst$1 = cst$23,
    null$0 = cst_dev_null,
    current_dir_name = cst$24,
    parent_dir_name = cst$25,
    dir_sep = cst$26,
    quotequote = "'\\''",
    null$1 = "NUL",
    current_dir_name$0 = cst$24,
    parent_dir_name$0 = cst$25,
    dir_sep$0 = "\\",
    cst$5 = cst$24,
    null$2 = cst_dev_null,
    current_dir_name$1 = cst$24,
    parent_dir_name$1 = cst$25,
    dir_sep$1 = cst$26,
    Stdlib = global_data.Stdlib,
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Sys = global_data.Stdlib__Sys;
   function generic_basename(is_dir_sep, current_dir_name, name){
    if(name == cst$19) return current_dir_name;
    var n$3 = caml_ml_string_length(name) - 1 | 0, n = n$3;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    var p = n + 1 | 0, n$1 = n;
    for(;;){
     if(0 > n$1) return caml_call3(Stdlib_String[16], name, 0, p);
     if(caml_call2(is_dir_sep, name, n$1))
      return caml_call3
              (Stdlib_String[16], name, n$1 + 1 | 0, (p - n$1 | 0) - 1 | 0);
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
   }
   function generic_dirname(is_dir_sep, current_dir_name, name){
    if(name == cst$19) return current_dir_name;
    var n$5 = caml_ml_string_length(name) - 1 | 0, n = n$5;
    for(;;){
     if(0 > n) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n)) break;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
    var n$1 = n;
    for(;;){
     if(0 > n$1) return current_dir_name;
     if(caml_call2(is_dir_sep, name, n$1)) break;
     var n$2 = n$1 - 1 | 0;
     n$1 = n$2;
    }
    var n$3 = n$1;
    for(;;){
     if(0 > n$3) return caml_call3(Stdlib_String[16], name, 0, 1);
     if(! caml_call2(is_dir_sep, name, n$3))
      return caml_call3(Stdlib_String[16], name, 0, n$3 + 1 | 0);
     var n$4 = n$3 - 1 | 0;
     n$3 = n$4;
    }
   }
   function is_dir_sep(s, i){return 47 === caml_string_get(s, i) ? 1 : 0;}
   function is_relative(n){
    var
     _aH_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _aI_ = _aH_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    return _aI_;
   }
   function is_implicit(n){
    var _aC_ = is_relative(n);
    if(_aC_){
     var
      _aD_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _aE_ =
        _aD_ || (caml_call3(Stdlib_String[16], n, 0, 2) !== cst$27 ? 1 : 0);
     if(_aE_)
      var
       _aF_ = caml_ml_string_length(n) < 3 ? 1 : 0,
       _aG_ =
         _aF_ || (caml_call3(Stdlib_String[16], n, 0, 3) !== cst$28 ? 1 : 0);
     else
      var _aG_ = _aE_;
    }
    else
     var _aG_ = _aC_;
    return _aG_;
   }
   function check_suffix(name, suff){
    return caml_call2(Stdlib_String[12], suff, name);
   }
   function chop_suffix_opt(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var r = caml_call3(Stdlib_String[16], filename, len_f - len_s | 0, len_s);
    return r == suffix
            ? [0,
              caml_call3(Stdlib_String[16], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   var
    _h_ = [0, 7, 0],
    _g_ = [0, 1, [0, 3, [0, 5, 0]]],
    _f_ = [0, [2, 0, [4, 6, [0, 2, 6], 0, [2, 0, 0]]], "%s%06x%s"],
    cst_Filename_chop_extension = "Filename.chop_extension",
    cst_Filename_chop_suffix = "Filename.chop_suffix",
    _d_ = [0, cst$20, 0],
    cst_2_1$0 = cst_2_1$1,
    cst_2$0 = cst_2$1,
    cst_Filename_quote_command_bad = "Filename.quote_command: bad file name ",
    _c_ = [0, cst$20, 0],
    cst_2_1 = cst_2_1$1,
    cst_2 = cst_2$1,
    cst_tmp = "/tmp";
   try{var _j_ = caml_sys_getenv("TMPDIR"), temp_dir_name = _j_;}
   catch(_aB_){
    var _a_ = caml_wrap_exception(_aB_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var temp_dir_name = cst_tmp;
   }
   function quote(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 39);
    var _ay_ = l - 1 | 0, _ax_ = 0;
    if(_ay_ >= 0){
     var i = _ax_;
     for(;;){
      if(39 === caml_string_get(s, i))
       caml_call2(Stdlib_Buffer[16], b, quotequote);
      else{
       var _aA_ = caml_string_get(s, i);
       caml_call2(Stdlib_Buffer[12], b, _aA_);
      }
      var _az_ = i + 1 | 0;
      if(_ay_ === i) break;
      i = _az_;
     }
    }
    caml_call2(Stdlib_Buffer[12], b, 39);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_command(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _am_ = cst_2_1;
     else
      var _aw_ = quote(f), _am_ = caml_call2(Stdlib[28], cst_2, _aw_);
     var _an_ = _am_;
    }
    else
     var _an_ = cst$4;
    if(stdout)
     var
      f$0 = stdout[1],
      _ao_ = quote(f$0),
      _ap_ = caml_call2(Stdlib[28], cst, _ao_);
    else
     var _ap_ = cst$3;
    var _aq_ = caml_call2(Stdlib[28], _ap_, _an_);
    if(stdin)
     var
      f$1 = stdin[1],
      _ar_ = quote(f$1),
      _as_ = caml_call2(Stdlib[28], cst$0, _ar_);
    else
     var _as_ = cst$2;
    var
     _at_ = caml_call2(Stdlib[28], _as_, _aq_),
     _au_ = caml_call2(Stdlib_List[20], quote, [0, cmd, args]),
     _av_ = caml_call2(Stdlib_String[7], cst$1, _au_);
    return caml_call2(Stdlib[28], _av_, _at_);
   }
   function basename(_al_){
    return generic_basename(is_dir_sep, current_dir_name, _al_);
   }
   function dirname(_ak_){
    return generic_dirname(is_dir_sep, current_dir_name, _ak_);
   }
   var
    Unix =
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       temp_dir_name,
       quote,
       quote_command,
       basename,
       dirname];
   function is_dir_sep$0(s, i){
    var c = caml_string_get(s, i), _ah_ = 47 === c ? 1 : 0;
    if(_ah_)
     var _ai_ = _ah_;
    else
     var _aj_ = 92 === c ? 1 : 0, _ai_ = _aj_ || (58 === c ? 1 : 0);
    return _ai_;
   }
   function is_relative$0(n){
    var
     _ab_ = caml_ml_string_length(n) < 1 ? 1 : 0,
     _ac_ = _ab_ || (47 !== caml_string_get(n, 0) ? 1 : 0);
    if(_ac_){
     var
      _ad_ = caml_ml_string_length(n) < 1 ? 1 : 0,
      _ae_ = _ad_ || (92 !== caml_string_get(n, 0) ? 1 : 0);
     if(_ae_)
      var
       _af_ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _ag_ = _af_ || (58 !== caml_string_get(n, 1) ? 1 : 0);
     else
      var _ag_ = _ae_;
    }
    else
     var _ag_ = _ac_;
    return _ag_;
   }
   function is_implicit$0(n){
    var _U_ = is_relative$0(n);
    if(_U_){
     var
      _V_ = caml_ml_string_length(n) < 2 ? 1 : 0,
      _W_ = _V_ || (caml_call3(Stdlib_String[16], n, 0, 2) !== cst$27 ? 1 : 0);
     if(_W_){
      var
       _X_ = caml_ml_string_length(n) < 2 ? 1 : 0,
       _Y_ = _X_ || (caml_call3(Stdlib_String[16], n, 0, 2) !== ".\\" ? 1 : 0);
      if(_Y_){
       var
        _Z_ = caml_ml_string_length(n) < 3 ? 1 : 0,
        ___ =
          _Z_ || (caml_call3(Stdlib_String[16], n, 0, 3) !== cst$28 ? 1 : 0);
       if(___)
        var
         _$_ = caml_ml_string_length(n) < 3 ? 1 : 0,
         _aa_ =
           _$_ || (caml_call3(Stdlib_String[16], n, 0, 3) !== "..\\" ? 1 : 0);
       else
        var _aa_ = ___;
      }
      else
       var _aa_ = _Y_;
     }
     else
      var _aa_ = _W_;
    }
    else
     var _aa_ = _U_;
    return _aa_;
   }
   function check_suffix$0(name, suff){
    var
     _R_ = caml_ml_string_length(suff) <= caml_ml_string_length(name) ? 1 : 0;
    if(_R_)
     var
      s =
        caml_call3
         (Stdlib_String[16],
          name,
          caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
          caml_ml_string_length(suff)),
      _S_ = caml_call1(Stdlib_String[27], suff),
      _T_ = caml_call1(Stdlib_String[27], s) == _S_ ? 1 : 0;
    else
     var _T_ = _R_;
    return _T_;
   }
   function chop_suffix_opt$0(suffix, filename){
    var
     len_s = caml_ml_string_length(suffix),
     len_f = caml_ml_string_length(filename);
    if(len_s > len_f) return 0;
    var
     r = caml_call3(Stdlib_String[16], filename, len_f - len_s | 0, len_s),
     _Q_ = caml_call1(Stdlib_String[27], suffix);
    return caml_call1(Stdlib_String[27], r) == _Q_
            ? [0,
              caml_call3(Stdlib_String[16], filename, 0, len_f - len_s | 0)]
            : 0;
   }
   try{var _i_ = caml_sys_getenv("TEMP"), temp_dir_name$0 = _i_;}
   catch(_P_){
    var _b_ = caml_wrap_exception(_P_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var temp_dir_name$0 = cst$5;
   }
   function quote$0(s){
    var
     l = caml_ml_string_length(s),
     b = caml_call1(Stdlib_Buffer[1], l + 20 | 0);
    caml_call2(Stdlib_Buffer[12], b, 34);
    function loop$0(counter, i){
     var i$0 = i;
     for(;;){
      if(i$0 === l) return caml_call2(Stdlib_Buffer[12], b, 34);
      var c = caml_string_get(s, i$0);
      if(34 === c){
       var _N_ = 0;
       if(counter >= 50)
        return caml_trampoline_return(loop_bs, [0, _N_, i$0]);
       var counter$1 = counter + 1 | 0;
       return loop_bs(counter$1, _N_, i$0);
      }
      if(92 === c){
       var _O_ = 0;
       if(counter >= 50)
        return caml_trampoline_return(loop_bs, [0, _O_, i$0]);
       var counter$0 = counter + 1 | 0;
       return loop_bs(counter$0, _O_, i$0);
      }
      caml_call2(Stdlib_Buffer[12], b, c);
      var i$1 = i$0 + 1 | 0;
      i$0 = i$1;
     }
    }
    function loop(i){return caml_trampoline(loop$0(0, i));}
    function loop_bs(counter, n, i){
     var n$0 = n, i$0 = i;
     for(;;){
      if(i$0 === l){caml_call2(Stdlib_Buffer[12], b, 34); return add_bs(n$0);}
      var match = caml_string_get(s, i$0);
      if(34 === match){
       add_bs((2 * n$0 | 0) + 1 | 0);
       caml_call2(Stdlib_Buffer[12], b, 34);
       var _M_ = i$0 + 1 | 0;
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, _M_]);
       var counter$1 = counter + 1 | 0;
       return loop$0(counter$1, _M_);
      }
      if(92 !== match){
       add_bs(n$0);
       if(counter >= 50) return caml_trampoline_return(loop$0, [0, i$0]);
       var counter$0 = counter + 1 | 0;
       return loop$0(counter$0, i$0);
      }
      var i$1 = i$0 + 1 | 0, n$1 = n$0 + 1 | 0;
      n$0 = n$1;
      i$0 = i$1;
     }
    }
    function add_bs(n){
     var _K_ = 1;
     if(n >= 1){
      var j = _K_;
      for(;;){
       caml_call2(Stdlib_Buffer[12], b, 92);
       var _L_ = j + 1 | 0;
       if(n === j) break;
       j = _L_;
      }
     }
     return;
    }
    loop(0);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   function quote_cmd_filename(f){
    if
     (!
      caml_call2
       (Stdlib_String[23],
        function(param){if(34 !== param && 37 !== param) return 0; return 1;},
        f))
     return caml_call2(Stdlib_String[15], f, 32)
             ? caml_call2(Stdlib_String[7], cst$7, [0, cst$6, [0, f, _c_]])
             : f;
    var _J_ = caml_call2(Stdlib[28], cst_Filename_quote_command_bad, f);
    return caml_call1(Stdlib[2], _J_);
   }
   function quote_command$0(cmd, stdin, stdout, stderr, args){
    if(stderr){
     var f = stderr[1];
     if(caml_equal(stderr, stdout))
      var _w_ = cst_2_1$0;
     else
      var
       _H_ = quote_cmd_filename(f),
       _w_ = caml_call2(Stdlib[28], cst_2$0, _H_);
     var _x_ = _w_;
    }
    else
     var _x_ = cst$16;
    var _y_ = [0, _x_, _d_];
    if(stdout)
     var
      f$0 = stdout[1],
      _z_ = quote_cmd_filename(f$0),
      _A_ = caml_call2(Stdlib[28], cst$8, _z_);
    else
     var _A_ = cst$15;
    var _B_ = [0, _A_, _y_];
    if(stdin)
     var
      f$1 = stdin[1],
      _C_ = quote_cmd_filename(f$1),
      _D_ = caml_call2(Stdlib[28], cst$9, _C_);
    else
     var _D_ = cst$14;
    var
     _E_ = caml_call2(Stdlib_List[20], quote$0, args),
     s = caml_call2(Stdlib_String[7], cst$10, _E_),
     b = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s) + 20 | 0);
    caml_call2
     (Stdlib_String[30],
      function(c){
       a:
       {
        if(62 <= c){
         var _I_ = c - 63 | 0;
         if(60 < _I_ >>> 0){
          if(62 <= _I_) break a;
         }
         else if(31 !== _I_) break a;
        }
        else
         if(42 <= c){
          if(60 !== c) break a;
         }
         else{
          if(33 > c) break a;
          switch(c - 33 | 0){case 2:case 3:case 6: break a;
          }
         }
        caml_call2(Stdlib_Buffer[12], b, 94);
        return caml_call2(Stdlib_Buffer[12], b, c);
       }
       return caml_call2(Stdlib_Buffer[12], b, c);
      },
      s);
    var
     _F_ = [0, cst$11, [0, caml_call1(Stdlib_Buffer[2], b), [0, _D_, _B_]]],
     _G_ = [0, cst$12, [0, quote_cmd_filename(cmd), _F_]];
    return caml_call2(Stdlib_String[7], cst$13, _G_);
   }
   function drive_and_path(s){
    var _s_ = 2 <= caml_ml_string_length(s) ? 1 : 0;
    if(_s_){
     var param = caml_string_get(s, 0);
     a:
     {
      b:
      {
       if(91 <= param){
        if(25 < param - 97 >>> 0) break b;
       }
       else if(65 > param) break b;
       var _t_ = 1;
       break a;
      }
      var _t_ = 0;
     }
     var _u_ = _t_ ? 58 === caml_string_get(s, 1) ? 1 : 0 : _t_;
    }
    else
     var _u_ = _s_;
    if(! _u_) return [0, cst$17, s];
    var
     _v_ =
       caml_call3(Stdlib_String[16], s, 2, caml_ml_string_length(s) - 2 | 0);
    return [0, caml_call3(Stdlib_String[16], s, 0, 2), _v_];
   }
   function dirname$0(s){
    var
     match = drive_and_path(s),
     path = match[2],
     drive = match[1],
     dir = generic_dirname(is_dir_sep$0, current_dir_name$0, path);
    return caml_call2(Stdlib[28], drive, dir);
   }
   function basename$0(s){
    var path = drive_and_path(s)[2];
    return generic_basename(is_dir_sep$0, current_dir_name$0, path);
   }
   var
    Win32 =
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name$0,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
   function basename$1(_r_){
    return generic_basename(is_dir_sep$0, current_dir_name$1, _r_);
   }
   function dirname$1(_q_){
    return generic_dirname(is_dir_sep$0, current_dir_name$1, _q_);
   }
   var
    Cygwin =
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote,
       quote_command,
       basename$1,
       dirname$1],
    _e_ = Stdlib_Sys[4],
    Sysdeps = _e_ !== "Cygwin" ? _e_ !== "Win32" ? Unix : Win32 : Cygwin,
    null$3 = Sysdeps[1],
    current_dir_name$2 = Sysdeps[2],
    parent_dir_name$2 = Sysdeps[3],
    dir_sep$2 = Sysdeps[4],
    is_dir_sep$1 = Sysdeps[5],
    is_relative$1 = Sysdeps[6],
    is_implicit$1 = Sysdeps[7],
    check_suffix$1 = Sysdeps[8],
    chop_suffix_opt$1 = Sysdeps[9],
    temp_dir_name$1 = Sysdeps[10],
    quote$1 = Sysdeps[11],
    quote_command$1 = Sysdeps[12],
    basename$2 = Sysdeps[13],
    dirname$2 = Sysdeps[14];
   function concat(dirname, filename){
    var l = caml_ml_string_length(dirname);
    if(0 !== l && ! is_dir_sep$1(dirname, l - 1 | 0)){
     var _p_ = caml_call2(Stdlib[28], dir_sep$2, filename);
     return caml_call2(Stdlib[28], dirname, _p_);
    }
    return caml_call2(Stdlib[28], dirname, filename);
   }
   function chop_suffix(name, suff){
    return check_suffix$1(name, suff)
            ? caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - caml_ml_string_length(suff) | 0)
            : caml_call1(Stdlib[1], cst_Filename_chop_suffix);
   }
   function extension_len(name){
    var i$3 = caml_ml_string_length(name) - 1 | 0, i0 = i$3;
    for(;;){
     if(0 <= i0 && ! is_dir_sep$1(name, i0)){
      if(46 === caml_string_get(name, i0)) break;
      var i$2 = i0 - 1 | 0;
      i0 = i$2;
      continue;
     }
     return 0;
    }
    var i$1 = i0 - 1 | 0, i = i$1;
    for(;;){
     if(0 <= i && ! is_dir_sep$1(name, i)){
      if(46 !== caml_string_get(name, i))
       return caml_ml_string_length(name) - i0 | 0;
      var i$0 = i - 1 | 0;
      i = i$0;
      continue;
     }
     return 0;
    }
   }
   function extension(name){
    var l = extension_len(name);
    return 0 === l
            ? cst$18
            : caml_call3
              (Stdlib_String[16],
               name,
               caml_ml_string_length(name) - l | 0,
               l);
   }
   function chop_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? caml_call1(Stdlib[1], cst_Filename_chop_extension)
            : caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   function remove_extension(name){
    var l = extension_len(name);
    return 0 === l
            ? name
            : caml_call3
              (Stdlib_String[16],
               name,
               0,
               caml_ml_string_length(name) - l | 0);
   }
   var prng_key = caml_call2(Stdlib_Domain[10][1], 0, Stdlib_Random[19][2]);
   function temp_file_name(temp_dir, prefix, suffix){
    var
     random_state = caml_call1(Stdlib_Domain[10][2], prng_key),
     rnd = caml_call1(Stdlib_Random[19][4], random_state) & 16777215;
    return concat
            (temp_dir, caml_call4(Stdlib_Printf[4], _f_, prefix, rnd, suffix));
   }
   var
    current_temp_dir_name =
      caml_call2
       (Stdlib_Domain[10][1],
        [0, function(_o_){return _o_;}],
        function(param){return temp_dir_name$1;});
   function set_temp_dir_name(s){
    return caml_call2(Stdlib_Domain[10][3], current_temp_dir_name, s);
   }
   function get_temp_dir_name(param){
    return caml_call1(Stdlib_Domain[10][2], current_temp_dir_name);
   }
   function temp_file(opt, prefix, suffix){
    var
     temp_dir =
       opt ? opt[1] : caml_call1(Stdlib_Domain[10][2], current_temp_dir_name),
     counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      runtime.caml_sys_close(runtime.caml_sys_open(name, _g_, 384));
      return name;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0;
      counter = counter$0;
     }
    }
   }
   function open_temp_file(_m_, _l_, opt, prefix, suffix){
    var
     mode = _m_ ? _m_[1] : _h_,
     perms = _l_ ? _l_[1] : 384,
     temp_dir =
       opt ? opt[1] : caml_call1(Stdlib_Domain[10][2], current_temp_dir_name),
     counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{
      var
       _n_ =
         [0,
          name,
          caml_call3(Stdlib[62], [0, 1, [0, 3, [0, 5, mode]]], perms, name)];
      return _n_;
     }
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0;
      counter = counter$0;
     }
    }
   }
   function temp_dir(_k_, opt, prefix, suffix){
    var
     temp_dir =
       _k_ ? _k_[1] : caml_call1(Stdlib_Domain[10][2], current_temp_dir_name),
     perms = opt ? opt[1] : 448,
     counter = 0;
    for(;;){
     var name = temp_file_name(temp_dir, prefix, suffix);
     try{runtime.caml_sys_mkdir(name, perms); return name;}
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      if(e[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(e, 0);
      if(20 <= counter) throw caml_maybe_attach_backtrace(e, 0);
      var counter$0 = counter + 1 | 0;
      counter = counter$0;
     }
    }
   }
   var
    Stdlib_Filename =
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       temp_dir,
       get_temp_dir_name,
       set_temp_dir_name,
       quote$1,
       quote_command$1];
   runtime.caml_register_global(66, Stdlib_Filename, "Stdlib__Filename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Complex
//# unitInfo: Requires: Stdlib, Stdlib__Float
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    zero = [254, 0., 0.],
    one = [254, 1., 0.],
    i = [254, 0., 1.],
    _a_ = [254, 0., 0.];
   function add(x, y){return [254, x[1] + y[1], x[2] + y[2]];}
   function sub(x, y){return [254, x[1] - y[1], x[2] - y[2]];}
   function neg(x){return [254, - x[1], - x[2]];}
   function conj(x){return [254, x[1], - x[2]];}
   function mul(x, y){
    return [254, x[1] * y[1] - x[2] * y[2], x[1] * y[2] + x[2] * y[1]];
   }
   function div(x, y){
    if(Math.abs(y[2]) <= Math.abs(y[1])){
     var r = y[2] / y[1], d = y[1] + r * y[2];
     return [254, (x[1] + r * x[2]) / d, (x[2] - r * x[1]) / d];
    }
    var r$0 = y[1] / y[2], d$0 = y[2] + r$0 * y[1];
    return [254, (r$0 * x[1] + x[2]) / d$0, (r$0 * x[2] - x[1]) / d$0];
   }
   function inv(x){return div(one, x);}
   function norm2(x){return x[1] * x[1] + x[2] * x[2];}
   function norm(x){return runtime.caml_hypot_float(x[1], x[2]);}
   function arg(x){return Math.atan2(x[2], x[1]);}
   function polar(n, a){return [254, Math.cos(a) * n, Math.sin(a) * n];}
   function sqrt(x){
    if(x[1] == 0. && x[2] == 0.) return _a_;
    var r = Math.abs(x[1]), i = Math.abs(x[2]);
    if(i <= r)
     var
      q = i / r,
      w = Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
    else
     var
      q$0 = r / i,
      w = Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
    if(0. <= x[1]) return [254, w, 0.5 * x[2] / w];
    var w$0 = 0. <= x[2] ? w : - w;
    return [254, 0.5 * i / w, w$0];
   }
   function exp(x){
    var e = Math.exp(x[1]);
    return [254, e * Math.cos(x[2]), e * Math.sin(x[2])];
   }
   function log(x){
    var _b_ = Math.atan2(x[2], x[1]);
    return [254, Math.log(norm(x)), _b_];
   }
   function pow(x, y){return exp(mul(y, log(x)));}
   var
    Stdlib_Complex =
      [0,
       zero,
       one,
       i,
       neg,
       conj,
       add,
       sub,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
   runtime.caml_register_global(15, Stdlib_Complex, "Stdlib__Complex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ArrayLabels
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array,
    init = Stdlib_Array[1],
    make_matrix = Stdlib_Array[2],
    init_matrix = Stdlib_Array[3],
    append = Stdlib_Array[4],
    concat = Stdlib_Array[5],
    sub = Stdlib_Array[6],
    copy = Stdlib_Array[7],
    fill = Stdlib_Array[8],
    blit = Stdlib_Array[9],
    to_list = Stdlib_Array[10],
    of_list = Stdlib_Array[11],
    iter = Stdlib_Array[12],
    iteri = Stdlib_Array[13],
    map = Stdlib_Array[14],
    map_inplace = Stdlib_Array[15],
    mapi = Stdlib_Array[16],
    mapi_inplace = Stdlib_Array[17],
    fold_left = Stdlib_Array[18],
    fold_left_map = Stdlib_Array[19],
    fold_right = Stdlib_Array[20],
    iter2 = Stdlib_Array[21],
    map2 = Stdlib_Array[22],
    for_all = Stdlib_Array[23],
    exists = Stdlib_Array[24],
    for_all2 = Stdlib_Array[25],
    exists2 = Stdlib_Array[26],
    mem = Stdlib_Array[27],
    memq = Stdlib_Array[28],
    find_opt = Stdlib_Array[29],
    find_index = Stdlib_Array[30],
    find_map = Stdlib_Array[31],
    find_mapi = Stdlib_Array[32],
    split = Stdlib_Array[33],
    combine = Stdlib_Array[34],
    sort = Stdlib_Array[35],
    stable_sort = Stdlib_Array[36],
    fast_sort = Stdlib_Array[37],
    shuffle = Stdlib_Array[38],
    to_seq = Stdlib_Array[39],
    to_seqi = Stdlib_Array[40],
    of_seq = Stdlib_Array[41],
    Floatarray = Stdlib_Array[42],
    Stdlib_ArrayLabels =
      [0,
       init,
       make_matrix,
       init_matrix,
       append,
       concat,
       sub,
       copy,
       fill,
       blit,
       to_list,
       of_list,
       iter,
       iteri,
       map,
       map_inplace,
       mapi,
       mapi_inplace,
       fold_left,
       fold_left_map,
       fold_right,
       iter2,
       map2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       shuffle,
       to_seq,
       to_seqi,
       of_seq,
       Floatarray];
   runtime.caml_register_global(1, Stdlib_ArrayLabels, "Stdlib__ArrayLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__ListLabels
//# unitInfo: Requires: Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    is_empty = Stdlib_List[4],
    cons = Stdlib_List[5],
    hd = Stdlib_List[6],
    tl = Stdlib_List[7],
    nth = Stdlib_List[8],
    nth_opt = Stdlib_List[9],
    rev = Stdlib_List[10],
    init = Stdlib_List[11],
    append = Stdlib_List[12],
    rev_append = Stdlib_List[13],
    concat = Stdlib_List[14],
    flatten = Stdlib_List[15],
    equal = Stdlib_List[16],
    compare = Stdlib_List[17],
    iter = Stdlib_List[18],
    iteri = Stdlib_List[19],
    map = Stdlib_List[20],
    mapi = Stdlib_List[21],
    rev_map = Stdlib_List[22],
    filter_map = Stdlib_List[23],
    concat_map = Stdlib_List[24],
    fold_left_map = Stdlib_List[25],
    fold_left = Stdlib_List[26],
    fold_right = Stdlib_List[27],
    iter2 = Stdlib_List[28],
    map2 = Stdlib_List[29],
    rev_map2 = Stdlib_List[30],
    fold_left2 = Stdlib_List[31],
    fold_right2 = Stdlib_List[32],
    for_all = Stdlib_List[33],
    exists = Stdlib_List[34],
    for_all2 = Stdlib_List[35],
    exists2 = Stdlib_List[36],
    mem = Stdlib_List[37],
    memq = Stdlib_List[38],
    find = Stdlib_List[39],
    find_opt = Stdlib_List[40],
    find_index = Stdlib_List[41],
    find_map = Stdlib_List[42],
    find_mapi = Stdlib_List[43],
    filter = Stdlib_List[44],
    find_all = Stdlib_List[45],
    filteri = Stdlib_List[46],
    partition = Stdlib_List[47],
    partition_map = Stdlib_List[48],
    assoc = Stdlib_List[49],
    assoc_opt = Stdlib_List[50],
    assq = Stdlib_List[51],
    assq_opt = Stdlib_List[52],
    mem_assoc = Stdlib_List[53],
    mem_assq = Stdlib_List[54],
    remove_assoc = Stdlib_List[55],
    remove_assq = Stdlib_List[56],
    split = Stdlib_List[57],
    combine = Stdlib_List[58],
    sort = Stdlib_List[59],
    stable_sort = Stdlib_List[60],
    fast_sort = Stdlib_List[61],
    sort_uniq = Stdlib_List[62],
    merge = Stdlib_List[63],
    to_seq = Stdlib_List[64],
    of_seq = Stdlib_List[65],
    Stdlib_ListLabels =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       is_empty,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_index,
       find_map,
       find_mapi,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq];
   runtime.caml_register_global(1, Stdlib_ListLabels, "Stdlib__ListLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__BytesLabels
//# unitInfo: Requires: Stdlib__Bytes
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    make = Stdlib_Bytes[1],
    init = Stdlib_Bytes[2],
    empty = Stdlib_Bytes[3],
    copy = Stdlib_Bytes[4],
    of_string = Stdlib_Bytes[5],
    to_string = Stdlib_Bytes[6],
    sub = Stdlib_Bytes[7],
    sub_string = Stdlib_Bytes[8],
    extend = Stdlib_Bytes[9],
    fill = Stdlib_Bytes[10],
    blit = Stdlib_Bytes[11],
    blit_string = Stdlib_Bytes[12],
    concat = Stdlib_Bytes[13],
    cat = Stdlib_Bytes[14],
    iter = Stdlib_Bytes[15],
    iteri = Stdlib_Bytes[16],
    map = Stdlib_Bytes[17],
    mapi = Stdlib_Bytes[18],
    fold_left = Stdlib_Bytes[19],
    fold_right = Stdlib_Bytes[20],
    for_all = Stdlib_Bytes[21],
    exists = Stdlib_Bytes[22],
    trim = Stdlib_Bytes[23],
    escaped = Stdlib_Bytes[24],
    index = Stdlib_Bytes[25],
    index_opt = Stdlib_Bytes[26],
    rindex = Stdlib_Bytes[27],
    rindex_opt = Stdlib_Bytes[28],
    index_from = Stdlib_Bytes[29],
    index_from_opt = Stdlib_Bytes[30],
    rindex_from = Stdlib_Bytes[31],
    rindex_from_opt = Stdlib_Bytes[32],
    contains = Stdlib_Bytes[33],
    contains_from = Stdlib_Bytes[34],
    rcontains_from = Stdlib_Bytes[35],
    uppercase_ascii = Stdlib_Bytes[36],
    lowercase_ascii = Stdlib_Bytes[37],
    capitalize_ascii = Stdlib_Bytes[38],
    uncapitalize_ascii = Stdlib_Bytes[39],
    compare = Stdlib_Bytes[40],
    equal = Stdlib_Bytes[41],
    starts_with = Stdlib_Bytes[42],
    ends_with = Stdlib_Bytes[43],
    unsafe_to_string = Stdlib_Bytes[44],
    unsafe_of_string = Stdlib_Bytes[45],
    split_on_char = Stdlib_Bytes[46],
    to_seq = Stdlib_Bytes[47],
    to_seqi = Stdlib_Bytes[48],
    of_seq = Stdlib_Bytes[49],
    get_utf_8_uchar = Stdlib_Bytes[50],
    set_utf_8_uchar = Stdlib_Bytes[51],
    is_valid_utf_8 = Stdlib_Bytes[52],
    get_utf_16be_uchar = Stdlib_Bytes[53],
    set_utf_16be_uchar = Stdlib_Bytes[54],
    is_valid_utf_16be = Stdlib_Bytes[55],
    get_utf_16le_uchar = Stdlib_Bytes[56],
    set_utf_16le_uchar = Stdlib_Bytes[57],
    is_valid_utf_16le = Stdlib_Bytes[58],
    get_uint8 = Stdlib_Bytes[59],
    get_int8 = Stdlib_Bytes[60],
    get_uint16_ne = Stdlib_Bytes[61],
    get_uint16_be = Stdlib_Bytes[62],
    get_uint16_le = Stdlib_Bytes[63],
    get_int16_ne = Stdlib_Bytes[64],
    get_int16_be = Stdlib_Bytes[65],
    get_int16_le = Stdlib_Bytes[66],
    get_int32_ne = Stdlib_Bytes[67],
    get_int32_be = Stdlib_Bytes[68],
    get_int32_le = Stdlib_Bytes[69],
    get_int64_ne = Stdlib_Bytes[70],
    get_int64_be = Stdlib_Bytes[71],
    get_int64_le = Stdlib_Bytes[72],
    set_uint8 = Stdlib_Bytes[73],
    set_int8 = Stdlib_Bytes[74],
    set_uint16_ne = Stdlib_Bytes[75],
    set_uint16_be = Stdlib_Bytes[76],
    set_uint16_le = Stdlib_Bytes[77],
    set_int16_ne = Stdlib_Bytes[78],
    set_int16_be = Stdlib_Bytes[79],
    set_int16_le = Stdlib_Bytes[80],
    set_int32_ne = Stdlib_Bytes[81],
    set_int32_be = Stdlib_Bytes[82],
    set_int32_le = Stdlib_Bytes[83],
    set_int64_ne = Stdlib_Bytes[84],
    set_int64_be = Stdlib_Bytes[85],
    set_int64_le = Stdlib_Bytes[86],
    unsafe_escape = Stdlib_Bytes[87],
    Stdlib_BytesLabels =
      [0,
       make,
       init,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit_string,
       concat,
       cat,
       iter,
       iteri,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare,
       equal,
       starts_with,
       ends_with,
       unsafe_to_string,
       unsafe_of_string,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       set_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       set_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       set_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_uint16_be,
       set_uint16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_escape];
   runtime.caml_register_global(1, Stdlib_BytesLabels, "Stdlib__BytesLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StringLabels
//# unitInfo: Requires: Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    make = Stdlib_String[1],
    init = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    blit = Stdlib_String[6],
    concat = Stdlib_String[7],
    cat = Stdlib_String[8],
    equal = Stdlib_String[9],
    compare = Stdlib_String[10],
    starts_with = Stdlib_String[11],
    ends_with = Stdlib_String[12],
    contains_from = Stdlib_String[13],
    rcontains_from = Stdlib_String[14],
    contains = Stdlib_String[15],
    sub = Stdlib_String[16],
    split_on_char = Stdlib_String[17],
    map = Stdlib_String[18],
    mapi = Stdlib_String[19],
    fold_left = Stdlib_String[20],
    fold_right = Stdlib_String[21],
    for_all = Stdlib_String[22],
    exists = Stdlib_String[23],
    trim = Stdlib_String[24],
    escaped = Stdlib_String[25],
    uppercase_ascii = Stdlib_String[26],
    lowercase_ascii = Stdlib_String[27],
    capitalize_ascii = Stdlib_String[28],
    uncapitalize_ascii = Stdlib_String[29],
    iter = Stdlib_String[30],
    iteri = Stdlib_String[31],
    index_from = Stdlib_String[32],
    index_from_opt = Stdlib_String[33],
    rindex_from = Stdlib_String[34],
    rindex_from_opt = Stdlib_String[35],
    index = Stdlib_String[36],
    index_opt = Stdlib_String[37],
    rindex = Stdlib_String[38],
    rindex_opt = Stdlib_String[39],
    to_seq = Stdlib_String[40],
    to_seqi = Stdlib_String[41],
    of_seq = Stdlib_String[42],
    get_utf_8_uchar = Stdlib_String[43],
    is_valid_utf_8 = Stdlib_String[44],
    get_utf_16be_uchar = Stdlib_String[45],
    is_valid_utf_16be = Stdlib_String[46],
    get_utf_16le_uchar = Stdlib_String[47],
    is_valid_utf_16le = Stdlib_String[48],
    get_uint8 = Stdlib_String[49],
    get_int8 = Stdlib_String[50],
    get_uint16_ne = Stdlib_String[51],
    get_uint16_be = Stdlib_String[52],
    get_uint16_le = Stdlib_String[53],
    get_int16_ne = Stdlib_String[54],
    get_int16_be = Stdlib_String[55],
    get_int16_le = Stdlib_String[56],
    get_int32_ne = Stdlib_String[57],
    hash = Stdlib_String[58],
    seeded_hash = Stdlib_String[59],
    get_int32_be = Stdlib_String[60],
    get_int32_le = Stdlib_String[61],
    get_int64_ne = Stdlib_String[62],
    get_int64_be = Stdlib_String[63],
    get_int64_le = Stdlib_String[64],
    Stdlib_StringLabels =
      [0,
       make,
       init,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat,
       cat,
       equal,
       compare,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       fold_left,
       fold_right,
       for_all,
       exists,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       hash,
       seeded_hash,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le];
   runtime.caml_register_global
    (1, Stdlib_StringLabels, "Stdlib__StringLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__MoreLabels
//# unitInfo: Requires: Stdlib__Hashtbl, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Set = global_data.Stdlib__Set,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_MoreLabels = [0, Stdlib_Hashtbl, Stdlib_Map, Stdlib_Set];
   runtime.caml_register_global(3, Stdlib_MoreLabels, "Stdlib__MoreLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__StdLabels
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdlib_StdLabels = [0];
   runtime.caml_register_global(0, Stdlib_StdLabels, "Stdlib__StdLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdlib__Effect
//# unitInfo: Requires: Stdlib, Stdlib__Callback, Stdlib__Printexc, Stdlib__Printf
//# unitInfo: Effects_without_cps: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_alloc_stack = runtime.caml_alloc_stack,
    caml_continuation_use_noexc = runtime.caml_continuation_use_noexc,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_restore_raw_backtrace = runtime.caml_restore_raw_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception,
    jsoo_effect_not_supported = runtime.jsoo_effect_not_supported;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Unhandled = [248, "Stdlib.Effect.Unhandled", caml_fresh_oo_id(0)],
    Continuation_already_resumed =
      [248, "Stdlib.Effect.Continuation_already_resumed", caml_fresh_oo_id(0)],
    _a_ =
      [0,
       [11, "Stdlib.Effect.Unhandled(", [2, 0, [12, 41, 0]]],
       "Stdlib.Effect.Unhandled(%s)"];
   function printer(param){
    if(param[1] !== Unhandled) return 0;
    var
     x = param[2],
     _i_ = caml_call1(Stdlib_Printexc[26], x),
     msg = caml_call2(Stdlib_Printf[4], _a_, _i_);
    return [0, msg];
   }
   caml_call1(Stdlib_Printexc[9], printer);
   var
    Should_not_see_this =
      [248, "Stdlib.Effect.Should_not_see_this__", caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2],
     "Effect.Unhandled",
     [0, Unhandled, Should_not_see_this]);
   caml_call2
    (Stdlib_Callback[2],
     "Effect.Continuation_already_resumed",
     Continuation_already_resumed);
   function continue$0(k, v){
    var _h_ = caml_continuation_use_noexc(k);
    function _g_(x){return x;}
    return jsoo_effect_not_supported();
   }
   function discontinue(k, e){
    var _f_ = caml_continuation_use_noexc(k);
    function _e_(e){throw caml_maybe_attach_backtrace(e, 1);}
    return jsoo_effect_not_supported();
   }
   function discontinue_with_backtrace(k, e, bt){
    var _d_ = caml_continuation_use_noexc(k);
    function _c_(e){
     caml_restore_raw_backtrace(e, bt);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    return jsoo_effect_not_supported();
   }
   function match_with(comp, arg, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[3], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     k[2] = last_fiber;
     return caml_call1(f, k);
    }
    var s = caml_alloc_stack(handler[1], handler[2], effc);
    return jsoo_effect_not_supported();
   }
   function try_with(comp, arg, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[1], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     k[2] = last_fiber;
     return caml_call1(f, k);
    }
    var
     s =
       caml_alloc_stack
        (function(x){return x;},
         function(e){throw caml_maybe_attach_backtrace(e, 1);},
         effc);
    return jsoo_effect_not_supported();
   }
   var
    Deep =
      [0,
       continue$0,
       discontinue,
       discontinue_with_backtrace,
       match_with,
       try_with],
    cst_Initial_setup = "Initial_setup__",
    cst_E = "E",
    cst_impossible = "impossible";
   function fiber(f){
    var
     Initial_setup = [248, cst_Initial_setup, caml_fresh_oo_id(0)],
     E = [248, cst_E, caml_fresh_oo_id(0)];
    function f$0(param){return caml_call1(f, jsoo_effect_not_supported());}
    function error(param){return caml_call1(Stdlib[2], cst_impossible);}
    function effc(eff, k, last_fiber){
     if(eff !== Initial_setup) return error(0);
     k[2] = last_fiber;
     throw [0, E, k];
    }
    var s = caml_alloc_stack(error, error, effc);
    try{jsoo_effect_not_supported(); var _b_ = 0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== E) throw caml_maybe_attach_backtrace(exn, 0);
     var k = exn[2];
     return k;
    }
    return error(0);
   }
   function continue_gen(k, resume_fun, v, handler){
    function effc(eff, k, last_fiber){
     var match = caml_call1(handler[3], eff);
     if(! match) return jsoo_effect_not_supported();
     var f = match[1];
     k[2] = last_fiber;
     return caml_call1(f, k);
    }
    var
     stack =
       runtime.caml_continuation_use_and_update_handler_noexc
        (k, handler[1], handler[2], effc);
    return jsoo_effect_not_supported();
   }
   function continue_with(k, v, handler){
    return continue_gen(k, function(x){return x;}, v, handler);
   }
   function discontinue_with(k, v, handler){
    return continue_gen
            (k,
             function(e){throw caml_maybe_attach_backtrace(e, 1);},
             v,
             handler);
   }
   function discontinue_with_backtrace$0(k, v, bt, handler){
    return continue_gen
            (k,
             function(e){
              caml_restore_raw_backtrace(e, bt);
              throw caml_maybe_attach_backtrace(e, 0);
             },
             v,
             handler);
   }
   var
    Stdlib_Effect =
      [0,
       Unhandled,
       Continuation_already_resumed,
       Deep,
       [0,
        fiber,
        continue_with,
        discontinue_with,
        discontinue_with_backtrace$0]];
   runtime.caml_register_global(13, Stdlib_Effect, "Stdlib__Effect");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRsaWIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsImZhaWx3aXRoIiwicyIsImludmFsaWRfYXJnIiwibWluIiwieCIsInkiLCJtYXgiLCJhYnMiLCJsbm90IiwiaW5maW5pdHkiLCJuZWdfaW5maW5pdHkiLCJuYW4iLCJtYXhfZmxvYXQiLCJtaW5fZmxvYXQiLCJlcHNpbG9uX2Zsb2F0Iiwic3ltYm9sX2NvbmNhdCIsImNoYXJfb2ZfaW50IiwibiIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJzMSIsImwiLCJpIiwiaSQwIiwic3RyaW5nX29mX2Zsb2F0IiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInN5bWJvbCIsImwxIiwibDIiLCJoMSIsImgyIiwidGwiLCJoMyIsInN0ZGluIiwic3Rkb3V0Iiwic3RkZXJyIiwib3Blbl9vdXRfZ2VuIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIm9wZW5fb3V0Iiwib3Blbl9vdXRfYmluIiwiZmx1c2hfYWxsIiwiYSIsIm91dHB1dF9ieXRlcyIsIm9jIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dCIsIm9mcyIsImxlbiIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfdmFsdWUiLCJjaGFuIiwidiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsInBvcyQwIiwiaGQiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwiY2xvc2VfaW5fbm9lcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9mbG9hdCIsInJlYWRfZmxvYXRfb3B0Iiwic3RyaW5nX29mX2Zvcm1hdCIsInN5bWJvbCQwIiwic3RyMiIsInN0cjEiLCJzMiIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJmX3lldF90b19ydW4kMCIsIm9sZF9leGl0JDAiLCJuZXdfZXhpdCIsInN1Y2Nlc3MiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImRvX2F0X2V4aXQiLCJleGl0IiwicmV0Y29kZSIsImxlZnQiLCJyaWdodCIsImlzX2xlZnQiLCJpc19yaWdodCIsImZpbmRfbGVmdCIsImZpbmRfcmlnaHQiLCJtYXBfbGVmdCIsImUiLCJtYXBfcmlnaHQiLCJtYXAiLCJ2JDAiLCJmb2xkIiwiZXF1YWwiLCJlMSIsImUyIiwidjEiLCJ2MiIsInYxJDAiLCJ2MiQwIiwiY29tcGFyZSIsIm9jYW1sX3ZlcnNpb24iLCJvY2FtbF9yZWxlYXNlIiwiZXhlY3V0YWJsZV9uYW1lIiwib3NfdHlwZSIsImJhY2tlbmRfdHlwZSIsInVuaXgiLCJ3aW4zMiIsImN5Z3dpbiIsIm1heF9hcnJheV9sZW5ndGgiLCJtYXhfZmxvYXRhcnJheV9sZW5ndGgiLCJtYXhfc3RyaW5nX2xlbmd0aCIsImdldGVudl9vcHQiLCJpbnRlcmFjdGl2ZSIsInNldF9zaWduYWwiLCJzaWdfbnVtIiwic2lnX2JlaCIsImNhdGNoX2JyZWFrIiwib24iLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJtYXhfZXBoZV9sZW5ndGgiLCJjcmVhdGUiLCJsZW5ndGgiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsIm8iLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwibzEiLCJvMiIsIm1ha2UiLCJ1aWQiLCJBIiwicHJvdmFibHlfZXF1YWwiLCJCIiwic2V0IiwiaW5jciIsImRlY3IiLCJmb3JjZV9nZW5fbGF6eV9ibG9jayIsIm9ubHlfdmFsIiwiYmxrIiwiY2xvc3VyZSQwIiwicmVzdWx0JDAiLCJjbG9zdXJlIiwicmVzdWx0IiwiZSQwIiwiZm9yY2VfbGF6eV9ibG9jayIsImZvcmNlX2dlbiIsImx6diIsInQiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwibWFwX3ZhbCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCIsInNlcTEiLCJzZXEyIiwic2VxIiwiZmlsdGVyX21hcCIsInNlcSQwIiwiZmlsdGVyIiwiY29uY2F0IiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwiaXRlciIsInVuZm9sZCIsInUiLCJ1JDAiLCJpc19lbXB0eSIsInhzIiwidW5jb25zIiwieHMkMCIsInhzJDEiLCJpdGVyaSIsImZvbGRfbGVmdGkiLCJhY2N1JDEiLCJmb3JfYWxsIiwicCIsImV4aXN0cyIsImZpbmQiLCJmaW5kX2luZGV4IiwiZmluZF9tYXAiLCJmaW5kX21hcGkiLCJpdGVyMiIsInlzIiwieXMkMCIsInlzJDEiLCJmb2xkX2xlZnQyIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwiZXEiLCJjbXAiLCJpbml0X2F1eCIsImoiLCJpbml0IiwicmVwZWF0IiwiZm9yZXZlciIsImN5Y2xlX25vbmVtcHR5IiwiY3ljbGUiLCJpdGVyYXRlMSIsIml0ZXJhdGUiLCJtYXBpX2F1eCIsIm1hcGkiLCJ0YWlsX3NjYW4iLCJzJDAiLCJzY2FuIiwidGFrZV9hdXgiLCJ0YWtlIiwiZHJvcCIsIm4kMCIsIm4kMSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwibm9kZSIsImdyb3VwIiwidG9fbGF6eSIsImZhaWx1cmUiLCJtZW1vaXplIiwib25jZSIsImFjdGlvbiIsInppcCIsIm1hcDIiLCJpbnRlcmxlYXZlIiwic29ydGVkX21lcmdlMSIsInNvcnRlZF9tZXJnZSIsIm1hcF9mc3QiLCJ4eXMiLCJ4eXMkMCIsIm1hcF9zbmQiLCJ1bnppcCIsImZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCIsImZpbHRlcl9tYXBfZmluZF9yaWdodF9tYXAiLCJ6IiwicGFydGl0aW9uX21hcCIsInBhcnRpdGlvbiIsInBlZWwiLCJ4c3MiLCJ0cmFuc3Bvc2UiLCJ0YWlscyIsImhlYWRzIiwicmVtYWluZGVycyIsInhzcyQwIiwidGFpbHMkMCIsImhlYWRzJDAiLCJtYXBfcHJvZHVjdCIsInByb2R1Y3QiLCJvZl9kaXNwZW5zZXIiLCJpdCIsInRvX2Rpc3BlbnNlciIsImludHMiLCJzb21lIiwidmFsdWUiLCJkZWZhdWx0JDAiLCJnZXQiLCJiaW5kIiwiam9pbiIsIm5vbmUiLCJpc19ub25lIiwiaXNfc29tZSIsIm8wIiwidjAiLCJ0b19yZXN1bHQiLCJ0b19saXN0IiwidG9fc2VxIiwib2siLCJlcnJvciIsImdldF9vayIsImdldF9lcnJvciIsIm1hcF9lcnJvciIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwicjAiLCJyMSIsImUwIiwidG9fb3B0aW9uIiwidG9fZmxvYXQiLCJ0b19zdHJpbmciLCJzZWVkZWRfaGFzaCIsInNlZWQiLCJoYXNoIiwiZXNjYXBlZCIsImxvd2VyY2FzZV9hc2NpaSIsInVwcGVyY2FzZV9hc2NpaSIsImMxIiwiYzIiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsInV0Zl9kZWNvZGVfaXNfdmFsaWQiLCJkIiwidXRmX2RlY29kZV9sZW5ndGgiLCJ1dGZfZGVjb2RlX3VjaGFyIiwidXRmX2RlY29kZSIsInV0Zl9kZWNvZGVfaW52YWxpZCIsInV0Zl84X2J5dGVfbGVuZ3RoIiwidXRmXzE2X2J5dGVfbGVuZ3RoIiwibCQwIiwibnRoIiwibCQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwibGFzdCIsImkkMSIsInIyIiwiZmxhdHRlbiIsImExIiwicjEkMCIsImEyIiwicmV2X21hcCIsImZvbGRfcmlnaHQiLCJiMiIsImIxIiwiYjEkMCIsInJldl9tYXAyIiwiZm9sZF9yaWdodDIiLCJtZW0iLCJtZW1xIiwiYXNzb2MiLCJhc3NvY19vcHQiLCJhc3NxIiwiYXNzcV9vcHQiLCJtZW1fYXNzb2MiLCJtZW1fYXNzcSIsInJlbW92ZV9hc3NvYyIsInBhaXIiLCJyZW1vdmVfYXNzcSIsImZpbmRfb3B0IiwiZmluZF9hbGwiLCJmaWx0ZXJpIiwiY29uY2F0X21hcCIsImZvbGRfbGVmdF9tYXAiLCJsX2FjY3UiLCJ4JDAiLCJ5ZXMiLCJubyIsInNwbGl0IiwicnkiLCJyeCIsImNvbWJpbmUiLCJtZXJnZSIsInQyIiwidDEiLCJzdGFibGVfc29ydCIsInNvcnQiLCJ4MiIsIngxIiwidGwkMSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJ0bCQwIiwic29ydF91bmlxIiwiYyQwIiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2IiwiYWNjdSQyIiwiY29tcGFyZV9sZW5ndGhzIiwiY29tcGFyZV9sZW5ndGhfd2l0aCIsImF1eCIsInRhaWwiLCJvZl9zZXEiLCJzZXEkMSIsImxvZ25vdCIsImNvcHkiLCJvZl9zdHJpbmciLCJzdWIiLCJzdWJfc3RyaW5nIiwiZXh0ZW5kIiwiZHN0b2ZmIiwic3Jjb2ZmIiwiY3B5bGVuIiwiZmlsbCIsImJsaXQiLCJvZnMxIiwib2ZzMiIsImJsaXRfc3RyaW5nIiwic2VwIiwic2VwbGVuIiwiZHN0IiwicG9zIiwiaGQkMCIsImNhdCIsImlzX3NwYWNlIiwidHJpbSIsInVuc2FmZV9lc2NhcGUiLCJiJDAiLCJhcHBseTEiLCJjYXBpdGFsaXplX2FzY2lpIiwidW5jYXBpdGFsaXplX2FzY2lpIiwic3RhcnRzX3dpdGgiLCJwcmVmaXgiLCJsZW5fcyIsImxlbl9wcmUiLCJlbmRzX3dpdGgiLCJzdWZmaXgiLCJsZW5fc3VmIiwiZGlmZiIsImluZGV4X3JlYyIsImxpbSIsImluZGV4IiwiaW5kZXhfcmVjX29wdCIsImluZGV4X29wdCIsImluZGV4X2Zyb20iLCJpbmRleF9mcm9tX29wdCIsInJpbmRleF9yZWMiLCJyaW5kZXgiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9yZWNfb3B0IiwicmluZGV4X29wdCIsInJpbmRleF9mcm9tX29wdCIsImNvbnRhaW5zX2Zyb20iLCJjb250YWlucyIsInJjb250YWluc19mcm9tIiwic3BsaXRfb25fY2hhciIsInRvX3NlcWkiLCJuZXdfbGVuIiwibmV3X2J1ZiIsInVuc2FmZV9nZXRfdWludDE2X2xlIiwidW5zYWZlX2dldF91aW50MTZfYmUiLCJnZXRfaW50OCIsImdldF91aW50MTZfbGUiLCJnZXRfdWludDE2X2JlIiwiZ2V0X2ludDE2X25lIiwiZ2V0X2ludDE2X2xlIiwiZ2V0X2ludDE2X2JlIiwiZ2V0X2ludDMyX2xlIiwiZ2V0X2ludDMyX2JlIiwiZ2V0X2ludDY0X2xlIiwiZ2V0X2ludDY0X2JlIiwidW5zYWZlX3NldF91aW50MTZfbGUiLCJ1bnNhZmVfc2V0X3VpbnQxNl9iZSIsInNldF9pbnQxNl9sZSIsInNldF9pbnQxNl9iZSIsInNldF9pbnQzMl9sZSIsInNldF9pbnQzMl9iZSIsInNldF9pbnQ2NF9sZSIsInNldF9pbnQ2NF9iZSIsInNldF91aW50OCIsInNldF91aW50MTZfbmUiLCJkZWNfaW52YWxpZCIsImRlY19yZXQiLCJub3RfaW5feDgwX3RvX3hCRiIsIm5vdF9pbl94QTBfdG9feEJGIiwibm90X2luX3g4MF90b194OUYiLCJub3RfaW5feDkwX3RvX3hCRiIsIm5vdF9pbl94ODBfdG9feDhGIiwidXRmXzhfdWNoYXJfMyIsImIwIiwidXRmXzhfdWNoYXJfNCIsImIzIiwiZ2V0X3V0Zl84X3VjaGFyIiwiYjEkNCIsImIyJDMiLCJpJDQiLCJiMSQyIiwiaSQ1IiwiYjIkMSIsImkkNiIsImIzJDEiLCJpJDEwIiwiaSQxMSIsImkkMTIiLCJpJDciLCJiMSQxIiwiaSQ4IiwiYjIkMCIsImkkOSIsImIzJDAiLCJpJDEzIiwiYjEkNSIsImkkMTQiLCJiMiQ0IiwiaSQyIiwiYjEkMyIsImkkMyIsImIyJDIiLCJpJDE1Iiwic2V0X3V0Zl84X3VjaGFyIiwibGFzdCQxIiwibGFzdCQwIiwiaXNfdmFsaWRfdXRmXzgiLCJsYXN0JDMiLCJsYXN0JDIiLCJsYXN0JDQiLCJsYXN0JDUiLCJnZXRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwic2V0X3V0Zl8xNmJlX3VjaGFyIiwidSQxIiwiaXNfdmFsaWRfdXRmXzE2YmUiLCJnZXRfdXRmXzE2bGVfdWNoYXIiLCJzZXRfdXRmXzE2bGVfdWNoYXIiLCJpc192YWxpZF91dGZfMTZsZSIsImJ0cyIsImJvcyIsIm9mX2J5dGVzIiwidG9fYnl0ZXMiLCJnIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiZGF0YV9zaXplIiwidG90YWxfc2l6ZSIsImZyb21fYnl0ZXMiLCJmcm9tX3N0cmluZyIsIm1ha2VfbWF0cml4Iiwic3giLCJzeSIsImluaXRfbWF0cml4Iiwicm93IiwibWFwX2lucGxhY2UiLCJtYXBpX2lucGxhY2UiLCJsYSIsImxiIiwicmVzJDAiLCJsaXN0X2xlbmd0aCIsIm9mX2xpc3QiLCJpbnB1dF9hcnJheSIsImVsdCIsIm91dHB1dF9hcnJheSIsImVsdCQwIiwiYWNjJDIiLCJhMCIsImJpIiwiYWkiLCJuYSIsIm5iIiwibWF4c29uIiwiaTMxIiwiZSQxIiwiaiQwIiwiZmF0aGVyIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJzaHVmZmxlIiwicmFuZCIsInNpZ25hbGluZ19uYW4iLCJpc19maW5pdGUiLCJpc19pbmZpbml0ZSIsImlzX25hbiIsImVwc2lsb24iLCJvZl9zdHJpbmdfb3B0IiwiaXNfaW50ZWdlciIsIm1pbl9tYXgiLCJtaW5fbnVtIiwibWF4X251bSIsIm1pbl9tYXhfbnVtIiwidW5zYWZlX2ZpbGwiLCJjaGVjayIsImhsZW4iLCJzcmMiLCJzb2ZzIiwiZG9mcyIsImgiLCJtZW1faWVlZSIsIm1hcF90b19hcnJheSIsIm1hcF9mcm9tX2FycmF5IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsIm1pbl9pbnQiLCJtYXhfaW50IiwibWF4X2ludCQwIiwidW5zaWduZWRfdG9faW50IiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9sdCIsInVuc2lnbmVkX2RpdiIsInEiLCJ1bnNpZ25lZF9yZW0iLCJzaXplIiwiZHVtbXlfcG9zIiwiemVyb19wb3MiLCJlbmdpbmUiLCJ0YmwiLCJzdGF0ZSIsIm5ld19lbmdpbmUiLCJmcm9tX2Z1bmN0aW9uIiwicmVhZF9mdW4iLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwic2V0X3Bvc2l0aW9uIiwicG9zaXRpb24iLCJzZXRfZmlsZW5hbWUiLCJmbmFtZSIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJleG4kMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJwcmVzIiwicHJlcyQwIiwicmVtb3ZlIiwidW5pb24iLCJyMiQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImNvbnNfZW51bSIsImUyJDIiLCJlMSQyIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsInB2IiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZF9maXJzdCIsInYwJDEiLCJ2MCQwIiwiZmluZF9maXJzdF9vcHQiLCJmaW5kX2xhc3QiLCJmaW5kX2xhc3Rfb3B0IiwidHJ5X2pvaW4iLCJ2JDEiLCJ4MCIsImwkMyIsImwkNCIsIngwJDAiLCJsJDUiLCJ4MCQxIiwibmwiLCJtaWQiLCJsJDIiLCJ4NCIsImFkZF9zZXEiLCJzZXFfb2ZfZW51bSIsInNub2NfZW51bSIsInJldl9zZXFfb2ZfZW51bSIsInRvX3Jldl9zZXEiLCJ0b19zZXFfZnJvbSIsImxvdyIsImxkIiwibHJkIiwicmQiLCJybGQiLCJkYXRhIiwiZDAkMSIsImQwIiwiZDAkMCIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJhZGRfdG9fbGlzdCIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImsiLCJhZGRfbWF4X2JpbmRpbmciLCJjb25jYXRfb3Jfam9pbiIsImQxIiwiZDIiLCJkMiQwIiwiZDEkMCIsImQyJDEiLCJkMSQxIiwicHZkIiwiZnZkIiwibTEiLCJtMiIsImJpbmRpbmdzX2F1eCIsImJpbmRpbmdzIiwiYnMiLCJjbGVhciIsInB1c2giLCJwb3AiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsImNlbGwiLCJtYXRjaCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlX29wdCIsImNlbGwkMCIsInFfcmVzIiwicHJldiIsInByZXYkMCIsInRyYW5zZmVyIiwicTEiLCJxMiIsImNvbnRlbnRzIiwiYnVmZmVyIiwicmVzZXQiLCJpbm5lciIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsInVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heCIsInVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXgiLCJhZGRfdXRmXzhfdWNoYXIiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJhZGRfdXRmXzE2bGVfdWNoYXIiLCJhZGRfc3Vic3RyaW5nIiwib2Zmc2V0IiwibmV3X3Bvc2l0aW9uIiwiYWRkX3N1YmJ5dGVzIiwiYWRkX3N0cmluZyIsImFkZF9ieXRlcyIsImFkZF9idWZmZXIiLCJhZGRfY2hhbm5lbCIsInRvX3JlYWQkMSIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJwcmV2aW91cyQwIiwib3BlbmluZyIsImxpbSQwIiwic3RvcCQwIiwiayQyIiwiY2xvc2luZyIsInN0b3AiLCJrJDAiLCJrJDEiLCJuZXh0X2kiLCJpZGVudCIsInRydW5jYXRlIiwiYWRkX2ludDgiLCJhZGRfaW50MTZfbmUiLCJhZGRfaW50MzJfbmUiLCJhZGRfaW50NjRfbmUiLCJhZGRfaW50MTZfbGUiLCJhZGRfaW50MTZfYmUiLCJhZGRfaW50MzJfbGUiLCJhZGRfaW50MzJfYmUiLCJhZGRfaW50NjRfbGUiLCJhZGRfaW50NjRfYmUiLCJwcm90ZWN0IiwicmVsZWFzZSIsImFjcXVpcmUiLCJ0cnlfYWNxdWlyZSIsInJldCIsImdldF92YWx1ZSIsIm1ha2UkMCIsInJlbGVhc2UkMCIsImFjcXVpcmUkMCIsInRyeV9hY3F1aXJlJDAiLCJjcHVfcmVsYXgiLCJjcmVhdGVfZGxzIiwia2V5X2NvdW50ZXIiLCJwYXJlbnRfa2V5cyIsIm5ld19rZXkiLCJzcGxpdF9mcm9tX3BhcmVudCIsImluaXRfb3JwaGFuIiwiaWR4Iiwia2kiLCJtYXliZV9ncm93Iiwic3oiLCJuZXdfc3oiLCJuZXdfc3QiLCJvbGR2YWwiLCJuZXdfb2JqIiwic3QkMCIsImN1cnZhbCIsInVwZGF0ZWRfb2JqIiwiZ2V0X2lkIiwiZG9tYWluIiwic2VsZiIsImlzX21haW5fZG9tYWluIiwiZmlyc3RfZG9tYWluX3NwYXduZWQiLCJmaXJzdF9zcGF3bl9mdW5jdGlvbiIsImJlZm9yZV9maXJzdF9zcGF3biIsIm9sZF9mIiwibmV3X2YiLCJhdF9leGl0X2tleSIsInNwYXduIiwicGsiLCJ0ZXJtX3N5bmMiLCJib2R5IiwibG9vcCIsImV4IiwicmVjb21tZW5kZWRfZG9tYWluX2NvdW50Iiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwiY3JlYXRlX2NoYXJfc2V0IiwiYWRkX2luX2NoYXJfc2V0Iiwic3RyX2luZCIsIm1hc2siLCJmcmVlemVfY2hhcl9zZXQiLCJyZXZfY2hhcl9zZXQiLCJjaGFyX3NldCQwIiwiaXNfaW5fY2hhcl9zZXQiLCJwYWRfb2ZfcGFkX29wdCIsInBhZF9vcHQiLCJ3aWR0aCIsInBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCIsImZtdCIsInBhZF9vcHQkMCIsInBhZF9vcHQkMSIsInBhZF9vcHQkMiIsInBhZF9vcHQkMyIsInBhZF9vcHQkNCIsInByZWNfb3B0IiwicGFkX29wdCQ1IiwibmRlYyIsInBhZF9vcHQkNiIsInBhZF9vcHQkNyIsInBhZF9vcHQkOCIsImRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIiwiYnVmZmVyX2NyZWF0ZSIsImluaXRfc2l6ZSIsImJ1ZmZlcl9jaGVja19zaXplIiwib3ZlcmhlYWQiLCJtaW5fbGVuIiwibmV3X3N0ciIsImJ1ZmZlcl9hZGRfY2hhciIsImJ1ZmZlcl9hZGRfc3RyaW5nIiwic3RyX2xlbiIsImJ1ZmZlcl9jb250ZW50cyIsImNoYXJfb2ZfaWNvbnYiLCJjaGFyX29mX2Zjb252IiwiY0YiLCJicHJpbnRfcGFkdHkiLCJwYWR0eSIsImJwcmludF9pZ25vcmVkX2ZsYWciLCJpZ25fZmxhZyIsImJwcmludF9wYWRfb3B0IiwiYnByaW50X3BhZGRpbmciLCJwYWR0eSQwIiwiYnByaW50X3ByZWNpc2lvbiIsImJwcmludF9pY29udl9mbGFnIiwiYnByaW50X2FsdGludF9mbXQiLCJicHJpbnRfZmNvbnZfZmxhZyIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCIsInN0ciQwIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsImZtdHR5JDQiLCJmbXR0eSQ1IiwiZm10dHkkNiIsImZtdHR5JDciLCJmbXR0eSQ4IiwiZm10dHkkOSIsInN1Yl9mbXR0eSIsImZtdHR5JDEwIiwic3ViX2ZtdHR5JDAiLCJmbXR0eSQxMSIsImZtdHR5JDEyIiwiZm10dHkkMTMiLCJmbXR0eSQxNCIsImZtdHR5JDE1IiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXRpdGVyIiwiZm10JDAiLCJpZ25fZmxhZyQwIiwic3RyJDEiLCJzZXQkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDEiLCJmbXQkMSIsInN5bW0iLCJmbXR0eV9yZWxfZGV0IiwiZGUiLCJlZCIsImFmIiwiZmEiLCJkZSQwIiwiZWQkMCIsImFmJDAiLCJmYSQwIiwiZGUkMSIsImVkJDEiLCJhZiQxIiwiZmEkMSIsImRlJDIiLCJlZCQyIiwiYWYkMiIsImZhJDIiLCJkZSQzIiwiZWQkMyIsImFmJDMiLCJmYSQzIiwiZGUkNCIsImVkJDQiLCJhZiQ0IiwiZmEkNCIsImRlJDUiLCJlZCQ1IiwiYWYkNSIsImZhJDUiLCJkZSQ2IiwiZWQkNiIsImFmJDYiLCJmYSQ2IiwiZGUkNyIsImVkJDciLCJhZiQ3IiwiZmEkNyIsImRlJDgiLCJlZCQ4IiwiYWYkOCIsImZhJDgiLCJ0cmFucyIsImpkIiwiZGoiLCJnYSIsImFnIiwiZGUkOSIsImVkJDkiLCJhZiQ5IiwiZmEkOSIsImRlJDEwIiwiZWQkMTAiLCJhZiQxMCIsImZhJDEwIiwiZGUkMTEiLCJlZCQxMSIsImFmJDExIiwiZmEkMTEiLCJkZSQxMiIsImVkJDEyIiwiYWYkMTIiLCJmYSQxMiIsImRlJDEzIiwiZWQkMTMiLCJhZiQxMyIsImZhJDEzIiwicmVzdDEiLCJyZXN0MiIsInJlc3QxJDAiLCJyZXN0MiQwIiwicmVzdDEkMSIsInJlc3QyJDEiLCJyZXN0MSQyIiwicmVzdDIkMiIsInJlc3QxJDMiLCJyZXN0MiQzIiwicmVzdDEkNCIsInJlc3QyJDQiLCJyZXN0MSQ1IiwicmVzdDIkNSIsInJlc3QxJDYiLCJyZXN0MiQ2IiwicmVzdDEkNyIsInR5MSQwIiwicmVzdDIkNyIsInR5MiQwIiwicmVzdDEkOCIsInR5MTIiLCJ0eTExIiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QxJDkiLCJyZXN0MiQ5IiwicmVzdDEkMTAiLCJyZXN0MiQxMCIsInJlc3QxJDExIiwicmVzdDIkMTEiLCJyZXN0MSQxMiIsInJlc3QyJDEyIiwicmVzdDEkMTMiLCJyZXN0MiQxMyIsImZtdHR5X29mX2ZtdCIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJ0eV9yZXN0IiwicHJlY190eSIsImZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsInR5JDAiLCJmb3JtYXR0aW5nX2dlbiIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eTAiLCJmbXR0eV9yZXN0IiwiZm10X3Jlc3QiLCJmbXR0eV9yZXN0JDAiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdHR5X3Jlc3QkMSIsImZtdCQyIiwiZm10X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMiIsImZtdCQzIiwiZm10X3Jlc3QkMyIsImZtdHR5X3Jlc3QkMyIsImZtdCQ0IiwiZm10X3Jlc3QkNCIsImZtdHR5X3Jlc3QkNCIsImZtdCQ1IiwiZm10X3Jlc3QkNSIsImZtdHR5X3Jlc3QkNSIsInByZWMkNCIsImZtdCQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInBhZCQ5IiwicGFkJDEwIiwiZm10dHlfcmVzdCQ2IiwicHJlYyQ2IiwiZm10JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicGFkJDExIiwicGFkJDEyIiwiZm10dHlfcmVzdCQ3IiwicHJlYyQ4IiwiZm10JDgiLCJmbXRfcmVzdCQ4IiwicGFkJDEzIiwicGFkJDE0IiwiZm10dHlfcmVzdCQ4IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXQkMTEiLCJmbXRfcmVzdCQxMSIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10JDEzIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eTEiLCJmbXRfcmVzdCQxMyIsInN1Yl9mbXR0eSQxIiwiZm10JDE0IiwiZm10dHlfcmVzdCQxMSIsImZtdF9yZXN0JDE0IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNiIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm10dHkzIiwiZm10MyIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxNyIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE4IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMTkiLCJmbXQkMjAiLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsImZtdHR5JDIxIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjAiLCJmbXQkMjEiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsInN1Yl9mbXR0eV9yZXN0JDMiLCJzdWJfZm10dHlfcmVzdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDYiLCJzdWJfZm10dHlfcmVzdCQ3Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDE0Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxOCIsInN1Yl9mbXR0eV9yZXN0JDE5Iiwic3ViX2ZtdHR5X3Jlc3QkMjAiLCJzdWJfZm10dHlfcmVzdCQyMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJzdWJfZm10dHlfcmVzdCQyNCIsInN1Yl9mbXR0eV9yZXN0JDI1Iiwic3ViX2ZtdHR5X3Jlc3QkMjYiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsIndpZHRoJDAiLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiZm9ybWF0X29mX2Zjb252Iiwic3ltYiIsInRyYW5zZm9ybV9pbnRfYWx0IiwiZGlnaXRzIiwicHV0IiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsImhleCIsInNpZ24iLCJjYW1sX3NwZWNpYWxfdmFsIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9wcmludGYkMCIsIm5ld19hY2MiLCJtYWtlX3ByaW50ZiIsIm1ha2VfcGFkZGluZyIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwicCQwIiwicCQxIiwiYWNjJDMiLCJhY2MkNCIsImthY2MiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2lnbm9yZWRfcGFyYW0iLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwieCQxIiwieCQyIiwieCQzIiwieCQ0IiwieCQ1IiwieCQ2IiwieCQ3IiwieCQ4IiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJ4JDkiLCJ4JDEwIiwieCQxMSIsIngkMTIiLCJ4JDEzIiwieCQxNCIsIngkMTUiLCJ4JDE2Iiwia29jIiwicmVzdCQyNCIsInJlc3QkMjUiLCJ4JDE3IiwicmVzdCQyNiIsIngkMTgiLCJyZXN0JDI3IiwieCQxOSIsInJlc3QkMjgiLCJyZXN0JDI5IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQzIiwicCQ0IiwicCQ1IiwicCQyIiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsInBhcnNlIiwibGl0X3N0YXJ0IiwiZW5kX2luZCIsImFkZF9saXRlcmFsIiwic3RyX2luZCQxIiwic3RyX2luZCQyIiwicGFyc2VfZmxhZ3MiLCJzdHJfaW5kJDAiLCJwYXJzZV90YWciLCJzdHJfaW5kJDMiLCJzdHJfaW5kXzEiLCJwYXJzZV9pbnRlZ2VyIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsIm5leHRfaW5kIiwic3RyX2luZF80Iiwic3RyX2luZF81Iiwic3RyX2luZCQ0Iiwic3RyX2luZF8xJDAiLCJzdHJfaW5kXzIkMCIsInN0cl9pbmRfMyQwIiwicyQxIiwiZm9ybWF0dGluZ19saXQkMSIsIm5leHRfaW5kJDAiLCJwY3RfaW5kIiwibWludXMiLCJwbHVzIiwic3BhY2UiLCJzZXRfZmxhZyIsInN0cl9pbmQkNSIsInNwYWNlJDAiLCJoYXNoJDAiLCJwbHVzJDAiLCJtaW51cyQwIiwiemVybyQwIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJwYXJzZV9wb3NpdGl2ZSIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfY29udmVyc2lvbiIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJzeW1iJDAiLCJwYXJzZV9jb252IiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiY2hlY2tfbm9fMCIsIm9wdF9vZl9wYWQiLCJ3aWR0aCQxIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0Iiwic3ViX2VuZCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2ZtdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJmbXRfcmVzdCQyNSIsInN1Yl9lbmQkMCIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsImlnbm9yZWQkNSIsImNvbXB1dGVfaW50X2NvbnYiLCJpZ25vcmVkJDgiLCJzcGFjZSQxIiwiaGFzaCQxIiwicGx1cyQyIiwia2luZCIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDEiLCJpZ24kMCIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJzdWJfZW5kJDEiLCJzdWJfZW5kJDIiLCJzdHJfaW5kJDYiLCJzdHJfaW5kJDciLCJvcHRpb24iLCJzdWJmbXQiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImYkMCIsImludmFsaWRfc3RhdGVfZGVzY3JpcHRpb24iLCJuZWdhdGl2ZV9sZW5ndGhfcmVxdWVzdGVkIiwibmVnYXRpdmVfY2FwYWNpdHlfcmVxdWVzdGVkIiwibWlzc2luZ19lbGVtZW50IiwidW5leHBlY3RlZF9lbXB0eV9lbGVtZW50IiwiY2hlY2tfc2FtZV9sZW5ndGgiLCJsZW5ndGhfYSIsImNoZWNrX3ZhbGlkX2xlbmd0aCIsImFyciIsImNhcGFjaXR5IiwidW5zYWZlX2dldCIsImdldF9sYXN0IiwicG9wX2xhc3QiLCJwb3BfbGFzdF9vcHQiLCJyZW1vdmVfbGFzdCIsImVuc3VyZV9jYXBhY2l0eSIsImNhcGFjaXR5X3JlcXVlc3QiLCJjdXJfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJuZXdfYXJyIiwiZW5zdXJlX2V4dHJhX2NhcGFjaXR5IiwiZXh0cmFfY2FwYWNpdHlfcmVxdWVzdCIsImZpdF9jYXBhY2l0eSIsInNldF9jYXBhY2l0eSIsImFkZF9sYXN0X2lmX3Jvb20iLCJlbGVtIiwiYWRkX2xhc3QiLCJhcHBlbmRfbGlzdCIsImxpIiwibGkkMCIsImFwcGVuZF9pdGVyIiwiYXBwZW5kX3NlcSIsImFwcGVuZF9hcnJheV9pZl9yb29tIiwibGVuZ3RoX2IiLCJhcHBlbmRfYXJyYXkiLCJhcHBlbmRfaWZfcm9vbSIsImFycl9hIiwiYXJyX2IiLCJpdGVyJDAiLCJvZl9hcnJheSIsInRvX2FycmF5IiwidG9fc2VxX3JlZW50cmFudCIsInRvX3NlcV9yZXYiLCJ0b19zZXFfcmV2X3JlZW50cmFudCIsImFzc29jMyIsInkyIiwieTEiLCJtYWtlX3N5bWxpc3QiLCJoZWxwX2FjdGlvbiIsImFkZF9oZWxwIiwic3BlY2xpc3QiLCJhZGQxIiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJjdXJyZW50IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwib3B0IiwiZm9sbG93JDAiLCJrZXl3b3JkIiwiZm9sbG93JDIiLCJub19hcmciLCJnZXRfYXJnIiwiY29uc3VtZV9hcmciLCJ0cmVhdF9hY3Rpb24iLCJub19hcmckMCIsImdldF9hcmckMCIsImNvbnN1bWVfYXJnJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJhcmckMSIsInIkMiIsImFyZyQyIiwiZiQzIiwiYXJnJDMiLCJyJDMiLCJhcmckNCIsInNwZWNzIiwidHJlYXRfYWN0aW9uJDAiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImYkNyIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsInNwZWMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsIndvcmQkMCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJsb2NmbXQiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwic3RyaW5nX29mX2V4dGVuc2lvbl9jb25zdHJ1Y3RvIiwiY29uc3RydWN0b3IiLCJmaWVsZHNfb3B0IiwiY29uc3RydWN0b3IkMCIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsInJhd19iYWNrdHJhY2VfZW50cmllcyIsImJ0IiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaW5mbyIsImlzX3JhaXNlIiwibGluZXMiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwicGFyYW0iLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90X2RlZm5hbWUiLCJiYWNrdHJhY2Vfc2xvdHMiLCJiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IiwiZW50cnkiLCJyYXdfYmFja3RyYWNlX2xlbmd0aCIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJvbGRfcHJpbnRlcnMiLCJuZXdfcHJpbnRlcnMiLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsImVycm9ycyIsImRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbiIsInN0YXR1cyIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwiZW1wdHlfYmFja3RyYWNlIiwiaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiIsImRlYnVnZ2VyX2luX3VzZSIsImV4biQxIiwicmF3X2JhY2t0cmFjZSQwIiwiY29uc3QkMCIsImNvbXBvc2UiLCJmbGlwIiwibmVnYXRlIiwiZmluYWxseSQwIiwid29yayIsImZpbmFsbHlfbm9fZXhuIiwid29ya19leG4kMCIsIndvcmtfZXhuIiwid29ya19idCIsImV2ZW50bG9nX3BhdXNlIiwiZXZlbnRsb2dfcmVzdW1lIiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJkZWxldGVfYWxhcm0iLCJjcmVhdGVfYWxhcm0iLCJudWxsX3RyYWNrZXIiLCJzYW1wbGluZ19yYXRlIiwidHJhY2tlciIsImNhbGxzdGFja19zaXplIiwib3Blbl9iaW4iLCJvcGVuX3RleHQiLCJvcGVuX2dlbiIsIndpdGhfb3BlbiIsIm9wZW5mdW4iLCJ3aXRoX29wZW5fYmluIiwid2l0aF9vcGVuX3RleHQiLCJ3aXRoX29wZW5fZ2VuIiwic2VlayIsImNsb3NlIiwiY2xvc2Vfbm9lcnIiLCJpbnB1dF9jaGFyIiwiaW5wdXRfYnl0ZSIsImlucHV0X2JpZ2FycmF5IiwicmVhbGx5X2lucHV0X2JpZ2FycmF5IiwicmVhZF91cHRvIiwiZW5zdXJlIiwibmV3X2xlbiQwIiwibmV3X2xlbiQxIiwiaW5wdXRfYWxsIiwiY2h1bmtfc2l6ZSIsImluaXRpYWxfc2l6ZSIsImluaXRpYWxfc2l6ZSQwIiwiaW5pdGlhbF9zaXplJDEiLCJucmVhZCIsImJ1ZiQyIiwiYnVmJDAiLCJidWYkMSIsInJlbSIsImlucHV0X2xpbmVzIiwiZm9sZF9saW5lcyIsInNldF9iaW5hcnlfbW9kZSIsImZsdXNoIiwib3V0cHV0X2NoYXIiLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaWdhcnJheSIsImhleF9vZl9zdHJpbmciLCJjaGFyX2hleCIsInN0cmluZ19vZl9oZXgiLCJkaWdpdCIsImhhc2hfbGVuZ3RoIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImNoYW5uZWwiLCJ0b3JlYWQiLCJidWZfc2l6ZSIsImN0eCIsInRvcmVhZCQwIiwidG9yZWFkJDEiLCJmaWxlbmFtZSIsImRpZ2VzdCIsInRvX2hleCIsIm9mX2hleCIsImtpbmRfc2l6ZV9pbl9ieXRlcyIsImNsb29wIiwiY29sIiwiZmxvb3AiLCJsYXlvdXQiLCJkaW1zIiwiZGxlbiIsInNpemVfaW5fYnl0ZXMiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQwIiwiZGltIiwic2l6ZV9pbl9ieXRlcyQxIiwic2xpY2UiLCJpbml0JDAiLCJiYSIsImNyZWF0ZSQxIiwiZGltMSIsImRpbTIiLCJzaXplX2luX2J5dGVzJDIiLCJzbGljZV9sZWZ0Iiwic2xpY2VfcmlnaHQiLCJpbml0JDEiLCJvZl9hcnJheSQwIiwiY3JlYXRlJDIiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDIiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwic2VyaWFsaXphdGlvbl9wcmVmaXgiLCJpMyIsImk0IiwiaTMkMCIsImk0JDAiLCJtayIsInNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiIsInRvX2JpbmFyeV9zdHJpbmciLCJvZl9iaW5hcnlfc3RyaW5nIiwicmVpbml0IiwibWFrZV9zZWxmX2luaXQiLCJtYXhfaW50MzEiLCJtYXhfaW50MzIiLCJiaXRzIiwiaW50X2F1eCIsImludCQwIiwiYm91bmQiLCJmdWxsX2ludCIsImludF9pbl9yYW5nZV9hdXgiLCJuYml0cyIsInNwYW4iLCJpbnRfaW5fcmFuZ2UiLCJiaXRzMzIiLCJpbnQzMmF1eCIsImludDMyIiwiaW50MzJfaW5fcmFuZ2UiLCJiaXRzNjQiLCJpbnQ2NGF1eCIsImludDY0IiwiaW50NjRfaW5fcmFuZ2UiLCJuYXRpdmViaXRzIiwibmF0aXZlaW50IiwibmF0aXZlaW50X2luX3JhbmdlIiwiZmxvYXQkMCIsImJvb2wiLCJta19kZWZhdWx0IiwicmFuZG9tX2tleSIsImJpdHMkMCIsImludCQxIiwiZnVsbF9pbnQkMCIsImludF9pbl9yYW5nZSQwIiwiaW50MzIkMCIsImludDMyX2luX3JhbmdlJDAiLCJuYXRpdmVpbnQkMCIsIm5hdGl2ZWludF9pbl9yYW5nZSQwIiwiaW50NjQkMCIsImludDY0X2luX3JhbmdlJDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJiaXRzMzIkMCIsImJpdHM2NCQwIiwibmF0aXZlYml0cyQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic3BsaXQkMCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZ19rZXkiLCJwb3dlcl8yX2Fib3ZlIiwicmFuZG9tIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwibmlkeCIsIm1hdGNoJDAiLCJvc2l6ZSIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsInJlcGxhY2UiLCJyZXBsYWNlX3NlcSIsImhhc2hfcGFyYW0iLCJyZWJ1aWxkIiwiZ2V0X2NvcHkiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJjb3VudCIsImFkZF9hdXgiLCJzZXR0ZXIiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0JDAiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3YnVja2V0Iiwib2xkbGVuIiwibmV3dCIsIm9iIiwib2kiLCJvaCIsIm9pJDAiLCJuaSIsImZpbmRfYXV4IiwiZm91bmQiLCJub3Rmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJ1bmtub3duIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfaW5maW5pdHkiLCJwcF9vdXRwdXRfc3RyaW5nIiwicHBfb3V0cHV0X25ld2xpbmUiLCJmb3JtYXRfcHBfdGV4dCIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX3NhbWVfbGluZSIsImZvcm1hdF9wcF90b2tlbiIsInNpemUkMCIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiYWR2YW5jZV9sZWZ0IiwicGVuZGluZ19jb3VudCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwiZW5kX3dpdGhfbmV3bGluZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfYnl0ZXMiLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfcHJpbnRfbm90aGluZyIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInZhbGlkYXRlX2dlb21ldHJ5IiwibWFyZ2luIiwibWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Z1bGxfZ2VvbWV0cnkiLCJwcF9zZXRfZ2VvbWV0cnkiLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3VwZGF0ZV9nZW9tZXRyeSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2JsYW5rcyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwicHBfbWFyZ2luIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJzdGRidWZfa2V5Iiwic3RyX2Zvcm1hdHRlcl9rZXkiLCJidWZmZXJlZF9vdXRfc3RyaW5nIiwiYnVmZmVyZWRfb3V0X2ZsdXNoIiwic3RkX2J1Zl9rZXkiLCJlcnJfYnVmX2tleSIsInN0ZF9mb3JtYXR0ZXJfa2V5IiwiZXJyX2Zvcm1hdHRlcl9rZXkiLCJnZXRfc3RkX2Zvcm1hdHRlciIsImdldF9lcnJfZm9ybWF0dGVyIiwiZ2V0X3N0cl9mb3JtYXR0ZXIiLCJnZXRfc3RkYnVmIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bmNocm9uaXplZF9mb3JtYXR0ZXIiLCJvdXRwdXQkMCIsImZsdXNoJDAiLCJzeW5jaHJvbml6ZWRfZm9ybWF0dGVyX29mX291dF8iLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2l0ZXIiLCJwcF92IiwicHBfc2VwIiwiaXNfZmlyc3QiLCJwcF92JDAiLCJwcF9wcmludF9saXN0IiwicHBfcHJpbnRfYXJyYXkiLCJwcF9wcmludF9zZXEiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwicHBfcHJpbnRfZWl0aGVyIiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0IiwiYnR5IiwicCQ2IiwicCQ3Iiwic2l6ZSQxIiwicCQ4Iiwia2RwcmludGYiLCJkcHJpbnRmIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwiZnMiLCJmcyQwIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJjaGFyX2NvdW50IiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiaW5hbWUiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJvcGVuX2luX2ZpbGUiLCJjbG9zZV9pbiIsImljJDAiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja19jaGFyIiwiY2hlY2tfdGhpc19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwiY29udiIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsImlzX29jdGFsX2RpZ2l0IiwiaXNfaGV4YV9kaWdpdCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwibG93ZXJjYXNlIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJnZXRfZGlnaXQiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsImZpbmRfc3RvcCIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mX2dlbiIsImVmIiwiYXJncyQxIiwiZXhjJDAiLCJleGMiLCJhcmdzJDAiLCJrc2NhbmYiLCJrc2NhbmZfb3B0IiwiYnNjYW5mIiwiYnNjYW5mX29wdCIsImtzc2NhbmYiLCJzc2NhbmYiLCJzc2NhbmZfb3B0Iiwic2NhbmYiLCJzY2FuZl9vcHQiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicHVibGljX21ldGhvZF9sYWJlbCIsInRhZyIsImNvbXBhcmUkMCIsImNvbXBhcmUkMSIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZml0X3NpemUiLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibWV0aG9kcyIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfdmFyaWFibGUiLCJuZXdfbWV0aG9kc192YXJpYWJsZXMiLCJtZXRocyIsInZhbHMiLCJtZXRocyQwIiwibm1ldGhzIiwibnZhbHMiLCJnZXRfdmFyaWFibGUiLCJnZXRfdmFyaWFibGVzIiwiYWRkX2luaXRpYWxpemVyIiwiY3JlYXRlX3RhYmxlIiwicHVibGljX21ldGhvZHMiLCJ0YWdzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJvYmoiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGkiLCJnZXRfZGF0YSIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJyb290X2RhdGEiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwidGFibGVzX2RhdGEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsIngkMjAiLCJjbG8kMCIsIm4kMzgiLCJlJDEwIiwibiQzNyIsIm4kMzYiLCJuJDIiLCJuJDM1IiwiZiQyMCIsIm4kMyIsImYkMTkiLCJuJDM0IiwibiQ0IiwiZiQxOCIsImUkOSIsIm4kMzMiLCJuJDUiLCJmJDE3IiwibiQzMiIsImYkMTYiLCJ5JDAiLCJuJDYiLCJmJDE1IiwibiQzMSIsIm4kNyIsImYkMTQiLCJlJDgiLCJuJDMwIiwibiQ4IiwiZiQxMyIsIm4kMjkiLCJuJDkiLCJmJDEyIiwibiQyOCIsImYkOCIsImUkMiIsIm4kMTAiLCJmJDExIiwiZSQ3IiwibiQyNyIsImYkOSIsIm4kMTEiLCJmJDEwIiwibiQyNiIsIm4kMTIiLCJuJDI1IiwibiQxMyIsIm4kMjQiLCJtJDEyIiwibiQxNCIsImUkMyIsIm4kMjMiLCJlJDYiLCJtJDExIiwibiQxNSIsIm0kMSIsIm4kMjIiLCJtJDEwIiwibSQyIiwibSQ5IiwibSQzIiwibiQxNiIsIm0kOCIsIm4kMjEiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ3IiwiZSQ1IiwibiQyMCIsIm0kNSIsIm4kMTgiLCJtJDYiLCJuJDE5IiwiaW5pdF9tb2RfYmxvY2siLCJjb21wcyQwIiwibW9kdSIsInNoYXBlIiwiZm4kMCIsImNvbXBzIiwiaW5pdF9tb2QiLCJ1cGRhdGVfbW9kX2Jsb2NrIiwiY2wiLCJ1cGRhdGVfbW9kIiwicHJuZyIsImhrZXkiLCJjbGVhbiIsImRvX2J1Y2tldCIsImluc2VydF9idWNrZXQiLCJjb250YWluZXIiLCJyZW1vdmVfYnVja2V0IiwiaGsiLCJmaW5kX2luX2J1Y2tldCIsImJ1Y2tldF9sZW5ndGhfYWxpdmUiLCJzdGF0c19hbGl2ZSIsInNldF9kYXRhIiwiZXBoIiwicXVlcnkiLCJzZXRfa2V5X2RhdGEiLCJ0ZXN0X2tleSIsInQkMCIsImdldF9rZXkxIiwic2V0X2tleTEiLCJnZXRfa2V5MiIsInNldF9rZXkyIiwiZ2V0X2RhdGEkMCIsInNldF9kYXRhJDAiLCJtYWtlJDEiLCJrZXkxIiwia2V5MiIsInF1ZXJ5JDAiLCJrMiQwIiwiazEkMCIsImVxdWFsJDAiLCJzZWVkZWRfaGFzaCQwIiwibWFrZSQyIiwiYWRkJDAiLCJ0ZXN0X2tleXMiLCJyZW1vdmUkMCIsImZpbmQkMCIsImxlbmd0aCQwIiwiY2xlYXIkMCIsImxlbmd0aCQxIiwiZ2V0X2tleSQwIiwic2V0X2tleSQwIiwiZ2V0X2RhdGEkMSIsInNldF9kYXRhJDEiLCJtYWtlJDMiLCJxdWVyeSQxIiwibWFrZSQ0IiwiYWRkJDEiLCJ0ZXN0X2tleXMkMCIsInJlbW92ZSQxIiwiZmluZCQxIiwibGVuZ3RoJDIiLCJjbGVhciQxIiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJjaG9wX3N1ZmZpeF9vcHQiLCJsZW5fZiIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSIsInF1b3RlX2NvbW1hbmQiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwiY2hvcF9zdWZmaXhfb3B0JDAiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQwIiwibG9vcCQwIiwibG9vcF9icyIsImFkZF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMSIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiaTAiLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicmFuZG9tX3N0YXRlIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsIm9wZW5fdGVtcF9maWxlIiwicGVybXMiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicG9sYXIiLCJzcXJ0IiwicSQwIiwidyQwIiwiZXhwIiwibG9nIiwicG93IiwicHJpbnRlciIsImNvbnRpbnVlJDAiLCJkaXNjb250aW51ZSIsImRpc2NvbnRpbnVlX3dpdGhfYmFja3RyYWNlIiwibWF0Y2hfd2l0aCIsImNvbXAiLCJoYW5kbGVyIiwiZWZmYyIsImVmZiIsImxhc3RfZmliZXIiLCJ0cnlfd2l0aCIsImZpYmVyIiwiY29udGludWVfZ2VuIiwicmVzdW1lX2Z1biIsImNvbnRpbnVlX3dpdGgiLCJkaXNjb250aW51ZV93aXRoIiwiZGlzY29udGludWVfd2l0aF9iYWNrdHJhY2UkMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2VpdGhlci5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3N5cy5tbC5pbiIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL29iai5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3R5cGUubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9hdG9taWMubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvbGF6eS5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3NlcS5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL29wdGlvbi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3Jlc3VsdC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2Jvb2wubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9jaGFyLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvdWNoYXIubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9saXN0Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvaW50Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvYnl0ZXMubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9zdHJpbmcubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC91bml0Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2FycmF5Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvZmxvYXQubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2ludDY0Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvbmF0aXZlaW50Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3NldC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL21hcC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3N0YWNrLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvcXVldWUubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9tdXRleC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3NlbWFwaG9yZS5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2RvbWFpbi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3ByaW50Zi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2R5bmFycmF5Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvYXJnLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9mdW4ubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9nYy5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2luX2NoYW5uZWwubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9vdXRfY2hhbm5lbC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL3dlYWsubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL1VzZXJzL2pvbi8ub3BhbS81LjIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxNb2QubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9Vc2Vycy9qb24vLm9wYW0vNS4yLjAvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvVXNlcnMvam9uLy5vcGFtLzUuMi4wL2xpYi9vY2FtbC9lZmZlY3QubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1lBK2dCUUE7SSw4QkFrQ1k7OztXQTlCUkMsaUJBQ1IsV0FMSUQsVUFJSUM7O1dBRUVDLG1CQUNWLFdBUElGLFVBTU1FOztXQUVIQyxtQkFDUCxXQVRJSCxVQVFHRzs7V0FFRUMsbUJBQ1QsV0FYSUosVUFVS0k7O1dBSUlDLG1CQUNiLFdBZklMLFVBY1NLOztXQUZKQyxtQkFDVCxXQWJJTixVQVlLTTs7V0FJQUMsbUJBQ1QsV0FqQklQLFVBZ0JLTzs7V0FFREMsbUJBQ1IsV0FuQklSLFVBa0JJUTs7V0FFV0MsbUJBQUpDO09BQ2YsV0FEZUEsSUFwQlhWLFVBb0JlUzs7V0FFU0UsbUJBQVhDO09BQ2pCLFdBRGlCQSxLQUFBQSxLQXRCYlosVUFzQndCVzs7V0FFbkJFLG1CQUNULFlBekJJYixVQXdCS2E7O1dBRUFDLG9CQUNULFlBM0JJZCxVQTBCS2M7O1dBRUZDLG9CQUNQLFlBN0JJZixV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MUQsR0FBRTV3QixHQUFFc21ELElBQUcrK0I7SUFDcEMsT0FuQkVNO2FBa0IyQi8wRDtzQkFDVHZzQjtjQUFLLDJCQUFMQSxHQURhaWlEO2NBQ1IsTUFBQSw0QkFBTGppRDthQUF1QzthQUQ1QnJFO2FBQUtxbEY7R0FDa0M7Ozs7Ozs7O1FBbkRwRUs7UUE0Q0FHO1FBR0FDO1FBR0FDOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeGNlcHRpb25zICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgKCogZm9yIHJ1bnRpbWUvZmFpbF9uYXQuYyAqKVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuYXJyYXlfYm91bmRfZXJyb3JcIlxuICAgIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcblxubGV0IGZhaWx3aXRoIHMgPSByYWlzZShGYWlsdXJlIHMpXG5sZXQgaW52YWxpZF9hcmcgcyA9IHJhaXNlKEludmFsaWRfYXJndW1lbnQgcylcblxuZXhjZXB0aW9uIEV4aXRcbmV4Y2VwdGlvbiBNYXRjaF9mYWlsdXJlID0gTWF0Y2hfZmFpbHVyZVxuZXhjZXB0aW9uIEFzc2VydF9mYWlsdXJlID0gQXNzZXJ0X2ZhaWx1cmVcbmV4Y2VwdGlvbiBJbnZhbGlkX2FyZ3VtZW50ID0gSW52YWxpZF9hcmd1bWVudFxuZXhjZXB0aW9uIEZhaWx1cmUgPSBGYWlsdXJlXG5leGNlcHRpb24gTm90X2ZvdW5kID0gTm90X2ZvdW5kXG5leGNlcHRpb24gT3V0X29mX21lbW9yeSA9IE91dF9vZl9tZW1vcnlcbmV4Y2VwdGlvbiBTdGFja19vdmVyZmxvdyA9IFN0YWNrX292ZXJmbG93XG5leGNlcHRpb24gU3lzX2Vycm9yID0gU3lzX2Vycm9yXG5leGNlcHRpb24gRW5kX29mX2ZpbGUgPSBFbmRfb2ZfZmlsZVxuZXhjZXB0aW9uIERpdmlzaW9uX2J5X3plcm8gPSBEaXZpc2lvbl9ieV96ZXJvXG5leGNlcHRpb24gU3lzX2Jsb2NrZWRfaW8gPSBTeXNfYmxvY2tlZF9pb1xuZXhjZXB0aW9uIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlID0gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcblxuKCogQ29tcG9zaXRpb24gb3BlcmF0b3JzICopXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4oKiBEZWJ1Z2dpbmcgKilcblxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fRlVOQ1RJT05fXyA6IHN0cmluZyA9IFwiJWxvY19GVU5DVElPTlwiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NoX2Zsb2F0XCIgXCJjYW1sX2Fjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luaF9mbG9hdFwiIFwiY2FtbF9hc2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5oX2Zsb2F0XCIgXCJjYW1sX2F0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GOF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICB8IFtdIC0+IGwyXG4gIHwgaDEgOjogW10gLT4gaDEgOjogbDJcbiAgfCBoMSA6OiBoMiA6OiBbXSAtPiBoMSA6OiBoMiA6OiBsMlxuICB8IGgxIDo6IGgyIDo6IGgzIDo6IHRsIC0+IGgxIDo6IGgyIDo6IGgzIDo6ICh0bCBAIGwyKVxuXG4oKiBJL08gb3BlcmF0aW9ucyAqKVxuXG50eXBlIGluX2NoYW5uZWxcbnR5cGUgb3V0X2NoYW5uZWxcblxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX291dCA6IGludCAtPiBvdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XCJcbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9pbiA6IGludCAtPiBpbl9jaGFubmVsID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblwiXG5cbmxldCBzdGRpbiA9IG9wZW5fZGVzY3JpcHRvcl9pbiAwXG5sZXQgc3Rkb3V0ID0gb3Blbl9kZXNjcmlwdG9yX291dCAxXG5sZXQgc3RkZXJyID0gb3Blbl9kZXNjcmlwdG9yX291dCAyXG5cbigqIEdlbmVyYWwgb3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG50eXBlIG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHkgfCBPcGVuX3dyb25seSB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdCB8IE9wZW5fdHJ1bmMgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeSB8IE9wZW5fdGV4dCB8IE9wZW5fbm9uYmxvY2tcblxuZXh0ZXJuYWwgb3Blbl9kZXNjIDogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuXG5leHRlcm5hbCBzZXRfb3V0X2NoYW5uZWxfbmFtZTogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX291dF9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9vdXQob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfb3V0X2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5fb3V0IG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX3RleHRdIDBvNjY2IG5hbWVcblxubGV0IG9wZW5fb3V0X2JpbiBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl9iaW5hcnldIDBvNjY2IG5hbWVcblxuZXh0ZXJuYWwgZmx1c2ggOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2ZsdXNoXCJcblxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxzX2xpc3QgOiB1bml0IC0+IG91dF9jaGFubmVsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dF9jaGFubmVsc19saXN0XCJcblxubGV0IGZsdXNoX2FsbCAoKSA9XG4gIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiAoKVxuICAgIHwgYTo6bCAtPlxuICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgIGZsdXNoIGFcbiAgICAgICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgICAgICgpICgqIGlnbm9yZSBjaGFubmVscyBjbG9zZWQgZHVyaW5nIGEgcHJlY2VkaW5nIGZsdXNoLiAqKVxuICAgICAgICBlbmQ7XG4gICAgICAgIGl0ZXIgbFxuICBpbiBpdGVyIChvdXRfY2hhbm5lbHNfbGlzdCAoKSlcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dCA6IG91dF9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dF9zdHJpbmcgOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRcIlxuXG5leHRlcm5hbCBvdXRwdXRfY2hhciA6IG91dF9jaGFubmVsIC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5cbmxldCBvdXRwdXRfYnl0ZXMgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXQgb2MgcyAwIChieXRlc19sZW5ndGggcylcblxubGV0IG91dHB1dF9zdHJpbmcgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgMCAoc3RyaW5nX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0IG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0IG9jIHMgb2ZzIGxlblxuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gc3RyaW5nX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRfc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIG9mcyBsZW5cblxuZXh0ZXJuYWwgb3V0cHV0X2J5dGUgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5leHRlcm5hbCBvdXRwdXRfYmluYXJ5X2ludCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9pbnRcIlxuXG5leHRlcm5hbCBtYXJzaGFsX3RvX2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiB1bml0IGxpc3QgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxubGV0IG91dHB1dF92YWx1ZSBjaGFuIHYgPSBtYXJzaGFsX3RvX2NoYW5uZWwgY2hhbiB2IFtdXG5cbmV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRcIlxuZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3Nfb3V0XCJcbmV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2Vfb3V0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX291dCBvYyA9IGZsdXNoIG9jOyBjbG9zZV9vdXRfY2hhbm5lbCBvY1xubGV0IGNsb3NlX291dF9ub2VyciBvYyA9XG4gICh0cnkgZmx1c2ggb2Mgd2l0aCBfIC0+ICgpKTtcbiAgKHRyeSBjbG9zZV9vdXRfY2hhbm5lbCBvYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfb3V0IDogb3V0X2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIEdlbmVyYWwgaW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHNldF9pbl9jaGFubmVsX25hbWU6IGluX2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX2luX2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX2luKG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X2luX2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5faW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl90ZXh0XSAwIG5hbWVcblxubGV0IG9wZW5faW5fYmluIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fYmluYXJ5XSAwIG5hbWVcblxuZXh0ZXJuYWwgaW5wdXRfY2hhciA6IGluX2NoYW5uZWwgLT4gY2hhciA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0IDogaW5fY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2lucHV0XCJcblxubGV0IGlucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYyB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gKCkgZWxzZSBiZWdpblxuICAgIGxldCByID0gdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlbiBpblxuICAgIGlmIHIgPSAwXG4gICAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIChvZnMgKyByKSAobGVuIC0gcilcbiAgZW5kXG5cbmxldCByZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJyZWFsbHlfaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIGxlbiBpblxuICByZWFsbHlfaW5wdXQgaWMgcyAwIGxlbjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbmV4dGVybmFsIGlucHV0X3NjYW5fbGluZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X3NjYW5fbGluZVwiXG5cbmxldCBpbnB1dF9saW5lIGNoYW4gPVxuICBsZXQgcmVjIGJ1aWxkX3Jlc3VsdCBidWYgcG9zID0gZnVuY3Rpb25cbiAgICBbXSAtPiBidWZcbiAgfCBoZCA6OiB0bCAtPlxuICAgICAgbGV0IGxlbiA9IGJ5dGVzX2xlbmd0aCBoZCBpblxuICAgICAgYnl0ZXNfYmxpdCBoZCAwIGJ1ZiAocG9zIC0gbGVuKSBsZW47XG4gICAgICBidWlsZF9yZXN1bHQgYnVmIChwb3MgLSBsZW4pIHRsIGluXG4gIGxldCByZWMgc2NhbiBhY2N1IGxlbiA9XG4gICAgbGV0IG4gPSBpbnB1dF9zY2FuX2xpbmUgY2hhbiBpblxuICAgIGlmIG4gPSAwIHRoZW4gYmVnaW4gICAgICAgICAgICAgICAgICAgKCogbiA9IDA6IHdlIGFyZSBhdCBFT0YgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfICAtPiBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiBhY2N1XG4gICAgZW5kIGVsc2UgaWYgbiA+IDAgdGhlbiBiZWdpbiAgICAgICAgICAoKiBuID4gMDogbmV3bGluZSBmb3VuZCBpbiBidWZmZXIgKilcbiAgICAgIGxldCByZXMgPSBieXRlc19jcmVhdGUgKG4gLSAxKSBpblxuICAgICAgaWdub3JlICh1bnNhZmVfaW5wdXQgY2hhbiByZXMgMCAobiAtIDEpKTtcbiAgICAgIGlnbm9yZSAoaW5wdXRfY2hhciBjaGFuKTsgICAgICAgICAgICgqIHNraXAgdGhlIG5ld2xpbmUgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByZXNcbiAgICAgIHwgIF8gLT4gbGV0IGxlbiA9IGxlbiArIG4gLSAxIGluXG4gICAgICAgICAgICAgIGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIChyZXMgOjogYWNjdSlcbiAgICBlbmQgZWxzZSBiZWdpbiAgICAgICAgICAgICAgICAgICAgICAgICgqIG4gPCAwOiBuZXdsaW5lIG5vdCBmb3VuZCAqKVxuICAgICAgbGV0IGJlZyA9IGJ5dGVzX2NyZWF0ZSAoLW4pIGluXG4gICAgICBpZ25vcmUodW5zYWZlX2lucHV0IGNoYW4gYmVnIDAgKC1uKSk7XG4gICAgICBzY2FuIChiZWcgOjogYWNjdSkgKGxlbiAtIG4pXG4gICAgZW5kXG4gIGluIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgKHNjYW4gW10gMClcblxuZXh0ZXJuYWwgaW5wdXRfYnl0ZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuZXh0ZXJuYWwgaW5wdXRfYmluYXJ5X2ludCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2ludFwiXG5leHRlcm5hbCBpbnB1dF92YWx1ZSA6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pblwiXG5leHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3NfaW5cIlxuZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2VfaW5fbm9lcnIgaWMgPSAodHJ5IGNsb3NlX2luIGljIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9pbiA6IGluX2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBvdXRwdXQgKilcblxubGV0IHByaW50X2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZG91dCBjXG5sZXQgcHJpbnRfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzXG5sZXQgcHJpbnRfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRvdXQgc1xubGV0IHByaW50X2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmludF9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByaW50X2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3Rkb3V0IHM7IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgZXJyb3IgKilcblxubGV0IHByZXJyX2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZGVyciBjXG5sZXQgcHJlcnJfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzXG5sZXQgcHJlcnJfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRlcnIgc1xubGV0IHByZXJyX2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmVycl9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3RkZXJyIHM7IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5cbigqIElucHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBpbnB1dCAqKVxuXG5sZXQgcmVhZF9saW5lICgpID0gZmx1c2ggc3Rkb3V0OyBpbnB1dF9saW5lIHN0ZGluXG5sZXQgcmVhZF9pbnQgKCkgPSBpbnRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfaW50X29wdCAoKSA9IGludF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXQgKCkgPSBmbG9hdF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdF9vcHQgKCkgPSBmbG9hdF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxuXG4oKiBPcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICopXG5cbm1vZHVsZSBMYXJnZUZpbGUgPVxuICBzdHJ1Y3RcbiAgICBleHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRfNjRcIlxuICAgIGV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3Nfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICAgIGV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pbl82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3NfaW5fNjRcIlxuICAgIGV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICBlbmRcblxuKCogRm9ybWF0cyAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuICAgPSBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mbXRcbiAgICAgICAgICAgICAgICogc3RyaW5nXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcblxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5cbmxldCBzdHJpbmdfb2ZfZm9ybWF0IChGb3JtYXQgKF9mbXQsIHN0cikpID0gc3RyXG5cbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5cbmxldCAoIF5eICkgKEZvcm1hdCAoZm10MSwgc3RyMSkpIChGb3JtYXQgKGZtdDIsIHN0cjIpKSA9XG4gIEZvcm1hdCAoQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmNvbmNhdF9mbXQgZm10MSBmbXQyLFxuICAgICAgICAgIHN0cjEgXiBcIiUsXCIgXiBzdHIyKVxuXG4oKiBNaXNjZWxsYW5lb3VzICopXG5cbmV4dGVybmFsIHN5c19leGl0IDogaW50IC0+ICdhID0gXCJjYW1sX3N5c19leGl0XCJcblxuKCogZm9yIGF0X2V4aXQgKilcbnR5cGUgJ2EgYXRvbWljX3RcbmV4dGVybmFsIGF0b21pY19tYWtlIDogJ2EgLT4gJ2EgYXRvbWljX3QgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCBhdG9taWNfZ2V0IDogJ2EgYXRvbWljX3QgLT4gJ2EgPSBcIiVhdG9taWNfbG9hZFwiXG5leHRlcm5hbCBhdG9taWNfY29tcGFyZV9hbmRfc2V0IDogJ2EgYXRvbWljX3QgLT4gJ2EgLT4gJ2EgLT4gYm9vbFxuICA9IFwiJWF0b21pY19jYXNcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IGF0b21pY19tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gYXRvbWljX21ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBhdG9taWNfZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBhdG9taWNfY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBhdG9taWNfY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2RvbWFpbl9sb2NhbF9hdF9leGl0ID0gcmVmIChmdW4gKCkgLT4gKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID1cbiAgKCFkb19kb21haW5fbG9jYWxfYXRfZXhpdCkgKCk7XG4gIChhdG9taWNfZ2V0IGV4aXRfZnVuY3Rpb24pICgpXG5cbmxldCBleGl0IHJldGNvZGUgPVxuICBkb19hdF9leGl0ICgpO1xuICBzeXNfZXhpdCByZXRjb2RlXG5cbmxldCBfID0gcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIiBkb19hdF9leGl0XG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICAgID0gQXJnXG5tb2R1bGUgQXJyYXkgICAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICAgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgICA9IEF0b21pY1xubW9kdWxlIEJpZ2FycmF5ICAgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgICA9IEJ1ZmZlclxubW9kdWxlIEJ5dGVzICAgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgICAgPSBDYWxsYmFja1xubW9kdWxlIENoYXIgICAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICAgID0gQ29tcGxleFxubW9kdWxlIENvbmRpdGlvbiAgICAgID0gQ29uZGl0aW9uXG5tb2R1bGUgRGlnZXN0ICAgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBEb21haW4gICAgICAgICA9IERvbWFpblxubW9kdWxlIER5bmFycmF5ICAgICAgID0gRHluYXJyYXlcbm1vZHVsZSBFZmZlY3QgICAgICAgICA9IEVmZmVjdFxubW9kdWxlIEVpdGhlciAgICAgICAgID0gRWl0aGVyXG5tb2R1bGUgRXBoZW1lcm9uICAgICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgICAgPSBGbG9hdFxubW9kdWxlIEZvcm1hdCAgICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgICA9IEdjXG5tb2R1bGUgSGFzaHRibCAgICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW5fY2hhbm5lbCAgICAgPSBJbl9jaGFubmVsXG5tb2R1bGUgSW50ICAgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBNdXRleCAgICAgICAgICA9IE11dGV4XG5tb2R1bGUgTmF0aXZlaW50ICAgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgICA9IE9wdGlvblxubW9kdWxlIE91dF9jaGFubmVsICAgID0gT3V0X2NoYW5uZWxcbm1vZHVsZSBQYXJzaW5nICAgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQcmludGV4YyAgICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZW1hcGhvcmUgICAgICA9IFNlbWFwaG9yZVxubW9kdWxlIFNlcSAgICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTdGFjayAgICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJpbmcgICAgICAgICA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ0xhYmVscyAgID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgICAgPSBTeXNcbm1vZHVsZSBUeXBlICAgICAgICAgICA9IFR5cGVcbm1vZHVsZSBVY2hhciAgICAgICAgICA9IFVjaGFyXG5tb2R1bGUgVW5pdCAgICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKiBAY29uZmlndXJlX2lucHV0QCAqKVxuIzMgXCJzeXMubWwuaW5cIlxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGJhY2tlbmRfdHlwZSA9XG4gIHwgTmF0aXZlXG4gIHwgQnl0ZWNvZGVcbiAgfCBPdGhlciBvZiBzdHJpbmdcbigqIFN5c3RlbSBpbnRlcmZhY2UgKilcblxuZXh0ZXJuYWwgZ2V0X2NvbmZpZzogdW5pdCAtPiBzdHJpbmcgKiBpbnQgKiBib29sID0gXCJjYW1sX3N5c19nZXRfY29uZmlnXCJcbmV4dGVybmFsIGdldF9leGVjdXRhYmxlX25hbWUgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lXCJcbmV4dGVybmFsIGFyZ3YgOiBzdHJpbmcgYXJyYXkgPSBcIiVzeXNfYXJndlwiXG5leHRlcm5hbCBiaWdfZW5kaWFuIDogdW5pdCAtPiBib29sID0gXCIlYmlnX2VuZGlhblwiXG5leHRlcm5hbCB3b3JkX3NpemUgOiB1bml0IC0+IGludCA9IFwiJXdvcmRfc2l6ZVwiXG5leHRlcm5hbCBpbnRfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlaW50X3NpemVcIlxuZXh0ZXJuYWwgbWF4X3dvc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlbWF4X3dvc2l6ZVwiXG5leHRlcm5hbCB1bml4IDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX3VuaXhcIlxuZXh0ZXJuYWwgd2luMzIgOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfd2luMzJcIlxuZXh0ZXJuYWwgY3lnd2luIDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX2N5Z3dpblwiXG5leHRlcm5hbCBnZXRfYmFja2VuZF90eXBlIDogdW5pdCAtPiBiYWNrZW5kX3R5cGUgPSBcIiViYWNrZW5kX3R5cGVcIlxuXG5sZXQgZXhlY3V0YWJsZV9uYW1lID0gZ2V0X2V4ZWN1dGFibGVfbmFtZSgpXG5sZXQgKG9zX3R5cGUsIF8sIF8pID0gZ2V0X2NvbmZpZygpXG5sZXQgYmFja2VuZF90eXBlID0gZ2V0X2JhY2tlbmRfdHlwZSAoKVxubGV0IGJpZ19lbmRpYW4gPSBiaWdfZW5kaWFuICgpXG5sZXQgd29yZF9zaXplID0gd29yZF9zaXplICgpXG5sZXQgaW50X3NpemUgPSBpbnRfc2l6ZSAoKVxubGV0IHVuaXggPSB1bml4ICgpXG5sZXQgd2luMzIgPSB3aW4zMiAoKVxubGV0IGN5Z3dpbiA9IGN5Z3dpbiAoKVxubGV0IG1heF9hcnJheV9sZW5ndGggPSBtYXhfd29zaXplICgpXG5sZXQgbWF4X2Zsb2F0YXJyYXlfbGVuZ3RoID0gbWF4X2FycmF5X2xlbmd0aCAvICg2NCAvIHdvcmRfc2l6ZSlcbmxldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMVxuZXh0ZXJuYWwgcnVudGltZV92YXJpYW50IDogdW5pdCAtPiBzdHJpbmcgPSBcImNhbWxfcnVudGltZV92YXJpYW50XCJcbmV4dGVybmFsIHJ1bnRpbWVfcGFyYW1ldGVycyA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1wiXG5cbmV4dGVybmFsIGZpbGVfZXhpc3RzOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfZmlsZV9leGlzdHNcIlxuZXh0ZXJuYWwgaXNfZGlyZWN0b3J5IDogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2lzX2RpcmVjdG9yeVwiXG5leHRlcm5hbCBpc19yZWd1bGFyX2ZpbGUgOiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zeXNfaXNfcmVndWxhcl9maWxlXCJcbmV4dGVybmFsIHJlbW92ZTogc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX3JlbW92ZVwiXG5leHRlcm5hbCByZW5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IHVuaXQgPSBcImNhbWxfc3lzX3JlbmFtZVwiXG5leHRlcm5hbCBnZXRlbnY6IHN0cmluZyAtPiBzdHJpbmcgPSBcImNhbWxfc3lzX2dldGVudlwiXG5cbmxldCBnZXRlbnZfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChnZXRlbnYgcylcbiAgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG5leHRlcm5hbCBjb21tYW5kOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFwiXG5leHRlcm5hbCB0aW1lOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9zeXNfdGltZVwiIFwiY2FtbF9zeXNfdGltZV91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGNoZGlyOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2hkaXJcIlxuZXh0ZXJuYWwgbWtkaXI6IHN0cmluZyAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9zeXNfbWtkaXJcIlxuZXh0ZXJuYWwgcm1kaXI6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19ybWRpclwiXG5leHRlcm5hbCBnZXRjd2Q6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19nZXRjd2RcIlxuZXh0ZXJuYWwgcmVhZGRpciA6IHN0cmluZyAtPiBzdHJpbmcgYXJyYXkgPSBcImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XCJcblxubGV0IGludGVyYWN0aXZlID0gcmVmIGZhbHNlXG5cbnR5cGUgc2lnbmFsX2JlaGF2aW9yID1cbiAgICBTaWduYWxfZGVmYXVsdFxuICB8IFNpZ25hbF9pZ25vcmVcbiAgfCBTaWduYWxfaGFuZGxlIG9mIChpbnQgLT4gdW5pdClcblxuZXh0ZXJuYWwgc2lnbmFsIDogaW50IC0+IHNpZ25hbF9iZWhhdmlvciAtPiBzaWduYWxfYmVoYXZpb3JcbiAgICAgICAgICAgICAgICA9IFwiY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyXCJcblxubGV0IHNldF9zaWduYWwgc2lnX251bSBzaWdfYmVoID0gaWdub3JlKHNpZ25hbCBzaWdfbnVtIHNpZ19iZWgpXG5cbmxldCBzaWdhYnJ0ID0gLTFcbmxldCBzaWdhbHJtID0gLTJcbmxldCBzaWdmcGUgPSAtM1xubGV0IHNpZ2h1cCA9IC00XG5sZXQgc2lnaWxsID0gLTVcbmxldCBzaWdpbnQgPSAtNlxubGV0IHNpZ2tpbGwgPSAtN1xubGV0IHNpZ3BpcGUgPSAtOFxubGV0IHNpZ3F1aXQgPSAtOVxubGV0IHNpZ3NlZ3YgPSAtMTBcbmxldCBzaWd0ZXJtID0gLTExXG5sZXQgc2lndXNyMSA9IC0xMlxubGV0IHNpZ3VzcjIgPSAtMTNcbmxldCBzaWdjaGxkID0gLTE0XG5sZXQgc2lnY29udCA9IC0xNVxubGV0IHNpZ3N0b3AgPSAtMTZcbmxldCBzaWd0c3RwID0gLTE3XG5sZXQgc2lndHRpbiA9IC0xOFxubGV0IHNpZ3R0b3UgPSAtMTlcbmxldCBzaWd2dGFscm0gPSAtMjBcbmxldCBzaWdwcm9mID0gLTIxXG5sZXQgc2lnYnVzID0gLTIyXG5sZXQgc2lncG9sbCA9IC0yM1xubGV0IHNpZ3N5cyA9IC0yNFxubGV0IHNpZ3RyYXAgPSAtMjVcbmxldCBzaWd1cmcgPSAtMjZcbmxldCBzaWd4Y3B1ID0gLTI3XG5sZXQgc2lneGZzeiA9IC0yOFxuXG5leGNlcHRpb24gQnJlYWtcblxubGV0IGNhdGNoX2JyZWFrIG9uID1cbiAgaWYgb24gdGhlblxuICAgIHNldF9zaWduYWwgc2lnaW50IChTaWduYWxfaGFuZGxlKGZ1biBfIC0+IHJhaXNlIEJyZWFrKSlcbiAgZWxzZVxuICAgIHNldF9zaWduYWwgc2lnaW50IFNpZ25hbF9kZWZhdWx0XG5cblxuZXh0ZXJuYWwgZW5hYmxlX3J1bnRpbWVfd2FybmluZ3M6IGJvb2wgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1wiXG5leHRlcm5hbCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQ6IHVuaXQgLT4gYm9vbCA9XG4gIFwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcIlxuXG4oKiBUaGUgdmVyc2lvbiBzdHJpbmcgaXMgZm91bmQgaW4gZmlsZSAuLi9WRVJTSU9OICopXG5cbmxldCBvY2FtbF92ZXJzaW9uID0gXCJAVkVSU0lPTkBcIlxuXG5sZXQgZGV2ZWxvcG1lbnRfdmVyc2lvbiA9IEBPQ0FNTF9ERVZFTE9QTUVOVF9WRVJTSU9OQFxuXG50eXBlIGV4dHJhX3ByZWZpeCA9IFBsdXMgfCBUaWxkZVxuXG50eXBlIGV4dHJhX2luZm8gPSBleHRyYV9wcmVmaXggKiBzdHJpbmdcblxudHlwZSBvY2FtbF9yZWxlYXNlX2luZm8gPSB7XG4gIG1ham9yIDogaW50O1xuICBtaW5vciA6IGludDtcbiAgcGF0Y2hsZXZlbCA6IGludDtcbiAgZXh0cmEgOiBleHRyYV9pbmZvIG9wdGlvblxufVxuXG5sZXQgb2NhbWxfcmVsZWFzZSA9IHtcbiAgbWFqb3IgPSBAT0NBTUxfVkVSU0lPTl9NQUpPUkA7XG4gIG1pbm9yID0gQE9DQU1MX1ZFUlNJT05fTUlOT1JAO1xuICBwYXRjaGxldmVsID0gQE9DQU1MX1ZFUlNJT05fUEFUQ0hMRVZFTEA7XG4gIGV4dHJhID0gQE9DQU1MX1JFTEVBU0VfRVhUUkFAXG59XG5cbigqIE9wdGltaXphdGlvbiAqKVxuXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG5cbm1vZHVsZSBJbW1lZGlhdGU2NCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuICBtb2R1bGUgdHlwZSBJbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuICBlbmRcblxuICBtb2R1bGUgTWFrZShJbW1lZGlhdGUgOiBJbW1lZGlhdGUpKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA9IHN0cnVjdFxuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuICAgIGV4dGVybmFsIG1hZ2ljIDogXyByZXByIC0+IHQgcmVwciA9IFwiJWlkZW50aXR5XCJcbiAgICBsZXQgcmVwciA9XG4gICAgICBpZiB3b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIG1hZ2ljIEltbWVkaWF0ZVxuICAgICAgZWxzZVxuICAgICAgICBtYWdpYyBOb25faW1tZWRpYXRlXG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgYWRkX29mZnNldCA6IHQgLT4gSW50MzIudCAtPiB0ID0gXCJjYW1sX29ial9hZGRfb2Zmc2V0XCJcbmV4dGVybmFsIHdpdGhfdGFnIDogaW50IC0+IHQgLT4gdCA9IFwiY2FtbF9vYmpfd2l0aF90YWdcIlxuXG5sZXQgZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDBcbmxldCBsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAyNDNcblxubGV0IGZvcmNpbmdfdGFnID0gMjQ0XG5sZXQgY29udF90YWcgPSAyNDVcbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxuXG5cbmxldCBpbnRfdGFnID0gMTAwMFxubGV0IG91dF9vZl9oZWFwX3RhZyA9IDEwMDFcbmxldCB1bmFsaWduZWRfdGFnID0gMTAwMlxuXG5tb2R1bGUgRXh0ZW5zaW9uX2NvbnN0cnVjdG9yID1cbnN0cnVjdFxuICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcbiAgbGV0IG9mX3ZhbCB4ID1cbiAgICBsZXQgeCA9IHJlcHIgeCBpblxuICAgIGxldCBzbG90ID1cbiAgICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgICAgZWxzZSB4XG4gICAgaW5cbiAgICBsZXQgbmFtZSA9XG4gICAgICBpZiAoaXNfYmxvY2sgc2xvdCkgJiYgKHRhZyBzbG90KSA9IG9iamVjdF90YWcgdGhlbiBmaWVsZCBzbG90IDBcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcbiAgICBpblxuICAgICAgaWYgKHRhZyBuYW1lKSA9IHN0cmluZ190YWcgdGhlbiAob2JqIHNsb3QgOiB0KVxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIG5hbWUgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gaWQgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMSkgOiBpbnQpXG5lbmRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIlxuICBsZXQgY3JlYXRlIGwgPVxuICAgIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gbWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uY3JlYXRlXCI7XG4gICAgY3JlYXRlIGxcblxuICBsZXQgbGVuZ3RoIHggPSBzaXplKHJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBsZXQgZ2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleVwiO1xuICAgIGdldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleV9jb3B5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcIlxuICBsZXQgZ2V0X2tleV9jb3B5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5X2NvcHlcIjtcbiAgICBnZXRfa2V5X2NvcHkgZSBvXG5cbiAgZXh0ZXJuYWwgc2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuICBsZXQgc2V0X2tleSBlIG8geCA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5zZXRfa2V5XCI7XG4gICAgc2V0X2tleSBlIG8geFxuXG4gIGV4dGVybmFsIHVuc2V0X2tleTogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG4gIGxldCB1bnNldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnVuc2V0X2tleVwiO1xuICAgIHVuc2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBjaGVja19rZXk6IHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19rZXlcIlxuICBsZXQgY2hlY2tfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5jaGVja19rZXlcIjtcbiAgICBjaGVja19rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGxldCBibGl0X2tleSBlMSBvMSBlMiBvMiBsID1cbiAgICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmJsaXRfa2V5XCJcbiAgICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXRfa2V5IGUxIG8xIGUyIG8yIGxcblxuICBleHRlcm5hbCBnZXRfZGF0YTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YVwiXG4gIGV4dGVybmFsIGdldF9kYXRhX2NvcHk6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVwiXG4gIGV4dGVybmFsIHNldF9kYXRhOiB0IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfZGF0YVwiXG4gIGV4dGVybmFsIHVuc2V0X2RhdGE6IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2RhdGFcIlxuICBleHRlcm5hbCBjaGVja19kYXRhOiB0IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19kYXRhXCJcbiAgZXh0ZXJuYWwgYmxpdF9kYXRhIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9ibGl0X2RhdGFcIlxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVHlwZSBlcXVhbGl0eSB3aXRuZXNzICopXG5cbnR5cGUgKF8sIF8pIGVxID0gRXF1YWw6ICgnYSwgJ2EpIGVxXG5cbigqIFR5cGUgaWRlbnRpZmllcnMgKilcblxubW9kdWxlIElkID0gc3RydWN0XG4gIHR5cGUgXyBpZCA9IC4uXG4gIG1vZHVsZSB0eXBlIElEID0gc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBfIGlkICs9IElkIDogdCBpZFxuICBlbmRcblxuICB0eXBlICEnYSB0ID0gKG1vZHVsZSBJRCB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gIGxldCBtYWtlICh0eXBlIGEpICgpIDogYSB0ID1cbiAgICAobW9kdWxlIHN0cnVjdCB0eXBlIHQgPSBhIHR5cGUgXyBpZCArPSBJZCA6IHQgaWQgZW5kKVxuXG4gIGxldFtAaW5saW5lXSB1aWQgKHR5cGUgYSkgKChtb2R1bGUgQSkgOiBhIHQpID1cbiAgICBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBBLklkKVxuXG4gIGxldCBwcm92YWJseV9lcXVhbFxuICAgICAgKHR5cGUgYSBiKSAoKG1vZHVsZSBBKSA6IGEgdCkgKChtb2R1bGUgQikgOiBiIHQpIDogKGEsIGIpIGVxIG9wdGlvblxuICAgID1cbiAgICBtYXRjaCBBLklkIHdpdGggQi5JZCAtPiBTb21lIEVxdWFsIHwgXyAtPiBOb25lXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTdGVwaGVuIERvbGFuLCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTctMjAxOCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZS4gICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBtYWtlIDogJ2EgLT4gJ2EgdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsIG1ha2VfY29udGVuZGVkIDogJ2EgLT4gJ2EgdCA9IFwiY2FtbF9hdG9taWNfbWFrZV9jb250ZW5kZWRcIlxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiAnYSA9IFwiJWF0b21pY19sb2FkXCJcbmV4dGVybmFsIGV4Y2hhbmdlIDogJ2EgdCAtPiAnYSAtPiAnYSA9IFwiJWF0b21pY19leGNoYW5nZVwiXG5leHRlcm5hbCBjb21wYXJlX2FuZF9zZXQgOiAnYSB0IC0+ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVhdG9taWNfY2FzXCJcbmV4dGVybmFsIGZldGNoX2FuZF9hZGQgOiBpbnQgdCAtPiBpbnQgLT4gaW50ID0gXCIlYXRvbWljX2ZldGNoX2FkZFwiXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0IHNldCByIHggPSBpZ25vcmUgKGV4Y2hhbmdlIHIgeClcbmxldCBpbmNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAxKVxubGV0IGRlY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByICgtMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG4oKiBbdXBkYXRlX3RvX2ZvcmNpbmcgYmxrXSB0cmllcyB0byB1cGRhdGUgYSBbYmxrXSB3aXRoIFtsYXp5X3RhZ10gdG9cbiAgIFtmb3JjaW5nX3RhZ10gdXNpbmcgY29tcGFyZS1hbmQtc3dhcCAoQ0FTKSwgdGFraW5nIGNhcmUgdG8gaGFuZGxlIGNvbmN1cnJlbnRcbiAgIG1hcmtpbmcgb2YgdGhlIGhlYWRlciB3b3JkIGJ5IGEgY29uY3VycmVudCBHQyB0aHJlYWQuIFJldHVybnMgWzBdIGlmIHRoZVxuICAgQ0FTIGlzIHN1Y2Nlc3NmdWwuIElmIHRoZSBDQVMgZmFpbHMsIHRoZW4gdGhlIHRhZyB3YXMgb2JzZXJ2ZWQgdG8gYmVcbiAgIHNvbWV0aGluZyBvdGhlciB0aGFuIFtsYXp5X3RhZ10gZHVlIHRvIGEgY29uY3VycmVudCBtdXRhdG9yLiBJbiB0aGlzIGNhc2UsXG4gICB0aGUgZnVuY3Rpb24gcmV0dXJucyBbMV0uICopXG5leHRlcm5hbCB1cGRhdGVfdG9fZm9yY2luZyA6IE9iai50IC0+IGludCA9XG4gIFwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nXCIgW0BAbm9hbGxvY11cblxuKCogW3Jlc2V0X3RvX2xhenkgYmxrXSBleHBlY3RzIFtibGtdIHRvIGJlIGEgbGF6eSBvYmplY3Qgd2l0aCBbT2JqLmZvcmNpbmdfdGFnXVxuICAgYW5kIHVwZGF0ZXMgdGhlIHRhZyB0byBbT2JqLmxhenlfdGFnXSwgdGFraW5nIGNhcmUgdG8gaGFuZGxlIGNvbmN1cnJlbnRcbiAgIG1hcmtpbmcgb2YgdGhpcyBvYmplY3QncyBoZWFkZXIgYnkgYSBjb25jdXJyZW50IEdDIHRocmVhZC4gKilcbmV4dGVybmFsIHJlc2V0X3RvX2xhenkgOiBPYmoudCAtPiB1bml0ID0gXCJjYW1sX2xhenlfcmVzZXRfdG9fbGF6eVwiIFtAQG5vYWxsb2NdXG5cbigqIFt1cGRhdGVfdG9fZm9yd2FyZCBibGtdIGV4cGVjdHMgW2Jsa10gdG8gYmUgYSBsYXp5IG9iamVjdCB3aXRoXG4gICBbT2JqLmZvcmNpbmdfdGFnXSBhbmQgdXBkYXRlcyB0aGUgdGFnIHRvIFtPYmouZm9yd2FyZF90YWddLCB0YWtpbmcgY2FyZSB0b1xuICAgaGFuZGxlIGNvbmN1cnJlbnQgbWFya2luZyBvZiB0aGlzIG9iamVjdCdzIGhlYWRlciBieSBhIGNvbmN1cnJlbnQgR0MgdGhyZWFkLlxuICopXG5leHRlcm5hbCB1cGRhdGVfdG9fZm9yd2FyZCA6IE9iai50IC0+IHVuaXQgPVxuICBcImNhbWxfbGF6eV91cGRhdGVfdG9fZm9yd2FyZFwiIFtAQG5vYWxsb2NdXG5cbigqIEFzc3VtZXMgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBmb3JjaW5nICopXG5sZXQgZG9fZm9yY2VfYmxvY2sgYmxrID1cbiAgbGV0IGIgPSBPYmoucmVwciBibGsgaW5cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIGIgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciAoKSk7ICgqIFJlbGVhc2UgdGhlIGNsb3N1cmUgKilcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICB1cGRhdGVfdG9fZm9yd2FyZCBiO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIGIgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmVzZXRfdG9fbGF6eSBiO1xuICAgIHJhaXNlIGVcblxuKCogQXNzdW1lcyBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGZvcmNpbmcgKilcbmxldCBkb19mb3JjZV92YWxfYmxvY2sgYmxrID1cbiAgbGV0IGIgPSBPYmoucmVwciBibGsgaW5cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIGIgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgYiAwIChPYmoucmVwciAoKSk7ICgqIFJlbGVhc2UgdGhlIGNsb3N1cmUgKilcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgT2JqLnNldF9maWVsZCBiIDAgKE9iai5yZXByIHJlc3VsdCk7XG4gIHVwZGF0ZV90b19mb3J3YXJkIGI7XG4gIHJlc3VsdFxuXG4oKiBDYWxsZWQgYnkgW2ZvcmNlX2dlbl0gKilcbmxldCBmb3JjZV9nZW5fbGF6eV9ibG9jayB+b25seV92YWwgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFdlIGV4cGVjdCB0aGUgdGFnIHRvIGJlIFtsYXp5X3RhZ10sIGJ1dCBtYXkgYmUgb3RoZXIgdGFncyBkdWUgdG9cbiAgICAgY29uY3VycmVudCBmb3JjaW5nIG9mIGxhenkgdmFsdWVzLiAqKVxuICBtYXRjaCB1cGRhdGVfdG9fZm9yY2luZyAoT2JqLnJlcHIgYmxrKSB3aXRoXG4gIHwgMCB3aGVuIG9ubHlfdmFsIC0+IGRvX2ZvcmNlX3ZhbF9ibG9jayBibGtcbiAgfCAwIC0+IGRvX2ZvcmNlX2Jsb2NrIGJsa1xuICB8IF8gLT4gcmFpc2UgVW5kZWZpbmVkXG5cbigqIHVzZWQgaW4gdGhlICVsYXp5X2ZvcmNlIHByaW1pdGl2ZSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgYmxrID0gZm9yY2VfZ2VuX2xhenlfYmxvY2sgfm9ubHlfdmFsOmZhbHNlIGJsa1xuXG4oKiBbZm9yY2VfZ2VuIH5vbmx5X3ZhbDpmYWxzZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpc1xuICAgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmUgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzXG4gICBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsIGluc3RydW1lbnRhdGlvbiBpcyB0dXJuZWQgb24uICopXG5sZXQgZm9yY2VfZ2VuIH5vbmx5X3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgKCogVXNpbmcgW1N5cy5vcGFxdWVfaWRlbnRpdHldIHByZXZlbnRzIHR3byBwb3RlbnRpYWwgcHJvYmxlbXM6XG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGhhdmUgRm9yd2FyZF90YWcsIHRoZW4gaXQgY291bGQgaGF2ZSBiZWVuXG4gICAgICAgc2hvcnRjdXQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSkuIFRoaXMgaXMgbm90IGFuIGlzc3VlIGhlcmUgYXQgdGhlIG1vbWVudCBzaW5jZVxuICAgICAgIFtPYmoudGFnXSBpcyBub3Qgc2ltcGxpZmllZCBieSB0aGUgY29tcGlsZXIsIGFuZCBHUFIjNzEzIGFsc29cbiAgICAgICBlbnN1cmVzIHRoYXQgbm8gdmFsdWUgd2lsbCBiZSBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBiZSBpbW11dGFibGUsIHRoZW4gaWYgdGhlIGNvbXBpbGVyXG4gICAgICAgY2Fubm90IHByb3ZlIHRoYXQgdGhlIGxhc3QgYnJhbmNoIGlzIG5vdCB0YWtlbiBpdCB3aWxsIGlzc3VlIGFcbiAgICAgICB3YXJuaW5nIDU5IChtb2RpZmljYXRpb24gb2YgYW4gaW1tdXRhYmxlIHZhbHVlKSAqKVxuICBsZXQgbHp2ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSBsenYgaW5cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgKCogU1RBUlQgbm8gc2FmZSBwb2ludHMuIElmIGEgR0Mgb2NjdXJzIGhlcmUsIHRoZW4gdGhlIG9iamVjdCBbeF0gbWF5IGJlXG4gICAgIHNob3J0LWNpcmN1aXRlZCwgYW5kIGdldHRpbmcgdGhlIGZpcnN0IGZpZWxkIG9mIFt4XSB3b3VsZCBnZXQgdXMgdGhlIHdyb25nXG4gICAgIHZhbHVlLiBMdWNraWx5LCB0aGUgY29tcGlsZXIgZG9lcyBub3QgaW5zZXJ0IEdDIHNhZmUgcG9pbnRzIGF0IHRoaXMgcGxhY2UsXG4gICAgIHNvIGl0IGlzIG9rLiAqKVxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW5cbiAgICAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKVxuICAoKiBFTkQgbm8gc2FmZSBwb2ludHMgKilcbiAgZWxzZSBpZiB0ID0gT2JqLmZvcmNpbmdfdGFnIHRoZW4gcmFpc2UgVW5kZWZpbmVkXG4gIGVsc2UgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9nZW5fbGF6eV9ibG9jayB+b25seV92YWwgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbGludGVybmFsTGF6eS50XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG5sZXQgZm9yY2VfdmFsIGwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX2dlbiB+b25seV92YWw6dHJ1ZSBsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8XG4gICAgIHQgPSBPYmouZm9yY2luZ190YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBtYXAgZiB4ID1cbiAgbGF6eSAoZiAoZm9yY2UgeCkpXG5cbmxldCBtYXBfdmFsIGYgeCA9XG4gIGlmIGlzX3ZhbCB4XG4gIHRoZW4gZnJvbV92YWwgKGYgKGZvcmNlIHgpKVxuICBlbHNlIGxhenkgKGYgKGZvcmNlIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgY29uY2F0IHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgIGFwcGVuZCB4IChjb25jYXQgbmV4dCkgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgYXBwZW5kIChmIHgpIChmbGF0X21hcCBmIG5leHQpICgpXG5cbmxldCBjb25jYXRfbWFwID0gZmxhdF9tYXBcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGZvbGRfbGVmdCBmIGFjYyBuZXh0XG5cbmxldCByZWMgaXRlciBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgaXRlciBmIG5leHRcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcblxubGV0IGlzX2VtcHR5IHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoXywgXykgLT5cbiAgICAgIGZhbHNlXG5cbmxldCB1bmNvbnMgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIFNvbWUgKHgsIHhzKVxuICB8IE5pbCAtPlxuICAgICAgTm9uZVxuXG5cblxubGV0IHJlYyBsZW5ndGhfYXV4IGFjY3UgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zIChfLCB4cykgLT5cbiAgICAgIGxlbmd0aF9hdXggKGFjY3UgKyAxKSB4c1xuXG5sZXRbQGlubGluZV0gbGVuZ3RoIHhzID1cbiAgbGVuZ3RoX2F1eCAwIHhzXG5cbmxldCByZWMgaXRlcmlfYXV4IGYgaSB4cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgKClcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGYgaSB4O1xuICAgICAgaXRlcmlfYXV4IGYgKGkrMSkgeHNcblxubGV0W0BpbmxpbmVdIGl0ZXJpIGYgeHMgPVxuICBpdGVyaV9hdXggZiAwIHhzXG5cbmxldCByZWMgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IGkgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGFjY3VcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGkgeCBpblxuICAgICAgZm9sZF9sZWZ0aV9hdXggZiBhY2N1IChpKzEpIHhzXG5cbmxldFtAaW5saW5lXSBmb2xkX2xlZnRpIGYgYWNjdSB4cyA9XG4gIGZvbGRfbGVmdGlfYXV4IGYgYWNjdSAwIHhzXG5cbmxldCByZWMgZm9yX2FsbCBwIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggJiYgZm9yX2FsbCBwIHhzXG5cbmxldCByZWMgZXhpc3RzIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBwIHggfHwgZXhpc3RzIHAgeHNcblxubGV0IHJlYyBmaW5kIHAgeHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmQgcCB4c1xuXG5sZXQgZmluZF9pbmRleCBwIHhzID1cbiAgbGV0IHJlYyBhdXggaSB4cyA9IG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5vbmVcbiAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICBpZiBwIHggdGhlbiBTb21lIGkgZWxzZSBhdXggKGkrMSkgeHMgaW5cbiAgYXV4IDAgeHNcblxubGV0IHJlYyBmaW5kX21hcCBmIHhzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOb25lXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgZmluZF9tYXAgZiB4c1xuICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgcmVzdWx0XG5cbmxldCBmaW5kX21hcGkgZiB4cyA9XG4gIGxldCByZWMgYXV4IGkgeHMgPSBtYXRjaCB4cygpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIGF1eCAoaSsxKSB4c1xuICAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICAgIHJlc3VsdCBpblxuICBhdXggMCB4c1xuXG4oKiBbaXRlcjJdLCBbZm9sZF9sZWZ0Ml0sIFtmb3JfYWxsMl0sIFtleGlzdHMyXSwgW21hcDJdLCBbemlwXSB3b3JrIGFsc28gaW5cbiAgIHRoZSBjYXNlIHdoZXJlIHRoZSB0d28gc2VxdWVuY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMuIFRoZXkgc3RvcCBhcyBzb29uXG4gICBhcyBvbmUgc2VxdWVuY2UgaXMgZXhoYXVzdGVkLiBUaGVpciBiZWhhdmlvciBpcyBzbGlnaHRseSBhc3ltbWV0cmljOiB3aGVuXG4gICBbeHNdIGlzIGVtcHR5LCB0aGV5IGRvIG5vdCBmb3JjZSBbeXNdOyBob3dldmVyLCB3aGVuIFt5c10gaXMgZW1wdHksIFt4c10gaXNcbiAgIGZvcmNlZCwgZXZlbiB0aG91Z2ggdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gW3hzKCldIHR1cm5zIG91dFxuICAgdG8gYmUgdXNlbGVzcy4gKilcblxubGV0IHJlYyBpdGVyMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICAoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgICgpXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5O1xuICAgICAgICAgIGl0ZXIyIGYgeHMgeXNcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSB4cyB5cyA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgYWNjdVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGFjY3VcbiAgICAgIHwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgeCB5IGluXG4gICAgICAgICAgZm9sZF9sZWZ0MiBmIGFjY3UgeHMgeXNcblxubGV0IHJlYyBmb3JfYWxsMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgICAgICBmIHggeSAmJiBmb3JfYWxsMiBmIHhzIHlzXG5cbmxldCByZWMgZXhpc3RzMiBmIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBmYWxzZVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggeXMoKSB3aXRoXG4gICAgICB8IE5pbCAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIGYgeCB5IHx8IGV4aXN0czIgZiB4cyB5c1xuXG5sZXQgcmVjIGVxdWFsIGVxIHhzIHlzID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gIHwgTmlsLCBOaWwgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh4LCB4cyksIENvbnMgKHksIHlzKSAtPlxuICAgICAgZXEgeCB5ICYmIGVxdWFsIGVxIHhzIHlzXG4gIHwgTmlsLCBDb25zIChfLCBfKVxuICB8IENvbnMgKF8sIF8pLCBOaWwgLT5cbiAgICAgIGZhbHNlXG5cbmxldCByZWMgY29tcGFyZSBjbXAgeHMgeXMgPVxuICBtYXRjaCB4cygpLCB5cygpIHdpdGhcbiAgfCBOaWwsIE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICBsZXQgYyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBjb21wYXJlIGNtcCB4cyB5c1xuICB8IE5pbCwgQ29ucyAoXywgXykgLT5cbiAgICAgIC0xXG4gIHwgQ29ucyAoXywgXyksIE5pbCAtPlxuICAgICAgKzFcblxuXG5cbigqIFtpbml0X2F1eCBmIGkgal0gaXMgdGhlIHNlcXVlbmNlIFtmIGksIC4uLiwgZiAoai0xKV0uICopXG5cbmxldCByZWMgaW5pdF9hdXggZiBpIGogKCkgPVxuICBpZiBpIDwgaiB0aGVuIGJlZ2luXG4gICAgQ29ucyAoZiBpLCBpbml0X2F1eCBmIChpICsgMSkgailcbiAgZW5kXG4gIGVsc2VcbiAgICBOaWxcblxubGV0IGluaXQgbiBmID1cbiAgaWYgbiA8IDAgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU2VxLmluaXRcIlxuICBlbHNlXG4gICAgaW5pdF9hdXggZiAwIG5cblxubGV0IHJlYyByZXBlYXQgeCAoKSA9XG4gIENvbnMgKHgsIHJlcGVhdCB4KVxuXG5sZXQgcmVjIGZvcmV2ZXIgZiAoKSA9XG4gIENvbnMgKGYoKSwgZm9yZXZlciBmKVxuXG4oKiBUaGlzIHByZWxpbWluYXJ5IGRlZmluaXRpb24gb2YgW2N5Y2xlXSByZXF1aXJlcyB0aGUgc2VxdWVuY2UgW3hzXVxuICAgdG8gYmUgbm9uZW1wdHkuIEFwcGx5aW5nIGl0IHRvIGFuIGVtcHR5IHNlcXVlbmNlIHdvdWxkIHByb2R1Y2UgYVxuICAgc2VxdWVuY2UgdGhhdCBkaXZlcmdlcyB3aGVuIGl0IGlzIGZvcmNlZC4gKilcblxubGV0IHJlYyBjeWNsZV9ub25lbXB0eSB4cyAoKSA9XG4gIGFwcGVuZCB4cyAoY3ljbGVfbm9uZW1wdHkgeHMpICgpXG5cbigqIFtjeWNsZSB4c10gY2hlY2tzIHdoZXRoZXIgW3hzXSBpcyBlbXB0eSBhbmQsIGlmIHNvLCByZXR1cm5zIGFuIGVtcHR5XG4gICBzZXF1ZW5jZS4gT3RoZXJ3aXNlLCBbY3ljbGUgeHNdIHByb2R1Y2VzIG9uZSBjb3B5IG9mIFt4c10gZm9sbG93ZWRcbiAgIHdpdGggdGhlIGluZmluaXRlIHNlcXVlbmNlIFtjeWNsZV9ub25lbXB0eSB4c10uIFRodXMsIHRoZSBub25lbXB0aW5lc3NcbiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBqdXN0IG9uY2UuICopXG5cbmxldCBjeWNsZSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMnKSAtPlxuICAgICAgQ29ucyAoeCwgYXBwZW5kIHhzJyAoY3ljbGVfbm9uZW1wdHkgeHMpKVxuXG4oKiBbaXRlcmF0ZTEgZiB4XSBpcyB0aGUgc2VxdWVuY2UgW2YgeCwgZiAoZiB4KSwgLi4uXS5cbiAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKGl0ZXJhdGUgZiB4KV0uXG4gICBbaXRlcmF0ZTFdIGlzIHVzZWQgYXMgYSBidWlsZGluZyBibG9jayBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0uICopXG5cbmxldCByZWMgaXRlcmF0ZTEgZiB4ICgpID1cbiAgbGV0IHkgPSBmIHggaW5cbiAgQ29ucyAoeSwgaXRlcmF0ZTEgZiB5KVxuXG4oKiBbaXRlcmF0ZSBmIHhdIGlzIHRoZSBzZXF1ZW5jZSBbeCwgZiB4LCAuLi5dLiAqKVxuXG4oKiBUaGUgcmVhc29uIHdoeSB3ZSBnaXZlIHRoaXMgc2xpZ2h0bHkgaW5kaXJlY3QgZGVmaW5pdGlvbiBvZiBbaXRlcmF0ZV0sXG4gICBhcyBvcHBvc2VkIHRvIHRoZSBtb3JlIG5haXZlIGRlZmluaXRpb24gdGhhdCBtYXkgY29tZSB0byBtaW5kLCBpcyB0aGF0XG4gICB3ZSBhcmUgY2FyZWZ1bCB0byBhdm9pZCBldmFsdWF0aW5nIFtmIHhdIHVudGlsIHRoaXMgZnVuY3Rpb24gY2FsbCBpc1xuICAgYWN0dWFsbHkgbmVjZXNzYXJ5LiBUaGUgbmFpdmUgZGVmaW5pdGlvbiAobm90IHNob3duIGhlcmUpIGNvbXB1dGVzIHRoZVxuICAgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSBzZXF1ZW5jZSwgW2YgeF0sIHdoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IGlzXG4gICByZXF1ZXN0ZWQgYnkgdGhlIHVzZXIuICopXG5cbmxldCBpdGVyYXRlIGYgeCA9XG4gIGNvbnMgeCAoaXRlcmF0ZTEgZiB4KVxuXG5cblxubGV0IHJlYyBtYXBpX2F1eCBmIGkgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoZiBpIHgsIG1hcGlfYXV4IGYgKGkrMSkgeHMpXG5cbmxldFtAaW5saW5lXSBtYXBpIGYgeHMgPVxuICBtYXBpX2F1eCBmIDAgeHNcblxuKCogW3RhaWxfc2NhbiBmIHMgeHNdIGlzIGVxdWl2YWxlbnQgdG8gW3RhaWwgKHNjYW4gZiBzIHhzKV0uXG4gICBbdGFpbF9zY2FuXSBpcyB1c2VkIGFzIGEgYnVpbGRpbmcgYmxvY2sgaW4gdGhlIGRlZmluaXRpb24gb2YgW3NjYW5dLiAqKVxuXG4oKiBUaGlzIHNsaWdodGx5IGluZGlyZWN0IGRlZmluaXRpb24gb2YgW3NjYW5dIGlzIG1lYW50IHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgZWxlbWVudHMgdG9vIGVhcmx5OyBzZWUgdGhlIGFib3ZlIGNvbW1lbnQgYWJvdXQgW2l0ZXJhdGUxXSBhbmQgW2l0ZXJhdGVdLiAqKVxuXG5sZXQgcmVjIHRhaWxfc2NhbiBmIHMgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbGV0IHMgPSBmIHMgeCBpblxuICAgICAgQ29ucyAocywgdGFpbF9zY2FuIGYgcyB4cylcblxubGV0IHNjYW4gZiBzIHhzID1cbiAgY29ucyBzICh0YWlsX3NjYW4gZiBzIHhzKVxuXG4oKiBbdGFrZV0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW3Rha2UgMCB4c10gcmV0dXJucyBbZW1wdHldXG4gICBpbW1lZGlhdGVseSwgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCByZWMgdGFrZV9hdXggbiB4cyA9XG4gIGlmIG4gPSAwIHRoZW5cbiAgICBlbXB0eVxuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgICAgIENvbnMgKHgsIHRha2VfYXV4IChuLTEpIHhzKVxuXG5sZXQgdGFrZSBuIHhzID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcS50YWtlXCI7XG4gIHRha2VfYXV4IG4geHNcblxuKCogW2ZvcmNlX2Ryb3AgbiB4c10gaXMgZXF1aXZhbGVudCB0byBbZHJvcCBuIHhzICgpXS5cbiAgIFtmb3JjZV9kcm9wIG4geHNdIHJlcXVpcmVzIFtuID4gMF0uXG4gICBbZm9yY2VfZHJvcF0gaXMgdXNlZCBhcyBhIGJ1aWxkaW5nIGJsb2NrIGluIHRoZSBkZWZpbml0aW9uIG9mIFtkcm9wXS4gKilcblxubGV0IHJlYyBmb3JjZV9kcm9wIG4geHMgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgbGV0IG4gPSBuIC0gMSBpblxuICAgICAgaWYgbiA9IDAgdGhlblxuICAgICAgICB4cygpXG4gICAgICBlbHNlXG4gICAgICAgIGZvcmNlX2Ryb3AgbiB4c1xuXG4oKiBbZHJvcF0gaXMgZGVmaW5lZCBpbiBzdWNoIGEgd2F5IHRoYXQgW2Ryb3AgMCB4c10gcmV0dXJucyBbeHNdIGltbWVkaWF0ZWx5LFxuICAgd2l0aG91dCBhbGxvY2F0aW5nIGFueSBtZW1vcnkuICopXG5cbmxldCBkcm9wIG4geHMgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU2VxLmRyb3BcIlxuICBlbHNlIGlmIG4gPSAwIHRoZW5cbiAgICB4c1xuICBlbHNlXG4gICAgZnVuICgpIC0+XG4gICAgICBmb3JjZV9kcm9wIG4geHNcblxubGV0IHJlYyB0YWtlX3doaWxlIHAgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgaWYgcCB4IHRoZW4gQ29ucyAoeCwgdGFrZV93aGlsZSBwIHhzKSBlbHNlIE5pbFxuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgcCB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIGFzIG5vZGUgLT5cbiAgICAgIGlmIHAgeCB0aGVuIGRyb3Bfd2hpbGUgcCB4cyAoKSBlbHNlIG5vZGVcblxubGV0IHJlYyBncm91cCBlcSB4cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBDb25zIChjb25zIHggKHRha2Vfd2hpbGUgKGVxIHgpIHhzKSwgZ3JvdXAgZXEgKGRyb3Bfd2hpbGUgKGVxIHgpIHhzKSlcblxuZXhjZXB0aW9uIEZvcmNlZF90d2ljZVxuXG5tb2R1bGUgU3VzcGVuc2lvbiA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egc3VzcGVuc2lvbiA9XG4gICAgdW5pdCAtPiAnYVxuXG4gICgqIENvbnZlcnNpb25zLiAqKVxuXG4gIGxldCB0b19sYXp5IDogJ2Egc3VzcGVuc2lvbiAtPiAnYSBMYXp5LnQgPVxuICAgIExhenkuZnJvbV9mdW5cbiAgICAoKiBmdW4gcyAtPiBsYXp5IChzKCkpICopXG5cbiAgbGV0IGZyb21fbGF6eSAocyA6ICdhIExhenkudCkgOiAnYSBzdXNwZW5zaW9uID1cbiAgICBmdW4gKCkgLT4gTGF6eS5mb3JjZSBzXG5cbiAgKCogW21lbW9pemVdIHR1cm5zIGFuIGFyYml0cmFyeSBzdXNwZW5zaW9uIGludG8gYSBwZXJzaXN0ZW50IHN1c3BlbnNpb24uICopXG5cbiAgbGV0IG1lbW9pemUgKHMgOiAnYSBzdXNwZW5zaW9uKSA6ICdhIHN1c3BlbnNpb24gPVxuICAgIGZyb21fbGF6eSAodG9fbGF6eSBzKVxuXG4gICgqIFtmYWlsdXJlXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBmYWlscyB3aGVuIGZvcmNlZC4gKilcblxuICBsZXQgZmFpbHVyZSA6IF8gc3VzcGVuc2lvbiA9XG4gICAgZnVuICgpIC0+XG4gICAgICAoKiBBIHN1c3BlbnNpb24gY3JlYXRlZCBieSBbb25jZV0gaGFzIGJlZW4gZm9yY2VkIHR3aWNlLiAqKVxuICAgICAgcmFpc2UgRm9yY2VkX3R3aWNlXG5cbiAgKCogSWYgW2ZdIGlzIGEgc3VzcGVuc2lvbiwgdGhlbiBbb25jZSBmXSBpcyBhIHN1c3BlbnNpb24gdGhhdCBjYW4gYmUgZm9yY2VkXG4gICAgIGF0IG1vc3Qgb25jZS4gSWYgaXQgaXMgZm9yY2VkIG1vcmUgdGhhbiBvbmNlLCB0aGVuIFtGb3JjZWRfdHdpY2VdIGlzXG4gICAgIHJhaXNlZC4gKilcblxuICBsZXQgb25jZSAoZiA6ICdhIHN1c3BlbnNpb24pIDogJ2Egc3VzcGVuc2lvbiA9XG4gICAgbGV0IGFjdGlvbiA9IEF0b21pYy5tYWtlIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgICgqIEdldCB0aGUgZnVuY3Rpb24gY3VycmVudGx5IHN0b3JlZCBpbiBbYWN0aW9uXSwgYW5kIHdyaXRlIHRoZVxuICAgICAgICAgZnVuY3Rpb24gW2ZhaWx1cmVdIGluIGl0cyBwbGFjZSwgc28gdGhlIG5leHQgYWNjZXNzIHdpbGwgcmVzdWx0XG4gICAgICAgICBpbiBhIGNhbGwgdG8gW2ZhaWx1cmUoKV0uICopXG4gICAgICBsZXQgZiA9IEF0b21pYy5leGNoYW5nZSBhY3Rpb24gZmFpbHVyZSBpblxuICAgICAgZigpXG5cbmVuZCAoKiBTdXNwZW5zaW9uICopXG5cbmxldCByZWMgbWVtb2l6ZSB4cyA9XG4gIFN1c3BlbnNpb24ubWVtb2l6ZSAoZnVuICgpIC0+XG4gICAgbWF0Y2ggeHMoKSB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgICAgTmlsXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgQ29ucyAoeCwgbWVtb2l6ZSB4cylcbiAgKVxuXG5sZXQgcmVjIG9uY2UgeHMgPVxuICBTdXNwZW5zaW9uLm9uY2UgKGZ1biAoKSAtPlxuICAgIG1hdGNoIHhzKCkgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICAgIE5pbFxuICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgIENvbnMgKHgsIG9uY2UgeHMpXG4gIClcblxuXG5sZXQgcmVjIHppcCB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKCh4LCB5KSwgemlwIHhzIHlzKVxuXG5sZXQgcmVjIG1hcDIgZiB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBtYXRjaCB5cygpIHdpdGhcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgTmlsXG4gICAgICB8IENvbnMgKHksIHlzKSAtPlxuICAgICAgICAgIENvbnMgKGYgeCB5LCBtYXAyIGYgeHMgeXMpXG5cbmxldCByZWMgaW50ZXJsZWF2ZSB4cyB5cyAoKSA9XG4gIG1hdGNoIHhzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgeXMoKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgQ29ucyAoeCwgaW50ZXJsZWF2ZSB5cyB4cylcblxuKCogW3NvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIChjb25zIHggeHMpIHlzXS5cblxuICAgW3NvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgIFtzb3J0ZWRfbWVyZ2UgY21wIHhzIChjb25zIHkgeXMpXS5cblxuICAgW3NvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c10gaXMgZXF1aXZhbGVudCB0b1xuICAgICBbc29ydGVkX21lcmdlIGNtcCAoY29ucyB4IHhzKSAoY29ucyB5IHlzKV0uXG5cbiAgIFRoZXNlIHRocmVlIGZ1bmN0aW9ucyBhcmUgdXNlZCBhcyBidWlsZGluZyBibG9ja3MgaW4gdGhlIGRlZmluaXRpb25cbiAgIG9mIFtzb3J0ZWRfbWVyZ2VdLiAqKVxuXG5sZXQgcmVjIHNvcnRlZF9tZXJnZTFsIGNtcCB4IHhzIHlzICgpID1cbiAgbWF0Y2ggeXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBDb25zICh4LCB4cylcbiAgfCBDb25zICh5LCB5cykgLT5cbiAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5hbmQgc29ydGVkX21lcmdlMXIgY21wIHhzIHkgeXMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIENvbnMgKHksIHlzKVxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgc29ydGVkX21lcmdlMSBjbXAgeCB4cyB5IHlzXG5cbmFuZCBzb3J0ZWRfbWVyZ2UxIGNtcCB4IHhzIHkgeXMgPVxuICBpZiBjbXAgeCB5IDw9IDAgdGhlblxuICAgIENvbnMgKHgsIHNvcnRlZF9tZXJnZTFyIGNtcCB4cyB5IHlzKVxuICBlbHNlXG4gICAgQ29ucyAoeSwgc29ydGVkX21lcmdlMWwgY21wIHggeHMgeXMpXG5cbmxldCBzb3J0ZWRfbWVyZ2UgY21wIHhzIHlzICgpID1cbiAgbWF0Y2ggeHMoKSwgeXMoKSB3aXRoXG4gICAgfCBOaWwsIE5pbCAtPlxuICAgICAgICBOaWxcbiAgICB8IE5pbCwgY1xuICAgIHwgYywgTmlsIC0+XG4gICAgICAgIGNcbiAgICB8IENvbnMgKHgsIHhzKSwgQ29ucyAoeSwgeXMpIC0+XG4gICAgICAgIHNvcnRlZF9tZXJnZTEgY21wIHggeHMgeSB5c1xuXG5cbmxldCByZWMgbWFwX2ZzdCB4eXMgKCkgPVxuICBtYXRjaCB4eXMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICgoeCwgXyksIHh5cykgLT5cbiAgICAgIENvbnMgKHgsIG1hcF9mc3QgeHlzKVxuXG5sZXQgcmVjIG1hcF9zbmQgeHlzICgpID1cbiAgbWF0Y2ggeHlzKCkgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgTmlsXG4gIHwgQ29ucyAoKF8sIHkpLCB4eXMpIC0+XG4gICAgICBDb25zICh5LCBtYXBfc25kIHh5cylcblxubGV0IHVuemlwIHh5cyA9XG4gIG1hcF9mc3QgeHlzLCBtYXBfc25kIHh5c1xuXG5sZXQgc3BsaXQgPVxuICB1bnppcFxuXG4oKiBbZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHNdIGlzIGVxdWl2YWxlbnQgdG9cbiAgIFtmaWx0ZXJfbWFwIEVpdGhlci5maW5kX2xlZnQgKG1hcCBmIHhzKV0uICopXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX2xlZnRfbWFwIGYgeHMgKCkgPVxuICBtYXRjaCB4cygpIHdpdGhcbiAgfCBOaWwgLT5cbiAgICAgIE5pbFxuICB8IENvbnMgKHgsIHhzKSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgIHwgRWl0aGVyLkxlZnQgeSAtPlxuICAgICAgICAgIENvbnMgKHksIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzKVxuICAgICAgfCBFaXRoZXIuUmlnaHQgXyAtPlxuICAgICAgICAgIGZpbHRlcl9tYXBfZmluZF9sZWZ0X21hcCBmIHhzICgpXG5cbmxldCByZWMgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzICgpID1cbiAgbWF0Y2ggeHMoKSB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBOaWxcbiAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IEVpdGhlci5MZWZ0IF8gLT5cbiAgICAgICAgICBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMgKClcbiAgICAgIHwgRWl0aGVyLlJpZ2h0IHogLT5cbiAgICAgICAgICBDb25zICh6LCBmaWx0ZXJfbWFwX2ZpbmRfcmlnaHRfbWFwIGYgeHMpXG5cbmxldCBwYXJ0aXRpb25fbWFwIGYgeHMgPVxuICBmaWx0ZXJfbWFwX2ZpbmRfbGVmdF9tYXAgZiB4cyxcbiAgZmlsdGVyX21hcF9maW5kX3JpZ2h0X21hcCBmIHhzXG5cbmxldCBwYXJ0aXRpb24gcCB4cyA9XG4gIGZpbHRlciBwIHhzLCBmaWx0ZXIgKGZ1biB4IC0+IG5vdCAocCB4KSkgeHNcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW3BlZWwgeHNzXSBpcyBhIHBhaXIgb2ZcbiAgIHRoZSBmaXJzdCBjb2x1bW4gKGEgc2VxdWVuY2Ugb2YgZWxlbWVudHMpIGFuZCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgbWF0cml4IChhIHNlcXVlbmNlIG9mIHNob3J0ZXIgcm93cykuIFRoZXNlIHR3byBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBUaGUgcm93cyBvZiB0aGUgbWF0cml4IFt4c3NdIGFyZSBub3QgcmVxdWlyZWQgdG8gaGF2ZSB0aGUgc2FtZVxuICAgbGVuZ3RoLiBBbiBlbXB0eSByb3cgaXMgaWdub3JlZC4gKilcblxuKCogQmVjYXVzZSBbcGVlbF0gdXNlcyBbdW56aXBdLCBpdHMgYXJndW1lbnQgbXVzdCBiZSBwZXJzaXN0ZW50LiBUaGUgc2FtZVxuICAgcmVtYXJrIGFwcGxpZXMgdG8gW3RyYW5zcG9zZV0sIFtkaWFnb25hbHNdLCBbcHJvZHVjdF0sIGV0Yy4gKilcblxubGV0IHBlZWwgeHNzID1cbiAgdW56aXAgKGZpbHRlcl9tYXAgdW5jb25zIHhzcylcblxubGV0IHJlYyB0cmFuc3Bvc2UgeHNzICgpID1cbiAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgeHNzIGluXG4gIGlmIGlzX2VtcHR5IGhlYWRzIHRoZW4gYmVnaW5cbiAgICBhc3NlcnQgKGlzX2VtcHR5IHRhaWxzKTtcbiAgICBOaWxcbiAgZW5kXG4gIGVsc2VcbiAgICBDb25zIChoZWFkcywgdHJhbnNwb3NlIHRhaWxzKVxuXG4oKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gW2RpYWdvbmFsc10gdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQsIFtyZW1haW5kZXJzXSxcbiAgIHdoaWNoIGNvbnRhaW5zIHRoZSByZW1haW5kZXJzIG9mIHRoZSByb3dzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgIGRpc2NvdmVyZWQuICopXG5cbmxldCByZWMgZGlhZ29uYWxzIHJlbWFpbmRlcnMgeHNzICgpID1cbiAgbWF0Y2ggeHNzKCkgd2l0aFxuICB8IENvbnMgKHhzLCB4c3MpIC0+XG4gICAgICBiZWdpbiBtYXRjaCB4cygpIHdpdGhcbiAgICAgIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgbm9uZW1wdHkgcm93IFt4IDo6IHhzXS4gVGh1cywgdGhlIG5leHQgZGlhZ29uYWxcbiAgICAgICAgICAgICBpcyBbeCA6OiBoZWFkc106IHRoaXMgZGlhZ29uYWwgYmVnaW5zIHdpdGggW3hdIGFuZCBjb250aW51ZXMgd2l0aFxuICAgICAgICAgICAgIHRoZSBmaXJzdCBlbGVtZW50IG9mIGV2ZXJ5IHJvdyBpbiBbcmVtYWluZGVyc10uIEluIHRoZSByZWN1cnNpdmVcbiAgICAgICAgICAgICBjYWxsLCB0aGUgYXJndW1lbnQgW3JlbWFpbmRlcnNdIGlzIGluc3RhbnRpYXRlZCB3aXRoIFt4cyA6OlxuICAgICAgICAgICAgIHRhaWxzXSwgd2hpY2ggbWVhbnMgdGhhdCB3ZSBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3csIFt4c10sXG4gICAgICAgICAgICAgYW5kIHRoYXQgd2Uga2VlcCB0aGUgdGFpbHMgb2YgdGhlIHByZS1leGlzdGluZyByZW1haW5pbmcgcm93cy4gKilcbiAgICAgICAgICBsZXQgaGVhZHMsIHRhaWxzID0gcGVlbCByZW1haW5kZXJzIGluXG4gICAgICAgICAgQ29ucyAoY29ucyB4IGhlYWRzLCBkaWFnb25hbHMgKGNvbnMgeHMgdGFpbHMpIHhzcylcbiAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgKCogV2UgZGlzY292ZXIgYSBuZXcgZW1wdHkgcm93LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZGlhZ29uYWwgaXNcbiAgICAgICAgICAgICBqdXN0IFtoZWFkc10sIGFuZCBbcmVtYWluZGVyc10gaXMgaW5zdGFudGlhdGVkIHdpdGgganVzdCBbdGFpbHNdLFxuICAgICAgICAgICAgIGFzIHdlIGRvIG5vdCBoYXZlIG9uZSBtb3JlIHJlbWFpbmluZyByb3cuICopXG4gICAgICAgICAgbGV0IGhlYWRzLCB0YWlscyA9IHBlZWwgcmVtYWluZGVycyBpblxuICAgICAgICAgIENvbnMgKGhlYWRzLCBkaWFnb25hbHMgdGFpbHMgeHNzKVxuICAgICAgZW5kXG4gIHwgTmlsIC0+XG4gICAgICAoKiBUaGVyZSBhcmUgbm8gbW9yZSByb3dzIHRvIGJlIGRpc2NvdmVyZWQuIFRoZXJlIHJlbWFpbnMgdG8gZXhoYXVzdFxuICAgICAgICAgdGhlIHJlbWFpbmluZyByb3dzLiAqKVxuICAgICAgdHJhbnNwb3NlIHJlbWFpbmRlcnMgKClcblxuKCogSWYgW3hzc10gaXMgYSBtYXRyaXggKGEgc2VxdWVuY2Ugb2Ygcm93cyksIHRoZW4gW2RpYWdvbmFscyB4c3NdIGlzXG4gICB0aGUgc2VxdWVuY2Ugb2YgaXRzIGRpYWdvbmFscy5cblxuICAgVGhlIGZpcnN0IGRpYWdvbmFsIGNvbnRhaW5zIGp1c3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBmaXJzdCByb3cuIFRoZSBzZWNvbmQgZGlhZ29uYWwgY29udGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXG4gICBzZWNvbmQgcm93IGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGZpcnN0IHJvdzsgYW5kIHNvIG9uLlxuICAgVGhpcyBraW5kIG9mIGRpYWdvbmFsIGlzIGluIGZhY3Qgc29tZXRpbWVzIGtub3duIGFzIGFuIGFudGlkaWFnb25hbC5cblxuICAgLSBFdmVyeSBkaWFnb25hbCBpcyBhIGZpbml0ZSBzZXF1ZW5jZS5cbiAgIC0gVGhlIHJvd3Mgb2YgdGhlIG1hdHJpeCBbeHNzXSBhcmUgbm90IHJlcXVpcmVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIGlzIG5vdCByZXF1aXJlZCB0byBiZSBmaW5pdGUgKGluIGVpdGhlciBkaXJlY3Rpb24pLlxuICAgLSBUaGUgbWF0cml4IFt4c3NdIG11c3QgYmUgcGVyc2lzdGVudC4gKilcblxubGV0IGRpYWdvbmFscyB4c3MgPVxuICBkaWFnb25hbHMgZW1wdHkgeHNzXG5cbmxldCBtYXBfcHJvZHVjdCBmIHhzIHlzID1cbiAgY29uY2F0IChkaWFnb25hbHMgKFxuICAgIG1hcCAoZnVuIHggLT5cbiAgICAgIG1hcCAoZnVuIHkgLT5cbiAgICAgICAgZiB4IHlcbiAgICAgICkgeXNcbiAgICApIHhzXG4gICkpXG5cbmxldCBwcm9kdWN0IHhzIHlzID1cbiAgbWFwX3Byb2R1Y3QgKGZ1biB4IHkgLT4gKHgsIHkpKSB4cyB5c1xuXG5sZXQgb2ZfZGlzcGVuc2VyIGl0ID1cbiAgbGV0IHJlYyBjICgpID1cbiAgICBtYXRjaCBpdCgpIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgTmlsXG4gICAgfCBTb21lIHggLT5cbiAgICAgICAgQ29ucyAoeCwgYylcbiAgaW5cbiAgY1xuXG5sZXQgdG9fZGlzcGVuc2VyIHhzID1cbiAgbGV0IHMgPSByZWYgeHMgaW5cbiAgZnVuICgpIC0+XG4gICAgbWF0Y2ggKCFzKSgpIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgICBOb25lXG4gICAgfCBDb25zICh4LCB4cykgLT5cbiAgICAgICAgcyA6PSB4cztcbiAgICAgICAgU29tZSB4XG5cblxuXG5sZXQgcmVjIGludHMgaSAoKSA9XG4gIENvbnMgKGksIGludHMgKGkgKyAxKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2FcblxubGV0IG5vbmUgPSBOb25lXG5sZXQgc29tZSB2ID0gU29tZSB2XG5sZXQgdmFsdWUgbyB+ZGVmYXVsdCA9IG1hdGNoIG8gd2l0aCBTb21lIHYgLT4gdiB8IE5vbmUgLT4gZGVmYXVsdFxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIm9wdGlvbiBpcyBOb25lXCJcbmxldCBiaW5kIG8gZiA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gZiB2XG5sZXQgam9pbiA9IGZ1bmN0aW9uIFNvbWUgbyAtPiBvIHwgTm9uZSAtPiBOb25lXG5sZXQgbWFwIGYgbyA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gU29tZSAoZiB2KVxubGV0IGZvbGQgfm5vbmUgfnNvbWUgPSBmdW5jdGlvbiBTb21lIHYgLT4gc29tZSB2IHwgTm9uZSAtPiBub25lXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB2IC0+IGYgdiB8IE5vbmUgLT4gKClcbmxldCBpc19ub25lID0gZnVuY3Rpb24gTm9uZSAtPiB0cnVlIHwgU29tZSBfIC0+IGZhbHNlXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uIE5vbmUgLT4gZmFsc2UgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgZXF1YWwgZXEgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGVxIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gdHJ1ZVxufCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIGNtcCBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gY21wIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gMFxufCBOb25lLCBTb21lIF8gLT4gLTFcbnwgU29tZSBfLCBOb25lIC0+IDFcblxubGV0IHRvX3Jlc3VsdCB+bm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gRXJyb3Igbm9uZSB8IFNvbWUgdiAtPiBPayB2XG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE5vbmUgLT4gW10gfCBTb21lIHYgLT4gW3ZdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gTm9uZSAtPiBTZXEuZW1wdHkgfCBTb21lIHYgLT4gU2VxLnJldHVybiB2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2VcblxubGV0IG9rIHYgPSBPayB2XG5sZXQgZXJyb3IgZSA9IEVycm9yIGVcbmxldCB2YWx1ZSByIH5kZWZhdWx0ID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gZGVmYXVsdFxubGV0IGdldF9vayA9IGZ1bmN0aW9uIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgRXJyb3IgX1wiXG5sZXQgZ2V0X2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBlIHwgT2sgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBPayBfXCJcbmxldCBiaW5kIHIgZiA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IGYgdiB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgam9pbiA9IGZ1bmN0aW9uIE9rIHIgLT4gciB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwIGYgPSBmdW5jdGlvbiBPayB2IC0+IE9rIChmIHYpIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXBfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gRXJyb3IgKGYgZSkgfCBPayBfIGFzIHYgLT4gdlxubGV0IGZvbGQgfm9rIH5lcnJvciA9IGZ1bmN0aW9uIE9rIHYgLT4gb2sgdiB8IEVycm9yIGUgLT4gZXJyb3IgZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyAtPiAoKVxubGV0IGl0ZXJfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZiBlIHwgT2sgXyAtPiAoKVxubGV0IGlzX29rID0gZnVuY3Rpb24gT2sgXyAtPiB0cnVlIHwgRXJyb3IgXyAtPiBmYWxzZVxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgXyAtPiB0cnVlIHwgT2sgXyAtPiBmYWxzZVxuXG5sZXQgZXF1YWwgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgXywgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBPayBfLCBFcnJvciBfIC0+IC0xXG58IEVycm9yIF8sIE9rIF8gLT4gMVxuXG5sZXQgdG9fb3B0aW9uID0gZnVuY3Rpb24gT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gT2sgdiAtPiBbdl0gfCBFcnJvciBfIC0+IFtdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gT2sgdiAtPiBTZXEucmV0dXJuIHYgfCBFcnJvciBfIC0+IFNlcS5lbXB0eVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBib29sID0gZmFsc2UgfCB0cnVlXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmxldCBlcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19pbnQgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG5cbigqIFVURiBjb2RlY3MgdG9vbHMgKilcblxudHlwZSB1dGZfZGVjb2RlID0gaW50XG4oKiBUaGlzIGlzIGFuIGludCBbMHhEVVVVVVVVXSBkZWNvbXBvc2VkIGFzIGZvbGxvd3M6XG4gICAtIFtEXSBpcyBmb3VyIGJpdHMgZm9yIGRlY29kZSBpbmZvcm1hdGlvbiwgdGhlIGhpZ2hlc3QgYml0IGlzIHNldCBpZiB0aGVcbiAgICAgZGVjb2RlIGlzIHZhbGlkLiBUaGUgdGhyZWUgbG93ZXIgYml0cyBpbmRpY2F0ZSB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gICAgIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmUgY29uc3VtZWQgYnkgdGhlIGRlY29kZS5cbiAgIC0gW1VVVVVVVV0gaXMgdGhlIGRlY29kZWQgVW5pY29kZSBjaGFyYWN0ZXIgb3IgdGhlIFVuaWNvZGUgcmVwbGFjZW1lbnRcbiAgICAgY2hhcmFjdGVyIFUrRkZGRCBpZiBmb3IgaW52YWxpZCBkZWNvZGVzLiAqKVxuXG5sZXQgdmFsaWRfYml0ID0gMjdcbmxldCBkZWNvZGVfYml0cyA9IDI0XG5cbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2lzX3ZhbGlkIGQgPSAoZCBsc3IgdmFsaWRfYml0KSA9IDFcbmxldFtAaW5saW5lXSB1dGZfZGVjb2RlX2xlbmd0aCBkID0gKGQgbHNyIGRlY29kZV9iaXRzKSBsYW5kIDBiMTExXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV91Y2hhciBkID0gdW5zYWZlX29mX2ludCAoZCBsYW5kIDB4RkZGRkZGKVxubGV0W0BpbmxpbmVdIHV0Zl9kZWNvZGUgbiB1ID0gKCg4IGxvciBuKSBsc2wgZGVjb2RlX2JpdHMpIGxvciAodG9faW50IHUpXG5sZXRbQGlubGluZV0gdXRmX2RlY29kZV9pbnZhbGlkIG4gPSAobiBsc2wgZGVjb2RlX2JpdHMpIGxvciByZXBcblxubGV0IHV0Zl84X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+IDFcbnwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDNcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgdXRmXzE2X2J5dGVfbGVuZ3RoIHUgPSBtYXRjaCB0b19pbnQgdSB3aXRoXG58IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbnwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDJcbnwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxufCBfIC0+IGFzc2VydCBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgaW5pdCBpIGxhc3QgZiA9XG4gIGlmIGkgPiBsYXN0IHRoZW4gW11cbiAgZWxzZSBpZiBpID0gbGFzdCB0aGVuIFtmIGldXG4gIGVsc2VcbiAgICBsZXQgcjEgPSBmIGkgaW5cbiAgICBsZXQgcjIgPSBmIChpKzEpIGluXG4gICAgcjEgOjogcjIgOjogaW5pdCAoaSsyKSBsYXN0IGZcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGluaXQgMCAobGVuIC0gMSkgZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IFthMV0gLT5cbiAgICAgIGxldCByMSA9IGYgYTEgaW5cbiAgICAgIFtyMV1cbiAgfCBhMTo6YTI6OmwgLT5cbiAgICAgIGxldCByMSA9IGYgYTEgaW5cbiAgICAgIGxldCByMiA9IGYgYTIgaW5cbiAgICAgIHIxOjpyMjo6bWFwIGYgbFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBbYTFdIC0+XG4gICAgICBsZXQgcjEgPSBmIGkgYTEgaW5cbiAgICAgIFtyMV1cbiAgfCBhMTo6YTI6OmwgLT5cbiAgICAgIGxldCByMSA9IGYgaSBhMSBpblxuICAgICAgbGV0IHIyID0gZiAoaSsxKSBhMiBpblxuICAgICAgcjE6OnIyOjptYXBpIChpKzIpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChbYTFdLCBbYjFdKSAtPlxuICAgICAgbGV0IHIxID0gZiBhMSBiMSBpblxuICAgICAgW3IxXVxuICB8IChhMTo6YTI6OmwxLCBiMTo6YjI6OmwyKSAtPlxuICAgICAgbGV0IHIxID0gZiBhMSBiMSBpblxuICAgICAgbGV0IHIyID0gZiBhMiBiMiBpblxuICAgICAgcjE6OnIyOjptYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IGZpbmRfaW5kZXggcCA9XG4gIGxldCByZWMgYXV4IGkgPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgcCBhIHRoZW4gU29tZSBpIGVsc2UgYXV4IChpKzEpIGwgaW5cbiAgYXV4IDBcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX21hcGkgZiA9XG4gIGxldCByZWMgYXV4IGkgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gYXV4IChpKzEpIGxcbiAgICAgZW5kIGluXG4gIGF1eCAwXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGZpbmRfYWxsIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggOjogZmluZF9hbGwgcCBsIGVsc2UgZmluZF9hbGwgcCBsXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaWx0ZXJpIHAgaSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCB4OjpsIC0+XG4gICAgICBsZXQgaScgPSBpICsgMSBpblxuICAgICAgaWYgcCBpIHggdGhlbiB4IDo6IGZpbHRlcmkgcCBpJyBsIGVsc2UgZmlsdGVyaSBwIGknIGxcblxubGV0IGZpbHRlcmkgcCBsID0gZmlsdGVyaSBwIDAgbFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgeCA6OiBsIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBsXG4gICAgICB8IFNvbWUgdiAtPiB2IDo6IGZpbHRlcl9tYXAgZiBsXG5cbmxldFtAdGFpbF9tb2RfY29uc10gcmVjIGNvbmNhdF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCB4Ojp4cyAtPiBwcmVwZW5kX2NvbmNhdF9tYXAgKGYgeCkgZiB4c1xuYW5kW0B0YWlsX21vZF9jb25zXSBwcmVwZW5kX2NvbmNhdF9tYXAgeXMgZiB4cyA9XG4gIG1hdGNoIHlzIHdpdGhcbiAgfCBbXSAtPiBjb25jYXRfbWFwIGYgeHNcbiAgfCB5IDo6IHlzIC0+IHkgOjogcHJlcGVuZF9jb25jYXRfbWFwIHlzIGYgeHNcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fbWFwIHAgbCA9XG4gIGxldCByZWMgcGFydCBsZWZ0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IGxlZnQsIHJldiByaWdodClcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggcCB4IHdpdGhcbiAgICAgICB8IEVpdGhlci5MZWZ0IHYgLT4gcGFydCAodiA6OiBsZWZ0KSByaWdodCBsXG4gICAgICAgfCBFaXRoZXIuUmlnaHQgdiAtPiBwYXJ0IGxlZnQgKHYgOjogcmlnaHQpIGxcbiAgICAgZW5kXG4gIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSB2ZXJ5IGxvbmcgbGlzdCAobGVuZ3RoIG92ZXIgYWJvdXQgMTAwMDAwKSwgaXQgdXNlZCB0byBiZVxuICAgZmFzdGVyIHRvIGNvbnZlcnQgdGhlIGxpc3QgdG8gYW4gYXJyYXksIHNvcnQgdGhlIGFycmF5LCBhbmQgY29udmVydFxuICAgYmFjaywgdHJ1bmNhdGluZyB0aGUgYXJyYXkgb2JqZWN0IGFmdGVyIHByZXBlbmRpbmcgZWFjaCB0aG91c2FuZFxuICAgZW50cmllcyB0byB0aGUgcmVzdWx0aW5nIGxpc3QuIEltcG9zc2libGUgbm93IHRoYXQgT2JqLnRydW5jYXRlIGhhc1xuICAgYmVlbiByZW1vdmVkLiAqKVxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcblxubGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyA6OiBfIC0+IGZhbHNlXG5cbigqKiB7MSBDb21wYXJpc29ufSAqKVxuXG4oKiBOb3RlOiB3ZSBhcmUgKm5vdCogc2hvcnRjdXR0aW5nIHRoZSBsaXN0IGJ5IHVzaW5nXG4gICBbTGlzdC5jb21wYXJlX2xlbmd0aHNdIGZpcnN0OyB0aGlzIG1heSBiZSBzbG93ZXIgb24gbG9uZyBsaXN0c1xuICAgaW1tZWRpYXRlbHkgc3RhcnQgd2l0aCBkaXN0aW5jdCBlbGVtZW50cy4gSXQgaXMgYWxzbyBpbmNvcnJlY3QgZm9yXG4gICBbY29tcGFyZV0gYmVsb3csIGFuZCBpdCBpcyBiZXR0ZXIgKHByaW5jaXBsZSBvZiBsZWFzdCBzdXJwcmlzZSkgdG9cbiAgIHVzZSB0aGUgc2FtZSBhcHByb2FjaCBmb3IgYm90aCBmdW5jdGlvbnMuICopXG5sZXQgcmVjIGVxdWFsIGVxIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IFtdLCBfOjpfIHwgXzo6XywgW10gLT4gZmFsc2VcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPiBlcSBhMSBhMiAmJiBlcXVhbCBlcSBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfOjpfIC0+IC0xXG4gIHwgXzo6XywgW10gLT4gMVxuICB8IGExOjpsMSwgYTI6OmwyIC0+XG4gICAgbGV0IGMgPSBjbXAgYTEgYTIgaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjXG4gICAgZWxzZSBjb21wYXJlIGNtcCBsMSBsMlxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBvZl9zZXEgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+IFtdXG4gIHwgU2VxLkNvbnMgKHgxLCBzZXEpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBzZXEgKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFt4MV1cbiAgICAgIHwgU2VxLkNvbnMgKHgyLCBzZXEpIC0+IHgxIDo6IHgyIDo6IG9mX3NlcSBzZXFcbiAgICAgIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gSW50Lm1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCB1bnNhZmVfZXNjYXBlIHMgPVxuICAoKiBXZSBwZXJmb3JtIHR3byBwYXNzZXMgb24gdGhlIGlucHV0IHNlcXVlbmNlLCBvbmUgdG8gY29tcHV0ZSB0aGVcbiAgICAgcmVzdWx0IHNpemUgYW5kIG9uZSB0byB3cml0ZSB0aGUgcmVzdWx0LlxuXG4gICAgICMxMTUwOCwgIzExNTA5OiBUaGlzIGxvZ2ljIHdvdWxkIGJlIGluY29ycmVjdCBpbiBwcmVzZW5jZSBvZlxuICAgICBjb25jdXJyZW50IG1vZGlmaWNhdGlvbiB0byB0aGUgaW5wdXQsIG1ha2luZyB0aGUgdXNlIG9mXG4gICAgIFt1bnNhZmVfc2V0XSBiZWxvdyBtZW1vcnktdW5zYWZlLlxuXG4gICAgIFByZWNvbmRpdGlvbjogVGhpcyBmdW5jdGlvbiBtYXkgYmUgc2FmZWx5IGNhbGxlZCBvbjpcbiAgICAgLSBhbiBpbW11dGFibGUgYnl0ZSBzZXF1ZW5jZVxuICAgICAtIGEgdW5pcXVlbHktb3duZWQgYnl0ZSBzZXF1ZW5jZSAodGhlIGZ1bmN0aW9uIHRha2VzIG93bmVyc2hpcClcblxuICAgICBJbiBlaXRoZXIgY2FzZSB3ZSByZXR1cm4gYSB1bmlxdWVseS1vd25lZCBieXRlIHNlcXVlbmNlLlxuICAqKVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIHNcbiAgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBlc2NhcGVkIGIgPVxuICBsZXQgYiA9IGNvcHkgYiBpblxuICAoKiBXZSBjb3B5IG91ciBpbnB1dCB0byBvYnRhaW4gYSB1bmlxdWVseS1vd25lZCBieXRlIHNlcXVlbmNlIFtiXVxuICAgICB0byBzYXRpc2Z5IFt1bnNhZmVfZXNjYXBlXSdzIHByZWNvbmRpdGlvbiAqKVxuICB1bnNhZmVfZXNjYXBlIGJcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IHMgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIHMgPVxuICBsZXQgbiA9IGxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgcyBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHN0YXJ0c193aXRoIH5wcmVmaXggcyA9XG4gIGxldCBsZW5fcyA9IGxlbmd0aCBzXG4gIGFuZCBsZW5fcHJlID0gbGVuZ3RoIHByZWZpeCBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gbGVuX3ByZSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHVuc2FmZV9nZXQgcyBpIDw+IHVuc2FmZV9nZXQgcHJlZml4IGkgdGhlbiBmYWxzZVxuICAgIGVsc2UgYXV4IChpICsgMSlcbiAgaW4gbGVuX3MgPj0gbGVuX3ByZSAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBJbnQubWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiBUaGUgZ2V0XyBmdW5jdGlvbnMgYXJlIGFsbCBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNnVcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgdW5zYWZlX2dldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiBzd2FwMTYgKHVuc2FmZV9nZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSB1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IHVuc2FmZV9nZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX2dldF91aW50MTZfbmUgYiBpXG4gIGVsc2Ugc3dhcDE2ICh1bnNhZmVfZ2V0X3VpbnQxNl9uZSBiIGkpXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHVuc2FmZV9zZXRfdWludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHVuc2FmZV9zZXRfdWludDE2X25lIGIgaSB4XG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNl9iZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gdW5zYWZlX3NldF91aW50MTZfbmUgYiBpIHggZWxzZVxuICB1bnNhZmVfc2V0X3VpbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcblxuKCogVVRGIGNvZGVjcyBhbmQgdmFsaWRhdGlvbnMgKilcblxubGV0IGRlY19pbnZhbGlkID0gVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkXG5sZXRbQGlubGluZV0gZGVjX3JldCBuIHUgPSBVY2hhci51dGZfZGVjb2RlIG4gKFVjaGFyLnVuc2FmZV9vZl9pbnQgdSlcblxuKCogSW4gY2FzZSBvZiBkZWNvZGluZyBlcnJvciwgaWYgd2UgZXJyb3Igb24gdGhlIGZpcnN0IGJ5dGUsIHdlXG4gICBjb25zdW1lIHRoZSBieXRlLCBvdGhlcndpc2Ugd2UgY29uc3VtZSB0aGUgW25dIGJ5dGVzIHByZWNlZGluZ1xuICAgdGhlIGVycm9yaW5nIGJ5dGUuXG5cbiAgIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGNsaWVudCB1c2VzIGRlY29kZXMgd2l0aG91dCBjYXJpbmcgYWJvdXRcbiAgIHZhbGlkaXR5IGl0IG5hdHVyYWxseSByZXBsYWNlIGJvZ3VzIGRhdGEgd2l0aCBVY2hhci5yZXAgYWNjb3JkaW5nXG4gICB0byB0aGUgV0hBVFdHIEVuY29kaW5nIHN0YW5kYXJkLiBPdGhlciBzY2hlbWVzIGFyZSBwb3NzaWJsZSBieVxuICAgY29uc3VsdGluZyB0aGUgbnVtYmVyIG9mIHVzZWQgYnl0ZXMgb24gaW52YWxpZCBkZWNvZGVzLiBGb3IgbW9yZVxuICAgZGV0YWlscyBzZWUgaHR0cHM6Ly9oc2l2b25lbi5maS9icm9rZW4tdXRmLTgvXG5cbiAgIEZvciB0aGlzIHJlYXNvbiBpbiBbZ2V0X3V0Zl84X3VjaGFyXSB3ZSBncmFkdWFsbHkgY2hlY2sgdGhlIG5leHRcbiAgIGJ5dGUgaXMgYXZhaWxhYmxlIHJhdGhlciB0aGFuIGRvaW5nIGl0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZVxuICAgZmlyc3QgYnl0ZS4gQ29udHJhc3Qgd2l0aCBbaXNfdmFsaWRfdXRmXzhdLiAqKVxuXG4oKiBVVEYtOCAqKVxuXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194QkYgYiA9IGIgbHNyIDYgPD4gMGIxMFxubGV0W0BpbmxpbmVdIG5vdF9pbl94QTBfdG9feEJGIGIgPSBiIGxzciA1IDw+IDBiMTAxXG5sZXRbQGlubGluZV0gbm90X2luX3g4MF90b194OUYgYiA9IGIgbHNyIDUgPD4gMGIxMDBcbmxldFtAaW5saW5lXSBub3RfaW5feDkwX3RvX3hCRiBiID0gYiA8IDB4OTAgfHwgMHhCRiA8IGJcbmxldFtAaW5saW5lXSBub3RfaW5feDgwX3RvX3g4RiBiID0gYiBsc3IgNCA8PiAweDhcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzIgYjAgYjEgPVxuICAoKGIwIGxhbmQgMHgxRikgbHNsIDYpIGxvclxuICAoKGIxIGxhbmQgMHgzRikpXG5cbmxldFtAaW5saW5lXSB1dGZfOF91Y2hhcl8zIGIwIGIxIGIyID1cbiAgKChiMCBsYW5kIDB4MEYpIGxzbCAxMikgbG9yXG4gICgoYjEgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSlcblxubGV0W0BpbmxpbmVdIHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMgPVxuICAoKGIwIGxhbmQgMHgwNykgbHNsIDE4KSBsb3JcbiAgKChiMSBsYW5kIDB4M0YpIGxzbCAxMikgbG9yXG4gICgoYjIgbGFuZCAweDNGKSBsc2wgNikgbG9yXG4gICgoYjMgbGFuZCAweDNGKSlcblxubGV0IGdldF91dGZfOF91Y2hhciBiIGkgPVxuICBsZXQgYjAgPSBnZXRfdWludDggYiBpIGluICgqIHJhaXNlcyBpZiBbaV0gaXMgbm90IGEgdmFsaWQgaW5kZXguICopXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0X3VpbnQ4IGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgbWF0Y2ggQ2hhci51bnNhZmVfY2hyIGIwIHdpdGggKCogU2VlIFRoZSBVbmljb2RlIFN0YW5kYXJkLCBUYWJsZSAzLjcgKilcbiAgfCAnXFx4MDAnIC4uICdcXHg3RicgLT4gZGVjX3JldCAxIGIwXG4gIHwgJ1xceEMyJyAuLiAnXFx4REYnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGRlY19yZXQgMiAodXRmXzhfdWNoYXJfMiBiMCBiMSlcbiAgfCAnXFx4RTAnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3hBMF90b194QkYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhFMScgLi4gJ1xceEVDJyB8ICdcXHhFRScgLi4gJ1xceEVGJyAtPlxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgYjEgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIxIHRoZW4gZGVjX2ludmFsaWQgMSBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGxldCBiMiA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjIgdGhlbiBkZWNfaW52YWxpZCAyIGVsc2VcbiAgICAgIGRlY19yZXQgMyAodXRmXzhfdWNoYXJfMyBiMCBiMSBiMilcbiAgfCAnXFx4RUQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OUYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgZGVjX3JldCAzICh1dGZfOF91Y2hhcl8zIGIwIGIxIGIyKVxuICB8ICdcXHhGMCcgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDkwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjEnIC4uICdcXHhGMycgLT5cbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGIxID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMSB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgYjIgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIyIHRoZW4gZGVjX2ludmFsaWQgMiBlbHNlXG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGxldCBiMyA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194QkYgYjMgdGhlbiBkZWNfaW52YWxpZCAzIGVsc2VcbiAgICAgIGRlY19yZXQgNCAodXRmXzhfdWNoYXJfNCBiMCBiMSBiMiBiMylcbiAgfCAnXFx4RjQnIC0+XG4gICAgICBsZXQgaSA9IGkgKyAxIGluIGlmIGkgPiBtYXggdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBiMSA9IGdldCBiIGkgaW4gaWYgbm90X2luX3g4MF90b194OEYgYjEgdGhlbiBkZWNfaW52YWxpZCAxIGVsc2VcbiAgICAgIGxldCBpID0gaSArIDEgaW4gaWYgaSA+IG1heCB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGIyID0gZ2V0IGIgaSBpbiBpZiBub3RfaW5feDgwX3RvX3hCRiBiMiB0aGVuIGRlY19pbnZhbGlkIDIgZWxzZVxuICAgICAgbGV0IGkgPSBpICsgMSBpbiBpZiBpID4gbWF4IHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBsZXQgYjMgPSBnZXQgYiBpIGluIGlmIG5vdF9pbl94ODBfdG9feEJGIGIzIHRoZW4gZGVjX2ludmFsaWQgMyBlbHNlXG4gICAgICBkZWNfcmV0IDQgKHV0Zl84X3VjaGFyXzQgYjAgYjEgYjIgYjMpXG4gIHwgXyAtPiBkZWNfaW52YWxpZCAxXG5cbmxldCBzZXRfdXRmXzhfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50OCBpblxuICBsZXQgbWF4ID0gbGVuZ3RoIGIgLSAxIGluXG4gIG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgICBzZXRfdWludDggYiBpIHU7XG4gICAgICAxXG4gIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICAoc2V0X3VpbnQ4IGIgaSAoMHhDMCBsb3IgKHUgbHNyIDYpKTtcbiAgICAgICBzZXQgYiBsYXN0ICgweDgwIGxvciAodSBsYW5kIDB4M0YpKTtcbiAgICAgICAyKVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RTAgbG9yICh1IGxzciAxMikpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgMylcbiAgfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZVxuICAgICAgKHNldF91aW50OCBiIGkgKDB4RjAgbG9yICh1IGxzciAxOCkpO1xuICAgICAgIHNldCBiIChpICsgMSkgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpO1xuICAgICAgIHNldCBiIChpICsgMikgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSk7XG4gICAgICAgc2V0IGIgbGFzdCAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSk7XG4gICAgICAgNClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgaXNfdmFsaWRfdXRmXzggYiA9XG4gIGxldCByZWMgbG9vcCBtYXggYiBpID1cbiAgICBpZiBpID4gbWF4IHRoZW4gdHJ1ZSBlbHNlXG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDggaW5cbiAgICBtYXRjaCBDaGFyLnVuc2FmZV9jaHIgKGdldCBiIGkpIHdpdGhcbiAgICB8ICdcXHgwMCcgLi4gJ1xceDdGJyAtPiBsb29wIG1heCBiIChpICsgMSlcbiAgICB8ICdcXHhDMicgLi4gJ1xceERGJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAxIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFMCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94QTBfdG9feEJGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEUxJyAuLiAnXFx4RUMnIHwgJ1xceEVFJyAuLiAnXFx4RUYnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDIgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIGxhc3QpXG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBsb29wIG1heCBiIChsYXN0ICsgMSlcbiAgICB8ICdcXHhFRCcgLT5cbiAgICAgICAgbGV0IGxhc3QgPSBpICsgMiBpblxuICAgICAgICBpZiBsYXN0ID4gbWF4XG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feDlGIChnZXQgYiAoaSArIDEpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYwJyAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXhcbiAgICAgICAgfHwgbm90X2luX3g5MF90b194QkYgKGdldCBiIChpICsgMSkpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiAoaSArIDIpKVxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgbGFzdClcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgbWF4IGIgKGxhc3QgKyAxKVxuICAgIHwgJ1xceEYxJyAuLiAnXFx4RjMnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3hCRiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCAnXFx4RjQnIC0+XG4gICAgICAgIGxldCBsYXN0ID0gaSArIDMgaW5cbiAgICAgICAgaWYgbGFzdCA+IG1heFxuICAgICAgICB8fCBub3RfaW5feDgwX3RvX3g4RiAoZ2V0IGIgKGkgKyAxKSlcbiAgICAgICAgfHwgbm90X2luX3g4MF90b194QkYgKGdldCBiIChpICsgMikpXG4gICAgICAgIHx8IG5vdF9pbl94ODBfdG9feEJGIChnZXQgYiBsYXN0KVxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgbG9vcCBtYXggYiAobGFzdCArIDEpXG4gICAgfCBfIC0+IGZhbHNlXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkJFICopXG5cbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2YmVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfYmUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmJlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2JlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG5cbigqIFVURi0xNkxFICopXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgYiBpID1cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gIGxldCBtYXggPSBsZW5ndGggYiAtIDEgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IG1heCB0aGVuIGludmFsaWRfYXJnIFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiIGVsc2VcbiAgaWYgaSA9IG1heCB0aGVuIGRlY19pbnZhbGlkIDEgZWxzZVxuICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGRlY19yZXQgMiB1XG4gIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZGVjX2ludmFsaWQgMlxuICB8IGhpIC0+ICgqIGNvbWJpbmUgW2hpXSB3aXRoIGEgbG93IHN1cnJvZ2F0ZSAqKVxuICAgICAgbGV0IGxhc3QgPSBpICsgMyBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIGRlY19pbnZhbGlkIChtYXggLSBpICsgMSkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgKGkgKyAyKSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZGVjX2ludmFsaWQgMiAoKiByZXRyeSBoZXJlICopXG4gICAgICB8IGxvIC0+XG4gICAgICAgICAgbGV0IHUgPSAoKChoaSBsYW5kIDB4M0ZGKSBsc2wgMTApIGxvciAobG8gbGFuZCAweDNGRikpICsgMHgxMDAwMCBpblxuICAgICAgICAgIGRlY19yZXQgNCB1XG5cbmxldCBzZXRfdXRmXzE2bGVfdWNoYXIgYiBpIHUgPVxuICBsZXQgc2V0ID0gdW5zYWZlX3NldF91aW50MTZfbGUgaW5cbiAgbGV0IG1heCA9IGxlbmd0aCBiIC0gMSBpblxuICBpZiBpIDwgMCB8fCBpID4gbWF4IHRoZW4gaW52YWxpZF9hcmcgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIgZWxzZVxuICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICAgbGV0IGxhc3QgPSBpICsgMSBpblxuICAgICAgaWYgbGFzdCA+IG1heCB0aGVuIDAgZWxzZSAoc2V0IGIgaSB1OyAyKVxuICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICBpZiBsYXN0ID4gbWF4IHRoZW4gMCBlbHNlXG4gICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICAgbGV0IGhpID0gKDB4RDgwMCBsb3IgKHUnIGxzciAxMCkpIGluXG4gICAgICBsZXQgbG8gPSAoMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikpIGluXG4gICAgICBzZXQgYiBpIGhpOyBzZXQgYiAoaSArIDIpIGxvOyA0XG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGlzX3ZhbGlkX3V0Zl8xNmxlIGIgPVxuICBsZXQgcmVjIGxvb3AgbWF4IGIgaSA9XG4gICAgbGV0IGdldCA9IHVuc2FmZV9nZXRfdWludDE2X2xlIGluXG4gICAgaWYgaSA+IG1heCB0aGVuIHRydWUgZWxzZVxuICAgIGlmIGkgPSBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgfCB1IHdoZW4gdSA8IDB4RDgwMCB8fCB1ID4gMHhERkZGIC0+IGxvb3AgbWF4IGIgKGkgKyAyKVxuICAgIHwgdSB3aGVuIHUgPiAweERCRkYgLT4gZmFsc2VcbiAgICB8IF9oaSAtPlxuICAgICAgICBsZXQgbGFzdCA9IGkgKyAzIGluXG4gICAgICAgIGlmIGxhc3QgPiBtYXggdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIGdldCBiIChpICsgMikgd2l0aFxuICAgICAgICB8IHUgd2hlbiB1IDwgMHhEQzAwIHx8IHUgPiAweERGRkYgLT4gZmFsc2VcbiAgICAgICAgfCBfbG8gLT4gbG9vcCBtYXggYiAoaSArIDQpXG4gIGluXG4gIGxvb3AgKGxlbmd0aCBiIC0gMSkgYiAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBlbXB0eSA9IFwiXCJcbmxldCBvZl9ieXRlcyA9IEIudG9fc3RyaW5nXG5sZXQgdG9fYnl0ZXMgPSBCLm9mX3N0cmluZ1xubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBCLnN1YiAoYm9zIHMpIG9mcyBsZW4gfD4gYnRzXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0ID0gKCBeIClcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXIgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlcmkgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbmxldCBtYXAgZiBzID1cbiAgQi5tYXAgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IG1hcGkgZiBzID1cbiAgQi5tYXBpIGYgKGJvcyBzKSB8PiBidHNcbmxldCBmb2xkX3JpZ2h0IGYgeCBhID1cbiAgQi5mb2xkX3JpZ2h0IGYgKGJvcyB4KSBhXG5sZXQgZm9sZF9sZWZ0IGYgYSB4ID1cbiAgQi5mb2xkX2xlZnQgZiBhIChib3MgeClcbmxldCBleGlzdHMgZiBzID1cbiAgQi5leGlzdHMgZiAoYm9zIHMpXG5sZXQgZm9yX2FsbCBmIHMgPVxuICBCLmZvcl9hbGwgZiAoYm9zIHMpXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IGIgPSBib3MgcyBpblxuICAoKiBXZSBzYXRpc2Z5IFt1bnNhZmVfZXNjYXBlXSdzIHByZWNvbmRpdGlvbiBieSBwYXNzaW5nIGFuXG4gICAgIGltbXV0YWJsZSBieXRlIHNlcXVlbmNlIFtiXS4gKilcbiAgYnRzIChCLnVuc2FmZV9lc2NhcGUgYilcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBzdGFydHNfd2l0aCB+cHJlZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3ByZSA9IGxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9wcmUgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgaSA8PiB1bnNhZmVfZ2V0IHByZWZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGxlbl9zID49IGxlbl9wcmUgJiYgYXV4IDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGVuZHNfd2l0aCB+c3VmZml4IHMgPVxuICBsZXQgbGVuX3MgPSBsZW5ndGggc1xuICBhbmQgbGVuX3N1ZiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGV0IGRpZmYgPSBsZW5fcyAtIGxlbl9zdWYgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA9IGxlbl9zdWYgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiB1bnNhZmVfZ2V0IHMgKGRpZmYgKyBpKSA8PiB1bnNhZmVfZ2V0IHN1ZmZpeCBpIHRoZW4gZmFsc2VcbiAgICBlbHNlIGF1eCAoaSArIDEpXG4gIGluIGRpZmYgPj0gMCAmJiBhdXggMFxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaCA6IGludCAtPiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX3N0cmluZ19oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaCAwIHhcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG5cbigqIFVURiBkZWNvZGVycyBhbmQgdmFsaWRhdG9ycyAqKVxuXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIHMgaSA9IEIuZ2V0X3V0Zl84X3VjaGFyIChib3MgcykgaVxubGV0IGlzX3ZhbGlkX3V0Zl84IHMgPSBCLmlzX3ZhbGlkX3V0Zl84IChib3MgcylcblxubGV0IGdldF91dGZfMTZiZV91Y2hhciBzIGkgPSBCLmdldF91dGZfMTZiZV91Y2hhciAoYm9zIHMpIGlcbmxldCBpc192YWxpZF91dGZfMTZiZSBzID0gQi5pc192YWxpZF91dGZfMTZiZSAoYm9zIHMpXG5cbmxldCBnZXRfdXRmXzE2bGVfdWNoYXIgcyBpID0gQi5nZXRfdXRmXzE2bGVfdWNoYXIgKGJvcyBzKSBpXG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgcyA9IEIuaXNfdmFsaWRfdXRmXzE2bGUgKGJvcyBzKVxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBzdHJpbmcgLT4gaW50IC0+IGludCA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX3N0cmluZ19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9zdHJpbmdfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfc3RyaW5nX2dldDY0XCJcblxubGV0IGdldF9pbnQ4IHMgaSA9IEIuZ2V0X2ludDggKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9sZSBzIGkgPSBCLmdldF91aW50MTZfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X3VpbnQxNl9iZSBzIGkgPSBCLmdldF91aW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDE2X25lIHMgaSA9IEIuZ2V0X2ludDE2X25lIChib3MgcykgaVxubGV0IGdldF9pbnQxNl9sZSBzIGkgPSBCLmdldF9pbnQxNl9sZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50MTZfYmUgcyBpID0gQi5nZXRfaW50MTZfYmUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDMyX2xlIHMgaSA9IEIuZ2V0X2ludDMyX2xlIChib3MgcykgaVxubGV0IGdldF9pbnQzMl9iZSBzIGkgPSBCLmdldF9pbnQzMl9iZSAoYm9zIHMpIGlcbmxldCBnZXRfaW50NjRfbGUgcyBpID0gQi5nZXRfaW50NjRfbGUgKGJvcyBzKSBpXG5sZXQgZ2V0X2ludDY0X2JlIHMgaSA9IEIuZ2V0X2ludDY0X2JlIChib3MgcykgaVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcblxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDE2XG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGFycmF5cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6XG4gICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9maWxsXCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgbXVzdCBub3QgZXZhbHVhdGUgW2YgMF0gd2hlbiBbbCA8PSAwXS5cbiAgICAgV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gICgqIFdlIHJhaXNlIGV2ZW4gaWYgW3N4ID0gMCAmJiBzeSA8IDBdOiAqKVxuICBpZiBzeSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5Lm1ha2VfbWF0cml4XCI7XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBpZiBzeSA+IDAgdGhlbiBiZWdpblxuICAgIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgICBkb25lO1xuICBlbmQ7XG4gIHJlc1xuXG5sZXQgaW5pdF9tYXRyaXggc3ggc3kgZiA9XG4gICgqIFdlIHJhaXNlIGV2ZW4gaWYgW3N4ID0gMCAmJiBzeSA8IDBdOiAqKVxuICBpZiBzeSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRfbWF0cml4XCI7XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICAoKiBXZSBtdXN0IG5vdCBldmFsdWF0ZSBbZiB4IDBdIHdoZW4gW3N5IDw9IDBdOiAqKVxuICBpZiBzeSA+IDAgdGhlbiBiZWdpblxuICAgIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgICBsZXQgcm93ID0gY3JlYXRlIHN5IChmIHggMCkgaW5cbiAgICAgIGZvciB5ID0gMSB0byBwcmVkIHN5IGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcm93IHkgKGYgeCB5KVxuICAgICAgZG9uZTtcbiAgICAgIHVuc2FmZV9zZXQgcmVzIHggcm93XG4gICAgZG9uZTtcbiAgZW5kO1xuICByZXNcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcF9pbnBsYWNlIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IGEgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICBkb25lXG5cbmxldCBtYXBpX2lucGxhY2UgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgYSBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgZG9uZVxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjYyBpbnB1dF9hcnJheSA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXRfYXJyYXkgaW5cbiAgaWYgbGVuID0gMCB0aGVuIChhY2MsIFt8fF0pIGVsc2UgYmVnaW5cbiAgICBsZXQgYWNjLCBlbHQgPSBmIGFjYyAodW5zYWZlX2dldCBpbnB1dF9hcnJheSAwKSBpblxuICAgIGxldCBvdXRwdXRfYXJyYXkgPSBjcmVhdGUgbGVuIGVsdCBpblxuICAgIGxldCBhY2MgPSByZWYgYWNjIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBhY2MnLCBlbHQgPSBmICFhY2MgKHVuc2FmZV9nZXQgaW5wdXRfYXJyYXkgaSkgaW5cbiAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgdW5zYWZlX3NldCBvdXRwdXRfYXJyYXkgaSBlbHQ7XG4gICAgZG9uZTtcbiAgICAhYWNjLCBvdXRwdXRfYXJyYXlcbiAgZW5kXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfb3B0IHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIGlmIHAgeCB0aGVuIFNvbWUgeFxuICAgICAgZWxzZSBsb29wIChzdWNjIGkpXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9pbmRleCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIE5vbmVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIFNvbWUgaVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZpbmRfbWFwIGYgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGYgKHVuc2FmZV9nZXQgYSBpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoc3VjYyBpKVxuICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgZmluZF9tYXBpIGYgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChzdWNjIGkpXG4gICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzcGxpdCB4ID1cbiAgaWYgeCA9IFt8fF0gdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgYTAsIGIwID0gdW5zYWZlX2dldCB4IDAgaW5cbiAgICBsZXQgbiA9IGxlbmd0aCB4IGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbiBhMCBpblxuICAgIGxldCBiID0gY3JlYXRlIG4gYjAgaW5cbiAgICBmb3IgaSA9IDEgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBhaSwgYmkgPSB1bnNhZmVfZ2V0IHggaSBpblxuICAgICAgdW5zYWZlX3NldCBhIGkgYWk7XG4gICAgICB1bnNhZmVfc2V0IGIgaSBiaVxuICAgIGRvbmU7XG4gICAgYSwgYlxuICBlbmRcblxubGV0IGNvbWJpbmUgYSBiID1cbiAgbGV0IG5hID0gbGVuZ3RoIGEgaW5cbiAgbGV0IG5iID0gbGVuZ3RoIGIgaW5cbiAgaWYgbmEgPD4gbmIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmNvbWJpbmVcIjtcbiAgaWYgbmEgPSAwIHRoZW4gW3x8XVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHggPSBjcmVhdGUgbmEgKHVuc2FmZV9nZXQgYSAwLCB1bnNhZmVfZ2V0IGIgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbmEgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHggaSAodW5zYWZlX2dldCBhIGksIHVuc2FmZV9nZXQgYiBpKVxuICAgIGRvbmU7XG4gICAgeFxuICBlbmRcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG5sZXQgc2h1ZmZsZSB+cmFuZCBhID0gKCogRmlzaGVyLVlhdGVzICopXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAxIGRvXG4gICAgbGV0IGogPSByYW5kIChpICsgMSkgaW5cbiAgICBsZXQgdiA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgdW5zYWZlX3NldCBhIGkgKGdldCBhIGopO1xuICAgIHVuc2FmZV9zZXQgYSBqIHZcbiAgZG9uZVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZtYSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2ZtYV9mbG9hdFwiIFwiY2FtbF9mbWFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBxdWlldF9uYW4gPSBuYW5cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgc2lnbmFsaW5nX25hbiA9IGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBpc19maW5pdGUgKHg6IGZsb2F0KSA9IHggLS4geCA9IDAuXG5sZXQgaXNfaW5maW5pdGUgKHg6IGZsb2F0KSA9IDEuIC8uIHggPSAwLlxubGV0IGlzX25hbiAoeDogZmxvYXQpID0geCA8PiB4XG5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gU3RkbGliLm1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IFN0ZGxpYi5taW5fZmxvYXRcbmxldCBlcHNpbG9uID0gU3RkbGliLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ19vcHRcbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0XG50eXBlIGZwY2xhc3MgPSBTdGRsaWIuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjYnJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2JydF9mbG9hdFwiIFwiY2FtbF9jYnJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cDIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHAyX2Zsb2F0XCIgXCJjYW1sX2V4cDJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzJfZmxvYXRcIiBcImNhbWxfbG9nMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zaF9mbG9hdFwiIFwiY2FtbF9hY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbmhfZmxvYXRcIiBcImNhbWxfYXRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXJmIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXJmX2Zsb2F0XCIgXCJjYW1sX2VyZlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBlcmZjIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXJmY19mbG9hdFwiIFwiY2FtbF9lcmZjXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRydW5jIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdHJ1bmNfZmxvYXRcIiBcImNhbWxfdHJ1bmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9yb3VuZF9mbG9hdFwiIFwiY2FtbF9yb3VuZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG5bQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgaXNfaW50ZWdlciB4ID0geCA9IHRydW5jIHggJiYgaXNfZmluaXRlIHhcblxuZXh0ZXJuYWwgbmV4dF9hZnRlciA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gID0gXCJjYW1sX25leHRhZnRlcl9mbG9hdFwiIFwiY2FtbF9uZXh0YWZ0ZXJcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc3VjYyB4ID0gbmV4dF9hZnRlciB4IGluZmluaXR5XG5sZXQgcHJlZCB4ID0gbmV4dF9hZnRlciB4IG5lZ19pbmZpbml0eVxuXG5leHRlcm5hbCBjb3B5X3NpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpZ25fYml0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGJvb2xcbiAgPSBcImNhbWxfc2lnbmJpdF9mbG9hdFwiIFwiY2FtbF9zaWduYml0XCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbnR5cGUgdCA9IGZsb2F0XG5leHRlcm5hbCBjb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldFtAaW5saW5lXSBtaW4gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB8fCBpc19uYW4geSB0aGVuIChuYW4sIG5hbilcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgsIHkpIGVsc2UgKHksIHgpXG5cbmxldFtAaW5saW5lXSBtaW5fbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB0aGVuICh5LHkpXG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiAoeCx4KVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCx5KSBlbHNlICh5LHgpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcblxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcblxuICBsZXQgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXQ6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0ID1cbiAgICBcImNhbWxfZmxvYXRhcnJheV9ibGl0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY2hlY2sgYSBvZnMgbGVuIG1zZyA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gbGVuZ3RoIGEgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgbGV0IG1ha2UgbiB2ID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIG4gaW5cbiAgICB1bnNhZmVfZmlsbCByZXN1bHQgMCBuIHY7XG4gICAgcmVzdWx0XG5cbiAgbGV0IGluaXQgbCBmID1cbiAgICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaW5pdFwiXG4gICAgZWxzZVxuICAgICAgbGV0IHJlcyA9IGNyZWF0ZSBsIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgICAgZG9uZTtcbiAgICAgIHJlc1xuXG4gIGxldCBtYWtlX21hdHJpeCBzeCBzeSB2ID1cbiAgICAoKiBXZSByYWlzZSBldmVuIGlmIFtzeCA9IDAgJiYgc3kgPCAwXTogKilcbiAgICBpZiBzeSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1ha2VfbWF0cml4XCI7XG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2Ugc3ggKGNyZWF0ZSAwKSBpblxuICAgIGlmIHN5ID4gMCB0aGVuIGJlZ2luXG4gICAgICBmb3IgeCA9IDAgdG8gc3ggLSAxIGRvXG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQgcmVzIHggKG1ha2Ugc3kgdilcbiAgICAgIGRvbmU7XG4gICAgZW5kO1xuICAgIHJlc1xuXG4gIGxldCBpbml0X21hdHJpeCBzeCBzeSBmID1cbiAgICAoKiBXZSByYWlzZSBldmVuIGlmIFtzeCA9IDAgJiYgc3kgPCAwXTogKilcbiAgICBpZiBzeSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRfbWF0cml4XCI7XG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2Ugc3ggKGNyZWF0ZSAwKSBpblxuICAgIGlmIHN5ID4gMCB0aGVuIGJlZ2luXG4gICAgICBmb3IgeCA9IDAgdG8gc3ggLSAxIGRvXG4gICAgICAgIGxldCByb3cgPSBjcmVhdGUgc3kgaW5cbiAgICAgICAgZm9yIHkgPSAwIHRvIHN5IC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgcm93IHkgKGYgeCB5KVxuICAgICAgICBkb25lO1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IHJlcyB4IHJvd1xuICAgICAgZG9uZTtcbiAgICBlbmQ7XG4gICAgcmVzXG5cbiAgbGV0IGFwcGVuZCBhMSBhMiA9XG4gICAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gICAgbGV0IGwyID0gbGVuZ3RoIGEyIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgICB1bnNhZmVfYmxpdCBhMSAwIHJlc3VsdCAwIGwxO1xuICAgIHVuc2FmZV9ibGl0IGEyIDAgcmVzdWx0IGwxIGwyO1xuICAgIHJlc3VsdFxuXG4gICgqIG5leHQgMyBmdW5jdGlvbnM6IG1vZGlmaWVkIGNvcHkgb2YgY29kZSBmcm9tIHN0cmluZy5tbCAqKVxuICBsZXQgZW5zdXJlX2dlICh4OmludCkgeSA9XG4gICAgaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuY29uY2F0XCJcblxuICBsZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIGFjYykgYWNjKSB0bFxuXG4gIGxldCBjb25jYXQgbCA9XG4gICAgbGV0IGxlbiA9IHN1bV9sZW5ndGhzIDAgbCBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGwgaSA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gbGVuKVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQgaGxlbiA9IGxlbmd0aCBoZCBpblxuICAgICAgICB1bnNhZmVfYmxpdCBoZCAwIHJlc3VsdCBpIGhsZW47XG4gICAgICAgIGxvb3AgdGwgKGkgKyBobGVuKVxuICAgIGluXG4gICAgbG9vcCBsIDA7XG4gICAgcmVzdWx0XG5cbiAgbGV0IHN1YiBhIG9mcyBsZW4gPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LnN1YlwiO1xuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgYSBvZnMgcmVzdWx0IDAgbGVuO1xuICAgIHJlc3VsdFxuXG4gIGxldCBjb3B5IGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGwgaW5cbiAgICB1bnNhZmVfYmxpdCBhIDAgcmVzdWx0IDAgbDtcbiAgICByZXN1bHRcblxuICBsZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuZmlsbFwiO1xuICAgIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbiAgbGV0IGJsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBjaGVjayBzcmMgc29mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgY2hlY2sgZHN0IGRvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlblxuXG4gIGxldCB0b19saXN0IGEgPVxuICAgIExpc3QuaW5pdCAobGVuZ3RoIGEpICh1bnNhZmVfZ2V0IGEpXG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiByZXN1bHRcbiAgICAgIHwgaCA6OiB0IC0+IHVuc2FmZV9zZXQgcmVzdWx0IGkgaDsgZmlsbCAoaSArIDEpIHRcbiAgICBpblxuICAgIGZpbGwgMCBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcjIgZiBhIGIgPVxuICAgIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxuICBsZXQgbWFwIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtYXBfaW5wbGFjZSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgYSBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZVxuXG4gIGxldCBtYXAyIGYgYSBiID1cbiAgICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICAgIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gICAgaWYgbGEgPD4gbGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXJpIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgbGV0IG1hcGkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgbWFwaV9pbnBsYWNlIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmVcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZmluZF9vcHQgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgaWYgcCB4IHRoZW4gU29tZSB4XG4gICAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZpbmRfaW5kZXggcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIFNvbWUgaVxuICAgICAgZWxzZSBsb29wIChpICsgMSkgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZpbmRfbWFwIGYgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBtYXRjaCBmICh1bnNhZmVfZ2V0IGEgaSkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmaW5kX21hcGkgZiBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCBhIGkpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHJcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgc2h1ZmZsZSB+cmFuZCBhID0gKCogRmlzaGVyLVlhdGVzICopXG4gICAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDEgZG9cbiAgICAgIGxldCBqID0gcmFuZCAoaSArIDEpIGluXG4gICAgICBsZXQgdiA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICB1bnNhZmVfc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB1bnNhZmVfc2V0IGEgaiB2XG4gICAgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBuID49IDBsICYmIG4gPD0gbWF4X2ludCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbWFzayA9IDB4RkZGRiBsc2wgMTYgbG9yIDB4RkZGRiBpblxuICAgICAgZnVuIG4gLT4gU29tZSAodG9faW50IG4gbGFuZCBtYXNrKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSB4ID0geVxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxubGV0IHVuc2lnbmVkX2x0IG4gbSA9XG4gIHN1YiBuIG1pbl9pbnQgPCBzdWIgbSBtaW5faW50XG5cbmxldCBtaW4geCB5IDogdCA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA6IHQgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZSBiaXRuZXNzLlxuICAgU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2x0IG4gZCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfbHQgciBkIHRoZW4gcSBlbHNlIHN1Y2MgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIG4gPj0gMEwgJiYgbiA8PSBtYXhfaW50IHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZyA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG50eXBlIHQgPSBpbnQ2NFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IHggPSB5XG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG5sZXQgdW5zaWduZWRfbHQgbiBtID1cbiAgc3ViIG4gbWluX2ludCA8IHN1YiBtIG1pbl9pbnRcblxubGV0IG1pbiB4IHkgOiB0ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5IDogdCA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lIGJpdG5lc3MuXG4gICBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfbHQgbiBkIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9sdCByIGQgdGhlbiBxIGVsc2Ugc3VjYyBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBuID49IDBuICYmIG4gPD0gbWF4X2ludCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbmxldCB1bnNpZ25lZF9sdCBuIG0gPVxuICBzdWIgbiBtaW5faW50IDwgc3ViIG0gbWluX2ludFxuXG5sZXQgbWluIHggeSA6IHQgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgOiB0ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWUgYml0bmVzcy5cbiAgIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9sdCBuIGQgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2x0IHIgZCB0aGVuIHEgZWxzZSBzdWNjIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBJbnQubWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcbltAQHdhcm5pbmcgXCItdW51c2VkLWZpZWxkXCJdXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgdG9fbGlzdCA6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCB0b19saXN0ID0gZWxlbWVudHNcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkX3RvX2xpc3Q6IGtleSAtPiAnYSAtPiAnYSBsaXN0IHQgLT4gJ2EgbGlzdCB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPlxuICAgICAgJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChrZXkgLT4gJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBvZl9saXN0IDogKGtleSAqICdhKSBsaXN0IC0+ICdhIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgYWRkX3RvX2xpc3QgeCBkYXRhIG0gPVxuICAgICAgbGV0IGFkZCA9IGZ1bmN0aW9uIE5vbmUgLT4gU29tZSBbZGF0YV0gfCBTb21lIGwgLT4gU29tZSAoZGF0YSA6OiBsKSBpblxuICAgICAgdXBkYXRlIHggYWRkIG1cblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sXG4gICAgICAgICBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSxcbiAgICAgICAgIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW2ZdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZnZkID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGZ2ZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZCcgLT4gam9pbiBsJyB2IGQnIHInXG4gICAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0IGwnIHInXG4gICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IHRvX2xpc3QgPSBiaW5kaW5nc1xuICAgIGxldCBvZl9saXN0IGJzID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBtIChrLCB2KSAtPiBhZGQgayB2IG0pIGVtcHR5IGJzXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCBkcm9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IF9oZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDFcbiAgfCBbXSAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IGhkXG4gIHwgW10gICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gU29tZSBoZFxuICB8IFtdICAgIC0+IE5vbmVcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBGcmFuY29pcyBQb3R0aWVyLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSBjZWxsID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHsgY29udGVudDogJ2E7IG11dGFibGUgbmV4dDogJ2EgY2VsbCB9XG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBsZW5ndGg6IGludDtcbiAgbXV0YWJsZSBmaXJzdDogJ2EgY2VsbDtcbiAgbXV0YWJsZSBsYXN0OiAnYSBjZWxsXG59XG5cbmxldCBjcmVhdGUgKCkgPSB7XG4gIGxlbmd0aCA9IDA7XG4gIGZpcnN0ID0gTmlsO1xuICBsYXN0ID0gTmlsXG59XG5cbmxldCBjbGVhciBxID1cbiAgcS5sZW5ndGggPC0gMDtcbiAgcS5maXJzdCA8LSBOaWw7XG4gIHEubGFzdCA8LSBOaWxcblxubGV0IGFkZCB4IHEgPVxuICBsZXQgY2VsbCA9IENvbnMge1xuICAgIGNvbnRlbnQgPSB4O1xuICAgIG5leHQgPSBOaWxcbiAgfSBpblxuICBtYXRjaCBxLmxhc3Qgd2l0aFxuICB8IE5pbCAtPlxuICAgIHEubGVuZ3RoIDwtIDE7XG4gICAgcS5maXJzdCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG4gIHwgQ29ucyBsYXN0IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggKyAxO1xuICAgIGxhc3QubmV4dCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG5cbmxldCBwdXNoID1cbiAgYWRkXG5cbmxldCBwZWVrIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IGNvbnRlbnRcblxubGV0IHBlZWtfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gU29tZSBjb250ZW50XG5cbmxldCB0b3AgPVxuICBwZWVrXG5cbmxldCB0YWtlIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgY29udGVudFxuXG5sZXQgdGFrZV9vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgU29tZSBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgU29tZSBjb250ZW50XG5cbmxldCBwb3AgPVxuICB0YWtlXG5cbmxldCBjb3B5ID1cbiAgbGV0IHJlYyBjb3B5IHFfcmVzIHByZXYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gcV9yZXMubGFzdCA8LSBwcmV2OyBxX3Jlc1xuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IHJlcyA9IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gaW5cbiAgICAgIGJlZ2luIG1hdGNoIHByZXYgd2l0aFxuICAgICAgfCBOaWwgLT4gcV9yZXMuZmlyc3QgPC0gcmVzXG4gICAgICB8IENvbnMgcCAtPiBwLm5leHQgPC0gcmVzXG4gICAgICBlbmQ7XG4gICAgICBjb3B5IHFfcmVzIHJlcyBuZXh0XG4gIGluXG4gIGZ1biBxIC0+IGNvcHkgeyBsZW5ndGggPSBxLmxlbmd0aDsgZmlyc3QgPSBOaWw7IGxhc3QgPSBOaWwgfSBOaWwgcS5maXJzdFxuXG5sZXQgaXNfZW1wdHkgcSA9XG4gIHEubGVuZ3RoID0gMFxuXG5sZXQgbGVuZ3RoIHEgPVxuICBxLmxlbmd0aFxuXG5sZXQgaXRlciA9XG4gIGxldCByZWMgaXRlciBmIGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBmIGNvbnRlbnQ7XG4gICAgICBpdGVyIGYgbmV4dFxuICBpblxuICBmdW4gZiBxIC0+IGl0ZXIgZiBxLmZpcnN0XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBmb2xkIGYgYWNjdSBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBhY2N1XG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBjb250ZW50IGluXG4gICAgICBmb2xkIGYgYWNjdSBuZXh0XG4gIGluXG4gIGZ1biBmIGFjY3UgcSAtPiBmb2xkIGYgYWNjdSBxLmZpcnN0XG5cbmxldCB0cmFuc2ZlciBxMSBxMiA9XG4gIGlmIHExLmxlbmd0aCA+IDAgdGhlblxuICAgIG1hdGNoIHEyLmxhc3Qgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTEubGVuZ3RoO1xuICAgICAgcTIuZmlyc3QgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuICAgIHwgQ29ucyBsYXN0IC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTIubGVuZ3RoICsgcTEubGVuZ3RoO1xuICAgICAgbGFzdC5uZXh0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBxID1cbiAgbGV0IHJlYyBhdXggYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgIHwgTmlsIC0+IFNlcS5OaWxcbiAgICB8IENvbnMgeyBjb250ZW50PXg7IG5leHQ7IH0gLT4gU2VxLkNvbnMgKHgsIGF1eCBuZXh0KVxuICBpblxuICBhdXggcS5maXJzdFxuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHEgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHEgZztcbiAgcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxuKCogVGhlIFtpbm5lcl9idWZmZXJdIHR5cGUgZW5zdXJlcyB0aGF0IHRoZSBbbGVuZ3RoXSBhbmQgW2J1ZmZlcl0gZmllbGRzIGFyZVxuICAgYWx3YXlzIHN5bmNocm9uaXplZCwgW2xlbmd0aCA9IEJ5dGVzLmxlbmd0aCBidWZmZXJdLCBldmVuIGluIHByZXNlbmNlXG4gICBvZiBkYXRhIHJhY2VzLlxuKilcbnR5cGUgaW5uZXJfYnVmZmVyID0ge1xuICBidWZmZXI6IGJ5dGVzO1xuICBsZW5ndGg6IGludDtcbn1cblxudHlwZSB0ID1cbiB7bXV0YWJsZSBpbm5lciA6IGlubmVyX2J1ZmZlcjtcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbaW5uZXIubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGlubmVyLmJ1ZmZlcl1cbiAgIEluIGFic2VuY2Ugb2YgZGF0YSByYWNlcywgd2UgYWxzbyBoYXZlXG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5pbm5lci5sZW5ndGhdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5pbm5lci5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4geyBpbm5lciA9IHsgYnVmZmVyID0gczsgbGVuZ3RoID0gbn07IHBvc2l0aW9uID0gMDsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5pbm5lci5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmlubmVyLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMuYmxpdCBzcmMuaW5uZXIuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyO2xlbmd0aH0gPSBiLmlubmVyIGluXG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gbGVuZ3RoIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBidWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgbGV0IGlubmVyID1cbiAgICB7IGJ1ZmZlciA9IGIuaW5pdGlhbF9idWZmZXI7IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmluaXRpYWxfYnVmZmVyIH1cbiAgaW5cbiAgYi5pbm5lciA8LSBpbm5lclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmlubmVyLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5pbm5lcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmlubmVyLmxlbmd0aF0uXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmlubmVyLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5pbm5lci5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5pbm5lciA8LSB7IGJ1ZmZlciA9IG5ld19idWZmZXI7IGxlbmd0aCA9ICFuZXdfbGVuIH1cblxuKCogTm90ZTpcbiAgICBTb21lIG9mIHRoZSBmdW5jdGlvbnMgYmVsb3cgaGF2ZSBhIGZhc3QgcGF0aCB3aGVuIHRoZSBpbm5lclxuICBidWZmZXIgZG9lc24ndCBuZWVkIHRvIGJlIGV4dGVuZGVkLlxuICAgIEluIHRoaXMgY2FzZSwgaXQgaXMgcG9zc2libGUgdG8gdXNlIHVuc2FmZSBhY2Nlc3NlcyBvbiB0aGVcbiAgY29udGVudHMgb2YgdGhlIFtpbm5lcl0gZmllbGQgc2luY2UgaXRzIGZpZWxkcyBhcmUgaW1tdXRhYmxlLlxuICBJbiBwcmVzZW5jZSBvZiBkYXRhIHJhY2VzLCB3ZSBtYXkgYWNjZXNzIHRoZSB3cm9uZyBpbm5lciBidWZmZXIsIGJ1dCB3ZVxuICB3aWxsIHVzZSB0aGlzIGJ1ZmZlciBzYWZlbHkuXG4gIEFzIHNvb24gYXMgd2UgbmVlZCB0byByZXNpemUgdGhlIGJ1ZmZlciwgd2UgZmFsbCBiYWNrIHRvIHNhZmUgYWNjZXNzZXMuXG4qKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtidWZmZXI7bGVuZ3RofSA9IGIuaW5uZXIgaW5cbiAgaWYgcG9zID49IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiAxO1xuICAgIEJ5dGVzLnNldCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIGNcbiAgKSBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX3NldCBidWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG5sZXQgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4ID0gNFxubGV0IHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXggPSA0XG5cbmxldCByZWMgYWRkX3V0Zl84X3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmlubmVyLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl84X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzhfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzhfYnl0ZV9sZW5ndGhfbWF4OyBhZGRfdXRmXzhfdWNoYXIgYiB1KVxuICBlbHNlIChiLnBvc2l0aW9uIDwtIHBvcyArIG4pXG5cbmxldCByZWMgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmlubmVyLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7XG4gIGxldCBuID0gQnl0ZXMuc2V0X3V0Zl8xNmJlX3VjaGFyIGIuaW5uZXIuYnVmZmVyIHBvcyB1IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gKHJlc2l6ZSBiIHVjaGFyX3V0Zl8xNl9ieXRlX2xlbmd0aF9tYXg7IGFkZF91dGZfMTZiZV91Y2hhciBiIHUpXG4gIGVsc2UgKGIucG9zaXRpb24gPC0gcG9zICsgbilcblxubGV0IHJlYyBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIuaW5uZXIubGVuZ3RoIHRoZW4gcmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDtcbiAgbGV0IG4gPSBCeXRlcy5zZXRfdXRmXzE2bGVfdWNoYXIgYi5pbm5lci5idWZmZXIgcG9zIHUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAocmVzaXplIGIgdWNoYXJfdXRmXzE2X2J5dGVfbGVuZ3RoX21heDsgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSlcbiAgZWxzZSAoYi5wb3NpdGlvbiA8LSBwb3MgKyBuKVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyO2xlbmd0aH0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBsZW5ndGggdGhlbiAoXG4gICAgcmVzaXplIGIgbGVuO1xuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gbGVuXG4gICkgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBidWZmZXIgcG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7YnVmZmVyOyBsZW5ndGh9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIGxlbjtcbiAgICBCeXRlcy5ibGl0X3N0cmluZyBzIDAgYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gICkgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYnVmZmVyIHBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmlubmVyLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5pbm5lci5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuaW5uZXIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmlubmVyLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0IGluXG4gICAgIGlmIHN0b3AgPSBzdGFydCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgYmVnaW4gbWF0Y2ggZmluZF9pZGVudCBzIGogbGltIHdpdGhcbiAgICAgICAgIHwgaWRlbnQsIG5leHRfaSAtPlxuICAgICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgYWRkX2NoYXIgYiAnJCc7XG4gICAgICAgICAgIHN1YnN0ICcgJyBqXG4gICAgICAgICBlbmRcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzO1xuICAgICAgICAgaWYgY3VycmVudCA8PiAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy5nZXQgYi5pbm5lci5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy5nZXQgYi5pbm5lci5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5cbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBwb3NpdGlvbiA9IGIucG9zaXRpb24gaW5cbiAgbGV0IHtsZW5ndGg7IGJ1ZmZlcn0gPSBiLmlubmVyIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBwb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gbGVuZ3RoIHRoZW4gKFxuICAgIHJlc2l6ZSBiIDE7XG4gICAgc2V0X2ludDggYi5pbm5lci5idWZmZXIgYi5wb3NpdGlvbiB4XG4gICkgZWxzZVxuICAgIHVuc2FmZV9zZXRfaW50OCBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiAyO1xuICAgIHNldF9pbnQxNiBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQxNiBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiA0O1xuICAgIHNldF9pbnQzMiBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQzMiBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgcG9zaXRpb24gPSBiLnBvc2l0aW9uIGluXG4gIGxldCB7bGVuZ3RoOyBidWZmZXJ9ID0gYi5pbm5lciBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gcG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGxlbmd0aCB0aGVuIChcbiAgICByZXNpemUgYiA4O1xuICAgIHNldF9pbnQ2NCBiLmlubmVyLmJ1ZmZlciBiLnBvc2l0aW9uIHhcbiAgKSBlbHNlXG4gICAgdW5zYWZlX3NldF9pbnQ2NCBidWZmZXIgcG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBQYXNjYWwgQ3VvcSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk1IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdFxuZXh0ZXJuYWwgY3JlYXRlOiB1bml0IC0+IHQgPSBcImNhbWxfbWxfbXV0ZXhfbmV3XCJcbmV4dGVybmFsIGxvY2s6IHQgLT4gdW5pdCA9IFwiY2FtbF9tbF9tdXRleF9sb2NrXCJcbmV4dGVybmFsIHRyeV9sb2NrOiB0IC0+IGJvb2wgPSBcImNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2tcIlxuZXh0ZXJuYWwgdW5sb2NrOiB0IC0+IHVuaXQgPSBcImNhbWxfbWxfbXV0ZXhfdW5sb2NrXCJcblxuKCogcHJpdmF0ZSByZS1leHBvcnQgKilcbmV4dGVybmFsIHJlcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyZXJhaXNlXCJcblxuKCogY2Fubm90IGlubGluZSwgb3RoZXJ3aXNlIGZsYW1iZGEgbWlnaHQgbW92ZSBjb2RlIGFyb3VuZC4gKilcbmxldFtAaW5saW5lIG5ldmVyXSBwcm90ZWN0IG0gZiA9XG4gIGxvY2sgbTtcbiAgbWF0Y2ggZigpIHdpdGhcbiAgfCB4IC0+XG4gICAgdW5sb2NrIG07IHhcbiAgfCBleGNlcHRpb24gZSAtPlxuICAgICgqIE5PVEU6IFt1bmxvY2tdIGRvZXMgbm90IHBvbGwgZm9yIGFzeW5jaHJvbm91cyBleGNlcHRpb25zICopXG4gICAgdW5sb2NrIG07XG4gICAgcmVyYWlzZSBlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBYYXZpZXIgTGVyb3ksIENvbGzDqGdlIGRlIEZyYW5jZSBhbmQgSU5SSUEgUGFyaXMgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogU2VtYXBob3JlcyAqKVxuXG50eXBlIHNlbSA9IHtcbiAgbXV0OiBNdXRleC50OyAgICAgICAgICAgICAgICAgICAgICAgICAoKiBwcm90ZWN0cyBbdl0gKilcbiAgbXV0YWJsZSB2OiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAoKiB0aGUgY3VycmVudCB2YWx1ZSAqKVxuICBub256ZXJvOiBDb25kaXRpb24udCAgICAgICAgICAgICAgICAgICgqIHNpZ25hbGVkIHdoZW4gW3YgPiAwXSAqKVxufVxuXG5tb2R1bGUgQ291bnRpbmcgPSBzdHJ1Y3RcblxudHlwZSB0ID0gc2VtXG5cbmxldCBtYWtlIHYgPVxuICBpZiB2IDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU2VtYXBob3JlLkNvdW50aW5nLmluaXQ6IHdyb25nIGluaXRpYWwgdmFsdWVcIjtcbiAgeyBtdXQgPSBNdXRleC5jcmVhdGUoKTsgdjsgbm9uemVybyA9IENvbmRpdGlvbi5jcmVhdGUoKSB9XG5cbmxldCByZWxlYXNlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICBpZiBzLnYgPCBtYXhfaW50IHRoZW4gYmVnaW5cbiAgICBzLnYgPC0gcy52ICsgMTtcbiAgICBDb25kaXRpb24uc2lnbmFsIHMubm9uemVybztcbiAgICBNdXRleC51bmxvY2sgcy5tdXRcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBNdXRleC51bmxvY2sgcy5tdXQ7XG4gICAgcmFpc2UgKFN5c19lcnJvciBcIlNlbWFwaG9yZS5Db3VudGluZy5yZWxlYXNlOiBvdmVyZmxvd1wiKVxuICBlbmRcblxubGV0IGFjcXVpcmUgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIHdoaWxlIHMudiA9IDAgZG8gQ29uZGl0aW9uLndhaXQgcy5ub256ZXJvIHMubXV0IGRvbmU7XG4gIHMudiA8LSBzLnYgLSAxO1xuICBNdXRleC51bmxvY2sgcy5tdXRcblxubGV0IHRyeV9hY3F1aXJlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICBsZXQgcmV0ID0gaWYgcy52ID0gMCB0aGVuIGZhbHNlIGVsc2UgKHMudiA8LSBzLnYgLSAxOyB0cnVlKSBpblxuICBNdXRleC51bmxvY2sgcy5tdXQ7XG4gIHJldFxuXG5sZXQgZ2V0X3ZhbHVlIHMgPSBzLnZcblxuZW5kXG5cbm1vZHVsZSBCaW5hcnkgPSBzdHJ1Y3RcblxudHlwZSB0ID0gc2VtXG5cbmxldCBtYWtlIGIgPVxuICB7IG11dCA9IE11dGV4LmNyZWF0ZSgpO1xuICAgIHYgPSBpZiBiIHRoZW4gMSBlbHNlIDA7XG4gICAgbm9uemVybyA9IENvbmRpdGlvbi5jcmVhdGUoKSB9XG5cbmxldCByZWxlYXNlIHMgPVxuICBNdXRleC5sb2NrIHMubXV0O1xuICBzLnYgPC0gMTtcbiAgQ29uZGl0aW9uLnNpZ25hbCBzLm5vbnplcm87XG4gIE11dGV4LnVubG9jayBzLm11dFxuXG5sZXQgYWNxdWlyZSBzID1cbiAgTXV0ZXgubG9jayBzLm11dDtcbiAgd2hpbGUgcy52ID0gMCBkbyBDb25kaXRpb24ud2FpdCBzLm5vbnplcm8gcy5tdXQgZG9uZTtcbiAgcy52IDwtIDA7XG4gIE11dGV4LnVubG9jayBzLm11dFxuXG5sZXQgdHJ5X2FjcXVpcmUgcyA9XG4gIE11dGV4LmxvY2sgcy5tdXQ7XG4gIGxldCByZXQgPSBpZiBzLnYgPSAwIHRoZW4gZmFsc2UgZWxzZSAocy52IDwtIDA7IHRydWUpIGluXG4gIE11dGV4LnVubG9jayBzLm11dDtcbiAgcmV0XG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICBLQyBTaXZhcmFtYWtyaXNobmFuLCBJbmRpYW4gSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3ksIE1hZHJhcyAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFN0ZXBoZW4gRG9sYW4sIFVuaXZlcnNpdHkgb2YgQ2FtYnJpZGdlICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgVG9tIEtlbGx5LCBPQ2FtbCBMYWJzIENvbnN1bHRhbmN5ICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOSBJbmRpYW4gSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3ksIE1hZHJhcyAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBVbml2ZXJzaXR5IG9mIENhbWJyaWRnZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBPQ2FtbCBMYWJzIENvbnN1bHRhbmN5IEx0ZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgUmF3ID0gc3RydWN0XG4gICgqIExvdy1sZXZlbCBwcmltaXRpdmVzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lICopXG4gIHR5cGUgdCA9IHByaXZhdGUgaW50XG5cbiAgKCogVGhlIGxheW91dHMgb2YgW3N0YXRlXSBhbmQgW3Rlcm1fc3luY10gYXJlIGhhcmQtY29kZWQgaW5cbiAgICAgW3J1bnRpbWUvZG9tYWluLmNdICopXG5cbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBSdW5uaW5nXG4gICAgfCBGaW5pc2hlZCBvZiAoJ2EsIGV4bikgcmVzdWx0IFtAd2FybmluZyBcIi11bnVzZWQtY29uc3RydWN0b3JcIl1cblxuICB0eXBlICdhIHRlcm1fc3luYyA9IHtcbiAgICAoKiBwcm90ZWN0ZWQgYnkgW211dF0gKilcbiAgICBtdXRhYmxlIHN0YXRlIDogJ2Egc3RhdGUgW0B3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXSA7XG4gICAgbXV0IDogTXV0ZXgudCA7XG4gICAgY29uZCA6IENvbmRpdGlvbi50IDtcbiAgfVxuXG4gIGV4dGVybmFsIHNwYXduIDogKHVuaXQgLT4gJ2EpIC0+ICdhIHRlcm1fc3luYyAtPiB0XG4gICAgPSBcImNhbWxfZG9tYWluX3NwYXduXCJcbiAgZXh0ZXJuYWwgc2VsZiA6IHVuaXQgLT4gdFxuICAgID0gXCJjYW1sX21sX2RvbWFpbl9pZFwiIFtAQG5vYWxsb2NdXG4gIGV4dGVybmFsIGNwdV9yZWxheCA6IHVuaXQgLT4gdW5pdFxuICAgID0gXCJjYW1sX21sX2RvbWFpbl9jcHVfcmVsYXhcIlxuICBleHRlcm5hbCBnZXRfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50OiB1bml0IC0+IGludFxuICAgID0gXCJjYW1sX3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudFwiIFtAQG5vYWxsb2NdXG5lbmRcblxubGV0IGNwdV9yZWxheCAoKSA9IFJhdy5jcHVfcmVsYXggKClcblxudHlwZSBpZCA9IFJhdy50XG5cbnR5cGUgJ2EgdCA9IHtcbiAgZG9tYWluIDogUmF3LnQ7XG4gIHRlcm1fc3luYyA6ICdhIFJhdy50ZXJtX3N5bmM7XG59XG5cbm1vZHVsZSBETFMgPSBzdHJ1Y3RcblxuICBtb2R1bGUgT2JqX29wdCA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBub25lIDogdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gdFxuICAgIHZhbCBpc19zb21lIDogdCAtPiBib29sXG5cbiAgICAoKiogW3Vuc2FmZV9nZXQgb2JqXSBtYXkgb25seSBiZSBjYWxsZWQgc2FmZWx5XG4gICAgICAgIGlmIFtpc19zb21lXSBpcyB0cnVlLlxuXG4gICAgICAgIFt1bnNhZmVfZ2V0IChzb21lIHYpXSBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIFtPYmoub2JqIChPYmoucmVwciB2KV0uICopXG4gICAgdmFsIHVuc2FmZV9nZXQgOiB0IC0+ICdhXG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IE9iai50XG4gICAgbGV0IG5vbmUgPSBPYmoucmVwciAocmVmIDApXG4gICAgbGV0IHNvbWUgdiA9IE9iai5yZXByIHZcbiAgICBsZXQgaXNfc29tZSBvYmogPSAob2JqICE9IG5vbmUpXG4gICAgbGV0IHVuc2FmZV9nZXQgb2JqID0gT2JqLm9iaiBvYmpcbiAgZW5kXG5cbiAgdHlwZSBkbHNfc3RhdGUgPSBPYmpfb3B0LnQgYXJyYXlcblxuICBleHRlcm5hbCBnZXRfZGxzX3N0YXRlIDogdW5pdCAtPiBkbHNfc3RhdGUgPSBcIiVkbHNfZ2V0XCJcblxuICBleHRlcm5hbCBzZXRfZGxzX3N0YXRlIDogZGxzX3N0YXRlIC0+IHVuaXQgPVxuICAgIFwiY2FtbF9kb21haW5fZGxzX3NldFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY29tcGFyZV9hbmRfc2V0X2Rsc19zdGF0ZSA6IGRsc19zdGF0ZSAtPiBkbHNfc3RhdGUgLT4gYm9vbCA9XG4gICAgXCJjYW1sX2RvbWFpbl9kbHNfY29tcGFyZV9hbmRfc2V0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY3JlYXRlX2RscyAoKSA9XG4gICAgbGV0IHN0ID0gQXJyYXkubWFrZSA4IE9ial9vcHQubm9uZSBpblxuICAgIHNldF9kbHNfc3RhdGUgc3RcblxuICBsZXQgXyA9IGNyZWF0ZV9kbHMgKClcblxuICB0eXBlICdhIGtleSA9IGludCAqICh1bml0IC0+ICdhKVxuXG4gIGxldCBrZXlfY291bnRlciA9IEF0b21pYy5tYWtlIDBcblxuICB0eXBlIGtleV9pbml0aWFsaXplciA9XG4gICAgS0k6ICdhIGtleSAqICgnYSAtPiAnYSkgLT4ga2V5X2luaXRpYWxpemVyXG5cbiAgbGV0IHBhcmVudF9rZXlzID0gQXRvbWljLm1ha2UgKFtdIDoga2V5X2luaXRpYWxpemVyIGxpc3QpXG5cbiAgbGV0IHJlYyBhZGRfcGFyZW50X2tleSBraSA9XG4gICAgbGV0IGwgPSBBdG9taWMuZ2V0IHBhcmVudF9rZXlzIGluXG4gICAgaWYgbm90IChBdG9taWMuY29tcGFyZV9hbmRfc2V0IHBhcmVudF9rZXlzIGwgKGtpIDo6IGwpKVxuICAgIHRoZW4gYWRkX3BhcmVudF9rZXkga2lcblxuICBsZXQgbmV3X2tleSA/c3BsaXRfZnJvbV9wYXJlbnQgaW5pdF9vcnBoYW4gPVxuICAgIGxldCBpZHggPSBBdG9taWMuZmV0Y2hfYW5kX2FkZCBrZXlfY291bnRlciAxIGluXG4gICAgbGV0IGsgPSAoaWR4LCBpbml0X29ycGhhbikgaW5cbiAgICBiZWdpbiBtYXRjaCBzcGxpdF9mcm9tX3BhcmVudCB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIHNwbGl0IC0+IGFkZF9wYXJlbnRfa2V5IChLSShrLCBzcGxpdCkpXG4gICAgZW5kO1xuICAgIGtcblxuICAoKiBJZiBuZWNlc3NhcnksIGdyb3cgdGhlIGN1cnJlbnQgZG9tYWluJ3MgbG9jYWwgc3RhdGUgYXJyYXkgc3VjaCB0aGF0IFtpZHhdXG4gICAqIGlzIGEgdmFsaWQgaW5kZXggaW4gdGhlIGFycmF5LiAqKVxuICBsZXQgcmVjIG1heWJlX2dyb3cgaWR4ID1cbiAgICBsZXQgc3QgPSBnZXRfZGxzX3N0YXRlICgpIGluXG4gICAgbGV0IHN6ID0gQXJyYXkubGVuZ3RoIHN0IGluXG4gICAgaWYgaWR4IDwgc3ogdGhlbiBzdFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByZWMgY29tcHV0ZV9uZXdfc2l6ZSBzID1cbiAgICAgICAgaWYgaWR4IDwgcyB0aGVuIHMgZWxzZSBjb21wdXRlX25ld19zaXplICgyICogcylcbiAgICAgIGluXG4gICAgICBsZXQgbmV3X3N6ID0gY29tcHV0ZV9uZXdfc2l6ZSBzeiBpblxuICAgICAgbGV0IG5ld19zdCA9IEFycmF5Lm1ha2UgbmV3X3N6IE9ial9vcHQubm9uZSBpblxuICAgICAgQXJyYXkuYmxpdCBzdCAwIG5ld19zdCAwIHN6O1xuICAgICAgKCogV2Ugd2FudCBhIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgc2FmZSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgICAgIHNpbmdsZS1kb21haW4gbXVsdGktdGhyZWFkaW5nOiByZXRyeSBpZiB0aGUgRExTIHN0YXRlIGhhc1xuICAgICAgICAgY2hhbmdlZCB1bmRlciBvdXIgZmVldC5cbiAgICAgICAgIE5vdGUgdGhhdCB0aGUgbnVtYmVyIG9mIHJldHJpZXMgd2lsbCBiZSB2ZXJ5IHNtYWxsIGluXG4gICAgICAgICBjb250ZW5kZWQgc2NlbmFyaW9zLCBhcyB0aGUgYXJyYXkgb25seSBncm93cywgd2l0aFxuICAgICAgICAgZXhwb25lbnRpYWwgcmVzaXppbmcuICopXG4gICAgICBpZiBjb21wYXJlX2FuZF9zZXRfZGxzX3N0YXRlIHN0IG5ld19zdFxuICAgICAgdGhlbiBuZXdfc3RcbiAgICAgIGVsc2UgbWF5YmVfZ3JvdyBpZHhcbiAgICBlbmRcblxuICBsZXQgc2V0ICh0eXBlIGEpIChpZHgsIF9pbml0KSAoeCA6IGEpID1cbiAgICBsZXQgc3QgPSBtYXliZV9ncm93IGlkeCBpblxuICAgICgqIFtTeXMub3BhcXVlX2lkZW50aXR5XSBlbnN1cmVzIHRoYXQgZmxhbWJkYSBkb2VzIG5vdCBsb29rIGF0IHRoZSB0eXBlIG9mXG4gICAgICogW3hdLCB3aGljaCBtYXkgYmUgYSBbZmxvYXRdIGFuZCBjb25jbHVkZSB0aGF0IHRoZSBbc3RdIGlzIGEgZmxvYXQgYXJyYXkuXG4gICAgICogV2UgZG8gbm90IHdhbnQgT0NhbWwncyBmbG9hdCBhcnJheSBvcHRpbWlzYXRpb24ga2lja2luZyBpbiBoZXJlLiAqKVxuICAgIHN0LihpZHgpIDwtIE9ial9vcHQuc29tZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSB4KVxuXG5cbiAgbGV0W0BpbmxpbmUgbmV2ZXJdIGFycmF5X2NvbXBhcmVfYW5kX3NldCBhIGkgb2xkdmFsIG5ld3ZhbCA9XG4gICAgKCogTm90ZTogd2UgY2Fubm90IHVzZSBbQHBvbGwgZXJyb3JdIGR1ZSB0byB0aGVcbiAgICAgICBhbGxvY2F0aW9ucyBvbiBhLihpKSBpbiB0aGUgRG91YmxlX2FycmF5IGNhc2UuICopXG4gICAgbGV0IGN1cnZhbCA9IGEuKGkpIGluXG4gICAgaWYgY3VydmFsID09IG9sZHZhbCB0aGVuIChcbiAgICAgIEFycmF5LnVuc2FmZV9zZXQgYSBpIG5ld3ZhbDtcbiAgICAgIHRydWVcbiAgICApIGVsc2UgZmFsc2VcblxuICBsZXQgZ2V0ICh0eXBlIGEpICgoaWR4LCBpbml0KSA6IGEga2V5KSA6IGEgPVxuICAgIGxldCBzdCA9IG1heWJlX2dyb3cgaWR4IGluXG4gICAgbGV0IG9iaiA9IHN0LihpZHgpIGluXG4gICAgaWYgT2JqX29wdC5pc19zb21lIG9ialxuICAgIHRoZW4gKE9ial9vcHQudW5zYWZlX2dldCBvYmogOiBhKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB2IDogYSA9IGluaXQgKCkgaW5cbiAgICAgIGxldCBuZXdfb2JqID0gT2JqX29wdC5zb21lIChTeXMub3BhcXVlX2lkZW50aXR5IHYpIGluXG4gICAgICAoKiBBdCB0aGlzIHBvaW50LCBbc3RdIG9yIFtzdC4oaWR4KV0gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkXG4gICAgICAgICBieSBhbm90aGVyIHRocmVhZCBvbiB0aGUgc2FtZSBkb21haW4uXG5cbiAgICAgICAgIElmIFtzdF0gY2hhbmdlZCwgaXQgd2FzIHJlc2l6ZWQgaW50byBhIGxhcmdlciB2YWx1ZSxcbiAgICAgICAgIHdlIGNhbiBqdXN0IHJldXNlIHRoZSBuZXcgdmFsdWUuXG5cbiAgICAgICAgIElmIFtzdC4oaWR4KV0gY2hhbmdlZCwgd2UgZHJvcCB0aGUgY3VycmVudCB2YWx1ZSB0byBhdm9pZFxuICAgICAgICAgbGV0dGluZyBvdGhlciB0aHJlYWRzIG9ic2VydmUgYSAncmV2ZXJ0JyB0aGF0IGZvcmdldHNcbiAgICAgICAgIHByZXZpb3VzIG1vZGlmaWNhdGlvbnMuICopXG4gICAgICBsZXQgc3QgPSBnZXRfZGxzX3N0YXRlICgpIGluXG4gICAgICBpZiBhcnJheV9jb21wYXJlX2FuZF9zZXQgc3QgaWR4IG9iaiBuZXdfb2JqXG4gICAgICB0aGVuIHZcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgKCogaWYgc3QuKGlkeCkgY2hhbmdlZCwgc29tZW9uZSBtdXN0IGhhdmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgdGhlIGtleSBpbiB0aGUgbWVhbnRpbWUuICopXG4gICAgICAgIGxldCB1cGRhdGVkX29iaiA9IHN0LihpZHgpIGluXG4gICAgICAgIGlmIE9ial9vcHQuaXNfc29tZSB1cGRhdGVkX29ialxuICAgICAgICB0aGVuIChPYmpfb3B0LnVuc2FmZV9nZXQgdXBkYXRlZF9vYmogOiBhKVxuICAgICAgICBlbHNlIGFzc2VydCBmYWxzZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHlwZSBrZXlfdmFsdWUgPSBLViA6ICdhIGtleSAqICdhIC0+IGtleV92YWx1ZVxuXG4gIGxldCBnZXRfaW5pdGlhbF9rZXlzICgpIDoga2V5X3ZhbHVlIGxpc3QgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChLSSAoaywgc3BsaXQpKSAtPiBLViAoaywgKHNwbGl0IChnZXQgaykpKSlcbiAgICAgIChBdG9taWMuZ2V0IHBhcmVudF9rZXlzKVxuXG4gIGxldCBzZXRfaW5pdGlhbF9rZXlzIChsOiBrZXlfdmFsdWUgbGlzdCkgPVxuICAgIExpc3QuaXRlciAoZnVuIChLViAoaywgdikpIC0+IHNldCBrIHYpIGxcbmVuZFxuXG4oKioqKioqKiogSWRlbnRpdHkgKioqKioqKioqKilcblxubGV0IGdldF9pZCB7IGRvbWFpbjsgXyB9ID0gZG9tYWluXG5cbmxldCBzZWxmICgpID0gUmF3LnNlbGYgKClcblxubGV0IGlzX21haW5fZG9tYWluICgpID0gKHNlbGYgKCkgOj4gaW50KSA9IDBcblxuKCoqKioqKioqIENhbGxiYWNrcyAqKioqKioqKioqKVxuXG4oKiBmaXJzdCBzcGF3biwgZG9tYWluIHN0YXJ0dXAgYW5kIGF0IGV4aXQgZnVuY3Rpb25hbGl0eSAqKVxubGV0IGZpcnN0X2RvbWFpbl9zcGF3bmVkID0gQXRvbWljLm1ha2UgZmFsc2VcblxubGV0IGZpcnN0X3NwYXduX2Z1bmN0aW9uID0gcmVmIChmdW4gKCkgLT4gKCkpXG5cbmxldCBiZWZvcmVfZmlyc3Rfc3Bhd24gZiA9XG4gIGlmIEF0b21pYy5nZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdGhlblxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiZmlyc3QgZG9tYWluIGFscmVhZHkgc3Bhd25lZFwiKVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG9sZF9mID0gIWZpcnN0X3NwYXduX2Z1bmN0aW9uIGluXG4gICAgbGV0IG5ld19mICgpID0gb2xkX2YgKCk7IGYgKCkgaW5cbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSBuZXdfZlxuICBlbmRcblxubGV0IGRvX2JlZm9yZV9maXJzdF9zcGF3biAoKSA9XG4gIGlmIG5vdCAoQXRvbWljLmdldCBmaXJzdF9kb21haW5fc3Bhd25lZCkgdGhlbiBiZWdpblxuICAgIEF0b21pYy5zZXQgZmlyc3RfZG9tYWluX3NwYXduZWQgdHJ1ZTtcbiAgICAhZmlyc3Rfc3Bhd25fZnVuY3Rpb24oKTtcbiAgICAoKiBSZWxlYXNlIHRoZSBvbGQgZnVuY3Rpb24gKilcbiAgICBmaXJzdF9zcGF3bl9mdW5jdGlvbiA6PSAoZnVuICgpIC0+ICgpKVxuICBlbmRcblxubGV0IGF0X2V4aXRfa2V5ID0gRExTLm5ld19rZXkgKGZ1biAoKSAtPiAoZnVuICgpIC0+ICgpKSlcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBvbGRfZXhpdCA6IHVuaXQgLT4gdW5pdCA9IERMUy5nZXQgYXRfZXhpdF9rZXkgaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBmICgpOyBvbGRfZXhpdCAoKVxuICBpblxuICBETFMuc2V0IGF0X2V4aXRfa2V5IG5ld19leGl0XG5cbmxldCBkb19hdF9leGl0ICgpID1cbiAgbGV0IGYgOiB1bml0IC0+IHVuaXQgPSBETFMuZ2V0IGF0X2V4aXRfa2V5IGluXG4gIGYgKClcblxubGV0IF8gPSBTdGRsaWIuZG9fZG9tYWluX2xvY2FsX2F0X2V4aXQgOj0gZG9fYXRfZXhpdFxuXG4oKioqKioqKiBDcmVhdGlvbiBhbmQgVGVybWluYXRpb24gKioqKioqKiopXG5cbmxldCBzcGF3biBmID1cbiAgZG9fYmVmb3JlX2ZpcnN0X3NwYXduICgpO1xuICBsZXQgcGsgPSBETFMuZ2V0X2luaXRpYWxfa2V5cyAoKSBpblxuXG4gICgqIFt0ZXJtX3N5bmNdIGlzIHVzZWQgdG8gc3luY2hyb25pemUgd2l0aCB0aGUgam9pbmluZyBkb21haW5zICopXG4gIGxldCB0ZXJtX3N5bmMgPVxuICAgIFJhdy57IHN0YXRlID0gUnVubmluZyA7XG4gICAgICAgICAgbXV0ID0gTXV0ZXguY3JlYXRlICgpIDtcbiAgICAgICAgICBjb25kID0gQ29uZGl0aW9uLmNyZWF0ZSAoKSB9XG4gIGluXG5cbiAgbGV0IGJvZHkgKCkgPVxuICAgIG1hdGNoXG4gICAgICBETFMuY3JlYXRlX2RscyAoKTtcbiAgICAgIERMUy5zZXRfaW5pdGlhbF9rZXlzIHBrO1xuICAgICAgbGV0IHJlcyA9IGYgKCkgaW5cbiAgICAgIHJlc1xuICAgIHdpdGhcbiAgICAoKiBSdW4gdGhlIFthdF9leGl0XSBjYWxsYmFja3Mgd2hlbiB0aGUgZG9tYWluIGNvbXB1dGF0aW9uIGVpdGhlclxuICAgICAgIHRlcm1pbmF0ZXMgbm9ybWFsbHkgb3IgZXhjZXB0aW9uYWxseS4gKilcbiAgICB8IHJlcyAtPlxuICAgICAgICAoKiBJZiB0aGUgZG9tYWluIGNvbXB1dGF0aW9uIHRlcm1pbmF0ZWQgbm9ybWFsbHksIGJ1dCB0aGVcbiAgICAgICAgICAgW2F0X2V4aXRdIGNhbGxiYWNrcyByYWlzZWQgYW4gZXhjZXB0aW9uLCB0aGVuIHJldHVybiB0aGVcbiAgICAgICAgICAgZXhjZXB0aW9uLiAqKVxuICAgICAgICBkb19hdF9leGl0ICgpO1xuICAgICAgICByZXNcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgKCogSWYgYm90aCB0aGUgZG9tYWluIGNvbXB1dGF0aW9uIGFuZCB0aGUgW2F0X2V4aXRdIGNhbGxiYWNrc1xuICAgICAgICAgICByYWlzZSBleGNlcHRpb25zLCB0aGVuIGlnbm9yZSB0aGUgZXhjZXB0aW9uIGZyb20gdGhlXG4gICAgICAgICAgIFthdF9leGl0XSBjYWxsYmFja3MgYW5kIHJldHVybiB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLiAqKVxuICAgICAgICAodHJ5IGRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICAgICAgcmFpc2UgZXhuXG4gIGluXG4gIGxldCBkb21haW4gPSBSYXcuc3Bhd24gYm9keSB0ZXJtX3N5bmMgaW5cbiAgeyBkb21haW4gOyB0ZXJtX3N5bmMgfVxuXG5sZXQgam9pbiB7IHRlcm1fc3luYyA7IF8gfSA9XG4gIGxldCBvcGVuIFJhdyBpblxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIG1hdGNoIHRlcm1fc3luYy5zdGF0ZSB3aXRoXG4gICAgfCBSdW5uaW5nIC0+XG4gICAgICAgIENvbmRpdGlvbi53YWl0IHRlcm1fc3luYy5jb25kIHRlcm1fc3luYy5tdXQ7XG4gICAgICAgIGxvb3AgKClcbiAgICB8IEZpbmlzaGVkIHJlcyAtPlxuICAgICAgICByZXNcbiAgaW5cbiAgbWF0Y2ggTXV0ZXgucHJvdGVjdCB0ZXJtX3N5bmMubXV0IGxvb3Agd2l0aFxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4IC0+IHJhaXNlIGV4XG5cbmxldCByZWNvbW1lbmRlZF9kb21haW5fY291bnQgPSBSYXcuZ2V0X3JlY29tbWVuZGVkX2RvbWFpbl9jb3VudFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IXG4gIHwgRmxvYXRfQ0YgLT4gLTZcbiAgKCogRm9yICVoICVIIGFuZCAlI0YgZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IEludC5tYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCB8IEludF9DZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaVxuICB8IEludF9DaSAtPiAnaScgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfb1xuICB8IEludF9DbyAtPiAnbycgfCBJbnRfdSB8IEludF9DdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbigqIGBjRicgd2lsbCBiZSAnRicgZm9yIGRpc3BsYXlpbmcgZm9ybWF0IGFuZCAnZycgdG8gY2FsbCBsaWJjIHByaW50ZiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgPyhjRj0nRicpIGZjb252ID0gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIC0+ICdmJyB8IEZsb2F0X2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSAtPiAnRScgfCBGbG9hdF9nIC0+ICdnJ1xuICB8IEZsb2F0X0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiBjRlxuICB8IEZsb2F0X2ggLT4gJ2gnIHwgRmxvYXRfSCAtPiAnSCdcbiAgfCBGbG9hdF9DRiAtPiAnRidcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBhbmQvb3IgJyMnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9XG4gIGJlZ2luIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZmxhZ19wIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfZmxhZ19zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZmxhZ18gLT4gKCkgZW5kO1xuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X0NGIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0dcbiAgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT4gKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEZvcm1hdHRpbmdfbGl0LiAqKVxuKCogVXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZm10aW5nX2dlbiB3aXRoXG4gICAgICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkB7XCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQFtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgZW5kO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIGxldCBoZXggKCkgPVxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X2ZsYWdfcCAtPiAnKydcbiAgICAgIHwgRmxvYXRfZmxhZ19zIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICBsZXQgYWRkX2RvdF9pZl9uZWVkZWQgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSkgaW5cbiAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCIgaW5cbiAgbGV0IGNhbWxfc3BlY2lhbF92YWwgc3RyID0gbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+IHN0clxuICAgIHwgRlBfaW5maW5pdGUgLT4gaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICB8IEZQX25hbiAtPiBcIm5hblwiIGluXG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCAtPiBoZXggKClcbiAgfCBGbG9hdF9IIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKGhleCAoKSlcbiAgfCBGbG9hdF9DRiAtPiBjYW1sX3NwZWNpYWxfdmFsIChoZXggKCkpXG4gIHwgRmxvYXRfRiAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgY2FtbF9zcGVjaWFsX3ZhbCAoYWRkX2RvdF9pZl9uZWVkZWQgc3RyKVxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIC0+XG4gICAgZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeFxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaWduXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXRzLiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFydG91dCwgSU5SSUEgUGFyaXMtU2FjbGF5ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIG11dGFibGUgYXJyIDogJ2Egc2xvdCBhcnJheTtcbn1cbigqIHsyIFRoZSB0eXBlIFsnYSB0XX1cblxuICAgQSBkeW5hbWljIGFycmF5IGlzIHJlcHJlc2VudGVkIHVzaW5nIGEgYmFja2luZyBhcnJheSBbYXJyXSBhbmRcbiAgIGEgW2xlbmd0aF0uIEl0IGJlaGF2ZXMgYXMgYW4gYXJyYXkgb2Ygc2l6ZSBbbGVuZ3RoXSAtLSB0aGUgaW5kaWNlc1xuICAgZnJvbSBbMF0gdG8gW2xlbmd0aCAtIDFdIGluY2x1ZGVkIGNvbnRhaW4gdXNlci1wcm92aWRlZCB2YWx1ZXMgYW5kXG4gICBjYW4gYmUgW2dldF0gYW5kIFtzZXRdIC0tIGJ1dCB0aGUgbGVuZ3RoIG1heSBhbHNvIGNoYW5nZSBpbiB0aGVcbiAgIGZ1dHVyZSBieSBhZGRpbmcgb3IgcmVtb3ZpbmcgZWxlbWVudHMgYXQgdGhlIGVuZC5cblxuICAgV2UgdXNlIHRoZSBmb2xsb3dpbmcgY29uY2VwdHM7XG4gICAtIGNhcGFjaXR5OiB0aGUgbGVuZ3RoIG9mIHRoZSBiYWNraW5nIGFycmF5OlxuICAgICBbQXJyYXkubGVuZ3RoICBhcnJdXG4gICAtIGxpdmUgc3BhY2U6IHRoZSBwb3J0aW9uIG9mIHRoZSBiYWNraW5nIGFycmF5IHdpdGhcbiAgICAgaW5kaWNlcyBmcm9tIFswXSB0byBbbGVuZ3RoIC0gMV0gaW5jbHVkZWQuXG4gICAtIGVtcHR5IHNwYWNlOiB0aGUgcG9ydGlvbiBvZiB0aGUgYmFja2luZyBhcnJheVxuICAgICBmcm9tIFtsZW5ndGhdIHRvIHRoZSBlbmQgb2YgdGhlIGJhY2tpbmcgYXJyYXkuXG5cbiAgIHsyIFRoZSB0eXBlIFsnYSBzbG90XX1cblxuICAgV2Ugc2hvdWxkIG5vdCBrZWVwIGEgdXNlci1wcm92aWRlZCB2YWx1ZSBpbiB0aGUgZW1wdHkgc3BhY2UsIGFzXG4gICB0aGlzIGNvdWxkIGV4dGVuZCBpdHMgbGlmZXRpbWUgYW5kIG1heSByZXN1bHQgaW4gbWVtb3J5IGxlYWtzIG9mXG4gICBhcmJpdHJhcnkgc2l6ZS4gRnVuY3Rpb25zIHRoYXQgcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGR5bmFtaWNcbiAgIGFycmF5LCBzdWNoIGFzIFtwb3BfbGFzdF0gb3IgW3RydW5jYXRlXSwgbXVzdCByZWFsbHkgZXJhc2UgdGhlXG4gICBlbGVtZW50IGZyb20gdGhlIGJhY2tpbmcgYXJyYXkuXG5cbiAgIFRoaXMgY29uc3RyYWludCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gcmVwcmVzZW50IGFuIGR5bmFtaWMgYXJyYXkgb2ZcbiAgIGVsZW1lbnRzIG9mIHR5cGUgWydhXSB3aXRoIGEgYmFja2luZyBhcnJheSBvZiB0eXBlIFsnYSBhcnJheV06IHdoYXRcbiAgIHZhbGlkIHZhbHVlIG9mIHR5cGUgWydhXSB3b3VsZCB3ZSB1c2UgaW4gdGhlIGVtcHR5IHNwYWNlPyBUeXBpY2FsXG4gICBjaG9pY2VzIGluY2x1ZGU6XG4gICAtIGFjY2VwdGluZyBzY2VuYXJpb3Mgd2hlcmUgd2UgYWN0dWFsbHkgbGVhayB1c2VyLXByb3ZpZGVkIHZhbHVlc1xuICAgICAoYnV0IHRoaXMgY2FuIGJsb3d1cCBtZW1vcnkgdXNhZ2UgaW4gc29tZSBjYXNlcywgYW5kIGlzIGhhcmQgdG8gZGVidWcpXG4gICAtIHJlcXVpcmluZyBhIFwiZHVtbXlcIiB2YWx1ZSBhdCBjcmVhdGlvbiBvZiB0aGUgZHluYW1pYyBhcnJheVxuICAgICBvciBpbiB0aGUgcGFydHMgb2YgdGhlIEFQSSB0aGF0IGdyb3cgdGhlIGVtcHR5IHNwYWNlXG4gICAgIChidXQgdXNlcnMgZmluZCB0aGlzIHZlcnkgaW5jb252ZW5pZW50KVxuICAgLSB1c2luZyBhcmNhbmUgT2JqLm1hZ2ljIHRyaWNrc1xuICAgICAoYnV0IGV4cGVydHMgZG9uJ3QgYWdyZWUgb24gd2hpY2ggdHJpY2tzIGFyZSBzYWZlIHRvIHVzZSBhbmQvb3JcbiAgICAgIHNob3VsZCBiZSB1c2VkIGhlcmUpXG4gICAtIHVzaW5nIGEgYmFja2luZyBhcnJheSBvZiBbJ2Egb3B0aW9uXSB2YWx1ZXMsIHVzaW5nIFtOb25lXVxuICAgICBpbiB0aGUgZW1wdHkgc3BhY2VcbiAgICAgKGJ1dCB0aGlzIGdpdmVzIGEgbm90aWNlYWJseSBsZXNzIGVmZmljaWVudCBtZW1vcnkgcmVwcmVzZW50YXRpb24pXG5cbiAgIEluIHRoZSBwcmVzZW50IGltcGxlbWVudGF0aW9uLCB3ZSB1c2UgdGhlIFsnYSBvcHRpb25dIGFwcHJvYWNoLFxuICAgd2l0aCBhIHR3aXN0LiBXaXRoIFsnYSBvcHRpb25dLCBjYWxsaW5nIFtzZXQgYSBpIHhdIG11c3QgcmVhbGxvY2F0ZVxuICAgYSBuZXcgW1NvbWUgeF0gYmxvY2s6XG57W1xuICAgbGV0IHNldCBhIGkgeCA9XG4gICAgIGlmIGkgPCAwIHx8IGkgPj0gYS5sZW5ndGggdGhlbiBlcnJvciBcIm91dCBvZiBib3VuZHNcIjtcbiAgICAgYS5hcnIuKGkpIDwtIFNvbWUgeFxuXX1cbiAgIEluc3RlYWQgd2UgdXNlIHRoZSB0eXBlIFsnYSBzbG90XSBiZWxvdyxcbiAgIHdoaWNoIGJlaGF2ZXMgYXMgYW4gb3B0aW9uIHdob3NlIFtTb21lXSBjb25zdHJ1Y3RvclxuICAgKGNhbGxlZCBbRWxlbV0gaGVyZSkgaGFzIGEgX211dGFibGVfIGFyZ3VtZW50LlxuKilcbmFuZCAnYSBzbG90ID1cbnwgRW1wdHlcbnwgRWxlbSBvZiB7IG11dGFibGUgdjogJ2EgfVxuKCpcbiAgIFRoaXMgZ2l2ZXMgYW4gYWxsb2NhdGlvbi1mcmVlIGltcGxlbWVudGF0aW9uIG9mIFtzZXRdIHRoYXQgY2FsbHNcbiAgIFtBcnJheS5nZXRdIChpbnN0ZWFkIG9mIFtBcnJheS5zZXRdKSBvbiB0aGUgYmFja2luZyBhcnJheSBhbmQgdGhlblxuICAgbXV0YXRlcyB0aGUgW3ZdIHBhcmFtZXRlci4gSW4gcHNldWRvLWNvZGU6XG57W1xuICAgbGV0IHNldCBhIGkgeCA9XG4gICAgIGlmIGkgPCAwIHx8IGkgPj0gYS5sZW5ndGggdGhlbiBlcnJvciBcIm91dCBvZiBib3VuZHNcIjtcbiAgICAgbWF0Y2ggYS5hcnIuKGkpIHdpdGhcbiAgICAgfCBFbXB0eSAtPiBlcnJvciBcImludmFsaWQgc3RhdGU6IG1pc3NpbmcgZWxlbWVudFwiXG4gICAgIHwgRWxlbSBzIC0+IHMudiA8LSB4XG5dfVxuICAgV2l0aCB0aGlzIGFwcHJvYWNoLCBhY2Nlc3NpbmcgYW4gZWxlbWVudCBzdGlsbCBwYXlzIHRoZSBjb3N0IG9mIGFuXG4gICBleHRyYSBpbmRpcmVjdGlvbiAoY29tcGFyZWQgdG8gYXBwcm9hY2hlcyB0aGF0IGRvIG5vdCBib3ggZWxlbWVudHNcbiAgIGluIHRoZSBiYWNraW5nIGFycmF5KSwgYnV0IG9ubHkgb3BlcmF0aW9ucyB0aGF0IGFkZCBuZXcgZWxlbWVudHMgYXRcbiAgIHRoZSBlbmQgb2YgdGhlIGFycmF5IHBheSBleHRyYSBhbGxvY2F0aW9ucy5cblxuICAgVGhlcmUgYXJlIHNvbWUgc2l0dWF0aW9ucyB3aGVyZSBbJ2Egb3B0aW9uXSBpcyBiZXR0ZXI6IGl0IG1ha2VzXG4gICBbcG9wX2xhc3Rfb3B0XSBtb3JlIGVmZmljaWVudCBhcyB0aGUgdW5kZXJseWluZyBvcHRpb24gY2FuIGJlXG4gICByZXR1cm5lZCBkaXJlY3RseSwgYW5kIGl0IGFsc28gbGV0cyB1cyB1c2UgW0FycmF5LmJsaXRdIHRvXG4gICBpbXBsZW1lbnQgW2FwcGVuZF0uIFdlIGJlbGlldmUgdGhhdCBvcHRpbWl6aW5nIFtnZXRdIGFuZCBbc2V0XSBpc1xuICAgbW9yZSBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgYXJyYXlzLlxuXG4gICB7MiBJbnZhcmlhbnRzIGFuZCB2YWxpZCBzdGF0ZXN9XG5cbiAgIFdlIGVuZm9yY2UgdGhlIGludmFyaWFudCB0aGF0IFtsZW5ndGggPj0gMF0gYXQgYWxsIHRpbWVzLlxuICAgd2UgcmVseSBvbiB0aGlzIGludmFyaWFudCBmb3Igb3B0aW1pemF0aW9uLlxuXG4gICBUaGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgZGVmaW5lIHdoYXQgd2UgY2FsbCBhIFwidmFsaWRcIiBkeW5hcnJheTpcbiAgIC0gdmFsaWQgbGVuZ3RoOiBbbGVuZ3RoIDw9IEFycmF5Lmxlbmd0aCBhcnJdXG4gICAtIG5vIG1pc3NpbmcgZWxlbWVudCBpbiB0aGUgbGl2ZSBzcGFjZTpcbiAgICAgZm9yYWxsIGksIFswIDw9IGkgPCBsZW5ndGhdIGltcGxpZXMgW2Fyci4oaSkgPD4gRW1wdHldXG4gICAtIG5vIGVsZW1lbnQgaW4gdGhlIGVtcHR5IHNwYWNlOlxuICAgICBmb3JhbGwgaSwgW2xlbmd0aCA8PSBpIDwgQXJyYXkubGVuZ3RoIGFycl0gaW1wbGllcyBbYXJyLihpKSA9IEVtcHR5XVxuXG4gICBVbmZvcnR1bmF0ZWx5LCB3ZSBjYW5ub3QgZWFzaWx5IGVuZm9yY2UgdmFsaWRpdHkgYXMgYW4gaW52YXJpYW50IGluXG4gICBwcmVzZW5jZSBvZiBjb25jdXJyZW50IHVwZGF0ZXMuIFdlIGNhbiB0aHVzIG9ic2VydmUgZHluYXJyYXlzIGluXG4gICBcImludmFsaWQgc3RhdGVzXCIuIE91ciBpbXBsZW1lbnRhdGlvbiBtYXkgcmFpc2UgZXhjZXB0aW9ucyBvciByZXR1cm5cbiAgIGluY29ycmVjdCByZXN1bHRzIG9uIG9ic2VydmluZyBpbnZhbGlkIHN0YXRlcywgYnV0IG9mIGNvdXJzZSBpdFxuICAgbXVzdCBwcmVzZXJ2ZSBtZW1vcnkgc2FmZXR5LlxuKilcblxubW9kdWxlIEVycm9yID0gc3RydWN0XG4gIGxldFtAaW5saW5lIG5ldmVyXSBpbmRleF9vdXRfb2ZfYm91bmRzIGYgfmkgfmxlbmd0aCA9XG4gICAgaWYgbGVuZ3RoID0gMCB0aGVuXG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmdcbiAgICAgICAgXCJEeW5hcnJheS4lczogaW5kZXggJWQgb3V0IG9mIGJvdW5kcyAoZW1wdHkgZHluYXJyYXkpXCJcbiAgICAgICAgZiBpXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnXG4gICAgICAgIFwiRHluYXJyYXkuJXM6IGluZGV4ICVkIG91dCBvZiBib3VuZHMgKDAuLiVkKVwiXG4gICAgICAgIGYgaSAobGVuZ3RoIC0gMSlcblxuICBsZXRbQGlubGluZSBuZXZlcl0gbmVnYXRpdmVfbGVuZ3RoX3JlcXVlc3RlZCBmIG4gPVxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZ1xuICAgICAgXCJEeW5hcnJheS4lczogbmVnYXRpdmUgbGVuZ3RoICVkIHJlcXVlc3RlZFwiXG4gICAgICBmIG5cblxuICBsZXRbQGlubGluZSBuZXZlcl0gbmVnYXRpdmVfY2FwYWNpdHlfcmVxdWVzdGVkIGYgbiA9XG4gICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnXG4gICAgICBcIkR5bmFycmF5LiVzOiBuZWdhdGl2ZSBjYXBhY2l0eSAlZCByZXF1ZXN0ZWRcIlxuICAgICAgZiBuXG5cbiAgbGV0W0BpbmxpbmUgbmV2ZXJdIHJlcXVlc3RlZF9sZW5ndGhfb3V0X29mX2JvdW5kcyBmIHJlcXVlc3RlZF9sZW5ndGggPVxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZ1xuICAgICAgXCJEeW5hcnJheS4lczogY2Fubm90IGdyb3cgdG8gcmVxdWVzdGVkIGxlbmd0aCAlZCAobWF4X2FycmF5X2xlbmd0aCBpcyAlZClcIlxuICAgICAgZiByZXF1ZXN0ZWRfbGVuZ3RoIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbiAgKCogV2hlbiBvYnNlcnZpbmcgYW4gaW52YWxpZCBzdGF0ZSAoW21pc3NpbmdfZWxlbWVudF0sXG4gICAgIFtpbnZhbGlkX2xlbmd0aF0pLCB3ZSBkbyBub3QgZ2l2ZSB0aGUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvblxuICAgICBpbiB0aGUgZXJyb3IgbWVzc2FnZSwgYXMgdGhlIGVycm9yIGlzIHJlbGF0ZWQgdG8gaW52YWxpZCBvcGVyYXRpb25zXG4gICAgIHBlcmZvcm1lZCBlYXJsaWVyLCBhbmQgbm90IHRvIHRoZSBjYWxsc2l0ZSBvZiB0aGUgZnVuY3Rpb25cbiAgICAgaXRzZWxmLiAqKVxuXG4gIGxldCBpbnZhbGlkX3N0YXRlX2Rlc2NyaXB0aW9uID1cbiAgICBcIkludmFsaWQgZHluYXJyYXkgKHVuc3luY2hyb25pemVkIGNvbmN1cnJlbnQgbGVuZ3RoIGNoYW5nZSlcIlxuXG4gIGxldFtAaW5saW5lIG5ldmVyXSBtaXNzaW5nX2VsZW1lbnQgfmkgfmxlbmd0aCA9XG4gICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnXG4gICAgICBcIiVzOiBtaXNzaW5nIGVsZW1lbnQgYXQgcG9zaXRpb24gJWQgPCBsZW5ndGggJWRcIlxuICAgICAgaW52YWxpZF9zdGF0ZV9kZXNjcmlwdGlvblxuICAgICAgaSBsZW5ndGhcblxuICBsZXRbQGlubGluZSBuZXZlcl0gaW52YWxpZF9sZW5ndGggfmxlbmd0aCB+Y2FwYWNpdHkgPVxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZ1xuICAgICAgXCIlczogbGVuZ3RoICVkID4gY2FwYWNpdHkgJWRcIlxuICAgICAgaW52YWxpZF9zdGF0ZV9kZXNjcmlwdGlvblxuICAgICAgbGVuZ3RoIGNhcGFjaXR5XG5cbiAgbGV0W0BpbmxpbmUgbmV2ZXJdIGxlbmd0aF9jaGFuZ2VfZHVyaW5nX2l0ZXJhdGlvbiBmIH5leHBlY3RlZCB+b2JzZXJ2ZWQgPVxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZ1xuICAgICAgXCJEeW5hcnJheS4lczogYSBsZW5ndGggY2hhbmdlIGZyb20gJWQgdG8gJWQgb2NjdXJyZWQgZHVyaW5nIGl0ZXJhdGlvblwiXG4gICAgICBmIGV4cGVjdGVkIG9ic2VydmVkXG5cbiAgKCogV2hlbiBhbiBbRW1wdHldIGVsZW1lbnQgaXMgb2JzZXJ2ZWQgdW5leHBlY3RlZGx5IGF0IGluZGV4IFtpXSxcbiAgICAgaXQgbWF5IGJlIGVpdGhlciBhbiBvdXQtb2YtYm91bmRzIGFjY2VzcyBvciBhbiBpbnZhbGlkLXN0YXRlIHNpdHVhdGlvblxuICAgICBkZXBlbmRpbmcgb24gd2hldGhlciBbaSA8PSBsZW5ndGhdLiAqKVxuICBsZXRbQGlubGluZSBuZXZlcl0gdW5leHBlY3RlZF9lbXB0eV9lbGVtZW50IGYgfmkgfmxlbmd0aCA9XG4gICAgaWYgaSA8IGxlbmd0aCB0aGVuXG4gICAgICBtaXNzaW5nX2VsZW1lbnQgfmkgfmxlbmd0aFxuICAgIGVsc2VcbiAgICAgIGluZGV4X291dF9vZl9ib3VuZHMgZiB+aSB+bGVuZ3RoXG5cbiAgbGV0W0BpbmxpbmUgbmV2ZXJdIGVtcHR5X2R5bmFycmF5IGYgPVxuICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZ1xuICAgICAgXCJEeW5hcnJheS4lczogZW1wdHkgYXJyYXlcIiBmXG5lbmRcblxuKCogRGV0ZWN0aW5nIGl0ZXJhdG9yIGludmFsaWRhdGlvbi5cblxuICAgU2VlIHshaXRlcn0gYmVsb3cgZm9yIGEgZGV0YWlsZWQgdXNhZ2UgZXhhbXBsZS5cbiopXG5sZXQgY2hlY2tfc2FtZV9sZW5ndGggZiBhIH5sZW5ndGggPVxuICBsZXQgbGVuZ3RoX2EgPSBhLmxlbmd0aCBpblxuICBpZiBsZW5ndGggPD4gbGVuZ3RoX2EgdGhlblxuICAgIEVycm9yLmxlbmd0aF9jaGFuZ2VfZHVyaW5nX2l0ZXJhdGlvbiBmXG4gICAgICB+ZXhwZWN0ZWQ6bGVuZ3RoIH5vYnNlcnZlZDpsZW5ndGhfYVxuXG4oKiogQ2FyZWZ1bCB1bnNhZmUgYWNjZXNzLiAqKVxuXG4oKiBQb3N0Y29uZGl0aW9uIG9uIG5vbi1leGNlcHRpb25hbCByZXR1cm46XG4gICBbbGVuZ3RoIDw9IEFycmF5Lmxlbmd0aCBhcnJdICopXG5sZXRbQGlubGluZSBhbHdheXNdIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyID1cbiAgbGV0IGNhcGFjaXR5ID0gQXJyYXkubGVuZ3RoIGFyciBpblxuICBpZiBsZW5ndGggPiBjYXBhY2l0eSB0aGVuXG4gICAgRXJyb3IuaW52YWxpZF9sZW5ndGggfmxlbmd0aCB+Y2FwYWNpdHlcblxuKCogUHJlY29uZGl0aW9uOiBbMCA8PSBpIDwgbGVuZ3RoIDw9IEFycmF5Lmxlbmd0aCBhcnJdXG5cbiAgIFRoaXMgcHJlY29uZGl0aW9uIGlzIHR5cGljYWxseSBndWFyYW50ZWVkIGJ5IGtub3dpbmdcbiAgIFswIDw9IGkgPCBsZW5ndGhdIGFuZCBjYWxsaW5nIFtjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoIGFycl0uKilcbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCA9XG4gIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgYXJyIGkgd2l0aFxuICB8IEVtcHR5IC0+IEVycm9yLm1pc3NpbmdfZWxlbWVudCB+aSB+bGVuZ3RoXG4gIHwgRWxlbSB7dn0gLT4gdlxuXG5cbigqKiB7MTpkeW5hcnJheXMgRHluYW1pYyBhcnJheXN9ICopXG5cbmxldCBjcmVhdGUgKCkgPSB7XG4gIGxlbmd0aCA9IDA7XG4gIGFyciA9IFt8IHxdO1xufVxuXG5sZXQgbWFrZSBuIHggPVxuICBpZiBuIDwgMCB0aGVuIEVycm9yLm5lZ2F0aXZlX2xlbmd0aF9yZXF1ZXN0ZWQgXCJtYWtlXCIgbjtcbiAge1xuICAgIGxlbmd0aCA9IG47XG4gICAgYXJyID0gQXJyYXkuaW5pdCBuIChmdW4gXyAtPiBFbGVtIHt2ID0geH0pO1xuICB9XG5cbmxldCBpbml0IG4gZiA9XG4gIGlmIG4gPCAwIHRoZW4gRXJyb3IubmVnYXRpdmVfbGVuZ3RoX3JlcXVlc3RlZCBcImluaXRcIiBuO1xuICB7XG4gICAgbGVuZ3RoID0gbjtcbiAgICBhcnIgPSBBcnJheS5pbml0IG4gKGZ1biBpIC0+IEVsZW0ge3YgPSBmIGl9KTtcbiAgfVxuXG5sZXQgZ2V0IGEgaSA9XG4gICgqIFRoaXMgaW1wbGVtZW50YXRpb24gd2lsbCBwcm9wYWdhdGUgYW4gW0ludmFsaWRfYXJndW1lbnRdIGV4Y2VwdGlvblxuICAgICBmcm9tIGFycmF5IGxvb2t1cCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHRoZSBiYWNraW5nIGFycmF5LFxuICAgICBpbnN0ZWFkIG9mIHVzaW5nIG91ciBvd24gW0Vycm9yLmluZGV4X291dF9vZl9ib3VuZHNdLiBUaGlzIGlzXG4gICAgIGFsbG93ZWQgYnkgb3VyIHNwZWNpZmljYXRpb24sIGFuZCBtb3JlIGVmZmljaWVudCAtLSBubyBuZWVkIHRvXG4gICAgIGNoZWNrIHRoYXQgW2xlbmd0aCBhIDw9IGNhcGFjaXR5IGFdIGluIHRoZSBmYXN0IHBhdGguICopXG4gIG1hdGNoIGEuYXJyLihpKSB3aXRoXG4gIHwgRWxlbSBzIC0+IHMudlxuICB8IEVtcHR5IC0+XG4gICAgICBFcnJvci51bmV4cGVjdGVkX2VtcHR5X2VsZW1lbnQgXCJnZXRcIiB+aSB+bGVuZ3RoOmEubGVuZ3RoXG5cbmxldCBzZXQgYSBpIHggPVxuICAoKiBTZWUgeyFnZXR9IGNvbW1lbnQgb24gdGhlIHVzZSBvZiBjaGVja2VkIGFycmF5XG4gICAgIGFjY2VzcyB3aXRob3V0IG91ciBvd24gYm91bmQgY2hlY2tpbmcuICopXG4gIG1hdGNoIGEuYXJyLihpKSB3aXRoXG4gIHwgRWxlbSBzIC0+IHMudiA8LSB4XG4gIHwgRW1wdHkgLT5cbiAgICAgIEVycm9yLnVuZXhwZWN0ZWRfZW1wdHlfZWxlbWVudCBcInNldFwiIH5pIH5sZW5ndGg6YS5sZW5ndGhcblxubGV0IGxlbmd0aCBhID0gYS5sZW5ndGhcblxubGV0IGlzX2VtcHR5IGEgPSAoYS5sZW5ndGggPSAwKVxuXG5sZXQgY29weSB7bGVuZ3RoOyBhcnJ9ID1cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gICgqIHVzZSBbbGVuZ3RoXSBhcyB0aGUgbmV3IGNhcGFjaXR5IHRvIG1ha2VcbiAgICAgdGhpcyBhbiBPKGxlbmd0aCkgb3BlcmF0aW9uLiAqKVxuICB7XG4gICAgbGVuZ3RoO1xuICAgIGFyciA9IEFycmF5LmluaXQgbGVuZ3RoIChmdW4gaSAtPlxuICAgICAgbGV0IHYgPSB1bnNhZmVfZ2V0IGFyciB+aSB+bGVuZ3RoIGluXG4gICAgICBFbGVtIHt2fVxuICAgICk7XG4gIH1cblxubGV0IGdldF9sYXN0IGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gICgqIFdlIGtub3cgW2xlbmd0aCA8PSBjYXBhY2l0eSBhXS4gKilcbiAgaWYgbGVuZ3RoID0gMCB0aGVuIEVycm9yLmVtcHR5X2R5bmFycmF5IFwiZ2V0X2xhc3RcIjtcbiAgKCogV2Uga25vdyBbbGVuZ3RoID4gMF0uICopXG4gIHVuc2FmZV9nZXQgYXJyIH5pOihsZW5ndGggLSAxKSB+bGVuZ3RoXG5cbmxldCBmaW5kX2xhc3QgYSA9XG4gIGxldCB7YXJyOyBsZW5ndGh9ID0gYSBpblxuICBjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoIGFycjtcbiAgKCogV2Uga25vdyBbbGVuZ3RoIDw9IGNhcGFjaXR5IGFdLiAqKVxuICBpZiBsZW5ndGggPSAwIHRoZW4gTm9uZVxuICBlbHNlXG4gICAgKCogV2Uga25vdyBbbGVuZ3RoID4gMF0uICopXG4gICAgU29tZSAodW5zYWZlX2dldCBhcnIgfmk6KGxlbmd0aCAtIDEpIH5sZW5ndGgpXG5cbigqKiB7MTpyZW1vdmluZyBSZW1vdmluZyBlbGVtZW50c30gKilcblxubGV0IHBvcF9sYXN0IGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gICgqIFdlIGtub3cgW2xlbmd0aCA8PSBjYXBhY2l0eSBhXS4gKilcbiAgaWYgbGVuZ3RoID0gMCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgbGV0IGxhc3QgPSBsZW5ndGggLSAxIGluXG4gICgqIFdlIGtub3cgW2xlbmd0aCA+IDBdIHNvIFtsYXN0ID49IDBdLiAqKVxuICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IGFyciBsYXN0IHdpdGhcbiAgfCBFbXB0eSAtPlxuICAgICAgRXJyb3IubWlzc2luZ19lbGVtZW50IH5pOmxhc3Qgfmxlbmd0aFxuICB8IEVsZW0gcyAtPlxuICAgICAgQXJyYXkudW5zYWZlX3NldCBhcnIgbGFzdCBFbXB0eTtcbiAgICAgIGEubGVuZ3RoIDwtIGxhc3Q7XG4gICAgICBzLnZcblxubGV0IHBvcF9sYXN0X29wdCBhID1cbiAgbWF0Y2ggcG9wX2xhc3QgYSB3aXRoXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBOb25lXG4gIHwgeCAtPiBTb21lIHhcblxubGV0IHJlbW92ZV9sYXN0IGEgPVxuICBsZXQgbGFzdCA9IGxlbmd0aCBhIC0gMSBpblxuICBpZiBsYXN0ID49IDAgdGhlbiBiZWdpblxuICAgIGEubGVuZ3RoIDwtIGxhc3Q7XG4gICAgYS5hcnIuKGxhc3QpIDwtIEVtcHR5O1xuICBlbmRcblxubGV0IHRydW5jYXRlIGEgbiA9XG4gIGlmIG4gPCAwIHRoZW4gRXJyb3IubmVnYXRpdmVfbGVuZ3RoX3JlcXVlc3RlZCBcInRydW5jYXRlXCIgbjtcbiAgbGV0IHthcnI7IGxlbmd0aH0gPSBhIGluXG4gIGlmIGxlbmd0aCA8PSBuIHRoZW4gKClcbiAgZWxzZSBiZWdpblxuICAgIGEubGVuZ3RoIDwtIG47XG4gICAgQXJyYXkuZmlsbCBhcnIgbiAobGVuZ3RoIC0gbikgRW1wdHk7XG4gIGVuZFxuXG5sZXQgY2xlYXIgYSA9IHRydW5jYXRlIGEgMFxuXG5cbigqKiB7MTpjYXBhY2l0eSBCYWNraW5nIGFycmF5IGFuZCBjYXBhY2l0eX0gKilcblxubGV0IGNhcGFjaXR5IGEgPSBBcnJheS5sZW5ndGggYS5hcnJcblxubGV0IG5leHRfY2FwYWNpdHkgbiA9XG4gIGxldCBuJyA9XG4gICAgKCogRm9yIGxhcmdlIHZhbHVlcyBvZiBuLCB3ZSB1c2UgMS41IGFzIG91ciBncm93dGggZmFjdG9yLlxuXG4gICAgICAgRm9yIHNtYWxsZXIgdmFsdWVzIG9mIG4sIHdlIGdyb3cgbW9yZSBhZ2dyZXNzaXZlbHkgdG8gYXZvaWRcbiAgICAgICByZWFsbG9jYXRpbmcgdG9vIG11Y2ggd2hlbiBhY2N1bXVsYXRpbmcgZWxlbWVudHMgaW50byBhbiBlbXB0eVxuICAgICAgIGFycmF5LlxuXG4gICAgICAgVGhlIGNvbnN0YW50cyBcIjUxMiB3b3Jkc1wiIGFuZCBcIjggd29yZHNcIiBiZWxvdyBhcmUgdGFrZW4gZnJvbVxuICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZvbGx5L2Jsb2IvXG4gICAgICAgICAgIGMwNmMwZjQxZDkxZGFmMWE2YTVmM2ZjMWNkNDY1MzAyYWMyNjA0NTkvZm9sbHkvRkJWZWN0b3IuaCNMMTEyOC1MMTE1N1xuICAgICopXG4gICAgaWYgbiA8PSA1MTIgdGhlbiBuICogMlxuICAgIGVsc2UgbiArIG4gLyAyXG4gIGluXG4gICgqIGp1bXAgZGlyZWN0bHkgZnJvbSAwIHRvIDggKilcbiAgbWluIChtYXggOCBuJykgU3lzLm1heF9hcnJheV9sZW5ndGhcblxubGV0IGVuc3VyZV9jYXBhY2l0eSBhIGNhcGFjaXR5X3JlcXVlc3QgPVxuICBsZXQgYXJyID0gYS5hcnIgaW5cbiAgbGV0IGN1cl9jYXBhY2l0eSA9IEFycmF5Lmxlbmd0aCBhcnIgaW5cbiAgaWYgY2FwYWNpdHlfcmVxdWVzdCA8IDAgdGhlblxuICAgIEVycm9yLm5lZ2F0aXZlX2NhcGFjaXR5X3JlcXVlc3RlZCBcImVuc3VyZV9jYXBhY2l0eVwiIGNhcGFjaXR5X3JlcXVlc3RcbiAgZWxzZSBpZiBjdXJfY2FwYWNpdHkgPj0gY2FwYWNpdHlfcmVxdWVzdCB0aGVuXG4gICAgKCogVGhpcyBpcyB0aGUgZmFzdCBwYXRoLCB0aGUgY29kZSB1cCB0byBoZXJlIG11c3QgZG8gYXMgbGl0dGxlIGFzXG4gICAgICAgcG9zc2libGUuIChUaGlzIGlzIHdoeSB3ZSBkb24ndCB1c2UgW2xldCB7YXJyOyBsZW5ndGh9ID0gYV0gYXNcbiAgICAgICB1c3VhbCwgdGhlIGxlbmd0aCBpcyBub3QgbmVlZGVkIGluIHRoZSBmYXN0IHBhdGguKSopXG4gICAgKClcbiAgZWxzZSBiZWdpblxuICAgIGlmIGNhcGFjaXR5X3JlcXVlc3QgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuXG4gICAgICBFcnJvci5yZXF1ZXN0ZWRfbGVuZ3RoX291dF9vZl9ib3VuZHMgXCJlbnN1cmVfY2FwYWNpdHlcIiBjYXBhY2l0eV9yZXF1ZXN0O1xuICAgIGxldCBuZXdfY2FwYWNpdHkgPVxuICAgICAgKCogV2UgdXNlIGVpdGhlciB0aGUgbmV4dCBleHBvbmVudGlhbC1ncm93dGggc3RyYXRlZ3ksXG4gICAgICAgICBvciB0aGUgcmVxdWVzdGVkIHN0cmF0ZWd5LCB3aGljaGV2ZXIgaXMgYmlnZ2VyLlxuXG4gICAgICAgICBDb21wYXJlZCB0byBvbmx5IHVzaW5nIHRoZSBleHBvbmVudGlhbC1ncm93dGggc3RyYXRlZ3ksIHRoaXNcbiAgICAgICAgIGxldHMgdXMgdXNlIGxlc3MgbWVtb3J5IGJ5IGF2b2lkaW5nIGFueSBvdmVyc2hvb3Qgd2hlbmV2ZXJcbiAgICAgICAgIHRoZSBjYXBhY2l0eSByZXF1ZXN0IGlzIG5vdGljZWFibHkgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnRcbiAgICAgICAgIGNhcGFjaXR5LlxuXG4gICAgICAgICBDb21wYXJlZCB0byBvbmx5IHVzaW5nIHRoZSByZXF1ZXN0ZWQgY2FwYWNpdHksIHRoaXMgYXZvaWRzXG4gICAgICAgICBsb3NpbmcgdGhlIGFtb3J0aXplZCBndWFyYW50ZWU6IHdlIGFsbG9jYXRlZCBcImV4cG9uZW50aWFsbHlcbiAgICAgICAgIG9yIG1vcmVcIiwgc28gdGhlIGFtb3J0aXphdGlvbiBob2xkcy4gSW4gcGFydGljdWxhciwgbm90aWNlXG4gICAgICAgICB0aGF0IHJlcGVhdGVkIGNhbGxzIHRvIFtlbnN1cmVfY2FwYWNpdHkgYSAobGVuZ3RoIGEgKyAxKV1cbiAgICAgICAgIHdpbGwgaGF2ZSBhbW9ydGl6ZWQtbGluZWFyIHJhdGhlciB0aGFuIHF1YWRyYXRpYyBjb21wbGV4aXR5LlxuICAgICAgKilcbiAgICAgIG1heCAobmV4dF9jYXBhY2l0eSBjdXJfY2FwYWNpdHkpIGNhcGFjaXR5X3JlcXVlc3QgaW5cbiAgICBsZXQgbmV3X2FyciA9IEFycmF5Lm1ha2UgbmV3X2NhcGFjaXR5IEVtcHR5IGluXG4gICAgQXJyYXkuYmxpdCBhcnIgMCBuZXdfYXJyIDAgYS5sZW5ndGg7XG4gICAgYS5hcnIgPC0gbmV3X2FycjtcbiAgICAoKiBwb3N0Y29uZGl0aW9uOiAqKVxuICAgIGFzc2VydCAoMCA8PSBjYXBhY2l0eV9yZXF1ZXN0KTtcbiAgICBhc3NlcnQgKGNhcGFjaXR5X3JlcXVlc3QgPD0gQXJyYXkubGVuZ3RoIG5ld19hcnIpO1xuICBlbmRcblxubGV0IGVuc3VyZV9leHRyYV9jYXBhY2l0eSBhIGV4dHJhX2NhcGFjaXR5X3JlcXVlc3QgPVxuICBlbnN1cmVfY2FwYWNpdHkgYSAobGVuZ3RoIGEgKyBleHRyYV9jYXBhY2l0eV9yZXF1ZXN0KVxuXG5sZXQgZml0X2NhcGFjaXR5IGEgPVxuICBpZiBjYXBhY2l0eSBhID0gYS5sZW5ndGhcbiAgdGhlbiAoKVxuICBlbHNlIGEuYXJyIDwtIEFycmF5LnN1YiBhLmFyciAwIGEubGVuZ3RoXG5cbmxldCBzZXRfY2FwYWNpdHkgYSBuID1cbiAgaWYgbiA8IDAgdGhlblxuICAgIEVycm9yLm5lZ2F0aXZlX2NhcGFjaXR5X3JlcXVlc3RlZCBcInNldF9jYXBhY2l0eVwiIG47XG4gIGxldCBhcnIgPSBhLmFyciBpblxuICBsZXQgY3VyX2NhcGFjaXR5ID0gQXJyYXkubGVuZ3RoIGFyciBpblxuICBpZiBuIDwgY3VyX2NhcGFjaXR5IHRoZW4gYmVnaW5cbiAgICBhLmxlbmd0aCA8LSBtaW4gYS5sZW5ndGggbjtcbiAgICBhLmFyciA8LSBBcnJheS5zdWIgYXJyIDAgbjtcbiAgZW5kXG4gIGVsc2UgaWYgbiA+IGN1cl9jYXBhY2l0eSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19hcnIgPSBBcnJheS5tYWtlIG4gRW1wdHkgaW5cbiAgICBBcnJheS5ibGl0IGFyciAwIG5ld19hcnIgMCBhLmxlbmd0aDtcbiAgICBhLmFyciA8LSBuZXdfYXJyO1xuICBlbmRcblxubGV0IHJlc2V0IGEgPVxuICBhLmxlbmd0aCA8LSAwO1xuICBhLmFyciA8LSBbfHxdXG5cbigqKiB7MTphZGRpbmcgQWRkaW5nIGVsZW1lbnRzfSAqKVxuXG4oKiBXZSBjaG9zZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBbYWRkX2xhc3QgYSB4XSB0aGF0IGJlaGF2ZXMgY29ycmVjdGx5XG4gICBpbiBwcmVzZW5jZSBvZiBhc3luY2hyb25vdXMgLyByZS1lbnRyYW50IGNvZGUgZXhlY3V0aW9uIGFyb3VuZFxuICAgYWxsb2NhdGlvbnMgYW5kIHBvbGwgcG9pbnRzOiBpZiBhbm90aGVyIHRocmVhZCBvciBhIGNhbGxiYWNrIGdldHNcbiAgIGV4ZWN1dGVkIG9uIGFsbG9jYXRpb24sIHdlIGFkZCB0aGUgZWxlbWVudCBhdCB0aGUgbmV3IGVuZCBvZiB0aGVcbiAgIGR5bmFtaWMgYXJyYXkuXG5cbiAgIChXZSBkbyBub3QgZ2l2ZSB0aGUgc2FtZSBndWFyYW50ZWVzIGluIHByZXNlbmNlIG9mIGNvbmN1cnJlbnRcbiAgIHBhcmFsbGVsIHVwZGF0ZXMsIHdoaWNoIGFyZSBtdWNoIG1vcmUgZXhwZW5zaXZlIHRvIHByb3RlY3RcbiAgIGFnYWluc3QuKVxuKilcblxuKCogW2FkZF9sYXN0X2lmX3Jvb20gYSBlbGVtXSBvbmx5IHdyaXRlcyB0aGUgc2xvdCBpZiB0aGVyZSBpcyByb29tLCBhbmRcbiAgIHJldHVybnMgW2ZhbHNlXSBvdGhlcndpc2UuICopXG5sZXRbQGlubGluZV0gYWRkX2xhc3RfaWZfcm9vbSBhIGVsZW0gPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgKCogd2Uga25vdyBbMCA8PSBsZW5ndGhdICopXG4gIGlmIGxlbmd0aCA+PSBBcnJheS5sZW5ndGggYXJyIHRoZW4gZmFsc2VcbiAgZWxzZSBiZWdpblxuICAgICgqIHdlIGtub3cgWzAgPD0gbGVuZ3RoIDwgQXJyYXkubGVuZ3RoIGFycl0gKilcbiAgICBhLmxlbmd0aCA8LSBsZW5ndGggKyAxO1xuICAgIEFycmF5LnVuc2FmZV9zZXQgYXJyIGxlbmd0aCBlbGVtO1xuICAgIHRydWVcbiAgZW5kXG5cbmxldCBhZGRfbGFzdCBhIHggPVxuICBsZXQgZWxlbSA9IEVsZW0ge3YgPSB4fSBpblxuICBpZiBhZGRfbGFzdF9pZl9yb29tIGEgZWxlbSB0aGVuICgpXG4gIGVsc2UgYmVnaW5cbiAgICAoKiBzbG93IHBhdGggKilcbiAgICBsZXQgcmVjIGdyb3dfYW5kX2FkZCBhIGVsZW0gPVxuICAgICAgZW5zdXJlX2V4dHJhX2NhcGFjaXR5IGEgMTtcbiAgICAgIGlmIG5vdCAoYWRkX2xhc3RfaWZfcm9vbSBhIGVsZW0pXG4gICAgICB0aGVuIGdyb3dfYW5kX2FkZCBhIGVsZW1cbiAgICBpbiBncm93X2FuZF9hZGQgYSBlbGVtXG4gIGVuZFxuXG5sZXQgcmVjIGFwcGVuZF9saXN0IGEgbGkgPVxuICBtYXRjaCBsaSB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCB4IDo6IHhzIC0+IGFkZF9sYXN0IGEgeDsgYXBwZW5kX2xpc3QgYSB4c1xuXG5sZXQgYXBwZW5kX2l0ZXIgYSBpdGVyIGIgPVxuICBpdGVyIChmdW4geCAtPiBhZGRfbGFzdCBhIHgpIGJcblxubGV0IGFwcGVuZF9zZXEgYSBzZXEgPVxuICBTZXEuaXRlciAoZnVuIHggLT4gYWRkX2xhc3QgYSB4KSBzZXFcblxuKCogYXBwZW5kX2FycmF5OiBzYW1lIFsuLi5faWZfcm9vbV0gYW5kIGxvb3AgbG9naWMgYXMgW2FkZF9sYXN0XS4gKilcblxubGV0IGFwcGVuZF9hcnJheV9pZl9yb29tIGEgYiA9XG4gIGxldCB7YXJyOyBsZW5ndGggPSBsZW5ndGhfYX0gPSBhIGluXG4gIGxldCBsZW5ndGhfYiA9IEFycmF5Lmxlbmd0aCBiIGluXG4gIGlmIGxlbmd0aF9hICsgbGVuZ3RoX2IgPiBBcnJheS5sZW5ndGggYXJyIHRoZW4gZmFsc2VcbiAgZWxzZSBiZWdpblxuICAgIGEubGVuZ3RoIDwtIGxlbmd0aF9hICsgbGVuZ3RoX2I7XG4gICAgKCogTm90ZTogd2UgaW50ZW50aW9uYWxseSB1cGRhdGUgdGhlIGxlbmd0aCAqYmVmb3JlKiBmaWxsaW5nIHRoZVxuICAgICAgIGVsZW1lbnRzLiBUaGlzIFwicmVzZXJ2ZSBiZWZvcmUgZmlsbFwiIGFwcHJvYWNoIHByb3ZpZGVzIGJldHRlclxuICAgICAgIGJlaGF2aW9yIHRoYW4gXCJmaWxsIHRoZW4gbm90aWZ5XCIgaW4gcHJlc2VuY2Ugb2YgcmVlbnRyYW50XG4gICAgICAgbW9kaWZpY2F0aW9ucyAod2hpY2ggbWF5IG9jY3VyIGJlbG93LCBvbiBhIHBvbGwgcG9pbnQgaW4gdGhlIGxvb3Agb3JcbiAgICAgICB0aGUgW0VsZW1dIGFsbG9jYXRpb24pOlxuXG4gICAgICAgLSBJZiBzb21lIGNvZGUgYXN5bmNocm9ub3VzbHkgYWRkcyBuZXcgZWxlbWVudHMgYWZ0ZXIgdGhpc1xuICAgICAgICAgbGVuZ3RoIHVwZGF0ZSwgdGhleSB3aWxsIGdvIGFmdGVyIHRoZSBzcGFjZSB3ZSBqdXN0IHJlc2VydmVkLFxuICAgICAgICAgYW5kIGluIHBhcnRpY3VsYXIgbm8gYWRkaXRpb24gd2lsbCBiZSBsb3N0LiBJZiBpbnN0ZWFkIHdlXG4gICAgICAgICB1cGRhdGVkIHRoZSBsZW5ndGggYWZ0ZXIgdGhlIGxvb3AsIGFueSBhc3luY2hyb25vdXMgYWRkaXRpb25cbiAgICAgICAgIGR1cmluZyB0aGUgbG9vcCBjb3VsZCBiZSBlcmFzZWQgb3IgZXJhc2Ugb25lIG9mIG91ciBhZGRpdGlvbnMsXG4gICAgICAgICBzaWxlbnRseSwgd2l0aG91dCB3YXJuaW5nIHRoZSB1c2VyLlxuXG4gICAgICAgLSBJZiBzb21lIGNvZGUgYXN5bmNocm9ub3VzbHkgaXRlcmF0ZXMgb24gdGhlIGR5bmFycmF5LCBvclxuICAgICAgICAgcmVtb3ZlcyBlbGVtZW50cywgb3Igb3RoZXJ3aXNlIHRyaWVzIHRvIGFjY2VzcyB0aGVcbiAgICAgICAgIHJlc2VydmVkLWJ1dC1ub3QteWV0LWZpbGxlZCBzcGFjZSwgaXQgd2lsbCBnZXQgYSBjbGVhbiBcIm1pc3NpbmdcbiAgICAgICAgIGVsZW1lbnRcIiBlcnJvci4gVGhpcyBpcyB3b3JzZSB0aGFuIHdpdGggdGhlIGZpbGwtdGhlbi1ub3RpZnlcbiAgICAgICAgIGFwcHJvYWNoIHdoZXJlIHRoZSBuZXcgZWxlbWVudHMgd291bGQgb25seSBiZWNvbWUgdmlzaWJsZVxuICAgICAgICAgKHRvIGl0ZXJhdG9ycywgZm9yIHJlbW92YWwsIGV0Yy4pIGFsbHRvZ2V0aGVyIGF0IHRoZSBlbmQgb2ZcbiAgICAgICAgIGxvb3AuXG5cbiAgICAgICBUbyBzdW1tYXJpc2UsIFwicmVzZXJ2ZSBiZWZvcmUgZmlsbFwiIGlzIGJldHRlciBvbiBhZGQtYWRkIHJhY2VzLFxuICAgICAgIGFuZCBcImZpbGwgdGhlbiBub3RpZnlcIiBpcyBiZXR0ZXIgb24gYWRkLXJlbW92ZSBvciBhZGQtaXRlcmF0ZVxuICAgICAgIHJhY2VzLiBCdXQgdGhlIGtleSBkaWZmZXJlbmNlIGlzIHRoZSBmYWlsdXJlIG1vZGU6XG4gICAgICAgcmVzZXJ2ZS1iZWZvcmUgZmFpbHMgb24gYWRkLXJlbW92ZSBvciBhZGQtaXRlcmF0ZSByYWNlcyB3aXRoXG4gICAgICAgYSBjbGVhbiBlcnJvciwgd2hpbGUgbm90aWZ5LWFmdGVyIGZhaWxzIG9uIGFkZC1hZGQgcmFjZXMgd2l0aFxuICAgICAgIHNpbGVudGx5IGRpc2FwcGVhcmluZyBkYXRhLiAqKVxuICAgIGZvciBpID0gMCB0byBsZW5ndGhfYiAtIDEgZG9cbiAgICAgIGxldCB4ID0gQXJyYXkudW5zYWZlX2dldCBiIGkgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQgYXJyIChsZW5ndGhfYSArIGkpIChFbGVtIHt2ID0geH0pXG4gICAgZG9uZTtcbiAgICB0cnVlXG4gIGVuZFxuXG5sZXQgYXBwZW5kX2FycmF5IGEgYiA9XG4gIGlmIGFwcGVuZF9hcnJheV9pZl9yb29tIGEgYiB0aGVuICgpXG4gIGVsc2UgYmVnaW5cbiAgICAoKiBzbG93IHBhdGggKilcbiAgICBsZXQgcmVjIGdyb3dfYW5kX2FwcGVuZCBhIGIgPVxuICAgICAgZW5zdXJlX2V4dHJhX2NhcGFjaXR5IGEgKEFycmF5Lmxlbmd0aCBiKTtcbiAgICAgIGlmIG5vdCAoYXBwZW5kX2FycmF5X2lmX3Jvb20gYSBiKVxuICAgICAgdGhlbiBncm93X2FuZF9hcHBlbmQgYSBiXG4gICAgaW4gZ3Jvd19hbmRfYXBwZW5kIGEgYiAgZW5kXG5cbigqIGFwcGVuZDogc2FtZSBbLi4uX2lmX3Jvb21dIGFuZCBsb29wIGxvZ2ljIGFzIFthZGRfbGFzdF0sXG4gICBzYW1lIHJlc2VydmUtYmVmb3JlLWZpbGwgbG9naWMgYXMgW2FwcGVuZF9hcnJheV0uICopXG5cbigqIEl0IGlzIGEgcHJvZ3JhbW1pbmcgZXJyb3IgdG8gbXV0YXRlIHRoZSBsZW5ndGggb2YgW2JdIGR1cmluZyBhIGNhbGxcbiAgIHRvIFthcHBlbmQgYSBiXS4gVG8gZGV0ZWN0IHRoaXMgbWlzdGFrZSB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBsZW5ndGhcbiAgIG9mIFtiXSB0aHJvdWdob3V0IHRoZSBjb21wdXRhdGlvbiBhbmQgY2hlY2sgaXQgdGhhdCBkb2VzIG5vdFxuICAgY2hhbmdlLlxuKilcbmxldCBhcHBlbmRfaWZfcm9vbSBhIGIgfmxlbmd0aF9iID1cbiAgbGV0IHthcnIgPSBhcnJfYTsgbGVuZ3RoID0gbGVuZ3RoX2F9ID0gYSBpblxuICBpZiBsZW5ndGhfYSArIGxlbmd0aF9iID4gQXJyYXkubGVuZ3RoIGFycl9hIHRoZW4gZmFsc2VcbiAgZWxzZSBiZWdpblxuICAgIGEubGVuZ3RoIDwtIGxlbmd0aF9hICsgbGVuZ3RoX2I7XG4gICAgbGV0IGFycl9iID0gYi5hcnIgaW5cbiAgICBjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoX2IgYXJyX2I7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aF9iIC0gMSBkb1xuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGFycl9iIH5pIH5sZW5ndGg6bGVuZ3RoX2IgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQgYXJyX2EgKGxlbmd0aF9hICsgaSkgKEVsZW0ge3YgPSB4fSlcbiAgICBkb25lO1xuICAgIGNoZWNrX3NhbWVfbGVuZ3RoIFwiYXBwZW5kXCIgYiB+bGVuZ3RoOmxlbmd0aF9iO1xuICAgIHRydWVcbiAgZW5kXG5cbmxldCBhcHBlbmQgYSBiID1cbiAgbGV0IGxlbmd0aF9iID0gbGVuZ3RoIGIgaW5cbiAgaWYgYXBwZW5kX2lmX3Jvb20gYSBiIH5sZW5ndGhfYiB0aGVuICgpXG4gIGVsc2UgYmVnaW5cbiAgICAoKiBzbG93IHBhdGggKilcbiAgICBsZXQgcmVjIGdyb3dfYW5kX2FwcGVuZCBhIGIgfmxlbmd0aF9iID1cbiAgICAgIGVuc3VyZV9leHRyYV9jYXBhY2l0eSBhIGxlbmd0aF9iO1xuICAgICAgKCogRWxpZGluZyB0aGUgW2NoZWNrX3NhbWVfbGVuZ3RoXSBjYWxsIGJlbG93IHdvdWxkIGJlIHdyb25nIGluXG4gICAgICAgICB0aGUgY2FzZSB3aGVyZSBbYV0gYW5kIFtiXSBhcmUgYWxpYXNlcyBvZiBlYWNoIG90aGVyLCB3ZVxuICAgICAgICAgd291bGQgZ2V0IGludG8gYW4gaW5maW5pdGUgbG9vcCBpbnN0ZWFkIG9mIGZhaWxpbmcuXG5cbiAgICAgICAgIFdlIGNvdWxkIHB1c2ggdGhlIGNhbGwgdG8gW2FwcGVuZF9pZl9yb29tXSBpdHNlbGYsIGJ1dCB3ZVxuICAgICAgICAgcHJlZmVyIHRvIGtlZXAgaXQgaW4gdGhlIHNsb3cgcGF0aC4gICopXG4gICAgICBjaGVja19zYW1lX2xlbmd0aCBcImFwcGVuZFwiIGIgfmxlbmd0aDpsZW5ndGhfYjtcbiAgICAgIGlmIG5vdCAoYXBwZW5kX2lmX3Jvb20gYSBiIH5sZW5ndGhfYilcbiAgICAgIHRoZW4gZ3Jvd19hbmRfYXBwZW5kIGEgYiB+bGVuZ3RoX2JcbiAgICBpbiBncm93X2FuZF9hcHBlbmQgYSBiIH5sZW5ndGhfYlxuICBlbmRcblxuXG5cbigqKiB7MTppdGVyYXRpb24gSXRlcmF0aW9ufSAqKVxuXG4oKiBUaGUgaW1wbGVtZW50YXRpb24gY2hvaWNlIHRoYXQgd2UgbWFkZSBmb3IgaXRlcmF0b3JzIGlzIHRoZSBvbmVcbiAgIHRoYXQgbWF4aW1pemVzIGVmZmljaWVuY3kgYnkgYXZvaWRpbmcgcmVwZWF0ZWQgYm91bmQgY2hlY2tpbmc6IHdlXG4gICBjaGVjayB0aGUgbGVuZ3RoIG9mIHRoZSBkeW5hbWljIGFycmF5IG9uY2UgYXQgdGhlIGJlZ2lubmluZywgYW5kXG4gICB0aGVuIG9ubHkgb3BlcmF0ZSBvbiB0aGF0IHBvcnRpb24gb2YgdGhlIGR5bmFycmF5LCBpZ25vcmluZ1xuICAgZWxlbWVudHMgYWRkZWQgaW4gdGhlIG1lYW50aW1lLlxuXG4gICBUaGUgc3BlY2lmaWNhdGlvbiBzdGF0ZXMgdGhhdCBpdCBpcyBhIHByb2dyYW1taW5nIGVycm9yIHRvIG11dGF0ZVxuICAgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgZHVyaW5nIGl0ZXJhdGlvbi4gV2UgY2hlY2sgZm9yIHRoaXMgYW5kXG4gICByYWlzZSBhbiBlcnJvciBvbiBzaXplIGNoYW5nZS5cbiAgIE5vdGUgdGhhdCB3ZSBtYXkgc3RpbGwgbWlzcyBzb21lIHRyYW5zaWVudCBzdGF0ZSBjaGFuZ2VzIHRoYXQgY2FuY2VsXG4gICBlYWNoIG90aGVyIGFuZCBsZWF2ZSB0aGUgbGVuZ3RoIHVuY2hhbmdlZCBhdCB0aGUgbmV4dCBjaGVjay5cbiopXG5cbmxldCBpdGVyXyBmIGsgYSA9XG4gIGxldCB7YXJyOyBsZW5ndGh9ID0gYSBpblxuICAoKiBbY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnJdIGlzIHVzZWQgZm9yIG1lbW9yeSBzYWZldHksIGl0XG4gICAgIGd1YXJhbnRlZXMgdGhhdCB0aGUgYmFja2luZyBhcnJheSBoYXMgY2FwYWNpdHkgYXQgbGVhc3QgW2xlbmd0aF0sXG4gICAgIGFsbG93aW5nIHVuc2FmZSBhcnJheSBhY2Nlc3MuXG5cbiAgICAgW2NoZWNrX3NhbWVfbGVuZ3RoXSBpcyB1c2VkIGZvciBjb3JyZWN0bmVzcywgaXQgbGV0cyB0aGUgZnVuY3Rpb25cbiAgICAgZmFpbCBtb3JlIG9mdGVuIGlmIHdlIGRpc2NvdmVyIHRoZSBwcm9ncmFtbWluZyBlcnJvciBvZiBtdXRhdGluZ1xuICAgICB0aGUgbGVuZ3RoIGR1cmluZyBpdGVyYXRpb24uXG5cbiAgICAgV2UgY291bGQsIG5haXZlbHksIGNhbGwgW2NoZWNrX3NhbWVfbGVuZ3RoXSBhdCBlYWNoIGl0ZXJhdGlvbiBvZlxuICAgICB0aGUgbG9vcCAoYmVmb3JlIG9yIGFmdGVyLCBvciBib3RoKS4gSG93ZXZlciwgbm90aWNlIHRoYXQgdGhpcyBpc1xuICAgICBub3QgbmVjZXNzYXJ5IHRvIGRldGVjdCB0aGUgcmVtb3ZhbCBvZiBlbGVtZW50cyBmcm9tIFthXTogaWZcbiAgICAgZWxlbWVudHMgaGF2ZSBiZWVuIHJlbW92ZWQgYnkgdGhlIHRpbWUgdGhlIFtmb3JdIGxvb3AgcmVhY2hlc1xuICAgICB0aGVtLCB0aGVuIFt1bnNhZmVfZ2V0XSB3aWxsIGl0c2VsZiBmYWlsIHdpdGggYW4gW0ludmFsaWRfYXJndW1lbnRdXG4gICAgIGV4Y2VwdGlvbi4gV2Ugb25seSBuZWVkIHRvIGRldGVjdCB0aGUgYWRkaXRpb24gb2YgbmV3IGVsZW1lbnRzIHRvXG4gICAgIFthXSBkdXJpbmcgaXRlcmF0aW9uLCBhbmQgZm9yIHRoaXMgaXQgaXMgZW5vdWdoIHRvIGNhbGxcbiAgICAgW2NoZWNrX3NhbWVfbGVuZ3RoXSBvbmNlIGF0IHRoZSBlbmQuXG5cbiAgICAgQ2FsbGluZyBbY2hlY2tfc2FtZV9sZW5ndGhdIG1vcmUgb2Z0ZW4gY291bGQgY2F0Y2ggbW9yZVxuICAgICBwcm9ncmFtbWluZyBlcnJvcnMsIGJ1dCB0aGUgb25seSBlcnJvcnMgdGhhdCB3ZSBtaXNzIHdpdGggdGhpc1xuICAgICBvcHRpbWl6YXRpb24gYXJlIHRob3NlIHRoYXQga2VlcCB0aGUgYXJyYXkgc2l6ZSBjb25zdGFudCAtLVxuICAgICBhZGRpdGlvbnMgYW5kIGRlbGV0aW9ucyB0aGF0IGNhbmNlbCBlYWNoIG90aGVyLiBXZSBjb25zaWRlciB0aGlzXG4gICAgIGFuIGFjY2VwdGFibGUgdHJhZGVvZmYuXG4gICopXG4gIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyO1xuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgIGsgKHVuc2FmZV9nZXQgYXJyIH5pIH5sZW5ndGgpO1xuICBkb25lO1xuICBjaGVja19zYW1lX2xlbmd0aCBmIGEgfmxlbmd0aFxuXG5sZXQgaXRlciBrIGEgPVxuICBpdGVyXyBcIml0ZXJcIiBrIGFcblxubGV0IGl0ZXJpIGsgYSA9XG4gIGxldCB7YXJyOyBsZW5ndGh9ID0gYSBpblxuICBjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoIGFycjtcbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICBrIGkgKHVuc2FmZV9nZXQgYXJyIH5pIH5sZW5ndGgpO1xuICBkb25lO1xuICBjaGVja19zYW1lX2xlbmd0aCBcIml0ZXJpXCIgYSB+bGVuZ3RoXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IHthcnI7IGxlbmd0aH0gPSBhIGluXG4gIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyO1xuICBsZXQgcmVzID0ge1xuICAgIGxlbmd0aDtcbiAgICBhcnIgPSBBcnJheS5pbml0IGxlbmd0aCAoZnVuIGkgLT5cbiAgICAgIEVsZW0ge3YgPSBmICh1bnNhZmVfZ2V0IGFyciB+aSB+bGVuZ3RoKX0pO1xuICB9IGluXG4gIGNoZWNrX3NhbWVfbGVuZ3RoIFwibWFwXCIgYSB+bGVuZ3RoO1xuICByZXNcblxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gIGxldCByZXMgPSB7XG4gICAgbGVuZ3RoO1xuICAgIGFyciA9IEFycmF5LmluaXQgbGVuZ3RoIChmdW4gaSAtPlxuICAgICAgRWxlbSB7diA9IGYgaSAodW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCl9KTtcbiAgfSBpblxuICBjaGVja19zYW1lX2xlbmd0aCBcIm1hcGlcIiBhIH5sZW5ndGg7XG4gIHJlc1xuXG5sZXQgZm9sZF9sZWZ0IGYgYWNjIGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gIGxldCByID0gcmVmIGFjYyBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIC0gMSBkb1xuICAgIGxldCB2ID0gdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCBpblxuICAgIHIgOj0gZiAhciB2O1xuICBkb25lO1xuICBjaGVja19zYW1lX2xlbmd0aCBcImZvbGRfbGVmdFwiIGEgfmxlbmd0aDtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIGFjYyA9XG4gIGxldCB7YXJyOyBsZW5ndGh9ID0gYSBpblxuICBjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoIGFycjtcbiAgbGV0IHIgPSByZWYgYWNjIGluXG4gIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGxldCB2ID0gdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCBpblxuICAgIHIgOj0gZiB2ICFyO1xuICBkb25lO1xuICBjaGVja19zYW1lX2xlbmd0aCBcImZvbGRfcmlnaHRcIiBhIH5sZW5ndGg7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IHthcnI7IGxlbmd0aH0gPSBhIGluXG4gIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyO1xuICBsZXQgcmVjIGxvb3AgcCBhcnIgaSBsZW5ndGggPVxuICAgIGlmIGkgPSBsZW5ndGggdGhlbiBmYWxzZVxuICAgIGVsc2VcbiAgICAgIHAgKHVuc2FmZV9nZXQgYXJyIH5pIH5sZW5ndGgpXG4gICAgICB8fCBsb29wIHAgYXJyIChpICsgMSkgbGVuZ3RoXG4gIGluXG4gIGxldCByZXMgPSBsb29wIHAgYXJyIDAgbGVuZ3RoIGluXG4gIGNoZWNrX3NhbWVfbGVuZ3RoIFwiZXhpc3RzXCIgYSB+bGVuZ3RoO1xuICByZXNcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IHthcnI7IGxlbmd0aH0gPSBhIGluXG4gIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyO1xuICBsZXQgcmVjIGxvb3AgcCBhcnIgaSBsZW5ndGggPVxuICAgIGlmIGkgPSBsZW5ndGggdGhlbiB0cnVlXG4gICAgZWxzZVxuICAgICAgcCAodW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aClcbiAgICAgICYmIGxvb3AgcCBhcnIgKGkgKyAxKSBsZW5ndGhcbiAgaW5cbiAgbGV0IHJlcyA9IGxvb3AgcCBhcnIgMCBsZW5ndGggaW5cbiAgY2hlY2tfc2FtZV9sZW5ndGggXCJmb3JfYWxsXCIgYSB+bGVuZ3RoO1xuICByZXNcblxubGV0IGZpbHRlciBmIGEgPVxuICBsZXQgYiA9IGNyZWF0ZSAoKSBpblxuICBpdGVyXyBcImZpbHRlclwiIChmdW4geCAtPiBpZiBmIHggdGhlbiBhZGRfbGFzdCBiIHgpIGE7XG4gIGJcblxubGV0IGZpbHRlcl9tYXAgZiBhID1cbiAgbGV0IGIgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcl8gXCJmaWx0ZXJfbWFwXCIgKGZ1biB4IC0+XG4gICAgbWF0Y2ggZiB4IHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgeSAtPiBhZGRfbGFzdCBiIHlcbiAgKSBhO1xuICBiXG5cblxuKCoqIHsxOmNvbnZlcnNpb25zIENvbnZlcnNpb25zIHRvIG90aGVyIGRhdGEgc3RydWN0dXJlc30gKilcblxuKCogVGhlIGVhZ2VyIFt0b18qXSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBiZWhhdmUgc2ltaWxhcmx5IHRvIGl0ZXJhdG9yc1xuICAgaW4gcHJlc2VuY2Ugb2YgdXBkYXRlcyBkdXJpbmcgY29tcHV0YXRpb24uIFRoZSBbKl9yZWVudHJhbnRdXG4gICBmdW5jdGlvbnMgb2JleSB0aGVpciBtb3JlIHBlcm1pc3NpdmUgc3BlY2lmaWNhdGlvbiwgd2hpY2ggdG9sZXJhdGVzXG4gICBhbnkgY29uY3VycmVudCB1cGRhdGUuICopXG5cbmxldCBvZl9hcnJheSBhID1cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIHtcbiAgICBsZW5ndGg7XG4gICAgYXJyID0gQXJyYXkuaW5pdCBsZW5ndGggKGZ1biBpIC0+IEVsZW0ge3YgPSBBcnJheS51bnNhZmVfZ2V0IGEgaX0pO1xuICB9XG5cbmxldCB0b19hcnJheSBhID1cbiAgbGV0IHthcnI7IGxlbmd0aH0gPSBhIGluXG4gIGNoZWNrX3ZhbGlkX2xlbmd0aCBsZW5ndGggYXJyO1xuICBsZXQgcmVzID0gQXJyYXkuaW5pdCBsZW5ndGggKGZ1biBpIC0+XG4gICAgdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aClcbiAgaW5cbiAgY2hlY2tfc2FtZV9sZW5ndGggXCJ0b19hcnJheVwiIGEgfmxlbmd0aDtcbiAgcmVzXG5cbmxldCBvZl9saXN0IGxpID1cbiAgbGV0IGEgPSBjcmVhdGUgKCkgaW5cbiAgTGlzdC5pdGVyIChmdW4geCAtPiBhZGRfbGFzdCBhIHgpIGxpO1xuICBhXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gIGxldCBsID0gcmVmIFtdIGluXG4gIGZvciBpID0gbGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGwgOj0gdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCA6OiAhbFxuICBkb25lO1xuICBjaGVja19zYW1lX2xlbmd0aCBcInRvX2xpc3RcIiBhIH5sZW5ndGg7XG4gICFsXG5cbmxldCBvZl9zZXEgc2VxID1cbiAgbGV0IGluaXQgPSBjcmVhdGUoKSBpblxuICBhcHBlbmRfc2VxIGluaXQgc2VxO1xuICBpbml0XG5cbmxldCB0b19zZXEgYSA9XG4gIGxldCB7YXJyOyBsZW5ndGh9ID0gYSBpblxuICBjaGVja192YWxpZF9sZW5ndGggbGVuZ3RoIGFycjtcbiAgbGV0IHJlYyBhdXggaSA9IGZ1biAoKSAtPlxuICAgIGNoZWNrX3NhbWVfbGVuZ3RoIFwidG9fc2VxXCIgYSB+bGVuZ3RoO1xuICAgIGlmIGkgPj0gbGVuZ3RoIHRoZW4gU2VxLk5pbFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB2ID0gdW5zYWZlX2dldCBhcnIgfmkgfmxlbmd0aCBpblxuICAgICAgU2VxLkNvbnMgKHYsIGF1eCAoaSArIDEpKVxuICAgIGVuZFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxX3JlZW50cmFudCBhID1cbiAgbGV0IHJlYyBhdXggaSA9IGZ1biAoKSAtPlxuICAgIGlmIGkgPj0gbGVuZ3RoIGEgdGhlbiBTZXEuTmlsXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHYgPSBnZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAodiwgYXV4IChpICsgMSkpXG4gICAgZW5kXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFfcmV2IGEgPVxuICBsZXQge2FycjsgbGVuZ3RofSA9IGEgaW5cbiAgY2hlY2tfdmFsaWRfbGVuZ3RoIGxlbmd0aCBhcnI7XG4gIGxldCByZWMgYXV4IGkgPSBmdW4gKCkgLT5cbiAgICBjaGVja19zYW1lX2xlbmd0aCBcInRvX3NlcV9yZXZcIiBhIH5sZW5ndGg7XG4gICAgaWYgaSA8IDAgdGhlbiBTZXEuTmlsXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHYgPSB1bnNhZmVfZ2V0IGFyciB+aSB+bGVuZ3RoIGluXG4gICAgICBTZXEuQ29ucyAodiwgYXV4IChpIC0gMSkpXG4gICAgZW5kXG4gIGluXG4gIGF1eCAobGVuZ3RoIC0gMSlcblxubGV0IHRvX3NlcV9yZXZfcmVlbnRyYW50IGEgPVxuICBsZXQgcmVjIGF1eCBpID0gZnVuICgpIC0+XG4gICAgaWYgaSA8IDAgdGhlbiBTZXEuTmlsXG4gICAgZWxzZSBpZiBpID49IGxlbmd0aCBhIHRoZW5cbiAgICAgICgqIElmIHNvbWUgZWxlbWVudHMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gdGhlIG1lYW50aW1lLCB3ZSBza2lwXG4gICAgICAgICB0aG9zZSBlbGVtZW50cyBhbmQgY29udGludWUgd2l0aCB0aGUgbmV3IGVuZCBvZiB0aGUgYXJyYXkuICopXG4gICAgICBhdXggKGxlbmd0aCBhIC0gMSkgKClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgdiA9IGdldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICh2LCBhdXggKGkgLSAxKSlcbiAgICBlbmRcbiAgaW5cbiAgYXV4IChsZW5ndGggYSAtIDEpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IFJlc3RfYWxsIG9mIChzdHJpbmcgbGlzdCAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggYWxsIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcuc3RhcnRzX3dpdGggfnByZWZpeDpcIi1cIiBzIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IGFjdGlvbiwgZm9sbG93ID1cbiAgICAgICAgICB0cnkgYXNzb2MzIHMgIXNwZWNsaXN0LCBOb25lXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBrZXl3b3JkLCBhcmcgPSBzcGxpdCBzIGluXG4gICAgICAgICAgICBhc3NvYzMga2V5d29yZCAhc3BlY2xpc3QsIFNvbWUgYXJnXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgKFN0b3AgKFVua25vd24gcykpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBub19hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJubyBhcmd1bWVudFwiKSkpIGluXG4gICAgICAgIGxldCBnZXRfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBpZiAhY3VycmVudCArIDEgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2LighY3VycmVudCArIDEpXG4gICAgICAgICAgICAgIGVsc2UgcmFpc2UgKFN0b3AgKE1pc3NpbmcgcykpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiBhcmdcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbmNyIGN1cnJlbnRcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVjIHRyZWF0X2FjdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5pdCBmIC0+IG5vX2FyZyAoKTsgZiAoKTtcbiAgICAgICAgfCBCb29sIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBib29sX29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGJvb2xlYW5cIikpKVxuICAgICAgICAgICAgfCBTb21lIHMgLT4gZiBzXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXQgciAtPiBub19hcmcgKCk7IHIgOj0gdHJ1ZTtcbiAgICAgICAgfCBDbGVhciByIC0+IG5vX2FyZyAoKTsgciA6PSBmYWxzZTtcbiAgICAgICAgfCBTdHJpbmcgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU3ltYm9sIChzeW1iLCBmKSAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGlmIExpc3QubWVtIGFyZyBzeW1iIHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwib25lIG9mOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiAobWFrZV9zeW1saXN0IFwiXCIgXCIgXCIgXCJcIiBzeW1iKSkpKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgU2V0X3N0cmluZyByIC0+XG4gICAgICAgICAgICByIDo9IGdldF9hcmcgKCk7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBJbnQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9pbnQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEZsb2F0IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9mbG9hdCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBUdXBsZSBzcGVjcyAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgTGlzdC5pdGVyIHRyZWF0X2FjdGlvbiBzcGVjcztcbiAgICAgICAgfCBSZXN0IGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgLSAxIGRvXG4gICAgICAgICAgICAgIGYgIWFyZ3YuKCFjdXJyZW50ICsgMSk7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgfCBSZXN0X2FsbCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYWNjID0gcmVmIFtdIGluXG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IEFycmF5Lmxlbmd0aCAhYXJndiAtIDEgZG9cbiAgICAgICAgICAgICAgYWNjIDo9ICFhcmd2LighY3VycmVudCArIDEpIDo6ICFhY2M7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgIGYgKExpc3QucmV2ICFhY2MpXG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPVxuICAgICAgICAgICAgICBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1blxuICAgIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBJbnQubWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBJbnQubWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QgKyBzZWNvbmRfd29yZCBkb2MpXG5cblxubGV0IHJlcGxhY2VfbGVhZGluZ190YWIgcyA9XG4gIGxldCBzZWVuID0gcmVmIGZhbHNlIGluXG4gIFN0cmluZy5tYXAgKGZ1bmN0aW9uICdcXHQnIHdoZW4gbm90ICFzZWVuIC0+IHNlZW4gOj0gdHJ1ZTsgJyAnIHwgYyAtPiBjKSBzXG5cbmxldCBhZGRfcGFkZGluZyBsZW4ga3NkID1cbiAgbWF0Y2gga3NkIHdpdGhcbiAgfCAoXywgXywgXCJcIikgLT5cbiAgICAgICgqIERvIG5vdCBwYWQgdW5kb2N1bWVudGVkIG9wdGlvbnMsIHNvIHRoYXQgdGhleSBzdGlsbCBkb24ndCBzaG93IHVwIHdoZW5cbiAgICAgICAqIHJ1biB0aHJvdWdoIFt1c2FnZV0gb3IgW3BhcnNlXS4gKilcbiAgICAgIGtzZFxuICB8IChrd2QsIChTeW1ib2wgXyBhcyBzcGVjKSwgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlICgoSW50Lm1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBJbnQubWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGJlZ2luXG4gICAgdHJ5IHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICAgIGlmIGMgPSBzZXAgdGhlbiBzdGFzaCAoKSBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgICAgZG9uZVxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gKClcbiAgZW5kO1xuICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlbiBzdGFzaCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IEF0b21pYy5tYWtlIFtdXG5cbmxldCBsb2NmbXQgPSBmb3JtYXRfb2Zfc3RyaW5nIFwiRmlsZSBcXFwiJXNcXFwiLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOiAlc1wiXG5cbmxldCBmaWVsZCB4IGkgPVxuICBsZXQgZiA9IE9iai5maWVsZCB4IGkgaW5cbiAgaWYgbm90IChPYmouaXNfYmxvY2sgZikgdGhlblxuICAgIHNwcmludGYgXCIlZFwiIChPYmoubWFnaWMgZiA6IGludCkgICAgICAgICAgICgqIGNhbiBhbHNvIGJlIGEgY2hhciAqKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5zdHJpbmdfdGFnIHRoZW5cbiAgICBzcHJpbnRmIFwiJVNcIiAoT2JqLm1hZ2ljIGYgOiBzdHJpbmcpXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLmRvdWJsZV90YWcgdGhlblxuICAgIHN0cmluZ19vZl9mbG9hdCAoT2JqLm1hZ2ljIGYgOiBmbG9hdClcbiAgZWxzZVxuICAgIFwiX1wiXG5cbmxldCByZWMgb3RoZXJfZmllbGRzIHggaSA9XG4gIGlmIGkgPj0gT2JqLnNpemUgeCB0aGVuIFwiXCJcbiAgZWxzZSBzcHJpbnRmIFwiLCAlcyVzXCIgKGZpZWxkIHggaSkgKG90aGVyX2ZpZWxkcyB4IChpKzEpKVxuXG5sZXQgZmllbGRzIHggPVxuICBtYXRjaCBPYmouc2l6ZSB4IHdpdGhcbiAgfCAwIC0+IFwiXCJcbiAgfCAxIC0+IFwiXCJcbiAgfCAyIC0+IHNwcmludGYgXCIoJXMpXCIgKGZpZWxkIHggMSlcbiAgfCBfIC0+IHNwcmludGYgXCIoJXMlcylcIiAoZmllbGQgeCAxKSAob3RoZXJfZmllbGRzIHggMilcblxubGV0IHVzZV9wcmludGVycyB4ID1cbiAgbGV0IHJlYyBjb252ID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCBoZCB4IHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IGV4Y2VwdGlvbiBfIC0+IGNvbnYgdGxcbiAgICAgICAgIHwgU29tZSBzIC0+IFNvbWUgcylcbiAgICB8IFtdIC0+IE5vbmUgaW5cbiAgY29udiAoQXRvbWljLmdldCBwcmludGVycylcblxubGV0IGRlc3RydWN0X2V4dF9jb25zdHJ1Y3RvciB4ID1cbiAgaWYgT2JqLnRhZyB4IDw+IDAgdGhlblxuICAgICgoT2JqLm1hZ2ljIChPYmouZmllbGQgeCAwKSA6IHN0cmluZyksIE5vbmUpXG4gIGVsc2VcbiAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAoY29uc3RydWN0b3IsIFNvbWUgKGZpZWxkcyB4KSlcblxubGV0IHN0cmluZ19vZl9leHRlbnNpb25fY29uc3RydWN0b3IgdCA9XG4gIGxldCBjb25zdHJ1Y3RvciwgZmllbGRzX29wdCA9IGRlc3RydWN0X2V4dF9jb25zdHJ1Y3RvciB0IGluXG4gIG1hdGNoIGZpZWxkc19vcHQgd2l0aFxuICB8IE5vbmUgLT4gY29uc3RydWN0b3JcbiAgfCBTb21lIGYgLT4gY29uc3RydWN0b3IgXiBmXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBzdHJpbmdfb2ZfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIChPYmoucmVwciB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxuKCogRGlzYWJsZSB3YXJuaW5nIDM3OiB2YWx1ZXMgYXJlIGNvbnN0cnVjdGVkIGluIHRoZSBydW50aW1lICopXG50eXBlW0B3YXJuaW5nIFwiLTM3XCJdIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgOiBzdHJpbmc7XG4gICAgICBzdGFydF9sbnVtIDogaW50O1xuICAgICAgc3RhcnRfY2hhciA6IGludDtcbiAgICAgIGVuZF9vZmZzZXQgOiBpbnQ7ICgqIFJlbGF0aXZlIHRvIGJlZ2lubmluZyBvZiBzdGFydF9sbnVtICopXG4gICAgICBlbmRfbG51bSAgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICA6IGludDsgKCogUmVsYXRpdmUgdG8gYmVnaW5uaW5nIG9mIGVuZF9sbnVtIGxpbmUgKilcbiAgICAgIGlzX2lubGluZSAgOiBib29sO1xuICAgICAgZGVmbmFtZSAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgbGV0IGxpbmVzID1cbiAgICAgICAgaWYgbC5zdGFydF9sbnVtID0gbC5lbmRfbG51bSB0aGVuXG4gICAgICAgICAgUHJpbnRmLnNwcmludGYgXCIgJWRcIiBsLnN0YXJ0X2xudW1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIFByaW50Zi5zcHJpbnRmIFwicyAlZC0lZFwiIGwuc3RhcnRfbG51bSBsLmVuZF9sbnVtXG4gICAgICBpblxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzICVzIGluIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lJXMsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGxpbmVzIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xuICBlbmRfbGluZSA6IGludDtcbiAgZW5kX2NvbCA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5zdGFydF9sbnVtO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX29mZnNldDtcbiAgICAgIGVuZF9saW5lICAgID0gbC5lbmRfbG51bTtcbiAgICAgIGVuZF9jb2wgICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxubGV0IGNvbnN0IGMgXyA9IGNcbmxldCBjb21wb3NlIGYgZyB4ID0gZiAoZyB4KVxubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIEphY3F1ZXMtSGVucmkgSm91cmRhbiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFBhcmlzICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2LTIwMTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSAgICopXG4oKiAgICAgZXQgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xuICBmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG1ham9yX2hlYXBfaW5jcmVtZW50IDogaW50O1xuICBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgdmVyYm9zZSA6IGludDtcbiAgbWF4X292ZXJoZWFkIDogaW50O1xuICBzdGFja19saW1pdCA6IGludDtcbiAgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuXG5sZXQgZXZlbnRsb2dfcGF1c2UgKCkgPSAoKVxubGV0IGV2ZW50bG9nX3Jlc3VtZSAoKSA9ICgpXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcImNvbXBhY3Rpb25zOiAgICAgICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcImZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5mb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCBBdG9taWMudFxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgQXRvbWljLmdldCBhcmVjLmFjdGl2ZSB0aGVuIGJlZ2luXG4gICAgbGV0IGZpbmFsbHkgKCkgPSBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWMgaW5cbiAgICBGdW4ucHJvdGVjdCB+ZmluYWxseSBhcmVjLmZcbiAgZW5kXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IEF0b21pYy5zZXQgYSBmYWxzZVxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gQXRvbWljLm1ha2UgdHJ1ZTsgZiA9IGYgfSBpblxuICBEb21haW4uYXRfZXhpdCAoZnVuICgpIC0+IGRlbGV0ZV9hbGFybSBhcmVjLmFjdGl2ZSk7XG4gIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgYXJlYy5hY3RpdmVcblxuXG5tb2R1bGUgTWVtcHJvZiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgdFxuICAgIHR5cGUgYWxsb2NhdGlvbl9zb3VyY2UgPSBOb3JtYWwgfCBNYXJzaGFsIHwgQ3VzdG9tXG4gICAgdHlwZSBhbGxvY2F0aW9uID1cbiAgICAgIHsgbl9zYW1wbGVzIDogaW50O1xuICAgICAgICBzaXplIDogaW50O1xuICAgICAgICBzb3VyY2UgOiBhbGxvY2F0aW9uX3NvdXJjZTtcbiAgICAgICAgY2FsbHN0YWNrIDogUHJpbnRleGMucmF3X2JhY2t0cmFjZSB9XG5cbiAgICB0eXBlICgnbWlub3IsICdtYWpvcikgdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yOiBhbGxvY2F0aW9uIC0+ICdtaW5vciBvcHRpb247XG4gICAgICBhbGxvY19tYWpvcjogYWxsb2NhdGlvbiAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgcHJvbW90ZTogJ21pbm9yIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBkZWFsbG9jX21pbm9yOiAnbWlub3IgLT4gdW5pdDtcbiAgICAgIGRlYWxsb2NfbWFqb3I6ICdtYWpvciAtPiB1bml0O1xuICAgIH1cblxuICAgIGxldCBudWxsX3RyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGFsbG9jX21ham9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgcHJvbW90ZSA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGRlYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgICAgZGVhbGxvY19tYWpvciA9IChmdW4gXyAtPiAoKSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwgY19zdGFydCA6XG4gICAgICBmbG9hdCAtPiBpbnQgLT4gKCdtaW5vciwgJ21ham9yKSB0cmFja2VyIC0+IHRcbiAgICAgID0gXCJjYW1sX21lbXByb2Zfc3RhcnRcIlxuXG4gICAgbGV0IHN0YXJ0XG4gICAgICB+c2FtcGxpbmdfcmF0ZVxuICAgICAgPyhjYWxsc3RhY2tfc2l6ZSA9IG1heF9pbnQpXG4gICAgICB0cmFja2VyID1cbiAgICAgIGNfc3RhcnQgc2FtcGxpbmdfcmF0ZSBjYWxsc3RhY2tfc2l6ZSB0cmFja2VyXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2Zfc3RvcFwiXG5cbiAgICBleHRlcm5hbCBkaXNjYXJkIDogdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2ZfZGlzY2FyZFwiXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbl9jaGFubmVsXG5cbnR5cGUgb3Blbl9mbGFnID0gU3RkbGliLm9wZW5fZmxhZyA9XG4gIHwgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcblxubGV0IHN0ZGluID0gU3RkbGliLnN0ZGluXG5sZXQgb3Blbl9iaW4gPSBTdGRsaWIub3Blbl9pbl9iaW5cbmxldCBvcGVuX3RleHQgPSBTdGRsaWIub3Blbl9pblxubGV0IG9wZW5fZ2VuID0gU3RkbGliLm9wZW5faW5fZ2VuXG5cbmxldCB3aXRoX29wZW4gb3BlbmZ1biBzIGYgPVxuICBsZXQgaWMgPSBvcGVuZnVuIHMgaW5cbiAgRnVuLnByb3RlY3QgfmZpbmFsbHk6KGZ1biAoKSAtPiBTdGRsaWIuY2xvc2VfaW5fbm9lcnIgaWMpXG4gICAgKGZ1biAoKSAtPiBmIGljKVxuXG5sZXQgd2l0aF9vcGVuX2JpbiBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5faW5fYmluIHMgZlxuXG5sZXQgd2l0aF9vcGVuX3RleHQgcyBmID1cbiAgd2l0aF9vcGVuIFN0ZGxpYi5vcGVuX2luIHMgZlxuXG5sZXQgd2l0aF9vcGVuX2dlbiBmbGFncyBwZXJtIHMgZiA9XG4gIHdpdGhfb3BlbiAoU3RkbGliLm9wZW5faW5fZ2VuIGZsYWdzIHBlcm0pIHMgZlxuXG5sZXQgc2VlayA9IFN0ZGxpYi5MYXJnZUZpbGUuc2Vla19pblxubGV0IHBvcyA9IFN0ZGxpYi5MYXJnZUZpbGUucG9zX2luXG5sZXQgbGVuZ3RoID0gU3RkbGliLkxhcmdlRmlsZS5pbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX2luXG5sZXQgY2xvc2Vfbm9lcnIgPSBTdGRsaWIuY2xvc2VfaW5fbm9lcnJcblxubGV0IGlucHV0X2NoYXIgaWMgPVxuICBtYXRjaCBTdGRsaWIuaW5wdXRfY2hhciBpYyB3aXRoXG4gIHwgYyAtPiBTb21lIGNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG5sZXQgaW5wdXRfYnl0ZSBpYyA9XG4gIG1hdGNoIFN0ZGxpYi5pbnB1dF9ieXRlIGljIHdpdGhcbiAgfCBuIC0+IFNvbWUgblxuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCBpbnB1dF9saW5lIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2xpbmUgaWMgd2l0aFxuICB8IHMgLT4gU29tZSBzXG4gIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+IE5vbmVcblxubGV0IGlucHV0ID0gU3RkbGliLmlucHV0XG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dF9iaWdhcnJheSA6XG4gIHQgLT4gXyBCaWdhcnJheS5BcnJheTEudCAtPiBpbnQgLT4gaW50IC0+IGludFxuICA9IFwiY2FtbF9tbF9pbnB1dF9iaWdhcnJheVwiXG5cbmxldCBpbnB1dF9iaWdhcnJheSBpYyBidWYgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCaWdhcnJheS5BcnJheTEuZGltIGJ1ZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRfYmlnYXJyYXlcIlxuICBlbHNlIHVuc2FmZV9pbnB1dF9iaWdhcnJheSBpYyBidWYgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0IGljIGJ1ZiBwb3MgbGVuID1cbiAgbWF0Y2ggU3RkbGliLnJlYWxseV9pbnB1dCBpYyBidWYgcG9zIGxlbiB3aXRoXG4gIHwgKCkgLT4gU29tZSAoKVxuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBOb25lXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dF9iaWdhcnJheSBpYyBidWYgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gU29tZSAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXRfYmlnYXJyYXkgaWMgYnVmIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dF9iaWdhcnJheSBpYyBidWYgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dF9iaWdhcnJheSBpYyBidWYgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCaWdhcnJheS5BcnJheTEuZGltIGJ1ZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0X2JpZ2FycmF5XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0X2JpZ2FycmF5IGljIGJ1ZiBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIG1hdGNoIFN0ZGxpYi5yZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiB3aXRoXG4gIHwgcyAtPiBTb21lIHNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gTm9uZVxuXG4oKiBSZWFkIHVwIHRvIFtsZW5dIGJ5dGVzIGludG8gW2J1Zl0sIHN0YXJ0aW5nIGF0IFtvZnNdLiBSZXR1cm4gdG90YWwgYnl0ZXNcbiAgIHJlYWQuICopXG5sZXQgcmVhZF91cHRvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIG9mcyBsZW4gPVxuICAgIGlmIGxlbiA9IDAgdGhlbiBvZnNcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IFN0ZGxpYi5pbnB1dCBpYyBidWYgb2ZzIGxlbiBpblxuICAgICAgaWYgciA9IDAgdGhlblxuICAgICAgICBvZnNcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCAob2ZzICsgcikgKGxlbiAtIHIpXG4gICAgZW5kXG4gIGluXG4gIGxvb3Agb2ZzIGxlbiAtIG9mc1xuXG4oKiBCZXN0IGVmZm9ydCBhdHRlbXB0IHRvIHJldHVybiBhIGJ1ZmZlciB3aXRoID49IChvZnMgKyBuKSBieXRlcyBvZiBzdG9yYWdlLFxuICAgYW5kIHN1Y2ggdGhhdCBpdCBjb2luY2lkZXMgd2l0aCBbYnVmXSBhdCBpbmRpY2VzIDwgW29mc10uXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgaXMgZXF1YWwgdG8gW2J1Zl0gaXRzZWxmIGlmIGl0IGFscmVhZHkgaGFzIHN1ZmZpY2llbnRcbiAgIGZyZWUgc3BhY2UuXG5cbiAgIFRoZSByZXR1cm5lZCBidWZmZXIgbWF5IGhhdmUgKmZld2VyKiB0aGFuIFtvZnMgKyBuXSBieXRlcyBvZiBzdG9yYWdlIGlmIHRoaXNcbiAgIG51bWJlciBpcyA+IFtTeXMubWF4X3N0cmluZ19sZW5ndGhdLiBIb3dldmVyIHRoZSByZXR1cm5lZCBidWZmZXIgd2lsbFxuICAgKmFsd2F5cyogaGF2ZSA+IFtvZnNdIGJ5dGVzIG9mIHN0b3JhZ2UuIEluIHRoZSBsaW1pdGluZyBjYXNlIHdoZW4gW29mcyA9IGxlblxuICAgPSBTeXMubWF4X3N0cmluZ19sZW5ndGhdIChzbyB0aGF0IGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZXNpemUgdGhlIGJ1ZmZlciBhdFxuICAgYWxsKSwgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcblxubGV0IGVuc3VyZSBidWYgb2ZzIG4gPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPj0gb2ZzICsgbiB0aGVuIGJ1ZlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5ld19sZW4gPSByZWYgbGVuIGluXG4gICAgd2hpbGUgIW5ld19sZW4gPCBvZnMgKyBuIGRvXG4gICAgICBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiArIDFcbiAgICBkb25lO1xuICAgIGxldCBuZXdfbGVuID0gIW5ld19sZW4gaW5cbiAgICBsZXQgbmV3X2xlbiA9XG4gICAgICBpZiBuZXdfbGVuIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIG5ld19sZW5cbiAgICAgIGVsc2UgaWYgb2ZzIDwgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIGZhaWx3aXRoIFwiSW5fY2hhbm5lbC5pbnB1dF9hbGw6IGNoYW5uZWwgY29udGVudCBcXFxuICAgICAgICAgICAgICAgICAgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoXCJcbiAgICBpblxuICAgIGxldCBuZXdfYnVmID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1ZiAwIG5ld19idWYgMCBvZnM7XG4gICAgbmV3X2J1ZlxuICBlbmRcblxubGV0IGlucHV0X2FsbCBpYyA9XG4gIGxldCBjaHVua19zaXplID0gNjU1MzYgaW4gKCogSU9fQlVGRkVSX1NJWkUgKilcbiAgbGV0IGluaXRpYWxfc2l6ZSA9XG4gICAgdHJ5XG4gICAgICBTdGRsaWIuaW5fY2hhbm5lbF9sZW5ndGggaWMgLSBTdGRsaWIucG9zX2luIGljXG4gICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgLTFcbiAgaW5cbiAgbGV0IGluaXRpYWxfc2l6ZSA9IGlmIGluaXRpYWxfc2l6ZSA8IDAgdGhlbiBjaHVua19zaXplIGVsc2UgaW5pdGlhbF9zaXplIGluXG4gIGxldCBpbml0aWFsX3NpemUgPVxuICAgIGlmIGluaXRpYWxfc2l6ZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgaW5pdGlhbF9zaXplXG4gICAgZWxzZVxuICAgICAgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gIGluXG4gIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgaW5pdGlhbF9zaXplIGluXG4gIGxldCBucmVhZCA9IHJlYWRfdXB0byBpYyBidWYgMCBpbml0aWFsX3NpemUgaW5cbiAgaWYgbnJlYWQgPCBpbml0aWFsX3NpemUgdGhlbiAoKiBFT0YgcmVhY2hlZCwgYnVmZmVyIHBhcnRpYWxseSBmaWxsZWQgKilcbiAgICBCeXRlcy5zdWJfc3RyaW5nIGJ1ZiAwIG5yZWFkXG4gIGVsc2UgYmVnaW4gKCogbnJlYWQgPSBpbml0aWFsX3NpemUsIG1heWJlIEVPRiByZWFjaGVkICopXG4gICAgbWF0Y2ggU3RkbGliLmlucHV0X2NoYXIgaWMgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEVuZF9vZl9maWxlIC0+XG4gICAgICAgICgqIEVPRiByZWFjaGVkLCBidWZmZXIgaXMgY29tcGxldGVseSBmaWxsZWQgKilcbiAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgICB8IGMgLT5cbiAgICAgICAgKCogRU9GIG5vdCByZWFjaGVkICopXG4gICAgICAgIGxldCByZWMgbG9vcCBidWYgb2ZzID1cbiAgICAgICAgICBsZXQgYnVmID0gZW5zdXJlIGJ1ZiBvZnMgY2h1bmtfc2l6ZSBpblxuICAgICAgICAgIGxldCByZW0gPSBCeXRlcy5sZW5ndGggYnVmIC0gb2ZzIGluXG4gICAgICAgICAgKCogW3JlbV0gY2FuIGJlIDwgW2NodW5rX3NpemVdIGlmIGJ1ZmZlciBzaXplIGNsb3NlIHRvXG4gICAgICAgICAgICAgW1N5cy5tYXhfc3RyaW5nX2xlbmd0aF0gKilcbiAgICAgICAgICBsZXQgciA9IHJlYWRfdXB0byBpYyBidWYgb2ZzIHJlbSBpblxuICAgICAgICAgIGlmIHIgPCByZW0gdGhlbiAoKiBFT0YgcmVhY2hlZCAqKVxuICAgICAgICAgICAgQnl0ZXMuc3ViX3N0cmluZyBidWYgMCAob2ZzICsgcilcbiAgICAgICAgICBlbHNlICgqIHIgPSByZW0gKilcbiAgICAgICAgICAgIGxvb3AgYnVmIChvZnMgKyByZW0pXG4gICAgICAgIGluXG4gICAgICAgIGxldCBidWYgPSBlbnN1cmUgYnVmIG5yZWFkIChjaHVua19zaXplICsgMSkgaW5cbiAgICAgICAgQnl0ZXMuc2V0IGJ1ZiBucmVhZCBjO1xuICAgICAgICBsb29wIGJ1ZiAobnJlYWQgKyAxKVxuICBlbmRcblxubGV0IFtAdGFpbF9tb2RfY29uc10gcmVjIGlucHV0X2xpbmVzIGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2xpbmUgaWMgd2l0aFxuICB8IGxpbmUgLT4gbGluZSA6OiBpbnB1dF9saW5lcyBpY1xuICB8IGV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSAtPiBbXVxuXG5sZXQgcmVjIGZvbGRfbGluZXMgZiBhY2N1IGljID1cbiAgbWF0Y2ggU3RkbGliLmlucHV0X2xpbmUgaWMgd2l0aFxuICB8IGxpbmUgLT4gZm9sZF9saW5lcyBmIChmIGFjY3UgbGluZSkgaWNcbiAgfCBleGNlcHRpb24gRW5kX29mX2ZpbGUgLT4gYWNjdVxuXG5sZXQgc2V0X2JpbmFyeV9tb2RlID0gU3RkbGliLnNldF9iaW5hcnlfbW9kZV9pblxuXG5leHRlcm5hbCBpc19iaW5hcnlfbW9kZSA6IGluX2NoYW5uZWwgLT4gYm9vbCA9IFwiY2FtbF9tbF9pc19iaW5hcnlfbW9kZVwiXG5cbmV4dGVybmFsIGlzYXR0eSA6IHQgLT4gYm9vbCA9IFwiY2FtbF9zeXNfaXNhdHR5XCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjEgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gb3V0X2NoYW5uZWxcblxudHlwZSBvcGVuX2ZsYWcgPSBTdGRsaWIub3Blbl9mbGFnID1cbiAgfCBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xuXG5sZXQgc3Rkb3V0ID0gU3RkbGliLnN0ZG91dFxubGV0IHN0ZGVyciA9IFN0ZGxpYi5zdGRlcnJcbmxldCBvcGVuX2JpbiA9IFN0ZGxpYi5vcGVuX291dF9iaW5cbmxldCBvcGVuX3RleHQgPSBTdGRsaWIub3Blbl9vdXRcbmxldCBvcGVuX2dlbiA9IFN0ZGxpYi5vcGVuX291dF9nZW5cblxubGV0IHdpdGhfb3BlbiBvcGVuZnVuIHMgZiA9XG4gIGxldCBvYyA9IG9wZW5mdW4gcyBpblxuICBGdW4ucHJvdGVjdCB+ZmluYWxseTooZnVuICgpIC0+IFN0ZGxpYi5jbG9zZV9vdXRfbm9lcnIgb2MpXG4gICAgKGZ1biAoKSAtPiBmIG9jKVxuXG5sZXQgd2l0aF9vcGVuX2JpbiBzIGYgPVxuICB3aXRoX29wZW4gU3RkbGliLm9wZW5fb3V0X2JpbiBzIGZcblxubGV0IHdpdGhfb3Blbl90ZXh0IHMgZiA9XG4gIHdpdGhfb3BlbiBTdGRsaWIub3Blbl9vdXQgcyBmXG5cbmxldCB3aXRoX29wZW5fZ2VuIGZsYWdzIHBlcm0gcyBmID1cbiAgd2l0aF9vcGVuIChTdGRsaWIub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0pIHMgZlxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X2JpZ2FycmF5IDpcbiAgdCAtPiBfIEJpZ2FycmF5LkFycmF5MS50IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICA9IFwiY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXlcIlxuXG5sZXQgc2VlayA9IFN0ZGxpYi5MYXJnZUZpbGUuc2Vla19vdXRcbmxldCBwb3MgPSBTdGRsaWIuTGFyZ2VGaWxlLnBvc19vdXRcbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLm91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX291dFxubGV0IGNsb3NlX25vZXJyID0gU3RkbGliLmNsb3NlX291dF9ub2VyclxubGV0IGZsdXNoID0gU3RkbGliLmZsdXNoXG5sZXQgZmx1c2hfYWxsID0gU3RkbGliLmZsdXNoX2FsbFxubGV0IG91dHB1dF9jaGFyID0gU3RkbGliLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBTdGRsaWIub3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfc3RyaW5nID0gU3RkbGliLm91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBTdGRsaWIub3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gU3RkbGliLm91dHB1dFxubGV0IG91dHB1dF9zdWJzdHJpbmcgPSBTdGRsaWIub3V0cHV0X3N1YnN0cmluZ1xubGV0IG91dHB1dF9iaWdhcnJheSBvYyBidWYgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCaWdhcnJheS5BcnJheTEuZGltIGJ1ZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X2JpZ2FycmF5XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X2JpZ2FycmF5IG9jIGJ1ZiBvZnMgbGVuXG5cbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX291dFxuXG5leHRlcm5hbCBpc19iaW5hcnlfbW9kZSA6IG91dF9jaGFubmVsIC0+IGJvb2wgPSBcImNhbWxfbWxfaXNfYmluYXJ5X21vZGVcIlxuXG5leHRlcm5hbCBzZXRfYnVmZmVyZWQgOiB0IC0+IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZXRfYnVmZmVyZWRcIlxuXG5leHRlcm5hbCBpc19idWZmZXJlZCA6IHQgLT4gYm9vbCA9IFwiY2FtbF9tbF9pc19idWZmZXJlZFwiXG5cbmV4dGVybmFsIGlzYXR0eSA6IHQgLT4gYm9vbCA9IFwiY2FtbF9zeXNfaXNhdHR5XCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVXRpbGl0eSBmdW5jdGlvbnMgKilcblxubGV0IGhleF9vZl9zdHJpbmcgZCA9XG4gIGxldCBjaGFyX2hleCBuID1cbiAgICBDaGFyLmNociAoaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyArIG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgQ2hhci5jb2RlICdhJyArIG4gLSAxMCkgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggZCBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIChsZW4gKiAyKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBzdHJpbmdfb2ZfaGV4IHMgPVxuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5vZl9oZXhcIiBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIFN0cmluZy5pbml0IChTdHJpbmcubGVuZ3RoIHMgLyAyKSAoZnVuIGkgLT4gQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpXG5cbigqIEdlbmVyaWMgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0ID0gc3RyaW5nXG4gIHZhbCBoYXNoX2xlbmd0aCA6IGludFxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIHN0cmluZyA6IHN0cmluZyAtPiB0XG4gIHZhbCBieXRlcyA6IGJ5dGVzIC0+IHRcbiAgdmFsIHN1YnN0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHRcbiAgdmFsIHN1YmJ5dGVzIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB0XG4gIHZhbCBjaGFubmVsIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdFxuICB2YWwgZmlsZSA6IHN0cmluZyAtPiB0XG4gIHZhbCBvdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiB0IC0+IHVuaXRcbiAgdmFsIGlucHV0IDogaW5fY2hhbm5lbCAtPiB0XG4gIHZhbCB0b19oZXggOiB0IC0+IHN0cmluZ1xuICB2YWwgb2ZfaGV4IDogc3RyaW5nIC0+IHRcbmVuZFxuXG4oKiBCTEFLRTIgaGFzaGluZywgcGFyYW1ldGVyaXplZCBieSBoYXNoIHNpemUgKilcblxubW9kdWxlIEJMQUtFMiAoWDogc2lnIHZhbCBoYXNoX2xlbmd0aCA6IGludCBlbmQpIDogUyA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBoYXNoX2xlbmd0aCA9XG4gICAgaWYgWC5oYXNoX2xlbmd0aCA8IDEgfHwgWC5oYXNoX2xlbmd0aCA+IDY0XG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5CTEFLRTI6IHdyb25nIGhhc2ggc2l6ZVwiO1xuICAgIFguaGFzaF9sZW5ndGhcblxuICBsZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG4gIGxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG4gIHR5cGUgc3RhdGVcblxuICBleHRlcm5hbCBjcmVhdGVfZ2VuOiBpbnQgLT4gc3RyaW5nIC0+IHN0YXRlID0gXCJjYW1sX2JsYWtlMl9jcmVhdGVcIlxuICBleHRlcm5hbCB1cGRhdGU6IHN0YXRlIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYmxha2UyX3VwZGF0ZVwiXG4gIGV4dGVybmFsIGZpbmFsOiBzdGF0ZSAtPiBpbnQgLT4gdCA9IFwiY2FtbF9ibGFrZTJfZmluYWxcIlxuICBleHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBpbnQgLT4gc3RyaW5nIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsYWtlMl9zdHJpbmdcIlxuXG4gIGxldCBjcmVhdGUgKCkgPSBjcmVhdGVfZ2VuIGhhc2hfbGVuZ3RoIFwiXCJcblxuICBsZXQgc3RyaW5nIHN0ciA9XG4gICAgdW5zYWZlX3N0cmluZyBoYXNoX2xlbmd0aCBcIlwiIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuICBsZXQgYnl0ZXMgYiA9XG4gICAgc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbiAgbGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIjtcbiAgICB1bnNhZmVfc3RyaW5nIGhhc2hfbGVuZ3RoIFwiXCIgc3RyIG9mcyBsZW5cblxuICBsZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID1cbiAgICBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG4gIGxldCBjaGFubmVsIGljIHRvcmVhZCA9XG4gICAgbGV0IGJ1Zl9zaXplID0gNDA5NiBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgYnVmX3NpemUgaW5cbiAgICBsZXQgY3R4ID0gY3JlYXRlICgpIGluXG4gICAgaWYgdG9yZWFkIDwgMCB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGRvX3JlYWQgKCkgPVxuICAgICAgICBsZXQgbiA9IEluX2NoYW5uZWwuaW5wdXQgaWMgYnVmIDAgYnVmX3NpemUgaW5cbiAgICAgICAgaWYgbiA9IDBcbiAgICAgICAgdGhlbiBmaW5hbCBjdHggaGFzaF9sZW5ndGhcbiAgICAgICAgZWxzZSAodXBkYXRlIGN0eCAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWYpIDAgbjsgZG9fcmVhZCAoKSlcbiAgICAgIGluIGRvX3JlYWQgKClcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgbGV0IHJlYyBkb19yZWFkIHRvcmVhZCA9XG4gICAgICAgIGlmIHRvcmVhZCA9IDAgdGhlbiBmaW5hbCBjdHggaGFzaF9sZW5ndGggZWxzZSBiZWdpblxuICAgICAgICAgIGxldCBuID0gSW5fY2hhbm5lbC5pbnB1dCBpYyBidWYgMCAoSW50Lm1pbiBidWZfc2l6ZSB0b3JlYWQpIGluXG4gICAgICAgICAgaWYgbiA9IDBcbiAgICAgICAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgdXBkYXRlIGN0eCAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWYpIDAgbjtcbiAgICAgICAgICAgIGRvX3JlYWQgKHRvcmVhZCAtIG4pXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgaW4gZG9fcmVhZCB0b3JlYWRcbiAgICBlbmRcblxuICBsZXQgZmlsZSBmaWxlbmFtZSA9XG4gICAgSW5fY2hhbm5lbC53aXRoX29wZW5fYmluIGZpbGVuYW1lIChmdW4gaWMgLT4gY2hhbm5lbCBpYyAoLTEpKVxuXG4gIGxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPSBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbiAgbGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gaGFzaF9sZW5ndGhcblxuICBsZXQgdG9faGV4IGQgPVxuICAgIGlmIFN0cmluZy5sZW5ndGggZCA8PiBoYXNoX2xlbmd0aCB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICAgIGhleF9vZl9zdHJpbmcgZFxuXG4gIGxldCBvZl9oZXggcyA9XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IGhhc2hfbGVuZ3RoICogMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0Lm9mX2hleFwiO1xuICAgIHN0cmluZ19vZl9oZXggc1xuXG5lbmRcblxubW9kdWxlIEJMQUtFMTI4ID0gQkxBS0UyKHN0cnVjdCBsZXQgaGFzaF9sZW5ndGggPSAxNiBlbmQpXG5tb2R1bGUgQkxBS0UyNTYgPSBCTEFLRTIoc3RydWN0IGxldCBoYXNoX2xlbmd0aCA9IDMyIGVuZClcbm1vZHVsZSBCTEFLRTUxMiA9IEJMQUtFMihzdHJ1Y3QgbGV0IGhhc2hfbGVuZ3RoID0gNjQgZW5kKVxuXG4oKiBNRDUgaGFzaGluZyAqKVxuXG5tb2R1bGUgTUQ1ID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgbGV0IGhhc2hfbGVuZ3RoID0gMTZcblxuICBsZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG4gIGxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG4gIGV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG4gIGV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG4gIGxldCBzdHJpbmcgc3RyID1cbiAgICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuICBsZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG4gIGxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxuICBsZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxuICBsZXQgZmlsZSBmaWxlbmFtZSA9XG4gICAgSW5fY2hhbm5lbC53aXRoX29wZW5fYmluIGZpbGVuYW1lIChmdW4gaWMgLT4gY2hhbm5lbCBpYyAoLTEpKVxuXG4gIGxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPSBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbiAgbGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxuICBsZXQgdG9faGV4IGQgPVxuICAgIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICAgIGhleF9vZl9zdHJpbmcgZFxuXG4gIGxldCBvZl9oZXggcyA9XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgICBzdHJpbmdfb2ZfaGV4IHNcblxuZW5kXG5cbigqIERlZmF1bHQgZXhwb3J0ZWQgaW1wbGVtZW50YXRpb24gaXMgTUQ1ICopXG5cbmluY2x1ZGUgTUQ1XG5cbmxldCBmcm9tX2hleCA9IG9mX2hleFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDE2X2VsdCA9IEZsb2F0MTZfZWx0XG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG4oKiBLZWVwIHRoZSBvcmRlciBvZiB0aGVzZSBjb25zdHJ1Y3RvcnMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmRcbiAgIGVudW1lcmF0aW9uIGluIGJpZ2FycmF5LmggKilcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgfCBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgRmxvYXQxNiA6IChmbG9hdCwgZmxvYXQxNl9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG5sZXQgZmxvYXQxNiA9IEZsb2F0MTZcbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MTYgLT4gMlxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG5cbiAgbGV0IHJlYyBjbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sID0gQXJyYXkubGVuZ3RoIGlkeCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMCB0byBwcmVkIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgY2xvb3AgYXJyIGlkeCBmIChzdWNjIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCByZWMgZmxvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA8IDAgdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDEgdG8gbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBmbG9vcCBhcnIgaWR4IGYgKHByZWQgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbXMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW1zIGluXG4gICAgbGV0IGRsZW4gPSBBcnJheS5sZW5ndGggZGltcyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAwKSBmIDAgZGltczsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAxKSBmIChwcmVkIGRsZW4pIGRpbXM7IGFyclxuXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG4gIGxldCBpbml0ID0gb2ZfdmFsdWVcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAxIHRvIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbSBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICBmb3IgayA9IDAgdG8gcHJlZCBkaW0zIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBrID0gMSB0byBkaW0zIGRvXG4gICAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENhbWJpdW0sIENvbGxlZ2UgZGUgRnJhbmNlIGFuZCBJbnJpYSAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yICopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICBvcGVuIEJpZ2FycmF5XG5cbiAgdHlwZSB0ID0gKGludDY0LCBpbnQ2NF9lbHQsIGNfbGF5b3V0KSBBcnJheTEudFxuXG4gIGV4dGVybmFsIG5leHQ6IHQgLT4gKGludDY0W0B1bmJveGVkXSlcbiAgICAgID0gXCJjYW1sX2x4bV9uZXh0XCIgXCJjYW1sX2x4bV9uZXh0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4gIGxldCBjcmVhdGUgKCkgOiB0ID1cbiAgICBBcnJheTEuY3JlYXRlIEludDY0IENfbGF5b3V0IDRcblxuICBsZXQgc2V0IHMgaTEgaTIgaTMgaTQgPVxuICAgIEFycmF5MS51bnNhZmVfc2V0IHMgMCAoSW50NjQubG9nb3IgaTEgMUwpOyAoKiBtdXN0IGJlIG9kZCAqKVxuICAgIEFycmF5MS51bnNhZmVfc2V0IHMgMSBpMjtcbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDIgKGlmIGkzIDw+IDBMIHRoZW4gaTMgZWxzZSAxTCk7ICgqIG11c3Qgbm90IGJlIDAgKilcbiAgICBBcnJheTEudW5zYWZlX3NldCBzIDMgKGlmIGk0IDw+IDBMIHRoZW4gaTQgZWxzZSAyTCkgKCogbXVzdCBub3QgYmUgMCAqKVxuXG4gIGxldCBtayBpMSBpMiBpMyBpNCA9XG4gICAgbGV0IHMgPSBjcmVhdGUgKCkgaW5cbiAgICBzZXQgcyBpMSBpMiBpMyBpNDsgc1xuXG4gIGxldCBzZXJpYWxpemF0aW9uX3ByZWZpeCA9XG4gICAgXCJseG0xOlwiXG4gICAgKCogXCJseG1cIiBkZW5vdGVzIHRoZSBhbGdvcml0aG0gY3VycmVudGx5IGluIHVzZSwgYW5kICcxJyBpc1xuICAgICAgIGEgdmVyc2lvbiBudW1iZXIuIFdlIHNob3VsZCB1cGRhdGUgdGhpcyBwcmVmaXggaWYgd2UgY2hhbmdlXG4gICAgICAgdGhlIFJhbmRvbSBhbGdvcml0aG0gb3IgdGhlIHNlcmlhbGl6YXRpb24gZm9ybWF0LCBzbyB0aGF0IHVzZXJzXG4gICAgICAgZ2V0IGEgY2xlYW4gZXJyb3IgaW5zdGVhZCBvZiBiZWxpZXZpbmcgdGhhdCB0aGV5IGZhaXRoZnVsbHlcbiAgICAgICByZXByb2R1Y2UgdGhlaXIgcHJldmlvdXMgc3RhdGUgYW5kIGluIGZhY3QgZ2V0IGEgZGlmZmVyZW50XG4gICAgICAgc3RyZWFtLlxuXG4gICAgICAgTm90ZSB0aGF0IHRoZXJlIGlzIG5vIGNvbnN0cmFpbnQgdG8ga2VlcCB0aGUgc2FtZVxuICAgICAgIFwiPG5hbWU+PHZlcj46PGRhdGE+XCIgZm9ybWF0IG9yIG1lc3NhZ2Ugc2l6ZSBpbiBmdXR1cmUgdmVyc2lvbnMsXG4gICAgICAgd2UgY291bGQgY2hhbmdlIHRoZSBmb3JtYXQgY29tcGxldGVseSBpZiB3ZSB3YW50ZWQgYXMgbG9uZ1xuICAgICAgIGFzIHRoZXJlIGlzIG5vIGNvbmZ1c2lvbiBwb3NzaWJsZSB3aXRoIHRoZSBwcmV2aW91cyBmb3JtYXRzLiAqKVxuXG4gIGxldCBzZXJpYWxpemF0aW9uX3ByZWZpeF9sZW4gPVxuICAgIFN0cmluZy5sZW5ndGggc2VyaWFsaXphdGlvbl9wcmVmaXhcblxuICBsZXQgdG9fYmluYXJ5X3N0cmluZyBzID1cbiAgICBsZXQgcHJlZml4ID0gc2VyaWFsaXphdGlvbl9wcmVmaXggaW5cbiAgICBsZXQgcHJlZmxlbiA9IHNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKHByZWZsZW4gKyA0ICogOCkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyBwcmVmaXggMCBidWYgMCBwcmVmbGVuO1xuICAgIGZvciBpID0gMCB0byAzIGRvXG4gICAgICBCeXRlcy5zZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgaSAqIDgpIChBcnJheTEuZ2V0IHMgaSlcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG5cbiAgbGV0IG9mX2JpbmFyeV9zdHJpbmcgYnVmID1cbiAgICBsZXQgcHJlZml4ID0gc2VyaWFsaXphdGlvbl9wcmVmaXggaW5cbiAgICBsZXQgcHJlZmxlbiA9IHNlcmlhbGl6YXRpb25fcHJlZml4X2xlbiBpblxuICAgIGlmIFN0cmluZy5sZW5ndGggYnVmIDw+IHByZWZsZW4gKyA0ICogOFxuICAgICAgIHx8IG5vdCAoU3RyaW5nLnN0YXJ0c193aXRoIH5wcmVmaXggYnVmKVxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIChcIlJhbmRvbS5TdGF0ZS5vZl9iaW5hcnlfc3RyaW5nOiBleHBlY3RlZCBhIGZvcm1hdCBcXFxuICAgICAgICAgIGNvbXBhdGlibGUgd2l0aCBPQ2FtbCBcIiBeIFN5cy5vY2FtbF92ZXJzaW9uKTtcbiAgICBsZXQgaTEgPSBTdHJpbmcuZ2V0X2ludDY0X2xlIGJ1ZiAocHJlZmxlbiArIDAgKiA4KSBpblxuICAgIGxldCBpMiA9IFN0cmluZy5nZXRfaW50NjRfbGUgYnVmIChwcmVmbGVuICsgMSAqIDgpIGluXG4gICAgbGV0IGkzID0gU3RyaW5nLmdldF9pbnQ2NF9sZSBidWYgKHByZWZsZW4gKyAyICogOCkgaW5cbiAgICBsZXQgaTQgPSBTdHJpbmcuZ2V0X2ludDY0X2xlIGJ1ZiAocHJlZmxlbiArIDMgKiA4KSBpblxuICAgIG1rIGkxIGkyIGkzIGk0XG5cbiAgbGV0IGFzc2lnbiAoZHN0OiB0KSAoc3JjOiB0KSA9XG4gICAgQXJyYXkxLmJsaXQgc3JjIGRzdFxuXG4gIGxldCBjb3B5IHMgPVxuICAgIGxldCBzJyA9IGNyZWF0ZSgpIGluIGFzc2lnbiBzJyBzOyBzJ1xuXG4gICgqIFRoZSBzZWVkIGlzIGFuIGFycmF5IG9mIGludGVnZXJzLiAgSXQgY2FuIGJlIGp1c3Qgb25lIGludGVnZXIsXG4gICAgIGJ1dCBpdCBjYW4gYWxzbyBiZSAxMiBvciBtb3JlIGJ5dGVzLiAgVG8gaGlkZSB0aGUgZGlmZmVyZW5jZSxcbiAgICAgd2Ugc2VyaWFsaXplIHRoZSBhcnJheSBhcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLCB0aGVuIGhhc2ggdGhlXG4gICAgIHNlcXVlbmNlIHdpdGggTUQ1IChEaWdlc3QuYnl0ZXMpLiAgTUQ1IGdpdmVzIG9ubHkgMTI4IGJpdHMgd2hpbGVcbiAgICAgd2UgbmVlZCAyNTYgYml0cywgc28gd2UgaGFzaCB0d2ljZSB3aXRoIGRpZmZlcmVudCBzdWZmaXhlcy4gKilcbiAgbGV0IHJlaW5pdCBzIHNlZWQgPVxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBsZXQgYiA9IEJ5dGVzLmNyZWF0ZSAobiAqIDggKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgIEJ5dGVzLnNldF9pbnQ2NF9sZSBiIChpICogOCkgKEludDY0Lm9mX2ludCBzZWVkLihpKSlcbiAgICBkb25lO1xuICAgIEJ5dGVzLnNldCBiIChuICogOCkgJ1xceDAxJztcbiAgICBsZXQgZDEgPSBEaWdlc3QuYnl0ZXMgYiBpblxuICAgIEJ5dGVzLnNldCBiIChuICogOCkgJ1xceDAyJztcbiAgICBsZXQgZDIgPSBEaWdlc3QuYnl0ZXMgYiBpblxuICAgIHNldCBzIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQxIDApXG4gICAgICAgICAgKFN0cmluZy5nZXRfaW50NjRfbGUgZDEgOClcbiAgICAgICAgICAoU3RyaW5nLmdldF9pbnQ2NF9sZSBkMiAwKVxuICAgICAgICAgIChTdHJpbmcuZ2V0X2ludDY0X2xlIGQyIDgpXG5cbiAgbGV0IG1ha2Ugc2VlZCA9XG4gICAgbGV0IHMgPSBjcmVhdGUoKSBpbiByZWluaXQgcyBzZWVkOyBzXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID1cbiAgICBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgbWluX2ludDMxID0gLTB4NDAwMF8wMDAwXG4gICAgICAoKiA9IC0ye14zMH0sIHdoaWNoIGlzIFttaW5faW50XSBmb3IgMzEtYml0IGludGVnZXJzICopXG4gIGxldCBtYXhfaW50MzEgPSAweDNGRkZfRkZGRlxuICAgICAgKCogPSAgMnteMzB9LTEsIHdoaWNoIGlzIFttYXhfaW50XSBmb3IgMzEtYml0IGludGVnZXJzICopXG4gICgqIGF2b2lkIGludGVnZXIgbGl0ZXJhbHMgZm9yIHRoZXNlLCAzMi1iaXQgT0NhbWwgd291bGQgcmVqZWN0IHRoZW06ICopXG4gIGxldCBtaW5faW50MzIgPSAtKDEgbHNsIDMxKVxuICAgICAgKCogPSAtMHg4MDAwXzAwMDAgb24gcGxhdGZvcm1zIHdoZXJlIFtTeXMuaW50X3NpemUgPj0gMzJdICopXG4gIGxldCBtYXhfaW50MzIgPSAoMSBsc2wgMzEpIC0gMVxuICAgICAgKCogPSAgMHg3RkZGX0ZGRkYgb24gcGxhdGZvcm1zIHdoZXJlIFtTeXMuaW50X3NpemUgPj0gMzJdICopXG5cbiAgKCogUmV0dXJuIDMwIHJhbmRvbSBiaXRzIGFzIGFuIGludGVnZXIgMCA8PSB4IDwgMl4zMCAqKVxuICBsZXQgYml0cyBzID1cbiAgICBJbnQ2NC50b19pbnQgKG5leHQgcykgbGFuZCBtYXhfaW50MzFcblxuICAoKiBSZXR1cm4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW25dIChleGNsdWRlZCkuXG4gICAgIFtib3VuZF0gbWF5IGJlIGFueSBwb3NpdGl2ZSBbaW50XS4gIFttYXNrXSBtdXN0IGJlIG9mIHRoZSBmb3JtIFsye15pfS0xXVxuICAgICBhbmQgZ3JlYXRlciBvciBlcXVhbCB0byBbbl0uICBMYXJnZXIgdmFsdWVzIG9mIFttYXNrXSBtYWtlIHRoZSBmdW5jdGlvblxuICAgICBydW4gZmFzdGVyIChmZXdlciBzYW1wbGVzIGFyZSByZWplY3RlZCkuICBTbWFsbGVyIHZhbHVlcyBvZiBbbWFza11cbiAgICAgYXJlIHVzYWJsZSBvbiBhIHdpZGVyIHJhbmdlIG9mIE9DYW1sIGltcGxlbWVudGF0aW9ucy4gICopXG4gIGxldCByZWMgaW50X2F1eCBzIG4gbWFzayA9XG4gICAgKCogV2Ugc3RhcnQgYnkgZHJhd2luZyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGluIHRoZSBbIFswLCBtYXNrXSBdIHJhbmdlICopXG4gICAgbGV0IHIgPSBJbnQ2NC50b19pbnQgKG5leHQgcykgbGFuZCBtYXNrIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgKCogRm9yIHVuaWZvcm0gZGlzdHJpYnV0aW9uIG9mIHRoZSByZXN1bHQgYmV0d2VlbiAwIGluY2x1ZGVkIGFuZCBbbl1cbiAgICAgKiBleGNsdWRlZCwgdGhlIHJhbmRvbSBudW1iZXIgW3JdIG11c3QgaGF2ZSBiZWVuIGRyYXduIHVuaWZvcm1seSBpblxuICAgICAqIGFuIGludGVydmFsIHdob3NlIGxlbmd0aCBpcyBhIG11bHRpcGxlIG9mIFtuXS4gVG8gYWNoaWV2ZSB0aGlzLFxuICAgICAqIHdlIHVzZSByZWplY3Rpb24gc2FtcGxpbmcgb24gdGhlIGdyZWF0ZXN0IGludGVydmFsIFsgWzAsIGsqbi0xXSBdXG4gICAgICogdGhhdCBmaXRzIGluIFsgWzAsIG1hc2tdIF0uICBUaGF0IGlzLCB3ZSByZWplY3QgdGhlXG4gICAgICogc2FtcGxlIGlmIGl0IGZhbGxzIG91dHNpZGUgb2YgdGhpcyBpbnRlcnZhbCwgYW5kIGRyYXcgYWdhaW4uXG4gICAgICogVGhpcyBpcyB3aGF0IHRoZSB0ZXN0IGJlbG93IGRvZXMsIHdoaWxlIGNhcmVmdWx5IGF2b2lkaW5nXG4gICAgICogb3ZlcmZsb3dzIGFuZCBzcGFyaW5nIGEgZGl2aXNpb24gW21hc2sgLyBuXS4gKilcbiAgICBpZiByIC0gdiA+IG1hc2sgLSBuICsgMSB0aGVuIGludF9hdXggcyBuIG1hc2sgZWxzZSB2XG5cbiAgKCogUmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiAwIChpbmNsdWRlZCkgYW5kIFtib3VuZF0gKGV4Y2x1ZGVkKS5cbiAgICAgVGhlIGJvdW5kIG11c3QgZml0IGluIDMxLWJpdCBzaWduZWQgaW50ZWdlcnMuXG4gICAgIFRoaXMgZnVuY3Rpb24geWllbGRzIHRoZSBzYW1lIG91dHB1dCByZWdhcmRsZXNzIG9mIHRoZSBpbnRlZ2VyIHNpemUuICopXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiBtYXhfaW50MzEgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludF9hdXggcyBib3VuZCBtYXhfaW50MzFcblxuICAoKiBSZXR1cm4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgKGluY2x1ZGVkKSBhbmQgW2JvdW5kXSAoZXhjbHVkZWQpLlxuICAgICBbYm91bmRdIG1heSBiZSBhbnkgcG9zaXRpdmUgW2ludF0uICopXG4gIGxldCBmdWxsX2ludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiUmFuZG9tLmZ1bGxfaW50XCJcbiAgICAoKiBXaGVuIHRoZSBib3VuZCBmaXRzIGluIDMxLWJpdCBzaWduZWQgaW50ZWdlcnMsIHdlIHVzZSB0aGUgc2FtZSBtYXNrXG4gICAgICAgYXMgaW4gZnVuY3Rpb24gW2ludF0gc28gYXMgdG8geWllbGQgdGhlIHNhbWUgb3V0cHV0IG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICBzdXBwb3J0ZWQgYnkgT0NhbWwgKDMyLWJpdCBPQ2FtbCwgNjQtYml0IE9DYW1sLCBhbmQgSmF2YVNjcmlwdCkuXG4gICAgICAgV2hlbiB0aGUgYm91bmQgZml0cyBpbiAzMi1iaXQgc2lnbmVkIGludGVnZXJzLCB3ZSB1c2UgW21heF9pbnQzMl1cbiAgICAgICBhcyB0aGUgbWFzayBzbyBhcyB0byB5aWVsZCB0aGUgc2FtZSBvdXRwdXQgb24gYWxsIHBsYXRmb3JtcyB3aGVyZVxuICAgICAgIFtTeXMuaW50X3NpemUgPj0gMzJdIChpLmUuIEphdmFTY3JpcHQgYW5kIDY0LWJpdCBPQ2FtbCkuICopXG4gICAgZWxzZVxuICAgICAgaW50X2F1eCBzIGJvdW5kXG4gICAgICAgIChpZiBib3VuZCA8PSBtYXhfaW50MzEgdGhlbiBtYXhfaW50MzFcbiAgICAgICAgIGVsc2UgaWYgYm91bmQgPD0gbWF4X2ludDMyIHRoZW4gbWF4X2ludDMyXG4gICAgICAgICBlbHNlIG1heF9pbnQpXG5cbiAgKCogUmV0dXJuIGFuIGludGVnZXIgYmV0d2VlbiBbbWluXSAoaW5jbHVkZWQpIGFuZCBbbWF4XSAoaW5jbHVkZWQpLlxuICAgICBUaGUgW25iaXRzXSBwYXJhbWV0ZXIgaXMgdGhlIHNpemUgaW4gYml0cyBvZiB0aGUgc2lnbmVkIGludGVnZXJzXG4gICAgIHdlIGRyYXcgZnJvbSBbc10uXG4gICAgIFdlIG11c3QgaGF2ZSBbLTJ7Xm5iaXRzIC0gMX0gPD0gbWluIDw9IG1heCA8IDJ7Xm5iaXRzIC0gMX1dLlxuICAgICBNb3Jlb3ZlciwgZm9yIHRoZSBpdGVyYXRpb24gdG8gY29udmVyZ2UgcXVpY2tseSwgdGhlIGludGVydmFsXG4gICAgIFtbbWluLCBtYXhdXSBzaG91bGQgaGF2ZSB3aWR0aCBhdCBsZWFzdCBbMntebmJpdHMgLSAxfV0uXG4gICAgIEFzIHRoZSB3aWR0aCBhcHByb2FjaGVzIHRoaXMgbG93ZXIgbGltaXQsIHRoZSBhdmVyYWdlIG51bWJlciBvZlxuICAgICBkcmF3cyBhcHByb2FjaGVzIDIsIHdpdGggYSBxdWl0ZSBoaWdoIHN0YW5kYXJkIGRldmlhdGlvbiAoMiArIGVwc2lsb24pLiAqKVxuICBsZXQgcmVjIGludF9pbl9sYXJnZV9yYW5nZSBzIH5taW4gfm1heCB+bmJpdHMgPVxuICAgIGxldCBkcm9wID0gU3lzLmludF9zaXplIC0gbmJpdHMgaW5cbiAgICAoKiBUaGUgYml0c2hpZnRzIHJlcGxpY2F0ZSB0aGUgW25iaXRzXS10aCBiaXQgKHNpZ24gYml0KSB0byBoaWdoZXIgYml0czogKilcbiAgICBsZXQgciA9ICgoSW50NjQudG9faW50IChuZXh0IHMpKSBsc2wgZHJvcCkgYXNyIGRyb3AgaW5cbiAgICBpZiByIDwgbWluIHx8IHIgPiBtYXggdGhlbiBpbnRfaW5fbGFyZ2VfcmFuZ2UgcyB+bWluIH5tYXggfm5iaXRzIGVsc2UgclxuXG4gICgqIFJldHVybiBhbiBpbnRlZ2VyIGJldHdlZW4gW21pbl0gKGluY2x1ZGVkKSBhbmQgW21heF0gKGluY2x1ZGVkKS5cbiAgICAgW21hc2tdIGlzIGFzIGRlc2NyaWJlZCBmb3IgW2ludF9hdXhdLlxuICAgICBbbmJpdHNdIGlzIGFzIGRlc2NyaWJlZCBmb3IgW2ludF9pbl9sYXJnZV9yYW5nZV0uICopXG4gIGxldCBpbnRfaW5fcmFuZ2VfYXV4IHMgfm1pbiB+bWF4IH5tYXNrIH5uYml0cyA9XG4gICAgbGV0IHNwYW4gPSBtYXggLSBtaW4gKyAxIGluXG4gICAgaWYgc3BhbiA8PSBtYXNrICgqIFtzcGFuXSBpcyBzbWFsbCBlbm91Z2ggKilcbiAgICAmJiBzcGFuID4gMCAgICAgKCogbm8gb3ZlcmZsb3cgb2NjdXJyZWQgd2hlbiBjb21wdXRpbmcgW3NwYW5dICopXG4gICAgdGhlblxuICAgICAgKCogSnVzdCBkcmF3IGEgbnVtYmVyIGluIFtbMCwgc3BhbildIGFuZCBzaGlmdCBpdCBieSBbbWluXS4gKilcbiAgICAgIG1pbiArIGludF9hdXggcyBzcGFuIG1hc2tcbiAgICBlbHNlXG4gICAgICAoKiBTcGFuIHRvbyBsYXJnZSwgdXNlIHRoZSBhbHRlcm5hdGl2ZSBkcmF3aW5nIG1ldGhvZC4gKilcbiAgICAgIGludF9pbl9sYXJnZV9yYW5nZSBzIH5taW4gfm1heCB+bmJpdHNcblxuICAoKiBSZXR1cm4gYW4gaW50ZWdlciBiZXR3ZWVuIFttaW5dIChpbmNsdWRlZCkgYW5kIFttYXhdIChpbmNsdWRlZCkuXG4gICAgIFdlIG11c3QgaGF2ZSBbbWluIDw9IG1heF0uICopXG4gIGxldCBpbnRfaW5fcmFuZ2UgcyB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnRfaW5fcmFuZ2VcIjtcbiAgICAoKiBXaGVuIGJvdGggYm91bmRzIGZpdCBpbiAzMS1iaXQgc2lnbmVkIGludGVnZXJzLCB3ZSB1c2UgcGFyYW1ldGVyc1xuICAgICAgIFttYXNrXSBhbmQgW25iaXRzXSBhcHByb3ByaWF0ZSBmb3IgMzEtYml0IGludGVnZXJzLCBzbyBhcyB0b1xuICAgICAgIHlpZWxkIHRoZSBzYW1lIG91dHB1dCBvbiBhbGwgcGxhdGZvcm1zIHN1cHBvcnRlZCBieSBPQ2FtbC5cbiAgICAgICBXaGVuIGJvdGggYm91bmRzIGZpdCBpbiAzMi1iaXQgc2lnbmVkIGludGVnZXJzLCB3ZSB1c2UgcGFyYW1ldGVyc1xuICAgICAgIFttYXNrXSBhbmQgW25iaXRzXSBhcHByb3ByaWF0ZSBmb3IgMzItYml0IGludGVnZXJzLCBzbyBhcyB0b1xuICAgICAgIHlpZWxkIHRoZSBzYW1lIG91dHB1dCBvbiBKYXZhU2NyaXB0IGFuZCBvbiA2NC1iaXQgT0NhbWwuICopXG4gICAgaWYgbWluID49IG1pbl9pbnQzMSAmJiBtYXggPD0gbWF4X2ludDMxIHRoZW5cbiAgICAgIGludF9pbl9yYW5nZV9hdXggcyB+bWluIH5tYXggfm1hc2s6bWF4X2ludDMxIH5uYml0czozMVxuICAgIGVsc2UgaWYgbWluID49IG1pbl9pbnQzMiAmJiBtYXggPD0gbWF4X2ludDMyIHRoZW5cbiAgICAgIGludF9pbl9yYW5nZV9hdXggcyB+bWluIH5tYXggfm1hc2s6bWF4X2ludDMyIH5uYml0czozMlxuICAgIGVsc2VcbiAgICAgIGludF9pbl9yYW5nZV9hdXggcyB+bWluIH5tYXggfm1hc2s6bWF4X2ludCB+bmJpdHM6U3lzLmludF9zaXplXG5cbiAgKCogUmV0dXJuIDMyIHJhbmRvbSBiaXRzIGFzIGFuIFtpbnQzMl0gKilcbiAgbGV0IGJpdHMzMiBzID1cbiAgICBJbnQ2NC50b19pbnQzMiAobmV4dCBzKVxuXG4gICgqIFJldHVybiBhbiBbaW50MzJdIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgaW50MzJhdXggcyBuID1cbiAgICBsZXQgciA9IEludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJpdHMzMiBzKSAxIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgKCogRXhwbGFuYXRpb24gb2YgdGhpcyB0ZXN0OiBzZWUgY29tbWVudCBpbiBbaW50X2F1eF0uICopXG4gICAgaWYgSW50MzIuKHN1YiByIHYgPiBhZGQgKHN1YiBtYXhfaW50IG4pIDFsKVxuICAgIHRoZW4gaW50MzJhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDMyIHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMlwiXG4gICAgZWxzZSBpbnQzMmF1eCBzIGJvdW5kXG5cbiAgKCogUmV0dXJuIGFuIFtpbnQzMl0gYmV0d2VlbiBbbWluXSAoaW5jbHVkZWQpIGFuZCBbbWF4XSAoaW5jbHVkZWQpLlxuICAgICBXZSBtdXN0IGhhdmUgW21pbiA8PSBtYXhdLiAqKVxuICBsZXQgcmVjIGludDMyX2luX3JhbmdlX2F1eCBzIH5taW4gfm1heCA9XG4gICAgbGV0IHIgPSBJbnQ2NC50b19pbnQzMiAobmV4dCBzKSBpblxuICAgIGlmIHIgPCBtaW4gfHwgciA+IG1heCB0aGVuIGludDMyX2luX3JhbmdlX2F1eCBzIH5taW4gfm1heCBlbHNlIHJcblxuICBsZXQgaW50MzJfaW5fcmFuZ2UgcyB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heCB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMl9pbl9yYW5nZVwiXG4gICAgZWxzZVxuICAgICAgbGV0IHNwYW4gPSBJbnQzMi5zdWNjIChJbnQzMi5zdWIgbWF4IG1pbikgaW5cbiAgICAgICgqIEV4cGxhbmF0aW9uIG9mIHRoaXMgdGVzdDogc2VlIGNvbW1lbnQgaW4gW2ludF9pbl9yYW5nZV9hdXhdLiAqKVxuICAgICAgaWYgc3BhbiA8PSBJbnQzMi56ZXJvIHRoZW5cbiAgICAgICAgaW50MzJfaW5fcmFuZ2VfYXV4IHMgfm1pbiB+bWF4XG4gICAgICBlbHNlXG4gICAgICAgIEludDMyLmFkZCBtaW4gKGludDMyYXV4IHMgc3BhbilcblxuICAoKiBSZXR1cm4gNjQgcmFuZG9tIGJpdHMgYXMgYW4gW2ludDY0XSAqKVxuICBsZXQgYml0czY0IHMgPVxuICAgIG5leHQgc1xuXG4gICgqIFJldHVybiBhbiBbaW50NjRdIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgciA9IEludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJpdHM2NCBzKSAxIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgKCogRXhwbGFuYXRpb24gb2YgdGhpcyB0ZXN0OiBzZWUgY29tbWVudCBpbiBbaW50X2F1eF0uICopXG4gICAgaWYgSW50NjQuKHN1YiByIHYgPiBhZGQgKHN1YiBtYXhfaW50IG4pIDFMKVxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cbiAgKCogUmV0dXJuIGFuIFtpbnQ2NF0gYmV0d2VlbiBbbWluXSAoaW5jbHVkZWQpIGFuZCBbbWF4XSAoaW5jbHVkZWQpLlxuICAgICBXZSBtdXN0IGhhdmUgW21pbiA8PSBtYXhdLiAqKVxuICBsZXQgcmVjIGludDY0X2luX3JhbmdlX2F1eCBzIH5taW4gfm1heCA9XG4gICAgbGV0IHIgPSBuZXh0IHMgaW5cbiAgICBpZiByIDwgbWluIHx8IHIgPiBtYXggdGhlbiBpbnQ2NF9pbl9yYW5nZV9hdXggcyB+bWluIH5tYXggZWxzZSByXG5cbiAgbGV0IGludDY0X2luX3JhbmdlIHMgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXggdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJSYW5kb20uaW50NjRfaW5fcmFuZ2VcIlxuICAgIGVsc2VcbiAgICAgIGxldCBzcGFuID0gSW50NjQuc3VjYyAoSW50NjQuc3ViIG1heCBtaW4pIGluXG4gICAgICAoKiBFeHBsYW5hdGlvbiBvZiB0aGlzIHRlc3Q6IHNlZSBjb21tZW50IGluIFtpbnRfaW5fcmFuZ2VfYXV4XS4gKilcbiAgICAgIGlmIHNwYW4gPD0gSW50NjQuemVybyB0aGVuXG4gICAgICAgIGludDY0X2luX3JhbmdlX2F1eCBzIH5taW4gfm1heFxuICAgICAgZWxzZVxuICAgICAgICBJbnQ2NC5hZGQgbWluIChpbnQ2NGF1eCBzIHNwYW4pXG5cbiAgKCogUmV0dXJuIDMyIG9yIDY0IHJhbmRvbSBiaXRzIGFzIGEgW25hdGl2ZWludF0gKilcbiAgbGV0IG5hdGl2ZWJpdHMgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoYml0czMyIHMpXG4gICAgZWxzZSBmdW4gcyAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGJpdHM2NCBzKVxuXG4gICgqIFJldHVybiBhIFtuYXRpdmVpbnRdIGJldHdlZW4gMCAoaW5jbHVkZWQpIGFuZCBbYm91bmRdIChleGNsdWRlZCkuICopXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuICAoKiBSZXR1cm4gYSBbbmF0aXZlaW50XSBiZXR3ZWVuIFttaW5dIChpbmNsdWRlZCkgYW5kIFttYXhdIChpbmNsdWRlZCkuICopXG4gIGxldCBuYXRpdmVpbnRfaW5fcmFuZ2UgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIH5taW4gfm1heCAtPlxuICAgICAgTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMl9pbl9yYW5nZSBzXG4gICAgICAgIH5taW46KE5hdGl2ZWludC50b19pbnQzMiBtaW4pIH5tYXg6KE5hdGl2ZWludC50b19pbnQzMiBtYXgpKVxuICAgIGVsc2UgZnVuIHMgfm1pbiB+bWF4IC0+XG4gICAgICBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0X2luX3JhbmdlIHNcbiAgICAgICAgfm1pbjooSW50NjQub2ZfbmF0aXZlaW50IG1pbikgfm1heDooSW50NjQub2ZfbmF0aXZlaW50IG1heCkpXG5cbiAgKCogUmV0dXJuIGEgZmxvYXQgMCA8IHggPCAxIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhbW9uZyB0aGVcbiAgICAgbXVsdGlwbGVzIG9mIDJeLTUzICopXG4gIGxldCByZWMgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IGIgPSBuZXh0IHMgaW5cbiAgICBsZXQgbiA9IEludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYiAxMSBpblxuICAgIGlmIG4gPD4gMEwgdGhlbiBJbnQ2NC50b19mbG9hdCBuICouIDB4MS5wLTUzIGVsc2UgcmF3ZmxvYXQgc1xuXG4gICgqIFJldHVybiBhIGZsb2F0IGJldHdlZW4gMCBhbmQgW2JvdW5kXSAqKVxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICAoKiBSZXR1cm4gYSByYW5kb20gQm9vbGVhbiAqKVxuICBsZXQgYm9vbCBzID0gbmV4dCBzIDwgMExcblxuICAoKiBTcGxpdCBhIG5ldyBQUk5HIG9mZiB0aGUgZ2l2ZW4gUFJORyAqKVxuICBsZXQgc3BsaXQgcyA9XG4gICAgbGV0IGkxID0gYml0czY0IHMgaW4gbGV0IGkyID0gYml0czY0IHMgaW5cbiAgICBsZXQgaTMgPSBiaXRzNjQgcyBpbiBsZXQgaTQgPSBiaXRzNjQgcyBpblxuICAgIG1rIGkxIGkyIGkzIGk0XG5lbmRcblxubGV0IG1rX2RlZmF1bHQgKCkgPVxuICAoKiBUaGlzIGlzIHRoZSBzdGF0ZSBvYnRhaW5lZCB3aXRoIFtTdGF0ZS5tYWtlIFt8IDMxNDE1OTI2NSB8XV0uICopXG4gIFN0YXRlLm1rICgtNjE5Njg3NDI4OTU2NzcwNTA5N0wpXG4gICAgICAgICAgIDU4NjU3MzI0OTgzMzcxMzE4OUxcbiAgICAgICAgICAgKC04NTkxMjY4ODAzODY1MDQzNDA3TClcbiAgICAgICAgICAgNjM4ODYxMzU5NTg0OTc3MjA0NExcblxubGV0IHJhbmRvbV9rZXkgPVxuICBEb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50OlN0YXRlLnNwbGl0IG1rX2RlZmF1bHRcblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KVxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBmdWxsX2ludCBib3VuZCA9IFN0YXRlLmZ1bGxfaW50IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IGludF9pbl9yYW5nZSB+bWluIH5tYXggPVxuICBTdGF0ZS5pbnRfaW5fcmFuZ2UgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIH5taW4gfm1heFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIGJvdW5kXG5sZXQgaW50MzJfaW5fcmFuZ2Ugfm1pbiB+bWF4ID1cbiAgU3RhdGUuaW50MzJfaW5fcmFuZ2UgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIH5taW4gfm1heFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgYm91bmRcbmxldCBuYXRpdmVpbnRfaW5fcmFuZ2Ugfm1pbiB+bWF4ID1cbiAgU3RhdGUubmF0aXZlaW50X2luX3JhbmdlIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSB+bWluIH5tYXhcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBib3VuZFxubGV0IGludDY0X2luX3JhbmdlIH5taW4gfm1heCA9XG4gIFN0YXRlLmludDY0X2luX3JhbmdlIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSB+bWluIH5tYXhcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IChEb21haW4uRExTLmdldCByYW5kb21fa2V5KSBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChEb21haW4uRExTLmdldCByYW5kb21fa2V5KVxubGV0IGJpdHMzMiAoKSA9IFN0YXRlLmJpdHMzMiAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSlcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgbmF0aXZlYml0cyAoKSA9IFN0YXRlLm5hdGl2ZWJpdHMgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLnJlaW5pdCAoRG9tYWluLkRMUy5nZXQgcmFuZG9tX2tleSkgc2VlZFxubGV0IGluaXQgc2VlZCA9IGZ1bGxfaW5pdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBTcGxpdHRpbmcgKilcblxubGV0IHNwbGl0ICgpID0gU3RhdGUuc3BsaXQgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKERvbWFpbi5ETFMuZ2V0IHJhbmRvbV9rZXkpIHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiB0aGUgbG9hZCBmYWN0b3IgYmVjb21lcyB0b28gaGlnaC4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gQXRvbWljLm1ha2UgcmFuZG9taXplZF9kZWZhdWx0XG5cbmxldCByYW5kb21pemUgKCkgPSBBdG9taWMuc2V0IHJhbmRvbWl6ZWQgdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSBBdG9taWMuZ2V0IHJhbmRvbWl6ZWRcblxubGV0IHBybmdfa2V5ID0gRG9tYWluLkRMUy5uZXdfa2V5IFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdFxuXG4oKiBGdW5jdGlvbnMgd2hpY2ggYXBwZWFyIGJlZm9yZSB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgbXVzdCBlaXRoZXIgYmVcbiAgIGluZGVwZW5kZW50IG9mIHRoZSBoYXNoIGZ1bmN0aW9uIG9yIHRha2UgaXQgYXMgYSBwYXJhbWV0ZXIgKHNlZSAjMjIwMiBhbmRcbiAgIGNvZGUgYmVsb3cgdGhlIGZ1bmN0b3IgZGVmaW5pdGlvbnMuICopXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gQXRvbWljLmdldCByYW5kb21pemVkKSBpbml0aWFsX3NpemUgPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gIGxldCBzZWVkID1cbiAgICBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoRG9tYWluLkRMUy5nZXQgcHJuZ19rZXkpIGVsc2UgMFxuICBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IEludC5tYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc2VlZGVkX2hhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBrZXkgbmV4dFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBtZW1faW5fYnVja2V0IGtleSBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBzZWVkZWRfaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4oKiBQb2x5bW9ycGhpYyBoYXNoIGZ1bmN0aW9uLWJhc2VkIHRhYmxlcyAqKVxuKCogQ29kZSBpbmNsdWRlZCBiZWxvdyB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgdG8gZ3VhcmQgYWdhaW5zdCBhY2NpZGVudGFsXG4gICB1c2UgLSBzZWUgIzIyMDIgKilcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5sZXQgaGFzaF9wYXJhbSBuMSBuMiB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gbjEgbjIgMCB4XG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxuXG5sZXQga2V5X2luZGV4IGgga2V5ID1cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDRcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIGludmFsaWRfYXJnIFwiSGFzaHRibDogdW5zdXBwb3J0ZWQgaGFzaCB0YWJsZSBmb3JtYXRcIlxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIFtdXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGRhdGEgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG5sZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICBlbmRcblxubGV0IHJlYyBtZW1faW5fYnVja2V0IGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgIGNvbXBhcmUgayBrZXkgPSAwIHx8IG1lbV9pbl9idWNrZXQga2V5IG5leHRcblxubGV0IG1lbSBoIGtleSA9XG4gIG1lbV9pbl9idWNrZXQga2V5IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgYWRkX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxubGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgdGJsXG5cbmxldCByZWJ1aWxkID8ocmFuZG9tID0gQXRvbWljLmdldCByYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKERvbWFpbi5ETFMuZ2V0IHBybmdfa2V5KVxuICAgIGVsc2UgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLnNlZWRcbiAgICBlbHNlIDAgaW5cbiAgbGV0IGgnID0ge1xuICAgIHNpemUgPSBoLnNpemU7XG4gICAgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eTtcbiAgICBzZWVkID0gc2VlZDtcbiAgICBpbml0aWFsX3NpemUgPSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguaW5pdGlhbF9zaXplIGVsc2Ugc1xuICB9IGluXG4gIGluc2VydF9hbGxfYnVja2V0cyAoa2V5X2luZGV4IGgnKSBmYWxzZSBoLmRhdGEgaCcuZGF0YTtcbiAgaCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICEnYSB0XG5cbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0ID0gXCJjYW1sX3dlYWtfY3JlYXRlXCJcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlclxuICogICAgLSBMaW5rXG4gKiAgICAtIERhdGEgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDIgKCogQ0FNTF9FUEhFX0ZJUlNUX0tFWSBpbiB3ZWFrLmggKilcblxubGV0IGNyZWF0ZSBsID1cbiAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBPYmouRXBoZW1lcm9uLm1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgIGludmFsaWRfYXJnKFwiV2Vhay5jcmVhdGVcIik7XG4gIGNyZWF0ZSBsXG5cblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5sZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgIGludmFsaWRfYXJnKG1zZylcblxuZXh0ZXJuYWwgc2V0JyA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbmV4dGVybmFsIHVuc2V0IDogJ2EgdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG5sZXQgc2V0IGUgbyB4ID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5zZXRcIjtcbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB1bnNldCBlIG9cbiAgfCBTb21lIHggLT4gc2V0JyBlIG8geFxuXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxubGV0IGdldCBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldFwiO1xuICBnZXQgZSBvXG5cbmV4dGVybmFsIGdldF9jb3B5IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0X2NvcHlcIlxubGV0IGdldF9jb3B5IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0X2NvcHlcIjtcbiAgZ2V0X2NvcHkgZSBvXG5cbmV4dGVybmFsIGNoZWNrIDogJ2EgdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF93ZWFrX2NoZWNrXCJcbmxldCBjaGVjayBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmNoZWNrXCI7XG4gIGNoZWNrIGUgb1xuXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcblxuKCogYmxpdDogc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiAqKVxubGV0IGJsaXQgZTEgbzEgZTIgbzIgbCA9XG4gIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICB0aGVuIGludmFsaWRfYXJnIFwiV2Vhay5ibGl0XCJcbiAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0IGUxIG8xIGUyIG8yIGxcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhciAtIGxlblxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYWNjIC0+ICdhY2MpIC0+IHQgLT4gJ2FjYyAtPiAnYWNjXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBJbnQubWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBwcmV2X2xlbiBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHByZXZfbGVuO1xuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBBcnJheS5zdWIgaGJ1Y2tldCAwIHByZXZfbGVuXG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBJbnQubWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG4gICgqIEdlbmVyYWwgYXV4aWxpYXJ5IGZ1bmN0aW9uIGZvciBzZWFyY2hpbmcgZm9yIGEgcGFydGljdWxhciB2YWx1ZVxuICAgKiBpbiBhIGhhc2gtc2V0LCBhbmQgYWN0aW5nIGFjY29yZGluZyB0byB3aGV0aGVyIG9yIG5vdCBpdCdzIGZvdW5kICopXG5cbiAgbGV0IGZpbmRfYXV4IHQgZCBmb3VuZCBub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIG5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiBhcyBvcHQgd2hlbiBILmVxdWFsIHYgZCAtPiBmb3VuZCBidWNrZXQgaSBvcHQgdlxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gIGxldCBmaW5kX29wdCB0IGQgPSBmaW5kX2F1eCB0IGQgKGZ1biBfYiBfaSAgbyBfdiAtPiBvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gX2ggX2kgLT4gTm9uZSlcblxuICBsZXQgbWVyZ2UgdCBkICAgID0gZmluZF9hdXggdCBkIChmdW4gX2IgX2kgX28gIHYgLT4gdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuICBoICBpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGk7IGQpXG5cbiAgbGV0IGZpbmQgdCBkICAgICA9IGZpbmRfYXV4IHQgZCAoZnVuIF9iIF9pIF9vICB2IC0+IHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1biBfaCBfaSAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IHJlbW92ZSB0IGQgICA9IGZpbmRfYXV4IHQgZCAoZnVuICBiICBpIF9vIF92IC0+IHNldCBiIGkgTm9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIF9oIF9pIC0+ICgpKVxuXG4gIGxldCBtZW0gdCBkICAgICAgPSBmaW5kX2F1eCB0IGQgKGZ1biBfYiBfaSBfbyBfdiAtPiB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmdW4gX2ggX2kgLT4gZmFsc2UpXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IEludC5taW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCAwLCBcIlwiKSB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgKGJlZm9yZSwgd2lkdGgsIGFmdGVyKSA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcbiAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9maXRzIHwgUHBfaGJveCAtPiAoKVxuICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS50YWtlX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBwcmludF9pZl9uZXdsaW5lIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHByaW50aW5nIGNvbW1hbmQgKilcbiAgfCBTb21lIHsgc2l6ZTsgbGVuZ3RoOyBfIH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW5ndGg7XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgU2l6ZS50b19pbnQgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgc1xuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCB3aWR0aCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYm94X3R5cGUgPVxuICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0cyBpblxuICAgIFN0YWNrLnB1c2ggeyBib3hfdHlwZTsgd2lkdGggfSBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBTdGFjay5wdXNoIHRib3ggc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IFtdIC0+IGluc2VydGlvbl9wb2ludFxuICAgICAgICB8IGZpcnN0IDo6IF8gLT5cbiAgICAgICAgICBsZXQgcmVjIGZpbmQgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgaWYgaGVhZCA+PSBpbnNlcnRpb25fcG9pbnQgdGhlbiBoZWFkIGVsc2UgZmluZCB0YWlsXG4gICAgICAgICAgICB8IFtdIC0+IGZpcnN0IGluXG4gICAgICAgICAgZmluZCAhdGFicyBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChcIlwiLCBvZmZzZXQgKyBuLCBcIlwiKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgdGFiICsgb2ZmLCBcIlwiKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IHdpZHRoOyBffSAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSAtPlxuICAgIGxldCBiZWZvcmUsIG9mZiwgXyA9IGJyZWFrcyBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICAgIGJlZ2luIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzIGVsc2VcbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgcmVjIGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnBlZWtfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIE5vIHRva2VucyB0byBwcmludCAqKVxuICB8IFNvbWUgeyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gLT5cbiAgICBsZXQgcGVuZGluZ19jb3VudCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCBpblxuICAgIGlmIFNpemUuaXNfa25vd24gc2l6ZSB8fCBwZW5kaW5nX2NvdW50ID49IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiBiZWdpblxuICAgICAgUXVldWUudGFrZSBzdGF0ZS5wcF9xdWV1ZSB8PiBpZ25vcmU7ICgqIE5vdCBlbXB0eTogd2UgcGVlayBpbnRvIGl0ICopXG4gICAgICBsZXQgc2l6ZSA9IGlmIFNpemUuaXNfa25vd24gc2l6ZSB0aGVuIFNpemUudG9faW50IHNpemUgZWxzZSBwcF9pbmZpbml0eSBpblxuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgdG9rZW47XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbmd0aCArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICAoYWR2YW5jZV9sZWZ0IFtAdGFpbGNhbGxdKSBzdGF0ZVxuICAgIGVuZFxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemU7IHRva2VuID0gUHBfdGV4dCBzOyBsZW5ndGggPSBTaXplLnRvX2ludCBzaXplIH1cblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChTaXplLm9mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSkgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YWNrID1cbiAgU3RhY2suY2xlYXIgc3RhY2s7XG4gIGxldCBxdWV1ZV9lbGVtID0geyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX3RleHQgXCJcIjsgbGVuZ3RoID0gMCB9IGluXG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gLTE7IHF1ZXVlX2VsZW0gfSBzdGFja1xuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbiAgfCBTb21lIHsgbGVmdF90b3RhbDsgcXVldWVfZWxlbSB9IC0+XG4gICAgbGV0IHNpemUgPSBTaXplLnRvX2ludCBxdWV1ZV9lbGVtLnNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3RhbCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlblxuICAgICAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2tcbiAgICBlbHNlXG4gICAgICBtYXRjaCBxdWV1ZV9lbGVtLnRva2VuIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgXyB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZSB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRva2VuID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbjtcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIGxldCBlbGVtID0geyBsZWZ0X3RvdGFsID0gc3RhdGUucHBfcmlnaHRfdG90YWw7IHF1ZXVlX2VsZW0gPSB0b2tlbiB9IGluXG4gIFN0YWNrLnB1c2ggZWxlbSBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF9iZWdpbiAoaW5kZW50LCBicl90eSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMCB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fc3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBsZXQgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbjsgbGVuZ3RoID0gMCB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2Nsb3NlX3RhZzsgbGVuZ3RoID0gMCB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgICBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSkgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgfmVuZF93aXRoX25ld2xpbmUgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGVuZF93aXRoX25ld2xpbmUgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbmxldCBwcF9wcmludF9ieXRlcyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKEJ5dGVzLmxlbmd0aCBzKSAoQnl0ZXMudG9fc3RyaW5nIHMpXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cbmxldCBwcF9wcmludF9ub3RoaW5nIF9zdGF0ZSAoKSA9ICgpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIH5lbmRfd2l0aF9uZXdsaW5lOnRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgfmVuZF93aXRoX25ld2xpbmU6ZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgSW50Lm1heCAoSW50Lm1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBpZiBtYXJnaW4gPj0gcHBfaW5maW5pdHkgdGhlblxuICAgIEVycm9yIFwibWFyZ2luID49IHBwX2luZmluaXR5XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1N0ZGxpYi5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtTdGRsaWIub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuKCogSW5pdGlhbGlzZSBkb21haW4gbG9jYWwgc3RhdGUgKilcbm1vZHVsZSBETFMgPSBEb21haW4uRExTXG5cbmxldCBzdGRidWZfa2V5ID0gRExTLm5ld19rZXkgcHBfbWFrZV9idWZmZXJcbmxldCBfID0gRExTLnNldCBzdGRidWZfa2V5IHN0ZGJ1ZlxuXG5sZXQgc3RyX2Zvcm1hdHRlcl9rZXkgPSBETFMubmV3X2tleSAoZnVuICgpIC0+XG4gIGZvcm1hdHRlcl9vZl9idWZmZXIgKERMUy5nZXQgc3RkYnVmX2tleSkpXG5sZXQgXyA9IERMUy5zZXQgc3RyX2Zvcm1hdHRlcl9rZXkgc3RyX2Zvcm1hdHRlclxuXG5sZXQgYnVmZmVyZWRfb3V0X3N0cmluZyBrZXkgc3RyIG9mcyBsZW4gPVxuICBCdWZmZXIuYWRkX3N1YnN0cmluZyAoRG9tYWluLkRMUy5nZXQga2V5KSBzdHIgb2ZzIGxlblxuXG5sZXQgYnVmZmVyZWRfb3V0X2ZsdXNoIG9jIGtleSAoKSA9XG4gIGxldCBidWYgPSBEb21haW4uRExTLmdldCBrZXkgaW5cbiAgbGV0IGxlbiA9IEJ1ZmZlci5sZW5ndGggYnVmIGluXG4gIGxldCBzdHIgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gIG91dHB1dF9zdWJzdHJpbmcgb2Mgc3RyIDAgbGVuIDtcbiAgU3RkbGliLmZsdXNoIG9jO1xuICBCdWZmZXIuY2xlYXIgYnVmXG5cbmxldCBzdGRfYnVmX2tleSA9IERvbWFpbi5ETFMubmV3X2tleSAoZnVuICgpIC0+IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemUpXG5sZXQgZXJyX2J1Zl9rZXkgPSBEb21haW4uRExTLm5ld19rZXkgKGZ1biAoKSAtPiBCdWZmZXIuY3JlYXRlIHBwX2J1ZmZlcl9zaXplKVxuXG5sZXQgc3RkX2Zvcm1hdHRlcl9rZXkgPSBETFMubmV3X2tleSAoZnVuICgpIC0+XG4gIGxldCBwcGYgPVxuICAgIHBwX21ha2VfZm9ybWF0dGVyIChidWZmZXJlZF9vdXRfc3RyaW5nIHN0ZF9idWZfa2V5KVxuICAgICAgKGJ1ZmZlcmVkX291dF9mbHVzaCBTdGRsaWIuc3Rkb3V0IHN0ZF9idWZfa2V5KSBpZ25vcmUgaWdub3JlIGlnbm9yZVxuICBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIERvbWFpbi5hdF9leGl0IChwcF9wcmludF9mbHVzaCBwcGYpO1xuICBwcGYpXG5sZXQgXyA9IERMUy5zZXQgc3RkX2Zvcm1hdHRlcl9rZXkgc3RkX2Zvcm1hdHRlclxuXG5sZXQgZXJyX2Zvcm1hdHRlcl9rZXkgPSBETFMubmV3X2tleSAoZnVuICgpIC0+XG4gIGxldCBwcGYgPVxuICAgIHBwX21ha2VfZm9ybWF0dGVyIChidWZmZXJlZF9vdXRfc3RyaW5nIGVycl9idWZfa2V5KVxuICAgICAgKGJ1ZmZlcmVkX291dF9mbHVzaCBTdGRsaWIuc3RkZXJyIGVycl9idWZfa2V5KSBpZ25vcmUgaWdub3JlIGlnbm9yZVxuICBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIERvbWFpbi5hdF9leGl0IChwcF9wcmludF9mbHVzaCBwcGYpO1xuICBwcGYpXG5sZXQgXyA9IERMUy5zZXQgZXJyX2Zvcm1hdHRlcl9rZXkgZXJyX2Zvcm1hdHRlclxuXG5sZXQgZ2V0X3N0ZF9mb3JtYXR0ZXIgKCkgPSBETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5XG5sZXQgZ2V0X2Vycl9mb3JtYXR0ZXIgKCkgPSBETFMuZ2V0IGVycl9mb3JtYXR0ZXJfa2V5XG5sZXQgZ2V0X3N0cl9mb3JtYXR0ZXIgKCkgPSBETFMuZ2V0IHN0cl9mb3JtYXR0ZXJfa2V5XG5sZXQgZ2V0X3N0ZGJ1ZiAoKSA9IERMUy5nZXQgc3RkYnVmX2tleVxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIH5lbmRfd2l0aF9uZXdsaW5lOmZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG4oKiBGbHVzaCBbc3RyX2Zvcm1hdHRlcl0gYW5kIGdldCB0aGUgY29udGVudHMgb2YgW3N0ZGJ1Zl0uICopXG5sZXQgZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSA9XG4gIGxldCBzdGRidWYgPSBETFMuZ2V0IHN0ZGJ1Zl9rZXkgaW5cbiAgbGV0IHN0cl9mb3JtYXR0ZXIgPSBETFMuZ2V0IHN0cl9mb3JtYXR0ZXJfa2V5IGluXG4gIGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgc3RkYnVmIHN0cl9mb3JtYXR0ZXJcblxubGV0IG1ha2Vfc3luY2hyb25pemVkX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBETFMubmV3X2tleSAoZnVuICgpIC0+XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgb3V0cHV0JyA9IEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBpblxuICAgIGxldCBmbHVzaCcgKCkgPVxuICAgICAgb3V0cHV0IChCdWZmZXIuY29udGVudHMgYnVmKSAwIChCdWZmZXIubGVuZ3RoIGJ1Zik7XG4gICAgICBCdWZmZXIuY2xlYXIgYnVmO1xuICAgICAgZmx1c2ggKClcbiAgICBpblxuICAgIG1ha2VfZm9ybWF0dGVyIG91dHB1dCcgZmx1c2gnKVxuXG5sZXQgc3luY2hyb25pemVkX2Zvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2Vfc3luY2hyb25pemVkX2Zvcm1hdHRlciAob3V0cHV0X3N1YnN0cmluZyBvYykgKGZ1biAoKSAtPiBmbHVzaCBvYylcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nXG4qKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmcgaXMgcHJldHR5LXByaW50aW5nIHdpdGggbm8gbG93IGxldmVsIG91dHB1dC5cblxuICBXaGVuIHVzaW5nIGEgc3ltYm9saWMgZm9ybWF0dGVyLCBhbGwgcmVndWxhciBwcmV0dHktcHJpbnRpbmcgYWN0aXZpdGllc1xuICBvY2N1ciBidXQgb3V0cHV0IG1hdGVyaWFsIGlzIHN5bWJvbGljIGFuZCBzdG9yZWQgaW4gYSBidWZmZXIgb2Ygb3V0cHV0XG4gIGl0ZW1zLiBBdCB0aGUgZW5kIG9mIHByZXR0eS1wcmludGluZywgZmx1c2hpbmcgdGhlIG91dHB1dCBidWZmZXIgYWxsb3dzXG4gIHBvc3QtcHJvY2Vzc2luZyBvZiBzeW1ib2xpYyBvdXRwdXQgYmVmb3JlIGxvdyBsZXZlbCBvdXRwdXQgb3BlcmF0aW9ucy5cbiopXG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2l0ZW0gPVxuICB8IE91dHB1dF9mbHVzaFxuICB8IE91dHB1dF9uZXdsaW5lXG4gIHwgT3V0cHV0X3N0cmluZyBvZiBzdHJpbmdcbiAgfCBPdXRwdXRfc3BhY2VzIG9mIGludFxuICB8IE91dHB1dF9pbmRlbnQgb2YgaW50XG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2J1ZmZlciA9IHtcbiAgbXV0YWJsZSBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgOiBzeW1ib2xpY19vdXRwdXRfaXRlbSBsaXN0O1xufVxuXG5sZXQgbWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyICgpID1cbiAgeyBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgPSBbXSB9XG5cbmxldCBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gW11cblxubGV0IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIExpc3QucmV2IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IGl0ZW1zID0gZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iIGluXG4gIGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iO1xuICBpdGVtc1xuXG5sZXQgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBpdGVtID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBpdGVtIDo6IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBzeW1ib2xpY19mbHVzaCBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X2ZsdXNoXG4gIGFuZCBzeW1ib2xpY19uZXdsaW5lIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfbmV3bGluZVxuICBhbmQgc3ltYm9saWNfc3RyaW5nIHNvYiBzIGkgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3N0cmluZyAoU3RyaW5nLnN1YiBzIGkgbikpXG4gIGFuZCBzeW1ib2xpY19zcGFjZXMgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zcGFjZXMgbilcbiAgYW5kIHN5bWJvbGljX2luZGVudCBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X2luZGVudCBuKSBpblxuXG4gIGxldCBmID0gc3ltYm9saWNfc3RyaW5nIHNvYlxuICBhbmQgZyA9IHN5bWJvbGljX2ZsdXNoIHNvYlxuICBhbmQgaCA9IHN5bWJvbGljX25ld2xpbmUgc29iXG4gIGFuZCBpID0gc3ltYm9saWNfc3BhY2VzIHNvYlxuICBhbmQgaiA9IHN5bWJvbGljX2luZGVudCBzb2IgaW5cbiAgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqXG5cbigqXG5cbiAgQmFzaWMgZnVuY3Rpb25zIG9uIHRoZSAnc3RhbmRhcmQnIGZvcm1hdHRlclxuICAodGhlIGZvcm1hdHRlciB0aGF0IHByaW50cyB0byBbU3RkbGliLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94IHYgPSBwcF9vcGVuX2hib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvcGVuX3Zib3ggdiA9IHBwX29wZW5fdmJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5faHZib3ggdiA9IHBwX29wZW5faHZib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvcGVuX2hvdmJveCB2ID0gcHBfb3Blbl9ob3Zib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBvcGVuX2JveCB2ID0gcHBfb3Blbl9ib3ggKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBjbG9zZV9ib3ggdiA9IHBwX2Nsb3NlX2JveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIG9wZW5fc3RhZyB2ID0gcHBfb3Blbl9zdGFnIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgY2xvc2Vfc3RhZyB2ID0gcHBfY2xvc2Vfc3RhZyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2FzIHYgdyA9IHBwX3ByaW50X2FzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2IHdcbmFuZCBwcmludF9zdHJpbmcgdiA9IHBwX3ByaW50X3N0cmluZyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2J5dGVzIHYgPSBwcF9wcmludF9ieXRlcyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2ludCB2ID0gcHBfcHJpbnRfaW50IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfZmxvYXQgdiA9IHBwX3ByaW50X2Zsb2F0IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfY2hhciB2ID0gcHBfcHJpbnRfY2hhciAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2Jvb2wgdiA9IHBwX3ByaW50X2Jvb2wgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9icmVhayB2IHcgPSBwcF9wcmludF9icmVhayAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdiB3XG5hbmQgcHJpbnRfY3V0IHYgPSBwcF9wcmludF9jdXQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBwcmludF9zcGFjZSB2ID0gcHBfcHJpbnRfc3BhY2UgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBmb3JjZV9uZXdsaW5lIHYgPSBwcF9mb3JjZV9uZXdsaW5lIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfZmx1c2ggdiA9IHBwX3ByaW50X2ZsdXNoIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgcHJpbnRfbmV3bGluZSB2ID0gcHBfcHJpbnRfbmV3bGluZSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X2lmX25ld2xpbmUgdiA9IHBwX3ByaW50X2lmX25ld2xpbmUgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIG9wZW5fdGJveCB2ID0gcHBfb3Blbl90Ym94IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgY2xvc2VfdGJveCB2ID0gcHBfY2xvc2VfdGJveCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X3RicmVhayB2IHcgPSBwcF9wcmludF90YnJlYWsgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHYgd1xuXG5hbmQgc2V0X3RhYiB2ID0gcHBfc2V0X3RhYiAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHByaW50X3RhYiB2ID0gcHBfcHJpbnRfdGFiIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfbWFyZ2luIHYgPSBwcF9zZXRfbWFyZ2luIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X21hcmdpbiB2ID0gcHBfZ2V0X21hcmdpbiAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuXG5hbmQgc2V0X21heF9pbmRlbnQgdiA9IHBwX3NldF9tYXhfaW5kZW50IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X21heF9pbmRlbnQgdiA9IHBwX2dldF9tYXhfaW5kZW50IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfZ2VvbWV0cnkgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIHBwX3NldF9nZW9tZXRyeSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgfm1heF9pbmRlbnQgfm1hcmdpblxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5IH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBwcF9zYWZlX3NldF9nZW9tZXRyeSAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgfm1heF9pbmRlbnQgfm1hcmdpblxuYW5kIGdldF9nZW9tZXRyeSB2ID0gcHBfZ2V0X2dlb21ldHJ5IChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgdXBkYXRlX2dlb21ldHJ5IHYgPSBwcF91cGRhdGVfZ2VvbWV0cnkgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9tYXhfYm94ZXMgdiA9IHBwX3NldF9tYXhfYm94ZXMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWF4X2JveGVzIHYgPSBwcF9nZXRfbWF4X2JveGVzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgb3Zlcl9tYXhfYm94ZXMgdiA9IHBwX292ZXJfbWF4X2JveGVzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCB2ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCB2ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgdiA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyB2ID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHYgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyB2IHcgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHYgd1xuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyB2ID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHYgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyB2ID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHNldF9wcmludF90YWdzIHYgPVxuICBwcF9zZXRfcHJpbnRfdGFncyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIGdldF9wcmludF90YWdzIHYgPVxuICBwcF9nZXRfcHJpbnRfdGFncyAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgdlxuYW5kIHNldF9tYXJrX3RhZ3MgdiA9XG4gIHBwX3NldF9tYXJrX3RhZ3MgKERMUy5nZXQgc3RkX2Zvcm1hdHRlcl9rZXkpIHZcbmFuZCBnZXRfbWFya190YWdzIHYgPVxuICBwcF9nZXRfbWFya190YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5hbmQgc2V0X3RhZ3MgdiA9XG4gIHBwX3NldF90YWdzIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSB2XG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbmxldCBwcF9wcmludF9pdGVyID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBpdGVyIHBwX3YgcHBmIHYgPVxuICBsZXQgaXNfZmlyc3QgPSByZWYgdHJ1ZSBpblxuICBsZXQgcHBfdiB2ID1cbiAgICBpZiAhaXNfZmlyc3QgdGhlbiBpc19maXJzdCA6PSBmYWxzZSBlbHNlIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdlxuICBpblxuICBpdGVyIHBwX3YgdlxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgdiA9XG4gIHBwX3ByaW50X2l0ZXIgfnBwX3NlcCBMaXN0Lml0ZXIgcHBfdiBwcGYgdlxuXG4oKiBUbyBmb3JtYXQgYW4gYXJyYXkgKilcbmxldCBwcF9wcmludF9hcnJheSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgdiA9XG4gIHBwX3ByaW50X2l0ZXIgfnBwX3NlcCBBcnJheS5pdGVyIHBwX3YgcHBmIHZcblxuKCogVG8gZm9ybWF0IGEgc2VxdWVuY2UgKilcbmxldCBwcF9wcmludF9zZXEgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmIHNlcSA9XG4gIHBwX3ByaW50X2l0ZXIgfnBwX3NlcCBTZXEuaXRlciBwcF92IHBwZiBzZXFcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxubGV0IHBwX3ByaW50X29wdGlvbiA/KG5vbmUgPSBmdW4gXyAoKSAtPiAoKSkgcHBfdiBwcGYgPSBmdW5jdGlvblxufCBOb25lIC0+IG5vbmUgcHBmICgpXG58IFNvbWUgdiAtPiBwcF92IHBwZiB2XG5cbmxldCBwcF9wcmludF9yZXN1bHQgfm9rIH5lcnJvciBwcGYgPSBmdW5jdGlvblxufCBPayB2IC0+IG9rIHBwZiB2XG58IEVycm9yIGUgLT4gZXJyb3IgcHBmIGVcblxubGV0IHBwX3ByaW50X2VpdGhlciB+bGVmdCB+cmlnaHQgcHBmID0gZnVuY3Rpb25cbnwgRWl0aGVyLkxlZnQgbCAtPiBsZWZ0IHBwZiBsXG58IEVpdGhlci5SaWdodCByIC0+IHJpZ2h0IHBwZiByXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBjb21wdXRlX3RhZyBvdXRwdXQgdGFnX2FjYyA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDE2IGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBvdXRwdXQgcHBmIHRhZ19hY2M7XG4gIHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgbGV0IGxlbiA9IEJ1ZmZlci5sZW5ndGggYnVmIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gIGVsc2UgQnVmZmVyLnN1YiBidWYgMSAobGVuIC0gMilcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIERlZmluaW5nIGNvbnRpbnVhdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyBvZlxuICBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuXG5cbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBJbnRlcnByZXQgYSBmb3JtYXR0aW5nIGVudGl0eSBvbiBhIGZvcm1hdHRlci4gKilcbmxldCBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGZtdGluZ19saXQgPSBtYXRjaCBmbXRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX3N0YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxuXG5sZXQgcHJpbnRmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIChETFMuZ2V0IHN0ZF9mb3JtYXR0ZXJfa2V5KSBhY2MpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGVwcmludGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgKERMUy5nZXQgZXJyX2Zvcm1hdHRlcl9rZXkpIGFjYylcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCAoRExTLmdldCBzdGRfZm9ybWF0dGVyX2tleSkgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIChETFMuZ2V0IGVycl9mb3JtYXR0ZXJfa2V5KSAoKVxuXG5sZXQgKCkgPSBhdF9leGl0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnNcblxubGV0ICgpID0gRG9tYWluLmJlZm9yZV9maXJzdF9zcGF3biAoZnVuICgpIC0+XG4gIGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCk7XG4gIGxldCBmcyA9IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyICgpIGluXG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG4gICAge2ZzIHdpdGggb3V0X3N0cmluZyA9IGJ1ZmZlcmVkX291dF9zdHJpbmcgc3RkX2J1Zl9rZXk7XG4gICAgICAgICAgICAgb3V0X2ZsdXNoID0gYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRvdXQgc3RkX2J1Zl9rZXl9O1xuXG4gIGxldCBmcyA9IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBlcnJfZm9ybWF0dGVyICgpIGluXG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBlcnJfZm9ybWF0dGVyXG4gICAge2ZzIHdpdGggb3V0X3N0cmluZyA9IGJ1ZmZlcmVkX291dF9zdHJpbmcgZXJyX2J1Zl9rZXk7XG4gICAgICAgICAgICAgb3V0X2ZsdXNoID0gYnVmZmVyZWRfb3V0X2ZsdXNoIFN0ZGxpYi5zdGRlcnIgZXJyX2J1Zl9rZXl9O1xuKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFN0ZGxpYi5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFN0ZGxpYi5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFN0ZGxpYiBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBTdGRsaWIuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpbl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtTdGRsaWIuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBTdGRsaWIuc3RkaW4pKSBTdGRsaWIuc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXJfb3B0ID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkIG9wdGlvbiwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFN0ZGxpYi4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IEludC5taW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliKSBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG4gIHwgXyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG5cblxubGV0IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGVycm9yIHN0ciA9XG4gIGxldCBsb3dlcmNhc2UgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnQScgLi4gJ1onIC0+XG4gICAgICBjaGFyX29mX2ludCAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyArIGludF9vZl9jaGFyICdhJylcbiAgICB8IF8gLT4gYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoID0gcmVmIHdpZHRoIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBsb3dlcmNhc2UgYyA8PiBsb3dlcmNhc2Ugc3RyLltpXSB0aGVuIGVycm9yICgpO1xuICAgIGlmICF3aWR0aCA9IDAgdGhlbiBlcnJvciAoKTtcbiAgICB3aWR0aCA6PSBTY2FubmluZy5zdG9yZV9jaGFyICF3aWR0aCBpYiBjO1xuICBkb25lO1xuICAhd2lkdGhcblxuXG5sZXQgc2Nhbl9oZXhfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgbGV0IHdpZHRoID0gY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcInhcIiBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gSW50Lm1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBJbnQubWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgIClcbiAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGJhZF9mbG9hdCAoKSBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgfCBfIC0+IHdpZHRoXG4gICAgKVxuICAgIHwgXyAtPlxuICAgICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4gIClcbiAgfCAnMScgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuKCogU3BlY2lhbCBjYXNlIG9mIG5hbiBhbmQgaW5maW5pdHk6XG4gIHwgJ2knIC0+XG4gIHwgJ24nIC0+XG4qKVxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxuKCogU2NhbiBhIHJlZ3VsYXIgc3RyaW5nOlxuICAgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgYSBzcGFjZSwgaWYgbm8gc2Nhbm5pbmcgaW5kaWNhdGlvbiBoYXMgYmVlbiBnaXZlbjtcbiAgIG90aGVyd2lzZSwgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNjYW5uaW5nXG4gICBpbmRpY2F0aW9uIFtzdHBdLlxuICAgSXQgYWxzbyBzdG9wcyBhdCBlbmQgb2YgZmlsZSBvciB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGhhc1xuICAgYmVlbiByZWFkLiAqKVxubGV0IHNjYW5fc3RyaW5nIHN0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgbG9vcCB3aWR0aCA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbWF0Y2ggc3RwIHdpdGhcbiAgICAgIHwgU29tZSBjJyB3aGVuIGMgPSBjJyAtPiBTY2FubmluZy5za2lwX2NoYXIgd2lkdGggaWJcbiAgICAgIHwgU29tZSBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaW5cbiAgbG9vcCB3aWR0aFxuXG5cbigqIFNjYW4gYSBjaGFyOiBwZWVrIHN0cmljdGx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LCB3aGF0c29ldmVyLiAqKVxubGV0IHNjYW5fY2hhciB3aWR0aCBpYiA9XG4gICgqIFRoZSBjYXNlIHdpZHRoID0gMCBjb3VsZCBub3QgaGFwcGVuIGhlcmUsIHNpbmNlIGl0IGlzIHRlc3RlZCBiZWZvcmVcbiAgICAgY2FsbGluZyBzY2FuX2NoYXIsIGluIHRoZSBtYWluIHNjYW5uaW5nIGZ1bmN0aW9uLlxuICAgIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJhIGNoYXJhY3RlclwiIGVsc2UgKilcbiAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIpXG5cblxubGV0IGNoYXJfZm9yX2JhY2tzbGFzaCA9IGZ1bmN0aW9uXG4gIHwgJ24nIC0+ICdcXDAxMCdcbiAgfCAncicgLT4gJ1xcMDEzJ1xuICB8ICdiJyAtPiAnXFwwMDgnXG4gIHwgJ3QnIC0+ICdcXDAwOSdcbiAgfCBjIC0+IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPSBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnXG5cbmxldCBjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTAwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMwICtcbiAgICAgMTAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgXCJiYWQgY2hhcmFjdGVyIGRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWMlY1wiIGMwIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgaGV4YWRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9XG4gIGxldCBkID0gaW50X29mX2NoYXIgYyBpblxuICAoKiBDb3VsZCBhbHNvIGJlOlxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJzknIHRoZW4gZCAtIGludF9vZl9jaGFyICcwJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnRicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnQScgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ2YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ2EnIGVsc2UgYXNzZXJ0IGZhbHNlXG4gICopXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ2EnIHRoZW5cbiAgICBkIC0gODcgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ2EnICopIGVsc2VcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnQScgdGhlblxuICAgIGQgLSA1NSAgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICopIGVsc2VcbiAgICBkIC0gaW50X29mX2NoYXIgJzAnXG5cblxubGV0IGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTYgKiBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGYgXCJiYWQgY2hhcmFjdGVyIGhleGFkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjXCIgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIENhbGxlZCBpbiBwYXJ0aWN1bGFyIHdoZW4gZW5jb3VudGVyaW5nICdcXFxcJyBhcyBzdGFydGVyIG9mIGEgY2hhci5cbiAgIFN0b3BzIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyAnXFwnJy4gKilcbmxldCBjaGVja19uZXh0X2NoYXIgbWVzc2FnZSB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSBlbHNlXG4gIGNcblxuXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBDaGFyXCJcbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyA9IGNoZWNrX25leHRfY2hhciBcImEgU3RyaW5nXCJcblxubGV0IHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIgPVxuICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICB8ICdcXFxcJyB8ICdcXCcnIHwgJ1xcXCInIHwgJ24nIHwgJ3QnIHwgJ2InIHwgJ3InIGFzIGMgLT5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChjaGFyX2Zvcl9iYWNrc2xhc2ggYylcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzAgPSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyKVxuICB8ICd4JyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMilcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0X2VzY2FwZSBjXG5cblxuKCogU2NhbiBhIGNoYXJhY3RlciAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9jaGFyIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IGZpbmRfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjXG5cbiAgYW5kIGZpbmRfY2hhciB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFxcJyAtPlxuICAgICAgZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYikgaWIpXG4gICAgfCBjIC0+XG4gICAgICBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGMgaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGRlbGltaXRlZCBzdHJpbmcgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcXCInIGNcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8ICdcXFxcJyAtPiBzY2FuX2JhY2tzbGFzaCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBzY2FuX2JhY2tzbGFzaCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xccicgLT4gc2tpcF9uZXdsaW5lIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliKVxuXG4gIGFuZCBza2lwX25ld2xpbmUgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliICdcXHInKVxuXG4gIGFuZCBza2lwX3NwYWNlcyB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJyAnIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIHdpZHRoIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBib29sZWFuIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9ib29sIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBsZXQgbSA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAndCcgLT4gNFxuICAgIHwgJ2YnIC0+IDVcbiAgICB8IGMgLT5cbiAgICAgIGJhZF9pbnB1dFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCJ0aGUgY2hhcmFjdGVyICVDIGNhbm5vdCBzdGFydCBhIGJvb2xlYW5cIiBjKSBpblxuICBzY2FuX3N0cmluZyBOb25lIG0gaWJcblxuXG4oKiBTY2FuIGEgc3RyaW5nIGNvbnRhaW5pbmcgZWxlbWVudHMgaW4gY2hhcl9zZXQgYW5kIHRlcm1pbmF0ZWQgYnkgc2Nhbl9pbmRpY1xuICAgaWYgcHJvdmlkZWQuICopXG5sZXQgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBzY2FuX2luZGljIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2NoYXJzIGkgc3RwID1cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGkgPiAwICYmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSAmJlxuICAgICAgIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgJiZcbiAgICAgICBpbnRfb2ZfY2hhciBjIDw+IHN0cCB0aGVuXG4gICAgICBsZXQgXyA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgbWF4X2ludCBpYiBjIGluXG4gICAgICBzY2FuX2NoYXJzIChpIC0gMSkgc3RwIGluXG4gIG1hdGNoIHNjYW5faW5kaWMgd2l0aFxuICB8IE5vbmUgLT4gc2Nhbl9jaGFycyB3aWR0aCAoLTEpO1xuICB8IFNvbWUgYyAtPlxuICAgIHNjYW5fY2hhcnMgd2lkdGggKGludF9vZl9jaGFyIGMpO1xuICAgIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuXG4gICAgICBsZXQgY2kgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICAgIGlmIGMgPSBjaVxuICAgICAgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICAgICAgZWxzZSBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5cbigqIFRoZSBnbG9iYWwgZXJyb3IgcmVwb3J0IGZ1bmN0aW9uIGZvciBbU2NhbmZdLiAqKVxubGV0IHNjYW5mX2JhZF9pbnB1dCBpYiA9IGZ1bmN0aW9uXG4gIHwgU2Nhbl9mYWlsdXJlIHMgfCBGYWlsdXJlIHMgLT5cbiAgICBsZXQgaSA9IFNjYW5uaW5nLmNoYXJfY291bnQgaWIgaW5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwic2NhbmY6IGJhZCBpbnB1dCBhdCBjaGFyIG51bWJlciAlaTogJXNcIiBpIHMpXG4gIHwgeCAtPiByYWlzZSB4XG5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIGEgY291bnRlciBmcm9tIGFuIGlucHV0IGJ1ZmZlci4gKilcbmxldCBnZXRfY291bnRlciBpYiBjb3VudGVyID1cbiAgbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyIC0+IFNjYW5uaW5nLmxpbmVfY291bnQgaWJcbiAgfCBDaGFyX2NvdW50ZXIgLT4gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYlxuICB8IFRva2VuX2NvdW50ZXIgLT4gU2Nhbm5pbmcudG9rZW5fY291bnQgaWJcblxuXG4oKiBDb21wdXRlIHRoZSB3aWR0aCBvZiBhIHBhZGRpbmcgb3B0aW9uIChzZWUgXCIlNDJ7XCIgYW5kIFwiJTEyMyhcIikuICopXG5sZXQgd2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBtYXhfaW50XG4gIHwgU29tZSB3aWR0aCAtPiB3aWR0aFxuXG5cbmxldCBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyA9XG4gIGlmIGZtdGluZyA9IEVzY2FwZWRfcGVyY2VudCB0aGVuICclJywgXCJcIiBlbHNlXG4gICAgbGV0IHN0ciA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgaW5cbiAgICBsZXQgc3RwID0gc3RyLlsxXSBpblxuICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgMiAoU3RyaW5nLmxlbmd0aCBzdHIgLSAyKSBpblxuICAgIHN0cCwgc3ViX3N0clxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBSZWFkZXIgbWFuYWdlbWVudCAqKVxuXG4oKiBBIGNhbGwgdG8gdGFrZV9mb3JtYXRfcmVhZGVycyBvbiBhIGZvcm1hdCBpcyBldmFsdWF0ZWQgaW50byBmdW5jdGlvbnNcbiAgIHRha2luZyByZWFkZXJzIGFzIGFyZ3VtZW50cyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhbiBoZXRlcm9nZW5lb3VzIGxpc3QgKilcbigqIFdoZW4gYWxsIHJlYWRlcnMgYXJlIHRha2VuLCBmaW5hbGx5IHBhc3MgdGhlIGxpc3Qgb2YgdGhlIHJlYWRlcnMgdG8gdGhlXG4gICBjb250aW51YXRpb24gay4gKilcbmxldCByZWMgdGFrZV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIGQgPVxuZnVuIGsgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3RcbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX3N0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50MzIgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBOYXRpdmVpbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDY0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmxvYXQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBCb29sIChfLCByZXN0KSAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDdXN0b20gKF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpICAgIC0+XG4gICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSkgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgICAgICAgIC0+IHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyBrIGlnbiByZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAgICAgICAtPiBrIE5pbFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBmbXR0eSBjb21pbmcgZnJvbSBhIEZvcm1hdF9zdWJzdCBcIiUoLi4uJSlcIi4gKilcbmFuZCB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGZtdHR5IC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBSZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBpZ25vcmVkIHBhcmFtZXRlci4gKilcbmFuZCB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgaWdub3JlZCAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHNjYW5uaW5nICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHNjYW5uaW5nIGZ1bmN0aW9uLiAqKVxuKCogU2NhbiBhIHN0cmVhbSBhY2NvcmRpbmcgdG8gYSBmb3JtYXQgYW5kIHJlYWRlcnMgb2J0YWluZWQgYnlcbiAgIHRha2VfZm9ybWF0X3JlYWRlcnMsIGFuZCBhZ2dyZWdhdGUgc2Nhbm5lZCB2YWx1ZXMgaW50byBhblxuICAgaGV0ZXJvZ2VuZW91cyBsaXN0LiAqKVxuKCogUmV0dXJuIHRoZSBoZXRlcm9nZW5lb3VzIGxpc3Qgb2Ygc2Nhbm5lZCB2YWx1ZXMuICopXG5sZXQgcmVjIG1ha2Vfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZi5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+IChhLCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgc3RwKSB3aWR0aCBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAneycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ1snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgTm9uZSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG5cbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludCBjKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQzMiBjKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5fbmF0aXZlaW50IGMpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDY0IGMpXG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfRiB8IEZsb2F0X0NGKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9jYW1sX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cpKSxcbiAgICAgICAgICAgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfaCB8IEZsb2F0X0gpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2hleF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiBfIF8gaWIgPSBzY2FuX2Jvb2wgaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX2Jvb2xcbiAgfCBBbHBoYSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiVhXFxcIlwiXG4gIHwgVGhldGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIldFxcXCJcIlxuICB8IEN1c3RvbSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiU/XFxcIiAoY3VzdG9tIGNvbnZlcnRlcilcIlxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGJlZ2luIG1hdGNoIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpIC0+XG4gICAgICAgIGxldCB4ID0gcmVhZGVyIGliIGluXG4gICAgICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10X3Jlc3QgcmVhZGVyc19yZXN0KVxuICAgIHwgTmlsIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwic2NhbmY6IG1pc3NpbmcgcmVhZGVyXCJcbiAgICBlbmRcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgaWYgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgICBlbHNlIGJhZF9pbnB1dCBcImVuZCBvZiBpbnB1dCBub3QgZm91bmRcIlxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgc3RyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiBjaHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzIGZtdHR5XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKGZtdCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQsIGZtdCcgPVxuICAgICAgdHJ5XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10JyA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgKCogVE9ETzogZmluZCBhIHdheSB0byBhdm9pZCByZXBhcnNpbmcgdHdpY2UgKilcblxuICAgICAgICAoKiBUT0RPOiB0aGVzZSB0eXBlLWNoZWNrcyBiZWxvdyAqY2FuKiBmYWlsIGJlY2F1c2Ugb2YgdHlwZVxuICAgICAgICAgICBhbWJpZ3VpdHkgaW4gcHJlc2VuY2Ugb2YgaWdub3JlZC1yZWFkZXJzOiBcIiVfciVkXCIgYW5kIFwiJWQlX3JcIlxuICAgICAgICAgICBhcmUgdHlwZWQgaW4gdGhlIHNhbWUgd2F5LlxuXG4gICAgICAgICAgICMgU2NhbmYuc3NjYW5mIFwiXFxcIiVfciVkXFxcIjNcIiBcIiUoJWQlX3IlKVwiIGlnbm9yZVxuICAgICAgICAgICAgIChmdW4gZm10IG4gLT4gc3RyaW5nX29mX2Zvcm1hdCBmbXQsIG4pXG4gICAgICAgICAgIEV4Y2VwdGlvbjogQ2FtbGludGVybmFsRm9ybWF0LlR5cGVfbWlzbWF0Y2guXG5cbiAgICAgICAgICAgV2Ugc2hvdWxkIHByb3Blcmx5IGNhdGNoIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAqKVxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCBmbXR0eSksXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCcgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKEZvcm1hdCAoZm10LCBzKSxcbiAgICAgICAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycylcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKFNvbWUgc3RwKSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IE5vbmUgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIGxldCBjb3VudCA9IGdldF9jb3VudGVyIGliIGNvdW50ZXIgaW5cbiAgICBDb25zIChjb3VudCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCk7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICd7JztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ1snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG5cbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgIGJlZ2luIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10JyByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKF8sIGFyZ19yZXN0KSAtPiBhcmdfcmVzdFxuICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIE5pbFxuXG4oKiBDYXNlIGFuYWx5c2lzIG9uIHBhZGRpbmcgYW5kIHByZWNpc2lvbi4gKilcbigqIFJlamVjdCBmb3JtYXRzIGNvbnRhaW5pbmcgXCIlKlwiIG9yIFwiJS4qXCIuICopXG4oKiBQYXNzIHBhZGRpbmcgYW5kIHByZWNpc2lvbiB0byB0aGUgZ2VuZXJpYyBzY2FubmVyIGBzY2FuJy4gKilcbmFuZCBwYWRfcHJlY19zY2FuZiA6IHR5cGUgYSBjIGQgZSBmIHggeSB6IHQgLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+XG4gICAgICAoaW50IC0+IGludCAtPiBTY2FubmluZy5pbl9jaGFubmVsIC0+IHQpIC0+XG4gICAgICAoU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB6KSAtPlxuICAgICAgKHgsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gdG9rZW4gLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiB3IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoTGVmdCwgXyksIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJS1cXFwiXCJcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCBfKSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IEFyZ19wYWRkaW5nIF8sIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAoKiBEZWZpbmluZyBbc2NhbmZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW3NjYW5mXSAqKVxuXG5sZXQga3NjYW5mX2dlbiBpYiBlZiBhZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSBhcyBleGMpIC0+XG4gICAgICAgIGVmIGliIGV4Y1xuICAgIHwgZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgfCBhcmdzIC0+XG4gICAgICAgIGFmIChhcHBseSBmIGFyZ3MpXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxubGV0IGtzY2FuZiBpYiBlZiBmbXQgPVxuICBrc2NhbmZfZ2VuIGliIGVmIChmdW4geCAtPiB4KSBmbXRcblxubGV0IGtzY2FuZl9vcHQgaWIgZm10ID1cbiAga3NjYW5mX2dlbiBpYiAoZnVuIF8gXyAtPiBOb25lKSAoZnVuIHggLT4gU29tZSB4KSBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5sZXQgYnNjYW5mX29wdCBpYiBmbXQgPSBrc2NhbmZfb3B0IGliIGZtdFxuXG5sZXQga3NzY2FuZiBzIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGVmIGZtdFxubGV0IHNzY2FuZiBzIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbmxldCBzc2NhbmZfb3B0IHMgZm10ID0ga3NjYW5mX29wdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaW4gc2NhbmZfYmFkX2lucHV0IGZtdFxubGV0IHNjYW5mX29wdCBmbXQgPSBrc2NhbmZfb3B0IFNjYW5uaW5nLnN0ZGluIGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKE9iai5tYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIE9iai5tYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBPYmoubWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBPYmoubWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBPYmoubWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gT2JqLm1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBPYmoubWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIE9iai5tYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IE9iai5yZXByIGluaXQgfF07XG4gICAgIE9iai5tYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IE9iai5yZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5bQEB3YXJuaW5nIFwiLXVudXNlZC1maWVsZFwiXVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgT2JqLm1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBPYmoubWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gT2JqLm1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHNoYXBlID1cbiAgfCBGdW5jdGlvblxuICB8IExhenlcbiAgfCBDbGFzc1xuICB8IE1vZHVsZSBvZiBzaGFwZSBhcnJheVxuICB8IFZhbHVlIG9mIE9iai50XG5cbmxldCByZWMgaW5pdF9tb2RfZmllbGQgbW9kdSBpIGxvYyBzaGFwZSA9XG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgfCBGdW5jdGlvbiAtPlxuICAgICAgIGxldCByZWMgZm4gKHggOiAnYSkgPVxuICAgICAgICAgbGV0IGZuJyA6ICdhIC0+ICdiID0gT2JqLm9iaiAoT2JqLmZpZWxkIG1vZHUgaSkgaW5cbiAgICAgICAgIGlmIGZuID09IGZuJyB0aGVuXG4gICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGZuJyB4IGluXG4gICAgICAgT2JqLnJlcHIgZm5cbiAgICB8IExhenkgLT5cbiAgICAgICBsZXQgcmVjIGwgPVxuICAgICAgICAgbGF6eSAoXG4gICAgICAgICAgIGxldCBsJyA9IE9iai5vYmogKE9iai5maWVsZCBtb2R1IGkpIGluXG4gICAgICAgICAgIGlmIGwgPT0gbCcgdGhlblxuICAgICAgICAgICAgIHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpXG4gICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICBMYXp5LmZvcmNlIGwnKSBpblxuICAgICAgIE9iai5yZXByIGxcbiAgICB8IENsYXNzIC0+XG4gICAgICAgT2JqLnJlcHIgKENhbWxpbnRlcm5hbE9PLmR1bW15X2NsYXNzIGxvYylcbiAgICB8IE1vZHVsZSBjb21wcyAtPlxuICAgICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gICAgfCBWYWx1ZSB2IC0+IHZcbiAgaW5cbiAgT2JqLnNldF9maWVsZCBtb2R1IGkgaW5pdFxuXG5hbmQgaW5pdF9tb2RfYmxvY2sgbG9jIGNvbXBzID1cbiAgbGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCBjb21wcyBpblxuICBsZXQgbW9kdSA9IE9iai5uZXdfYmxvY2sgMCBsZW5ndGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICBpbml0X21vZF9maWVsZCBtb2R1IGkgbG9jIGNvbXBzLihpKVxuICBkb25lO1xuICBtb2R1XG5cbmxldCBpbml0X21vZCBsb2Mgc2hhcGUgPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIE9iai5yZXByIChpbml0X21vZF9ibG9jayBsb2MgY29tcHMpXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC5pbml0X21vZDogbm90IGEgbW9kdWxlXCJcblxubGV0IHJlYyB1cGRhdGVfbW9kX2ZpZWxkIG1vZHUgaSBzaGFwZSBuID1cbiAgbWF0Y2ggc2hhcGUgd2l0aFxuICB8IEZ1bmN0aW9uIHwgTGF6eSAtPlxuICAgICBPYmouc2V0X2ZpZWxkIG1vZHUgaSBuXG4gIHwgVmFsdWUgXyAtPlxuICAgICAoKSAoKiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB0aGVyZSAqKVxuICB8IENsYXNzIC0+XG4gICAgIGFzc2VydCAoT2JqLnRhZyBuID0gMCAmJiBPYmouc2l6ZSBuID0gNCk7XG4gICAgIGxldCBjbCA9IE9iai5maWVsZCBtb2R1IGkgaW5cbiAgICAgZm9yIGogPSAwIHRvIDMgZG9cbiAgICAgICBPYmouc2V0X2ZpZWxkIGNsIGogKE9iai5maWVsZCBuIGopXG4gICAgIGRvbmVcbiAgfCBNb2R1bGUgY29tcHMgLT5cbiAgICAgdXBkYXRlX21vZF9ibG9jayBjb21wcyAoT2JqLmZpZWxkIG1vZHUgaSkgblxuXG5hbmQgdXBkYXRlX21vZF9ibG9jayBjb21wcyBvIG4gPVxuICBhc3NlcnQgKE9iai50YWcgbiA9IDAgJiYgT2JqLnNpemUgbiA+PSBBcnJheS5sZW5ndGggY29tcHMpO1xuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNvbXBzIC0gMSBkb1xuICAgIHVwZGF0ZV9tb2RfZmllbGQgbyBpIGNvbXBzLihpKSAoT2JqLmZpZWxkIG4gaSlcbiAgZG9uZVxuXG5sZXQgdXBkYXRlX21vZCBzaGFwZSBvIG4gPVxuICBtYXRjaCBzaGFwZSB3aXRoXG4gIHwgTW9kdWxlIGNvbXBzIC0+XG4gICAgIHVwZGF0ZV9tb2RfYmxvY2sgY29tcHMgbyBuXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkNhbWxpbnRlcm5hbE1vZC51cGRhdGVfbW9kOiBub3QgYSBtb2R1bGVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG5cbiAgdHlwZSBrZXlcbiAgdHlwZSAhJ2EgdFxuICB2YWwgY3JlYXRlIDogP3JhbmRvbSAoKnRod2FydCB0b29scy9zeW5jX3N0ZGxpYl9kb2NzKikgOiBib29sIC0+IGludCAtPiAnYSB0XG4gIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgZmluZF9vcHQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuXG4gIHR5cGUga2V5XG4gIHR5cGUgISdhIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0XG4gIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgZmluZF9vcHQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIHNlZWRlZF9oYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILnNlZWRlZF9oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5zZWVkZWRfaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBJbnQubWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biBtIGIgLT4gSW50Lm1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhXG4gICAgICBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcblxuICBsZXQgbWFrZSBrZXkgZGF0YSA9XG4gICAgbGV0IGVwaCA9IGNyZWF0ZSAoKSBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIHNldF9rZXkgZXBoIGtleTtcbiAgICBlcGhcblxuICBsZXQgcXVlcnkgZXBoIGtleSA9XG4gICAgbWF0Y2ggZ2V0X2tleSBlcGggd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGsgd2hlbiBrID09IGtleSAtPiBnZXRfZGF0YSBlcGhcbiAgICB8IFNvbWUgXyAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgc2VlZGVkX2hhc2ggPSBILnNlZWRlZF9oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IHNlZWRlZF9oYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbiAgbW9kdWxlIEJ1Y2tldCA9IHN0cnVjdFxuXG4gICAgdHlwZSBub25yZWMgKCdrLCAnZCkgdCA9ICgnaywgJ2QpIHQgbGlzdCByZWZcbiAgICBsZXQgazFfbWFrZSA9IG1ha2VcbiAgICBsZXQgbWFrZSAoKSA9IHJlZiBbXVxuICAgIGxldCBhZGQgYiBrIGQgPSBiIDo9IGsxX21ha2UgayBkIDo6ICFiXG5cbiAgICBsZXQgdGVzdF9rZXkgayBlID1cbiAgICAgIG1hdGNoIGdldF9rZXkgZSB3aXRoXG4gICAgICB8IFNvbWUgeCB3aGVuIHggPT0gayAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXkgayBoIC0+IGIgOj0gTGlzdC5yZXZfYXBwZW5kIGFjYyB0XG4gICAgICAgIHwgaCA6OiB0IC0+IGxvb3AgdCAoaCA6OiBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAhYiBbXVxuXG4gICAgbGV0IGZpbmQgYiBrID1cbiAgICAgIG1hdGNoIExpc3QuZmluZF9vcHQgKHRlc3Rfa2V5IGspICFiIHdpdGhcbiAgICAgIHwgU29tZSBlIC0+IGdldF9kYXRhIGVcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgbGVuZ3RoIGIgPSBMaXN0Lmxlbmd0aCAhYlxuICAgIGxldCBjbGVhciBiID0gYiA6PSBbXVxuXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuXG4gIGxldCBtYWtlIGtleTEga2V5MiBkYXRhID1cbiAgICBsZXQgZXBoID0gY3JlYXRlICgpIGluXG4gICAgc2V0X2RhdGEgZXBoIGRhdGE7XG4gICAgc2V0X2tleTEgZXBoIGtleTE7XG4gICAgc2V0X2tleTIgZXBoIGtleTI7XG4gICAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IGtleTEpO1xuICAgIGVwaFxuXG4gIGxldCBxdWVyeSBlcGgga2V5MSBrZXkyID1cbiAgICBtYXRjaCBnZXRfa2V5MSBlcGggd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGsgd2hlbiBrID09IGtleTEgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2V0X2tleTIgZXBoIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsgd2hlbiBrID09IGtleTIgLT4gZ2V0X2RhdGEgZXBoXG4gICAgICAgIHwgU29tZSBfIC0+IE5vbmVcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIF8gLT4gTm9uZVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBzZWVkZWRfaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5zZWVkZWRfaGFzaCBzZWVkIGsxICsgSDIuc2VlZGVkX2hhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBzZWVkZWRfaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgc2VlZGVkX2hhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuICBtb2R1bGUgQnVja2V0ID0gc3RydWN0XG5cbiAgICB0eXBlIG5vbnJlYyAoJ2sxLCAnazIsICdkKSB0ID0gKCdrMSwgJ2syLCAnZCkgdCBsaXN0IHJlZlxuICAgIGxldCBrMl9tYWtlID0gbWFrZVxuICAgIGxldCBtYWtlICgpID0gcmVmIFtdXG4gICAgbGV0IGFkZCBiIGsxIGsyIGQgPSBiIDo9IGsyX21ha2UgazEgazIgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5cyBrMSBrMiBlID1cbiAgICAgIG1hdGNoIGdldF9rZXkxIGUsIGdldF9rZXkyIGUgd2l0aFxuICAgICAgfCBTb21lIHgxLCBTb21lIHgyIHdoZW4geDEgPT0gazEgJiYgeDIgPT0gazIgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVtb3ZlIGIgazEgazIgPVxuICAgICAgbGV0IHJlYyBsb29wIGwgYWNjID1cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBoIDo6IHQgd2hlbiB0ZXN0X2tleXMgazEgazIgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgazEgazIgPVxuICAgICAgbWF0Y2ggTGlzdC5maW5kX29wdCAodGVzdF9rZXlzIGsxIGsyKSAhYiB3aXRoXG4gICAgICB8IFNvbWUgZSAtPiBnZXRfZGF0YSBlXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGxlbmd0aCBiID0gTGlzdC5sZW5ndGggIWJcbiAgICBsZXQgY2xlYXIgYiA9IGIgOj0gW11cblxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuXG4gIGxldCBtYWtlIGtleXMgZGF0YSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGgga2V5cyBpblxuICAgIGxldCBlcGggPSBjcmVhdGUgbCBpblxuICAgIHNldF9kYXRhIGVwaCBkYXRhO1xuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyBzZXRfa2V5IGVwaCBpIGtleXMuKGkpIGRvbmU7XG4gICAgZXBoXG5cbiAgbGV0IHF1ZXJ5IGVwaCBrZXlzID1cbiAgICBsZXQgbCA9IGxlbmd0aCBlcGggaW5cbiAgICB0cnlcbiAgICAgIGlmIGwgPD4gQXJyYXkubGVuZ3RoIGtleXMgdGhlbiByYWlzZSBFeGl0O1xuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIG1hdGNoIGdldF9rZXkgZXBoIGkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gcmFpc2UgRXhpdFxuICAgICAgICB8IFNvbWUgayB3aGVuIGsgPT0ga2V5cy4oaSkgLT4gKClcbiAgICAgICAgfCBTb21lIF8gLT4gcmFpc2UgRXhpdFxuICAgICAgZG9uZTtcbiAgICAgIGdldF9kYXRhIGVwaFxuICAgIHdpdGggRXhpdCAtPiBOb25lXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgc2VlZGVkX2hhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILnNlZWRlZF9oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBzZWVkZWRfaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4gIG1vZHVsZSBCdWNrZXQgPSBzdHJ1Y3RcblxuICAgIHR5cGUgbm9ucmVjICgnaywgJ2QpIHQgPSAoJ2ssICdkKSB0IGxpc3QgcmVmXG4gICAgbGV0IGtuX21ha2UgPSBtYWtlXG4gICAgbGV0IG1ha2UgKCkgPSByZWYgW11cbiAgICBsZXQgYWRkIGIgayBkID0gYiA6PSBrbl9tYWtlIGsgZCA6OiAhYlxuXG4gICAgbGV0IHRlc3Rfa2V5cyBrIGUgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIGxlbmd0aCBlIDw+IEFycmF5Lmxlbmd0aCBrIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBrIC0gMSBkb1xuICAgICAgICAgIG1hdGNoIGdldF9rZXkgZSBpIHdpdGhcbiAgICAgICAgICB8IFNvbWUgeCB3aGVuIHggPT0gay4oaSkgLT4gKClcbiAgICAgICAgICB8IF8gLT4gcmFpc2UgRXhpdFxuICAgICAgICBkb25lO1xuICAgICAgICB0cnVlXG4gICAgICB3aXRoIEV4aXQgLT4gZmFsc2VcblxuICAgIGxldCByZW1vdmUgYiBrID1cbiAgICAgIGxldCByZWMgbG9vcCBsIGFjYyA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgaCA6OiB0IHdoZW4gdGVzdF9rZXlzIGsgaCAtPiBiIDo9IExpc3QucmV2X2FwcGVuZCBhY2MgdFxuICAgICAgICB8IGggOjogdCAtPiBsb29wIHQgKGggOjogYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgIWIgW11cblxuICAgIGxldCBmaW5kIGIgayA9XG4gICAgICBtYXRjaCBMaXN0LmZpbmRfb3B0ICh0ZXN0X2tleXMgaykgIWIgd2l0aFxuICAgICAgfCBTb21lIGUgLT4gZ2V0X2RhdGEgZVxuICAgICAgfCBOb25lIC0+IE5vbmVcblxuICAgIGxldCBsZW5ndGggYiA9IExpc3QubGVuZ3RoICFiXG4gICAgbGV0IGNsZWFyIGIgPSBiIDo9IFtdXG5cbiAgZW5kXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgRGFtaWVuIERvbGlnZXosIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgZ2VuZXJpY19xdW90ZSBxdW90ZXF1b3RlIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGlmIHMuW2ldID0gJ1xcJydcbiAgICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGIgcXVvdGVxdW90ZVxuICAgIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGIgIHMuW2ldXG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzFdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvYmFzZW5hbWUuaHRtbFxuICBJbiBzdGVwIDEgb2YgW1sxXV0sIHdlIGNob29zZSB0byByZXR1cm4gXCIuXCIgZm9yIGVtcHR5IGlucHV0LlxuICAgIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sKVxuICBJbiBzdGVwIDIsIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiAgU3RlcCA2IGlzIG5vdCBpbXBsZW1lbnRlZDogd2UgY29uc2lkZXIgdGhhdCB0aGUgW3N1ZmZpeF0gb3BlcmFuZCBpc1xuICAgIGFsd2F5cyBhYnNlbnQuICBTdWZmaXhlcyBhcmUgaGFuZGxlZCBieSBbY2hvcF9zdWZmaXhdIGFuZCBbY2hvcF9leHRlbnNpb25dLlxuKilcbmxldCBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyBmaW5kX2VuZCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gZmluZF9lbmQgKG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgbiAobiArIDEpXG4gIGFuZCBmaW5kX2JlZyBuIHAgPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgcFxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBTdHJpbmcuc3ViIG5hbWUgKG4gKyAxKSAocCAtIG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgKG4gLSAxKSBwXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIGZpbmRfZW5kIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzJdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvZGlybmFtZS5odG1sXG4gIEluIHN0ZXAgNiBvZiBbWzJdXSwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuKilcbmxldCBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIHRyYWlsaW5nX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gdHJhaWxpbmdfc2VwIChuIC0gMSlcbiAgICBlbHNlIGJhc2UgblxuICBhbmQgYmFzZSBuID1cbiAgICBpZiBuIDwgMCB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCBuXG4gICAgZWxzZSBiYXNlIChuIC0gMSlcbiAgYW5kIGludGVybWVkaWF0ZV9zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgKG4gLSAxKVxuICAgIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKG4gKyAxKVxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSB0cmFpbGluZ19zZXAgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbm1vZHVsZSB0eXBlIFNZU0RFUFMgPSBzaWdcbiAgdmFsIG51bGwgOiBzdHJpbmdcbiAgdmFsIGN1cnJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHBhcmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgZGlyX3NlcCA6IHN0cmluZ1xuICB2YWwgaXNfZGlyX3NlcCA6IHN0cmluZyAtPiBpbnQgLT4gYm9vbFxuICB2YWwgaXNfcmVsYXRpdmUgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgaXNfaW1wbGljaXQgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hlY2tfc3VmZml4IDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaG9wX3N1ZmZpeF9vcHQgOiBzdWZmaXg6c3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uXG4gIHZhbCB0ZW1wX2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBxdW90ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHF1b3RlX2NvbW1hbmQgOlxuICAgIHN0cmluZyAtPiA/c3RkaW46IHN0cmluZyAtPiA/c3Rkb3V0OiBzdHJpbmcgLT4gP3N0ZGVycjogc3RyaW5nXG4gICAgICAgICAgIC0+IHN0cmluZyBsaXN0IC0+IHN0cmluZ1xuICB2YWwgYmFzZW5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBkaXJuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuZW5kXG5cbm1vZHVsZSBVbml4IDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gcy5baV0gPSAnLydcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPSBTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJ1xuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgIFN0cmluZy5lbmRzX3dpdGggfnN1ZmZpeDpzdWZmIG5hbWVcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiByID0gc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJUTVBESVJcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi90bXBcIlxuICBsZXQgcXVvdGUgPSBnZW5lcmljX3F1b3RlIFwiJ1xcXFwnJ1wiXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIChjbWQgOjogYXJncykpXG4gICAgXiAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlIGYpXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBXaW4zMiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIk5VTFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiXFxcXFwiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IGxldCBjID0gcy5baV0gaW4gYyA9ICcvJyB8fCBjID0gJ1xcXFwnIHx8IGMgPSAnOidcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPVxuICAgIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnXFxcXCcpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgbi5bMV0gPD4gJzonKVxuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuXFxcXFwiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi5cXFxcXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgIChsZXQgcyA9IFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpIGluXG4gICAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmKVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgciA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbigqXG5RdW90aW5nIGNvbW1hbmRzIGZvciBleGVjdXRpb24gYnkgY21kLmV4ZSBpcyBkaWZmaWN1bHQuXG4xLSBFYWNoIGFyZ3VtZW50IGlzIGZpcnN0IHF1b3RlZCB1c2luZyB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlLCB0b1xuICAgcHJvdGVjdCBpdCBhZ2FpbnN0IHRoZSBwcm9jZXNzaW5nIHBlcmZvcm1lZCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSxcbiAgIHRoZW4gY21kLmV4ZSdzIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgZXNjYXBlZCB3aXRoICdeJywgdXNpbmdcbiAgIHRoZSBcInF1b3RlX2NtZFwiIGZ1bmN0aW9uIGJlbG93LiAgRm9yIG1vcmUgZGV0YWlscywgc2VlXG4gICBodHRwczovL2Jsb2dzLm1zZG4ubWljcm9zb2Z0LmNvbS90d2lzdHlsaXR0bGVwYXNzYWdlc2FsbGFsaWtlLzIwMTEvMDQvMjNcbjItIFRoZSBjb21tYW5kIGFuZCB0aGUgcmVkaXJlY3Rpb24gZmlsZXMsIGlmIGFueSwgbXVzdCBiZSBkb3VibGUtcXVvdGVkXG4gICBpbiBjYXNlIHRoZXkgY29udGFpbiBzcGFjZXMuICBUaGlzIHF1b3RpbmcgaXMgaW50ZXJwcmV0ZWQgYnkgY21kLmV4ZSxcbiAgIG5vdCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSwgaGVuY2UgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZVxuICAgY2Fubm90IGJlIHVzZWQuICBUaGUgdHdvIGNoYXJhY3RlcnMgd2UgZG9uJ3Qga25vdyBob3cgdG8gcXVvdGVcbiAgIGluc2lkZSBhIGRvdWJsZS1xdW90ZWQgY21kLmV4ZSBzdHJpbmcgYXJlIGRvdWJsZS1xdW90ZSBhbmQgcGVyY2VudC5cbiAgIFdlIGp1c3QgZmFpbCBpZiB0aGUgY29tbWFuZCBuYW1lIG9yIHRoZSByZWRpcmVjdGlvbiBmaWxlIG5hbWVzXG4gICBjb250YWluIGEgZG91YmxlIHF1b3RlIChub3QgYWxsb3dlZCBpbiBXaW5kb3dzIGZpbGUgbmFtZXMsIGFueXdheSlcbiAgIG9yIGEgcGVyY2VudC4gIFNlZSBmdW5jdGlvbiBcInF1b3RlX2NtZF9maWxlbmFtZVwiIGJlbG93LlxuMy0gVGhlIHdob2xlIHN0cmluZyBwYXNzZWQgdG8gU3lzLmNvbW1hbmQgaXMgdGhlbiBlbmNsb3NlZCBpbiBkb3VibGVcbiAgIHF1b3Rlcywgd2hpY2ggYXJlIGltbWVkaWF0ZWx5IHN0cmlwcGVkIGJ5IGNtZC5leGUuICBPdGhlcndpc2UsXG4gICBzb21lIG9mIHRoZSBkb3VibGUgcXVvdGVzIGZyb20gc3RlcCAyIGFib3ZlIGNhbiBiZSBtaXNwYXJzZWQuXG4gICBTZWUgZS5nLiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTk2NTE0MVxuKilcbiAgbGV0IHF1b3RlX2NtZCBzID1cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIDIwKSBpblxuICAgIFN0cmluZy5pdGVyXG4gICAgICAoZnVuIGMgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJygnIHwgJyknIHwgJyEnIHwgJ14nIHwgJyUnIHwgJ1xcXCInIHwgJzwnIHwgJz4nIHwgJyYnIHwgJ3wnIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXic7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjKVxuICAgICAgcztcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgcXVvdGVfY21kX2ZpbGVuYW1lIGYgPVxuICAgIGlmIFN0cmluZy5leGlzdHMgKGZ1bmN0aW9uICdcXFwiJyB8ICclJyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgZiB0aGVuXG4gICAgICBmYWlsd2l0aCAoXCJGaWxlbmFtZS5xdW90ZV9jb21tYW5kOiBiYWQgZmlsZSBuYW1lIFwiIF4gZilcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBmICcgJyB0aGVuXG4gICAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1wiXFxcIlwiOyBmOyBcIlxcXCJcIl1cbiAgICBlbHNlXG4gICAgICBmXG4gICgqIFJlZGlyZWN0aW9ucyBpbiBjbWQuZXhlOiBzZWUgaHR0cHM6Ly9zczY0LmNvbS9udC9zeW50YXgtcmVkaXJlY3Rpb24uaHRtbFxuICAgICBhbmQgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvd2luZG93cy9pdC1wcm8vd2luZG93cy14cC9iYjQ5MDk4Mih2PXRlY2huZXQuMTApXG4gICopXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcIiBbXG4gICAgICBcIlxcXCJcIjtcbiAgICAgIHF1b3RlX2NtZF9maWxlbmFtZSBjbWQ7XG4gICAgICBcIiBcIjtcbiAgICAgIHF1b3RlX2NtZCAoU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgYXJncykpO1xuICAgICAgKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIFwiXFxcIlwiXG4gICAgXVxuICBsZXQgaGFzX2RyaXZlIHMgPVxuICAgIGxldCBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIFN0cmluZy5sZW5ndGggcyA+PSAyICYmIGlzX2xldHRlciBzLlswXSAmJiBzLlsxXSA9ICc6J1xuICBsZXQgZHJpdmVfYW5kX3BhdGggcyA9XG4gICAgaWYgaGFzX2RyaXZlIHNcbiAgICB0aGVuIChTdHJpbmcuc3ViIHMgMCAyLCBTdHJpbmcuc3ViIHMgMiAoU3RyaW5nLmxlbmd0aCBzIC0gMikpXG4gICAgZWxzZSAoXCJcIiwgcylcbiAgbGV0IGRpcm5hbWUgcyA9XG4gICAgbGV0IChkcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgbGV0IGRpciA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aCBpblxuICAgIGRyaXZlIF4gZGlyXG4gIGxldCBiYXNlbmFtZSBzID1cbiAgICBsZXQgKF9kcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBDeWd3aW4gOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCA9IFdpbjMyLmlzX2Rpcl9zZXBcbiAgbGV0IGlzX3JlbGF0aXZlID0gV2luMzIuaXNfcmVsYXRpdmVcbiAgbGV0IGlzX2ltcGxpY2l0ID0gV2luMzIuaXNfaW1wbGljaXRcbiAgbGV0IGNoZWNrX3N1ZmZpeCA9IFdpbjMyLmNoZWNrX3N1ZmZpeFxuICBsZXQgY2hvcF9zdWZmaXhfb3B0ID0gV2luMzIuY2hvcF9zdWZmaXhfb3B0XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IHF1b3RlX2NvbW1hbmQgPSBVbml4LnF1b3RlX2NvbW1hbmRcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFN5c2RlcHMgPVxuICAodmFsIChtYXRjaCBTeXMub3NfdHlwZSB3aXRoXG4gICAgICAgfCBcIldpbjMyXCIgLT4gKG1vZHVsZSBXaW4zMjogU1lTREVQUylcbiAgICAgICB8IFwiQ3lnd2luXCIgLT4gKG1vZHVsZSBDeWd3aW46IFNZU0RFUFMpXG4gICAgICAgfCBfIC0+IChtb2R1bGUgVW5peDogU1lTREVQUykpKVxuXG5pbmNsdWRlIFN5c2RlcHNcblxubGV0IGNvbmNhdCBkaXJuYW1lIGZpbGVuYW1lID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRpcm5hbWUgaW5cbiAgaWYgbCA9IDAgfHwgaXNfZGlyX3NlcCBkaXJuYW1lIChsLTEpXG4gIHRoZW4gZGlybmFtZSBeIGZpbGVuYW1lXG4gIGVsc2UgZGlybmFtZSBeIGRpcl9zZXAgXiBmaWxlbmFtZVxuXG5sZXQgY2hvcF9zdWZmaXggbmFtZSBzdWZmID1cbiAgaWYgY2hlY2tfc3VmZml4IG5hbWUgc3VmZlxuICB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiXG5cbmxldCBleHRlbnNpb25fbGVuIG5hbWUgPVxuICBsZXQgcmVjIGNoZWNrIGkwIGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpMCAoaSAtIDEpXG4gICAgZWxzZSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBpMFxuICBpblxuICBsZXQgcmVjIHNlYXJjaF9kb3QgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkgKGkgLSAxKVxuICAgIGVsc2Ugc2VhcmNoX2RvdCAoaSAtIDEpXG4gIGluXG4gIHNlYXJjaF9kb3QgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbmxldCBleHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gXCJcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbCkgbFxuXG5sZXQgY2hvcF9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX2V4dGVuc2lvblwiXG4gIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmxldCByZW1vdmVfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIG5hbWUgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxuZXh0ZXJuYWwgb3Blbl9kZXNjOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5leHRlcm5hbCBjbG9zZV9kZXNjOiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2xvc2VcIlxuXG5sZXQgcHJuZ19rZXkgPVxuICBEb21haW4uRExTLm5ld19rZXkgUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJhbmRvbV9zdGF0ZSA9IERvbWFpbi5ETFMuZ2V0IHBybmdfa2V5IGluXG4gIGxldCBybmQgPSAoUmFuZG9tLlN0YXRlLmJpdHMgcmFuZG9tX3N0YXRlKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID1cbiAgRG9tYWluLkRMUy5uZXdfa2V5IH5zcGxpdF9mcm9tX3BhcmVudDpGdW4uaWQgKGZ1biAoKSAtPiB0ZW1wX2Rpcl9uYW1lKVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IERvbWFpbi5ETFMuc2V0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSBEb21haW4uRExTLmdldCBjdXJyZW50X3RlbXBfZGlyX25hbWVcblxubGV0IHRlbXBfZmlsZSA/KHRlbXBfZGlyID0gRG9tYWluLkRMUy5nZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMjAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCBvcGVuX3RlbXBfZmlsZSA/KG1vZGUgPSBbT3Blbl90ZXh0XSkgPyhwZXJtcyA9IDBvNjAwKVxuICAgID8odGVtcF9kaXIgPSBEb21haW4uRExTLmdldCBjdXJyZW50X3RlbXBfZGlyX25hbWUpXG4gICAgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDIwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgdGVtcF9kaXIgPyh0ZW1wX2RpciA9IERvbWFpbi5ETFMuZ2V0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSlcbiAgICA/KHBlcm1zID0gMG83MDApIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgU3lzLm1rZGlyIG5hbWUgcGVybXM7XG4gICAgICBuYW1lXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDIwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9IEZsb2F0Lmh5cG90IHgucmUgeC5pbVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICBLQyBTaXZhcmFtYWtyaXNobmFuLCBJbmRpYW4gSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3ksIE1hZHJhcyAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMSBJbmRpYW4gSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3ksIE1hZHJhcyAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAuLlxuZXh0ZXJuYWwgcGVyZm9ybSA6ICdhIHQgLT4gJ2EgPSBcIiVwZXJmb3JtXCJcblxudHlwZSBleG4gKz0gVW5oYW5kbGVkOiAnYSB0IC0+IGV4blxuZXhjZXB0aW9uIENvbnRpbnVhdGlvbl9hbHJlYWR5X3Jlc3VtZWRcblxubGV0ICgpID1cbiAgbGV0IHByaW50ZXIgPSBmdW5jdGlvblxuICAgIHwgVW5oYW5kbGVkIHggLT5cbiAgICAgICAgbGV0IG1zZyA9IFByaW50Zi5zcHJpbnRmIFwiU3RkbGliLkVmZmVjdC5VbmhhbmRsZWQoJXMpXCJcbiAgICAgICAgICAgIChQcmludGV4Yy5zdHJpbmdfb2ZfZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEBAIE9iai5yZXByIHgpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgbXNnXG4gICAgfCBfIC0+IE5vbmVcbiAgaW5cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBwcmludGVyXG5cbigqIFJlZ2lzdGVyIHRoZSBleGNlcHRpb25zIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIGFjY2VzcyBpdCAqKVxudHlwZSBfIHQgKz0gU2hvdWxkX25vdF9zZWVfdGhpc19fIDogdW5pdCB0XG5sZXQgXyA9IENhbGxiYWNrLnJlZ2lzdGVyX2V4Y2VwdGlvbiBcIkVmZmVjdC5VbmhhbmRsZWRcIlxuICAgICAgICAgIChVbmhhbmRsZWQgU2hvdWxkX25vdF9zZWVfdGhpc19fKVxubGV0IF8gPSBDYWxsYmFjay5yZWdpc3Rlcl9leGNlcHRpb24gXCJFZmZlY3QuQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFwiXG4gICAgICAgICAgQ29udGludWF0aW9uX2FscmVhZHlfcmVzdW1lZFxuXG50eXBlICgnYSwgJ2IpIHN0YWNrIFtAQGltbWVkaWF0ZV1cbnR5cGUgbGFzdF9maWJlciBbQEBpbW1lZGlhdGVdXG5cbmV4dGVybmFsIHJlc3VtZSA6XG4gICgnYSwgJ2IpIHN0YWNrIC0+ICgnYyAtPiAnYSkgLT4gJ2MgLT4gbGFzdF9maWJlciAtPiAnYiA9IFwiJXJlc3VtZVwiXG5leHRlcm5hbCBydW5zdGFjayA6ICgnYSwgJ2IpIHN0YWNrIC0+ICgnYyAtPiAnYSkgLT4gJ2MgLT4gJ2IgPSBcIiVydW5zdGFja1wiXG5cbm1vZHVsZSBEZWVwID0gc3RydWN0XG5cbiAgdHlwZSAoJ2EsJ2IpIGNvbnRpbnVhdGlvblxuXG4gIGV4dGVybmFsIHRha2VfY29udF9ub2V4YyA6ICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiAtPiAoJ2EsICdiKSBzdGFjayA9XG4gICAgXCJjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGNcIiBbQEBub2FsbG9jXVxuICBleHRlcm5hbCBhbGxvY19zdGFjayA6XG4gICAgKCdhIC0+ICdiKSAtPlxuICAgIChleG4gLT4gJ2IpIC0+XG4gICAgKCdjIHQgLT4gKCdjLCAnYikgY29udGludWF0aW9uIC0+IGxhc3RfZmliZXIgLT4gJ2IpIC0+XG4gICAgKCdhLCAnYikgc3RhY2sgPSBcImNhbWxfYWxsb2Nfc3RhY2tcIlxuICBleHRlcm5hbCBjb250X2xhc3RfZmliZXIgOiAoJ2EsICdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciA9IFwiJWZpZWxkMVwiXG4gIGV4dGVybmFsIGNvbnRfc2V0X2xhc3RfZmliZXIgOlxuICAgICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDFcIlxuXG4gIGxldCBjb250aW51ZSBrIHYgPVxuICAgIHJlc3VtZSAodGFrZV9jb250X25vZXhjIGspIChmdW4geCAtPiB4KSB2IChjb250X2xhc3RfZmliZXIgaylcblxuICBsZXQgZGlzY29udGludWUgayBlID1cbiAgICByZXN1bWUgKHRha2VfY29udF9ub2V4YyBrKSAoZnVuIGUgLT4gcmFpc2UgZSkgZSAoY29udF9sYXN0X2ZpYmVyIGspXG5cbiAgbGV0IGRpc2NvbnRpbnVlX3dpdGhfYmFja3RyYWNlIGsgZSBidCA9XG4gICAgcmVzdW1lICh0YWtlX2NvbnRfbm9leGMgaykgKGZ1biBlIC0+IFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIGUgYnQpXG4gICAgICBlIChjb250X2xhc3RfZmliZXIgaylcblxuICB0eXBlICgnYSwnYikgaGFuZGxlciA9XG4gICAgeyByZXRjOiAnYSAtPiAnYjtcbiAgICAgIGV4bmM6IGV4biAtPiAnYjtcbiAgICAgIGVmZmM6ICdjLidjIHQgLT4gKCgnYywnYikgY29udGludWF0aW9uIC0+ICdiKSBvcHRpb24gfVxuXG4gIGV4dGVybmFsIHJlcGVyZm9ybSA6XG4gICAgJ2EgdCAtPiAoJ2EsICdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYiA9IFwiJXJlcGVyZm9ybVwiXG5cbiAgbGV0IG1hdGNoX3dpdGggY29tcCBhcmcgaGFuZGxlciA9XG4gICAgbGV0IGVmZmMgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+XG4gICAgICAgICAgY29udF9zZXRfbGFzdF9maWJlciBrIGxhc3RfZmliZXI7XG4gICAgICAgICAgZiBrXG4gICAgICB8IE5vbmUgLT4gcmVwZXJmb3JtIGVmZiBrIGxhc3RfZmliZXJcbiAgICBpblxuICAgIGxldCBzID0gYWxsb2Nfc3RhY2sgaGFuZGxlci5yZXRjIGhhbmRsZXIuZXhuYyBlZmZjIGluXG4gICAgcnVuc3RhY2sgcyBjb21wIGFyZ1xuXG4gIHR5cGUgJ2EgZWZmZWN0X2hhbmRsZXIgPVxuICAgIHsgZWZmYzogJ2IuICdiIHQgLT4gKCgnYiwnYSkgY29udGludWF0aW9uIC0+ICdhKSBvcHRpb24gfVxuXG4gIGxldCB0cnlfd2l0aCBjb21wIGFyZyBoYW5kbGVyID1cbiAgICBsZXQgZWZmYycgZWZmIGsgbGFzdF9maWJlciA9XG4gICAgICBtYXRjaCBoYW5kbGVyLmVmZmMgZWZmIHdpdGhcbiAgICAgIHwgU29tZSBmIC0+XG4gICAgICAgICAgY29udF9zZXRfbGFzdF9maWJlciBrIGxhc3RfZmliZXI7XG4gICAgICAgICAgZiBrXG4gICAgICB8IE5vbmUgLT4gcmVwZXJmb3JtIGVmZiBrIGxhc3RfZmliZXJcbiAgICBpblxuICAgIGxldCBzID0gYWxsb2Nfc3RhY2sgKGZ1biB4IC0+IHgpIChmdW4gZSAtPiByYWlzZSBlKSBlZmZjJyBpblxuICAgIHJ1bnN0YWNrIHMgY29tcCBhcmdcblxuICBleHRlcm5hbCBnZXRfY2FsbHN0YWNrIDpcbiAgICAoJ2EsJ2IpIGNvbnRpbnVhdGlvbiAtPiBpbnQgLT4gUHJpbnRleGMucmF3X2JhY2t0cmFjZSA9XG4gICAgXCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrXCJcbmVuZFxuXG5tb2R1bGUgU2hhbGxvdyA9IHN0cnVjdFxuXG4gIHR5cGUgKCdhLCdiKSBjb250aW51YXRpb25cblxuICBleHRlcm5hbCBhbGxvY19zdGFjayA6XG4gICAgKCdhIC0+ICdiKSAtPlxuICAgIChleG4gLT4gJ2IpIC0+XG4gICAgKCdjIHQgLT4gKCdjLCAnYikgY29udGludWF0aW9uIC0+IGxhc3RfZmliZXIgLT4gJ2IpIC0+XG4gICAgKCdhLCAnYikgc3RhY2sgPSBcImNhbWxfYWxsb2Nfc3RhY2tcIlxuXG4gIGV4dGVybmFsIGNvbnRfbGFzdF9maWJlciA6ICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyID0gXCIlZmllbGQxXCJcbiAgZXh0ZXJuYWwgY29udF9zZXRfbGFzdF9maWJlciA6XG4gICAgKCdhLCAnYikgY29udGludWF0aW9uIC0+IGxhc3RfZmliZXIgLT4gdW5pdCA9IFwiJXNldGZpZWxkMVwiXG5cbiAgbGV0IGZpYmVyIDogdHlwZSBhIGIuIChhIC0+IGIpIC0+IChhLCBiKSBjb250aW51YXRpb24gPSBmdW4gZiAtPlxuICAgIGxldCBtb2R1bGUgTSA9IHN0cnVjdCB0eXBlIF8gdCArPSBJbml0aWFsX3NldHVwX18gOiBhIHQgZW5kIGluXG4gICAgbGV0IGV4Y2VwdGlvbiBFIG9mIChhLGIpIGNvbnRpbnVhdGlvbiBpblxuICAgIGxldCBmJyAoKSA9IGYgKHBlcmZvcm0gTS5Jbml0aWFsX3NldHVwX18pIGluXG4gICAgbGV0IGVycm9yIF8gPSBmYWlsd2l0aCBcImltcG9zc2libGVcIiBpblxuICAgIGxldCBlZmZjIGVmZiBrIGxhc3RfZmliZXIgPVxuICAgICAgbWF0Y2ggZWZmIHdpdGhcbiAgICAgIHwgTS5Jbml0aWFsX3NldHVwX18gLT5cbiAgICAgICAgICBjb250X3NldF9sYXN0X2ZpYmVyIGsgbGFzdF9maWJlcjtcbiAgICAgICAgICByYWlzZV9ub3RyYWNlIChFIGspXG4gICAgICB8IF8gLT4gZXJyb3IgKClcbiAgICBpblxuICAgIGxldCBzID0gYWxsb2Nfc3RhY2sgZXJyb3IgZXJyb3IgZWZmYyBpblxuICAgIG1hdGNoIHJ1bnN0YWNrIHMgZicgKCkgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEUgayAtPiBrXG4gICAgfCBfIC0+IGVycm9yICgpXG5cbiAgdHlwZSAoJ2EsJ2IpIGhhbmRsZXIgPVxuICAgIHsgcmV0YzogJ2EgLT4gJ2I7XG4gICAgICBleG5jOiBleG4gLT4gJ2I7XG4gICAgICBlZmZjOiAnYy4nYyB0IC0+ICgoJ2MsJ2EpIGNvbnRpbnVhdGlvbiAtPiAnYikgb3B0aW9uIH1cblxuICBleHRlcm5hbCB1cGRhdGVfaGFuZGxlciA6XG4gICAgKCdhLCdiKSBjb250aW51YXRpb24gLT5cbiAgICAoJ2IgLT4gJ2MpIC0+XG4gICAgKGV4biAtPiAnYykgLT5cbiAgICAoJ2QgdCAtPiAoJ2QsJ2IpIGNvbnRpbnVhdGlvbiAtPiBsYXN0X2ZpYmVyIC0+ICdjKSAtPlxuICAgICgnYSwnYykgc3RhY2sgPSBcImNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGNcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHJlcGVyZm9ybSA6XG4gICAgJ2EgdCAtPiAoJ2EsICdiKSBjb250aW51YXRpb24gLT4gbGFzdF9maWJlciAtPiAnYyA9IFwiJXJlcGVyZm9ybVwiXG5cbiAgbGV0IGNvbnRpbnVlX2dlbiBrIHJlc3VtZV9mdW4gdiBoYW5kbGVyID1cbiAgICBsZXQgZWZmYyBlZmYgayBsYXN0X2ZpYmVyID1cbiAgICAgIG1hdGNoIGhhbmRsZXIuZWZmYyBlZmYgd2l0aFxuICAgICAgfCBTb21lIGYgLT5cbiAgICAgICAgICBjb250X3NldF9sYXN0X2ZpYmVyIGsgbGFzdF9maWJlcjtcbiAgICAgICAgICBmIGtcbiAgICAgIHwgTm9uZSAtPiByZXBlcmZvcm0gZWZmIGsgbGFzdF9maWJlclxuICAgIGluXG4gICAgbGV0IGxhc3RfZmliZXIgPSBjb250X2xhc3RfZmliZXIgayBpblxuICAgIGxldCBzdGFjayA9IHVwZGF0ZV9oYW5kbGVyIGsgaGFuZGxlci5yZXRjIGhhbmRsZXIuZXhuYyBlZmZjIGluXG4gICAgcmVzdW1lIHN0YWNrIHJlc3VtZV9mdW4gdiBsYXN0X2ZpYmVyXG5cbiAgbGV0IGNvbnRpbnVlX3dpdGggayB2IGhhbmRsZXIgPVxuICAgIGNvbnRpbnVlX2dlbiBrIChmdW4geCAtPiB4KSB2IGhhbmRsZXJcblxuICBsZXQgZGlzY29udGludWVfd2l0aCBrIHYgaGFuZGxlciA9XG4gICAgY29udGludWVfZ2VuIGsgKGZ1biBlIC0+IHJhaXNlIGUpIHYgaGFuZGxlclxuXG4gIGxldCBkaXNjb250aW51ZV93aXRoX2JhY2t0cmFjZSBrIHYgYnQgaGFuZGxlciA9XG4gICAgY29udGludWVfZ2VuIGsgKGZ1biBlIC0+IFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIGUgYnQpIHYgaGFuZGxlclxuXG4gIGV4dGVybmFsIGdldF9jYWxsc3RhY2sgOlxuICAgICgnYSwnYikgY29udGludWF0aW9uIC0+IGludCAtPiBQcmludGV4Yy5yYXdfYmFja3RyYWNlID1cbiAgICBcImNhbWxfZ2V0X2NvbnRpbnVhdGlvbl9jYWxsc3RhY2tcIlxuZW5kXG4iXX0=
