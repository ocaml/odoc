// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.2

//# unitInfo: Provides: Db__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Db = [0], Db$0 = [0, Db];
   runtime.caml_register_global(0, Db$0, "Db__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db__Typexpr
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "_",
    cst$0 = "???",
    cst$1 = " -> ",
    cst$2 = ") ",
    cst$3 = cst$11,
    cst$4 = " ",
    cst$6 = "'_",
    cst$5 = "'",
    cst$7 = ")",
    cst$8 = cst$11,
    cst$9 = ", ",
    cst$10 = " * ",
    Stdlib = global_data.Stdlib,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_show_list_empty = "show_list: empty",
    cst_show_tuple_empty = "show_tuple: empty";
   function tuple(xs){
    if(! xs) return 0;
    if(xs[2]) return [2, xs];
    var x = xs[1];
    return x;
   }
   function show$0(counter, param){
    if(typeof param === "number") return 0 === param ? cst : cst$0;
    switch(param[0]){
      case 0:
       var
        b = param[2],
        a = param[1],
        _i_ = show(b),
        _j_ = caml_call2(Stdlib[28], cst$1, _i_),
        _k_ = show_parens(a);
       return caml_call2(Stdlib[28], _k_, _j_);
      case 1:
       var t = param[1], _l_ = param[2];
       if(! _l_) return t;
       if(_l_[2]){
        var
         xs = param[2],
         _m_ = caml_call2(Stdlib[28], cst$2, t),
         _n_ = show_list(xs),
         _o_ = caml_call2(Stdlib[28], _n_, _m_);
        return caml_call2(Stdlib[28], cst$3, _o_);
       }
       var
        x = _l_[1],
        _p_ = caml_call2(Stdlib[28], cst$4, t),
        _q_ = show_parens(x);
       return caml_call2(Stdlib[28], _q_, _p_);
      case 2:
       var xs$0 = param[1];
       if(counter >= 50)
        return caml_trampoline_return(show_tuple$0, [0, xs$0]);
       var counter$0 = counter + 1 | 0;
       return show_tuple$0(counter$0, xs$0);
      default:
       var name = param[1];
       return name !== "" ? caml_call2(Stdlib[28], cst$5, name) : cst$6;
    }
   }
   function show(param){return caml_trampoline(show$0(0, param));}
   function show_parens$0(counter, t){
    if(typeof t !== "number")
     switch(t[0]){
       case 1:
       case 3: break;
       default:
        var _g_ = show(t), _h_ = caml_call2(Stdlib[28], _g_, cst$7);
        return caml_call2(Stdlib[28], cst$8, _h_);
     }
    if(counter >= 50) return caml_trampoline_return(show$0, [0, t]);
    var counter$0 = counter + 1 | 0;
    return show$0(counter$0, t);
   }
   function show_parens(t){return caml_trampoline(show_parens$0(0, t));}
   function show_list(param){
    if(! param) return caml_call1(Stdlib[2], cst_show_list_empty);
    var x = param[1];
    if(! param[2]) return show(x);
    var
     xs = param[2],
     _d_ = show_list(xs),
     _e_ = caml_call2(Stdlib[28], cst$9, _d_),
     _f_ = show(x);
    return caml_call2(Stdlib[28], _f_, _e_);
   }
   function show_tuple$0(counter, param){
    if(! param) return caml_call1(Stdlib[2], cst_show_tuple_empty);
    var x = param[1];
    if(param[2]){
     var
      xs = param[2],
      _a_ = show_tuple(xs),
      _b_ = caml_call2(Stdlib[28], cst$10, _a_),
      _c_ = show_parens(x);
     return caml_call2(Stdlib[28], _c_, _b_);
    }
    if(counter >= 50) return caml_trampoline_return(show_parens$0, [0, x]);
    var counter$0 = counter + 1 | 0;
    return show_parens$0(counter$0, x);
   }
   function show_tuple(param){return caml_trampoline(show_tuple$0(0, param));}
   function size(typ){return runtime.caml_ml_string_length(show(typ));}
   var
    equal = runtime.caml_equal,
    hash = Stdlib_Hashtbl[28],
    Db_Typexpr = [0, tuple, size, show, equal, hash];
   runtime.caml_register_global(17, Db_Typexpr, "Db__Typexpr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db__Type_polarity
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$1 = " ",
    cst = "-",
    cst$0 = "+",
    poly = "@",
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   function to_string(param){return param ? cst : cst$0;}
   function not(param){return param ? 0 : 1;}
   var Sign = [0, to_string, not];
   function rev_concat(lst){
    return caml_call3
            (Stdlib_List[26],
             function(acc, xs){return caml_call2(Stdlib_List[13], xs, acc);},
             0,
             lst);
   }
   function _a_(any_is_poly, prefix, sgn, param){
    if(typeof param === "number")
     return 0 === param
             ? any_is_poly
               ? [0, [0, sgn, [0, poly, prefix]], 0]
               : [0, [0, sgn, prefix], 0]
             : 0;
    switch(param[0]){
      case 0:
       var
        b = param[2],
        a = param[1],
        _h_ = _a_(any_is_poly, prefix, sgn, b),
        _i_ = _a_(any_is_poly, prefix, caml_call1(Sign[2], sgn), a);
       return caml_call2(Stdlib_List[13], _i_, _h_);
      case 1:
       var
        args = param[2],
        name = param[1],
        prefix$0 = [0, caml_call1(Stdlib_String[27], name), prefix];
       return args
               ? rev_concat
                 (caml_call2
                   (Stdlib_List[21],
                    function(i, arg){
                     var prefix = [0, caml_call1(Stdlib[33], i), prefix$0];
                     return _a_(any_is_poly, prefix, sgn, arg);
                    },
                    args))
               : [0, [0, sgn, prefix$0], 0];
      case 2:
       var args$0 = param[1];
       return rev_concat
               (caml_call1
                 (caml_call1
                   (Stdlib_List[20],
                    function(_j_){return _a_(any_is_poly, prefix, sgn, _j_);}),
                  args$0));
      default: return [0, [0, sgn, [0, poly, prefix]], 0];
    }
   }
   function of_typ(any_is_poly, t){
    var
     _c_ = _a_(any_is_poly, 0, 0, t),
     lst =
       caml_call1
        (caml_call1
          (Stdlib_List[20],
           function(param){
            var
             path = param[2],
             polarity = param[1],
             _g_ = caml_call1(Stdlib_List[10], path);
            return [0, polarity, caml_call2(Stdlib_String[7], cst$1, _g_)];
           }),
         _c_),
     h = caml_call2(Stdlib_Hashtbl[1], 0, 16);
    caml_call2
     (Stdlib_List[18],
      function(v){
       try{var _e_ = caml_call2(Stdlib_Hashtbl[6], h, v), count = _e_;}
       catch(_f_){
        var _d_ = caml_wrap_exception(_f_);
        if(_d_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_d_, 0);
        var count = 0;
       }
       return caml_call3(Stdlib_Hashtbl[11], h, v, count + 1 | 0);
      },
      lst);
    var _b_ = caml_call1(Stdlib_Hashtbl[20], h);
    return caml_call1
            (caml_call1
              (Stdlib_Seq[29],
               function(param){
                var
                 count = param[2],
                 match = param[1],
                 path = match[2],
                 polarity = match[1];
                return [0, path, count, polarity];
               }),
             _b_);
   }
   var Db_Type_polarity = [0, Sign, of_typ, poly];
   runtime.caml_register_global(9, Db_Type_polarity, "Db__Type_polarity");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db__Entry
//# unitInfo: Requires: Fmt, Stdlib, Stdlib__Format, Stdlib__Int, Stdlib__List, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst$3 = "/",
    cst_Stdlib = "Stdlib",
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$3,
    cst$0 = "#",
    hashref = cst$4,
    cst$1 = ".",
    partial = [11, " ; pkg = . }\n", 0],
    cst = cst$3,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Int = global_data.Stdlib__Int,
    Fmt = global_data.Fmt,
    Stdlib_Format = global_data.Stdlib__Format,
    empty_string = caml_call2(Stdlib_String[1], 0, 95);
   function non_empty_string(s){return s == cst$4 ? empty_string : s;}
   var equal = runtime.caml_equal;
   function get_type(t){
    if(typeof t !== "number" && 1 !== t[0]){var typ = t[1]; return [0, typ];}
    return 0;
   }
   var
    Kind = [0, equal, get_type],
    cst_https_ocaml_org_p = "https://ocaml.org/p/",
    _a_ =
      [0,
       [11,
        "{ name = ",
        [2,
         0,
         [11,
          " ; rhs = ",
          [15,
           [11,
            " ; url = ",
            [2,
             0,
             [11,
              " ; kind = . ; cost = ",
              [4, 0, 0, 0, [11, " ; doc_html = ", [2, 0, partial]]]]]]]]]],
       "{ name = %s ; rhs = %a ; url = %s ; kind = . ; cost = %d ; doc_html = %s ; pkg = . }\n"],
    cst_html = ".html",
    cst_https_v2_ocaml_org_release = "https://v2.ocaml.org/releases/5.1/api/",
    cst_doc = "/doc/";
   function v(name, version){
    var _o_ = non_empty_string(version);
    return [0, non_empty_string(name), _o_];
   }
   function link(param){
    var
     version = param[2],
     name = param[1],
     _m_ = caml_call2(Stdlib[28], cst, version),
     _n_ = caml_call2(Stdlib[28], name, _m_);
    return caml_call2(Stdlib[28], cst_https_ocaml_org_p, _n_);
   }
   function pp(fmt, param){
    var
     doc_html = param[6],
     cost = param[5],
     url = param[3],
     rhs = param[2],
     name = param[1],
     _l_ = caml_call2(Fmt[62], 0, Fmt[57]);
    return caml_call8
            (Stdlib_Format[139],
             fmt,
             _a_,
             name,
             _l_,
             rhs,
             url,
             cost,
             doc_html);
   }
   function string_compare_shorter(a, b){
    var
     c =
       caml_call2
        (Stdlib_Int[9], caml_ml_string_length(a), caml_ml_string_length(b));
    return 0 === c ? caml_call2(Stdlib_String[10], a, b) : c;
   }
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    var cmp = caml_call2(Stdlib_Int[9], a$0[5], b$0[5]);
    if(0 !== cmp) return cmp;
    var c$0 = string_compare_shorter(a$0[1], b$0[1]);
    if(0 !== c$0) return c$0;
    var b = b$0[7], a = a$0[7], c = caml_call2(Stdlib_String[10], a[1], b[1]);
    if(0 !== c) return c;
    var c$1 = runtime.caml_compare(a$0[4], b$0[4]);
    if(0 !== c$1) return c$1;
    var c$2 = string_compare_shorter(a$0[6], b$0[6]);
    return 0 === c$2 ? caml_call2(Stdlib_String[10], a$0[3], b$0[3]) : c$2;
   }
   function equal$0(a, b){return 0 === compare(a, b) ? 1 : 0;}
   function link$0(t){
    var fullname = caml_call2(Stdlib_String[17], 46, t[1]);
    if(fullname && fullname[1] === cst_Stdlib){
     var
      name = fullname[2],
      path = caml_call1(Stdlib_List[10], name),
      match = caml_call2(Stdlib_String[37], t[3], 35);
     a:
     {
      if(path && match){
       var
        idx = match[1],
        path$0 = path[2],
        idx$0 = idx + 1 | 0,
        match$0 = caml_call3(Stdlib_String[33], t[3], idx$0, 45);
       if(match$0)
        var
         jdx = match$0[1],
         kind = caml_call3(Stdlib_String[16], t[3], idx$0, jdx - idx$0 | 0),
         jdx$0 = jdx + 1 | 0,
         target =
           caml_call3
            (Stdlib_String[16],
             t[3],
             jdx$0,
             caml_ml_string_length(t[3]) - jdx$0 | 0),
         _e_ = caml_call1(Stdlib_String[26], kind),
         tgt = caml_call2(Stdlib[28], _e_, target);
       else
        var
         tgt =
           caml_call3
            (Stdlib_String[16],
             t[3],
             idx$0,
             caml_ml_string_length(t[3]) - idx$0 | 0);
       var hashref$0 = caml_call2(Stdlib[28], cst$0, tgt), path$1 = path$0;
       break a;
      }
      var hashref$0 = hashref, path$1 = path;
     }
     var
      _f_ = caml_call1(Stdlib_List[10], path$1),
      path$2 = caml_call2(Stdlib_String[7], cst$1, _f_),
      _g_ = caml_call2(Stdlib[28], cst_html, hashref$0),
      _h_ = caml_call2(Stdlib[28], path$2, _g_);
     return caml_call2(Stdlib[28], cst_https_v2_ocaml_org_release, _h_);
    }
    var pkg_link = link(t[7]);
    function align(n, ys){
     if(0 === n) return 0;
     if(! ys) return 0;
     var ys$0 = ys[2], y = ys[1];
     return [0, y, align(n - 1 | 0, ys$0)];
    }
    var
     length = caml_call1(Stdlib_List[1], fullname),
     match$1 = caml_call2(Stdlib_String[37], t[3], 35);
    if(match$1){
     var
      idx$1 = match$1[1],
      tgt$0 =
        caml_call3
         (Stdlib_String[16],
          t[3],
          idx$1,
          caml_ml_string_length(t[3]) - idx$1 | 0),
      count = [0, 0];
     caml_call2
      (Stdlib_String[30],
       function(param){return 46 === param ? (count[1]++, 0) : 0;},
       tgt$0);
     var length$0 = length - count[1] | 0;
    }
    else
     var length$0 = length + 1 | 0;
    var
     _i_ = caml_call2(Stdlib_String[17], 47, t[3]),
     path$3 = align(length$0, caml_call1(Stdlib_List[10], _i_)),
     _j_ = caml_call1(Stdlib_List[10], path$3),
     path$4 = caml_call2(Stdlib_String[7], cst$2, _j_),
     _k_ = caml_call2(Stdlib[28], cst_doc, path$4);
    return caml_call2(Stdlib[28], pkg_link, _k_);
   }
   function v$0(name, kind, cost, rhs, doc_html, url, pkg, param){
    var
     _b_ = non_empty_string(doc_html),
     _c_ = non_empty_string(url),
     _d_ = caml_call2(Stdlib_Option[7], non_empty_string, rhs);
    return [0, non_empty_string(name), _d_, _c_, kind, cost, _b_, pkg];
   }
   var Db_Entry = [0, Kind, [0, v, link], pp, v$0, link$0, compare, equal$0];
   runtime.caml_register_global(19, Db_Entry, "Db__Entry");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db__String_automata
//# unitInfo: Requires: Db__Type_polarity, Stdlib__Array, Stdlib__Obj, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_sherlodoc_db_string_automa = "sherlodoc/db/string_automata.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array,
    Db_Type_polarity = global_data.Db__Type_polarity,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, 0, 0, 0, 0, 0],
    _b_ = [0, cst_sherlodoc_db_string_automa, 29, 13],
    _c_ = [0, cst_sherlodoc_db_string_automa, 83, 2],
    _d_ = [0, cst_sherlodoc_db_string_automa, 87, 2];
   function empty(param){return _a_.slice();}
   function size(t){return t[2][3];}
   function minimum(param){
    var t = param[2], match = t[4];
    if(typeof match === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var arr = match[1];
    return caml_check_bound(arr, 0)[1];
   }
   function find(t, pattern){
    var child$1 = t[2], j_str = t[1], child$0 = child$1, i$4 = 0;
    for(;;){
     var j_len = child$0[2], j$1 = child$0[1], j_stop = j$1 + j_len | 0;
     a:
     b:
     {
      var i$1 = i$4, j = j$1;
      for(;;){
       if(caml_ml_string_length(pattern) <= i$1) break b;
       if(j_stop <= j) break b;
       var
        j_chr = caml_string_get(j_str, j),
        i_chr = caml_string_get(pattern, i$1);
       if(i_chr !== j_chr) break;
       var j$0 = j + 1 | 0, i$2 = i$1 + 1 | 0;
       i$1 = i$2;
       j = j$0;
      }
      break a;
     }
     var n = i$1 - i$4 | 0;
     if((i$4 + n | 0) === caml_ml_string_length(pattern))
      var
       match$0 =
         [0,
          [0,
           child$0[1] + n | 0,
           child$0[2] - n | 0,
           child$0[3],
           child$0[4],
           child$0[5]]];
     else if(n === child$0[2]){
      var i$5 = i$4 + n | 0;
      if(caml_ml_string_length(pattern) <= i$5)
       var match$0 = [0, child$0];
      else{
       var param = child$0[5], chr = caml_string_get(pattern, i$5);
       a:
       if(param){
        var arr = param[1];
        b:
        {
         var i = 0;
         for(;;){
          if(arr.length - 1 <= i) break b;
          var node = caml_check_bound(arr, i)[1 + i];
          if(chr === caml_string_get(j_str, node[1] - 1 | 0)) break;
          var i$0 = i + 1 | 0;
          i = i$0;
         }
         var match = [0, node];
         break a;
        }
        var match = 0;
       }
       else
        var match = 0;
       if(match){
        var child = match[1], i$3 = i$5 + 1 | 0;
        child$0 = child;
        i$4 = i$3;
        continue;
       }
       var match$0 = 0;
      }
     }
     else
      var match$0 = 0;
     if(! match$0) return 0;
     var child$2 = match$0[1];
     return [0, [0, t[1], child$2]];
    }
   }
   function find_skip(spaces, t, pattern, yield$0){
    function skip(param){
     var node = t[2];
     if(1 <= node[2]){
      var
       _e_ = 32 === caml_string_get(t[1], node[1]) ? 1 : 0,
       spaces$0 = spaces + _e_ | 0;
      if(1 < spaces$0) return 0;
      var node$0 = t[2];
      if(1 <= node$0[2])
       return find_skip
               (spaces$0,
                [0,
                 t[1],
                 [0,
                  node$0[1] + 1 | 0,
                  node$0[2] - 1 | 0,
                  node$0[3],
                  node$0[4],
                  node$0[5]]],
                pattern,
                yield$0);
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var match = node[5];
     if(! match) return 0;
     var children = match[1];
     return caml_call2
             (Stdlib_Array[12],
              function(child){
               if(0 <= child[2])
                return find_skip
                        (spaces,
                         [0,
                          t[1],
                          [0,
                           child[1] - 1 | 0,
                           child[2] + 1 | 0,
                           child[3],
                           child[4],
                           child[5]]],
                         pattern,
                         yield$0);
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              },
              children);
    }
    if(0 === spaces) return skip(0);
    if(1 === spaces && pattern == Db_Type_polarity[3]){
     var match = find(t, pattern);
     if(! match) return 0;
     var here = match[1];
     return caml_call1(yield$0, here);
    }
    skip(0);
    var match$0 = find(t, pattern);
    if(! match$0) return 0;
    var here$0 = match$0[1];
    return caml_call1(yield$0, here$0);
   }
   function find_star(t$0, pattern){
    var found = [0, 0];
    function go(t, param){
     if(param){
      var ps = param[2], p = param[1];
      return find_skip(0, t, p, function(t){return go(t, ps);});
     }
     found[1] = [0, t, found[1]];
     return 0;
    }
    var match = caml_call2(Stdlib_String[17], 32, pattern);
    if(match){
     var ps = match[2], p = match[1], match$0 = find(t$0, p);
     if(match$0){var t = match$0[1]; go(t, ps);}
    }
    return found[1];
   }
   var Db_String_automata = [0, empty, find, find_star, minimum, size];
   runtime.caml_register_global(8, Db_String_automata, "Db__String_automata");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db__Storage
//# unitInfo: Requires: Stdlib__Int, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Map = global_data.Stdlib__Map,
    Occurences = caml_call1(Stdlib_Map[1], [0, Stdlib_Int[9]]),
    Db_Storage = [0, Occurences];
   runtime.caml_register_global(2, Db_Storage, "Db__Storage");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Db
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Db = [0];
   runtime.caml_register_global(0, Db, "Db");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuZGIub2Jqcy9qc29vL2RlZmF1bHQvZGIuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInR1cGxlIiwieHMiLCJ4Iiwic2hvdyQwIiwiYiIsImEiLCJzaG93Iiwic2hvd19wYXJlbnMiLCJ0Iiwic2hvd19saXN0IiwieHMkMCIsInNob3dfdHVwbGUkMCIsIm5hbWUiLCJzaG93X3BhcmVucyQwIiwic2hvd190dXBsZSIsInNpemUiLCJ0eXAiLCJlcXVhbCIsImhhc2giLCJwb2x5IiwidG9fc3RyaW5nIiwibm90IiwicmV2X2NvbmNhdCIsImxzdCIsImFjYyIsImFueV9pc19wb2x5IiwicHJlZml4Iiwic2duIiwiYXJncyIsInByZWZpeCQwIiwiaSIsImFyZyIsImFyZ3MkMCIsIm9mX3R5cCIsInBhdGgiLCJwb2xhcml0eSIsImgiLCJ2IiwiY291bnQiLCJoYXNocmVmIiwiZW1wdHlfc3RyaW5nIiwibm9uX2VtcHR5X3N0cmluZyIsInMiLCJnZXRfdHlwZSIsInZlcnNpb24iLCJsaW5rIiwicHAiLCJmbXQiLCJkb2NfaHRtbCIsImNvc3QiLCJ1cmwiLCJyaHMiLCJzdHJpbmdfY29tcGFyZV9zaG9ydGVyIiwiYyIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJjbXAiLCJjJDAiLCJjJDEiLCJjJDIiLCJlcXVhbCQwIiwibGluayQwIiwiZnVsbG5hbWUiLCJpZHgiLCJwYXRoJDAiLCJpZHgkMCIsImpkeCIsImtpbmQiLCJqZHgkMCIsInRhcmdldCIsInRndCIsImhhc2hyZWYkMCIsInBhdGgkMSIsInBhdGgkMiIsInBrZ19saW5rIiwiYWxpZ24iLCJuIiwieXMiLCJ5cyQwIiwieSIsImxlbmd0aCIsImlkeCQxIiwidGd0JDAiLCJsZW5ndGgkMCIsInBhdGgkMyIsInBhdGgkNCIsInYkMCIsInBrZyIsImVtcHR5IiwibWluaW11bSIsImFyciIsImZpbmQiLCJwYXR0ZXJuIiwiY2hpbGQkMSIsImpfc3RyIiwiY2hpbGQkMCIsImkkNCIsImpfbGVuIiwiaiQxIiwial9zdG9wIiwiaSQxIiwiaiIsImpfY2hyIiwiaV9jaHIiLCJqJDAiLCJpJDIiLCJpJDUiLCJjaHIiLCJub2RlIiwiaSQwIiwiY2hpbGQiLCJpJDMiLCJjaGlsZCQyIiwiZmluZF9za2lwIiwic3BhY2VzIiwieWllbGQkMCIsInNraXAiLCJzcGFjZXMkMCIsIm5vZGUkMCIsImNoaWxkcmVuIiwiaGVyZSIsImhlcmUkMCIsImZpbmRfc3RhciIsInQkMCIsImZvdW5kIiwiZ28iLCJwcyIsInAiXSwic291cmNlcyI6WyIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL2RiL2RiX18ubWwtZ2VuIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9kYi90eXBleHByLm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9kYi90eXBlX3BvbGFyaXR5Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9kYi9lbnRyeS5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zaGVybG9kb2MvZGIvc3RyaW5nX2F1dG9tYXRhLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBaUJjLHVDQUFBOzs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ1RWQSxNQUdBQztJQUhRLEtBR1JBLElBRk07T0FFTkEsT0FBTSxXQUFOQTtRQURFQyxJQUNGRDtJQURTLE9BQVBDO0dBQ1k7WUFFVkM7SUFBTzs7O09BQzhCO1FBQS9CQztRQUFIQztRQUFrQyxNQURyQ0MsS0FDTUY7UUFBc0IsTUFBQTtRQUFoQixNQVVoQkcsWUFWT0Y7T0FBeUIsT0FBQTs7V0FDeEJHO2lCQUFVLE9BQVZBOztRQUUrQjtTQUE1QlA7U0FBNEIsTUFBQSw4QkFGL0JPO1NBRWdCLE1BWXhCQyxVQVpXUjtTQUFhLE1BQUE7UUFBQSxPQUFBOztPQURhO1FBQXhCQztRQUF3QixNQUFBLDhCQUQ3Qk07UUFDYSxNQVFyQkQsWUFSYUw7T0FBd0IsT0FBQTs7V0FFL0JRO09BQU07UUFBQSxPQUFBLHVCQWdCWkMsa0JBaEJNRDs7T0FBTSxP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Q3VILElBQWlEOztLQVd0REYsZUFDcUJySCxHQURyQnFIOzs7SUFURSxZQUFBLGtDQVFRaEM7O0tBTE4sSUFERGtDLGVBQUxDLGNBQ00sVUF2RE5wQyxLQTREVWdDLEtBTlZJO3FCQUdPeEgsZ0JBVERzSCxHQVNDdEgsR0FIRnVIOztXQU9IRjtHQUVFO2dDQXZISnBDLE9Bd0RBRyxNQTREQStCLFdBOUdBakMsU0FGQTNFOzs7RTs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBEYi5FbnRyeSAqKVxubW9kdWxlIEVudHJ5ID0gRGJfX0VudHJ5XG5cbigqKiBAY2Fub25pY2FsIERiLlN0b3JhZ2UgKilcbm1vZHVsZSBTdG9yYWdlID0gRGJfX1N0b3JhZ2VcblxuKCoqIEBjYW5vbmljYWwgRGIuU3RyaW5nX2F1dG9tYXRhICopXG5tb2R1bGUgU3RyaW5nX2F1dG9tYXRhID0gRGJfX1N0cmluZ19hdXRvbWF0YVxuXG4oKiogQGNhbm9uaWNhbCBEYi5UeXBlX3BvbGFyaXR5ICopXG5tb2R1bGUgVHlwZV9wb2xhcml0eSA9IERiX19UeXBlX3BvbGFyaXR5XG5cbigqKiBAY2Fub25pY2FsIERiLlR5cGV4cHIgKilcbm1vZHVsZSBUeXBleHByID0gRGJfX1R5cGV4cHJcblxubW9kdWxlIERiX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsInR5cGUgdCA9XG4gIHwgQXJyb3cgb2YgdCAqIHRcbiAgfCBDb25zdHIgb2Ygc3RyaW5nICogdCBsaXN0XG4gIHwgVHVwbGUgb2YgdCBsaXN0XG4gIHwgUG9seSBvZiBzdHJpbmdcbiAgfCBBbnlcbiAgfCBVbmhhbmRsZWRcblxubGV0IHR1cGxlID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBBbnlcbiAgfCBbIHggXSAtPiB4XG4gIHwgeHMgLT4gVHVwbGUgeHNcblxubGV0IHJlYyBzaG93ID0gZnVuY3Rpb25cbiAgfCBBcnJvdyAoYSwgYikgLT4gc2hvd19wYXJlbnMgYSBeIFwiIC0+IFwiIF4gc2hvdyBiXG4gIHwgQ29uc3RyICh0LCBbXSkgLT4gdFxuICB8IENvbnN0ciAodCwgWyB4IF0pIC0+IHNob3dfcGFyZW5zIHggXiBcIiBcIiBeIHRcbiAgfCBDb25zdHIgKHQsIHhzKSAtPiBcIihcIiBeIHNob3dfbGlzdCB4cyBeIFwiKSBcIiBeIHRcbiAgfCBUdXBsZSB4cyAtPiBzaG93X3R1cGxlIHhzXG4gIHwgUG9seSBcIlwiIC0+IFwiJ19cIlxuICB8IFBvbHkgbmFtZSAtPiBcIidcIiBeIG5hbWVcbiAgfCBBbnkgLT4gXCJfXCJcbiAgfCBVbmhhbmRsZWQgLT4gXCI/Pz9cIlxuXG5hbmQgc2hvd19wYXJlbnMgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEFycm93IF8gfCBUdXBsZSBfIC0+IFwiKFwiIF4gc2hvdyB0IF4gXCIpXCJcbiAgfCBfIC0+IHNob3cgdFxuXG5hbmQgc2hvd19saXN0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWlsd2l0aCBcInNob3dfbGlzdDogZW1wdHlcIlxuICB8IFsgeCBdIC0+IHNob3cgeFxuICB8IHggOjogeHMgLT4gc2hvdyB4IF4gXCIsIFwiIF4gc2hvd19saXN0IHhzXG5cbmFuZCBzaG93X3R1cGxlID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWlsd2l0aCBcInNob3dfdHVwbGU6IGVtcHR5XCJcbiAgfCBbIHggXSAtPiBzaG93X3BhcmVucyB4XG4gIHwgeCA6OiB4cyAtPiBzaG93X3BhcmVucyB4IF4gXCIgKiBcIiBeIHNob3dfdHVwbGUgeHNcblxubGV0IHNpemUgdHlwID0gdHlwIHw+IHNob3cgfD4gU3RyaW5nLmxlbmd0aFxubGV0IGVxdWFsID0gU3RkbGliLiggPSApXG5sZXQgaGFzaCA9IEhhc2h0YmwuaGFzaFxuIiwib3BlbiBUeXBleHByXG5cbm1vZHVsZSBTaWduID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBQb3NcbiAgICB8IE5lZ1xuXG4gIGxldCB0b19zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgUG9zIC0+IFwiK1wiXG4gICAgfCBOZWcgLT4gXCItXCJcblxuICBsZXQgbm90ID0gZnVuY3Rpb25cbiAgICB8IFBvcyAtPiBOZWdcbiAgICB8IE5lZyAtPiBQb3NcbmVuZFxuXG5sZXQgcmV2X2NvbmNhdCBsc3QgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyB4cyAtPiBMaXN0LnJldl9hcHBlbmQgeHMgYWNjKSBbXSBsc3RcblxudHlwZSB0ID0gc3RyaW5nICogaW50ICogU2lnbi50XG5cbmxldCBwb2x5ID0gXCJAXCJcblxubGV0IHJlYyBvZl90eXAgfmFueV9pc19wb2x5IH5wcmVmaXggfnNnbiA9IGZ1bmN0aW9uXG4gIHwgUG9seSBfIC0+IFsgc2duLCBwb2x5IDo6IHByZWZpeCBdXG4gIHwgQW55IC0+IGlmIGFueV9pc19wb2x5IHRoZW4gWyBzZ24sIHBvbHkgOjogcHJlZml4IF0gZWxzZSBbIHNnbiwgcHJlZml4IF1cbiAgfCBBcnJvdyAoYSwgYikgLT5cbiAgICBMaXN0LnJldl9hcHBlbmRcbiAgICAgIChvZl90eXAgfmFueV9pc19wb2x5IH5wcmVmaXggfnNnbjooU2lnbi5ub3Qgc2duKSBhKVxuICAgICAgKG9mX3R5cCB+YW55X2lzX3BvbHkgfnByZWZpeCB+c2duIGIpXG4gIHwgQ29uc3RyIChuYW1lLCBhcmdzKSAtPiBiZWdpblxuICAgIGxldCBwcmVmaXggPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIG5hbWUgOjogcHJlZml4IGluXG4gICAgbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBbXSAtPiBbIHNnbiwgcHJlZml4IF1cbiAgICB8IF8gLT5cbiAgICAgIHJldl9jb25jYXRcbiAgICAgIEBAIExpc3QubWFwaVxuICAgICAgICAgICAoZnVuIGkgYXJnIC0+XG4gICAgICAgICAgICAgbGV0IHByZWZpeCA9IHN0cmluZ19vZl9pbnQgaSA6OiBwcmVmaXggaW5cbiAgICAgICAgICAgICBvZl90eXAgfmFueV9pc19wb2x5IH5wcmVmaXggfnNnbiBhcmcpXG4gICAgICAgICAgIGFyZ3NcbiAgZW5kXG4gIHwgVHVwbGUgYXJncyAtPiByZXZfY29uY2F0IEBAIExpc3QubWFwIChvZl90eXAgfmFueV9pc19wb2x5IH5wcmVmaXggfnNnbikgQEAgYXJnc1xuICB8IFVuaGFuZGxlZCAtPiBbXVxuXG5sZXQgcmVncm91cCBsc3QgPVxuICBsZXQgaCA9IEhhc2h0YmwuY3JlYXRlIDE2IGluXG4gIExpc3QuaXRlclxuICAgIChmdW4gdiAtPlxuICAgICAgbGV0IGNvdW50ID1cbiAgICAgICAgdHJ5IEhhc2h0YmwuZmluZCBoIHYgd2l0aFxuICAgICAgICB8IE5vdF9mb3VuZCAtPiAwXG4gICAgICBpblxuICAgICAgSGFzaHRibC5yZXBsYWNlIGggdiAoY291bnQgKyAxKSlcbiAgICBsc3QgO1xuICBIYXNodGJsLnRvX3NlcSBoXG5cbmxldCBvZl90eXAgfmFueV9pc19wb2x5IHQgPVxuICB0XG4gIHw+IG9mX3R5cCB+YW55X2lzX3BvbHkgfnByZWZpeDpbXSB+c2duOlBvc1xuICB8PiBMaXN0Lm1hcCAoZnVuIChwb2xhcml0eSwgcGF0aCkgLT4gcG9sYXJpdHksIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QucmV2IHBhdGgpKVxuICB8PiByZWdyb3VwXG4gIHw+IFNlcS5tYXAgKGZ1biAoKHBvbGFyaXR5LCBwYXRoKSwgY291bnQpIC0+IHBhdGgsIGNvdW50LCBwb2xhcml0eSlcbiIsImxldCBlbXB0eV9zdHJpbmcgPSBTdHJpbmcubWFrZSAwICdfJ1xuXG5sZXQgbm9uX2VtcHR5X3N0cmluZyBzID1cbiAgKCogdG8gcHJvdGVjdCBhZ2FpbnN0IGBhbmNpZW50YCBzZWdmYXVsdGluZyBvbiBzdGF0aWNhbGx5IGFsbG9jYXRlZCB2YWx1ZXMgKilcbiAgaWYgcyA9IFwiXCIgdGhlbiBlbXB0eV9zdHJpbmcgZWxzZSBzXG5cbm1vZHVsZSBLaW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBEb2MgKCoqIFN0YW5kYWxvbmUgZG9jIGNvbW1lbnQgKilcbiAgICB8IFBhZ2UgKCoqIE1sZCBwYWdlICopXG4gICAgfCBJbXBsICgqKiBTb3VyY2UgcGFnZSAqKVxuICAgIHwgTW9kdWxlXG4gICAgfCBNb2R1bGVfdHlwZVxuICAgIHwgQ2xhc3NcbiAgICB8IENsYXNzX3R5cGVcbiAgICB8IE1ldGhvZFxuICAgIHwgVmFsIG9mIFR5cGV4cHIudFxuICAgIHwgVHlwZV9kZWNsIG9mIHN0cmluZyBvcHRpb25cbiAgICB8IFR5cGVfZXh0ZW5zaW9uXG4gICAgfCBFeHRlbnNpb25fY29uc3RydWN0b3Igb2YgVHlwZXhwci50XG4gICAgfCBFeGNlcHRpb24gb2YgVHlwZXhwci50XG4gICAgfCBDb25zdHJ1Y3RvciBvZiBUeXBleHByLnRcbiAgICB8IEZpZWxkIG9mIFR5cGV4cHIudFxuXG4gIGxldCBlcXVhbCA9ICggPSApXG5cbiAgbGV0IGdldF90eXBlIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgVmFsIHR5cCB8IEV4dGVuc2lvbl9jb25zdHJ1Y3RvciB0eXAgfCBFeGNlcHRpb24gdHlwIHwgQ29uc3RydWN0b3IgdHlwIHwgRmllbGQgdHlwIC0+XG4gICAgICBTb21lIHR5cFxuICAgIHwgRG9jIHwgUGFnZSB8IEltcGwgfCBNb2R1bGUgfCBNb2R1bGVfdHlwZSB8IENsYXNzIHwgQ2xhc3NfdHlwZSB8IE1ldGhvZCB8IFR5cGVfZGVjbCBfXG4gICAgfCBUeXBlX2V4dGVuc2lvbiAtPlxuICAgICAgTm9uZVxuZW5kXG5cbm1vZHVsZSBQYWNrYWdlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBuYW1lIDogc3RyaW5nXG4gICAgOyB2ZXJzaW9uIDogc3RyaW5nXG4gICAgfVxuXG4gIGxldCB2IH5uYW1lIH52ZXJzaW9uID1cbiAgICB7IG5hbWUgPSBub25fZW1wdHlfc3RyaW5nIG5hbWU7IHZlcnNpb24gPSBub25fZW1wdHlfc3RyaW5nIHZlcnNpb24gfVxuXG4gIGxldCBjb21wYXJlIGEgYiA9IFN0cmluZy5jb21wYXJlIGEubmFtZSBiLm5hbWVcbiAgbGV0IGxpbmsgeyBuYW1lOyB2ZXJzaW9uIH0gPSBcImh0dHBzOi8vb2NhbWwub3JnL3AvXCIgXiBuYW1lIF4gXCIvXCIgXiB2ZXJzaW9uXG5lbmRcblxudHlwZSB0ID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgcmhzIDogc3RyaW5nIG9wdGlvblxuICA7IHVybCA6IHN0cmluZ1xuICA7IGtpbmQgOiBLaW5kLnRcbiAgOyBjb3N0IDogaW50XG4gIDsgZG9jX2h0bWwgOiBzdHJpbmdcbiAgOyBwa2cgOiBQYWNrYWdlLnRcbiAgfVxuXG5sZXQgcHAgZm10IHsgbmFtZTsgcmhzOyB1cmw7IGtpbmQgPSBfOyBjb3N0OyBkb2NfaHRtbDsgcGtnID0gXyB9ID1cbiAgRm9ybWF0LmZwcmludGZcbiAgICBmbXRcbiAgICBcInsgbmFtZSA9ICVzIDsgcmhzID0gJWEgOyB1cmwgPSAlcyA7IGtpbmQgPSAuIDsgY29zdCA9ICVkIDsgZG9jX2h0bWwgPSAlcyA7IHBrZyA9IC4gfVxcblwiXG4gICAgbmFtZVxuICAgIChGbXQub3B0aW9uIEZtdC5zdHJpbmcpXG4gICAgcmhzXG4gICAgdXJsXG4gICAgY29zdFxuICAgIGRvY19odG1sXG5cbmxldCBzdHJpbmdfY29tcGFyZV9zaG9ydGVyIGEgYiA9XG4gIG1hdGNoIEludC5jb21wYXJlIChTdHJpbmcubGVuZ3RoIGEpIChTdHJpbmcubGVuZ3RoIGIpIHdpdGhcbiAgfCAwIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICB8IGMgLT4gY1xuXG5sZXQgc3RydWN0dXJhbF9jb21wYXJlIGEgYiA9XG4gIG1hdGNoIHN0cmluZ19jb21wYXJlX3Nob3J0ZXIgYS5uYW1lIGIubmFtZSB3aXRoXG4gIHwgMCAtPiBiZWdpblxuICAgIG1hdGNoIFBhY2thZ2UuY29tcGFyZSBhLnBrZyBiLnBrZyB3aXRoXG4gICAgfCAwIC0+IGJlZ2luXG4gICAgICBtYXRjaCBTdGRsaWIuY29tcGFyZSBhLmtpbmQgYi5raW5kIHdpdGhcbiAgICAgIHwgMCAtPiBiZWdpblxuICAgICAgICBtYXRjaCBzdHJpbmdfY29tcGFyZV9zaG9ydGVyIGEuZG9jX2h0bWwgYi5kb2NfaHRtbCB3aXRoXG4gICAgICAgIHwgMCAtPiBTdHJpbmcuY29tcGFyZSBhLnVybCBiLnVybFxuICAgICAgICB8IGMgLT4gY1xuICAgICAgZW5kXG4gICAgICB8IGMgLT4gY1xuICAgIGVuZFxuICAgIHwgYyAtPiBjXG4gIGVuZFxuICB8IGMgLT4gY1xuXG5sZXQgY29tcGFyZSBhIGIgPVxuICBpZiBhID09IGJcbiAgdGhlbiAwXG4gIGVsc2UgYmVnaW5cbiAgICBtYXRjaCBJbnQuY29tcGFyZSBhLmNvc3QgYi5jb3N0IHdpdGhcbiAgICB8IDAgLT4gc3RydWN0dXJhbF9jb21wYXJlIGEgYlxuICAgIHwgY21wIC0+IGNtcFxuICBlbmRcblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5sZXQgc3RkbGliX2xpbmsgfm5hbWUgdCA9XG4gIGxldCBwYXRoLCBoYXNocmVmID1cbiAgICBtYXRjaCBMaXN0LnJldiBuYW1lLCBTdHJpbmcuaW5kZXhfb3B0IHQudXJsICcjJyB3aXRoXG4gICAgfCBfIDo6IHBhdGgsIFNvbWUgaWR4IC0+XG4gICAgICBsZXQgaWR4ID0gaWR4ICsgMSBpblxuICAgICAgbGV0IHRndCA9XG4gICAgICAgIG1hdGNoIFN0cmluZy5pbmRleF9mcm9tX29wdCB0LnVybCBpZHggJy0nIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFN0cmluZy5zdWIgdC51cmwgaWR4IChTdHJpbmcubGVuZ3RoIHQudXJsIC0gaWR4KVxuICAgICAgICB8IFNvbWUgamR4IC0+XG4gICAgICAgICAgbGV0IGtpbmQgPSBTdHJpbmcuc3ViIHQudXJsIGlkeCAoamR4IC0gaWR4KSBpblxuICAgICAgICAgIGxldCBqZHggPSBqZHggKyAxIGluXG4gICAgICAgICAgbGV0IHRhcmdldCA9IFN0cmluZy5zdWIgdC51cmwgamR4IChTdHJpbmcubGVuZ3RoIHQudXJsIC0gamR4KSBpblxuICAgICAgICAgIFN0cmluZy51cHBlcmNhc2VfYXNjaWkga2luZCBeIHRhcmdldFxuICAgICAgaW5cbiAgICAgIHBhdGgsIFwiI1wiIF4gdGd0XG4gICAgfCBwYXRoLCBfIC0+IHBhdGgsIFwiXCJcbiAgaW5cbiAgbGV0IHBhdGggPSBTdHJpbmcuY29uY2F0IFwiLlwiIChMaXN0LnJldiBwYXRoKSBpblxuICBcImh0dHBzOi8vdjIub2NhbWwub3JnL3JlbGVhc2VzLzUuMS9hcGkvXCIgXiBwYXRoIF4gXCIuaHRtbFwiIF4gaGFzaHJlZlxuXG5sZXQgbGluayB0ID1cbiAgbGV0IGZ1bGxuYW1lID0gU3RyaW5nLnNwbGl0X29uX2NoYXIgJy4nIHQubmFtZSBpblxuICBtYXRjaCBmdWxsbmFtZSB3aXRoXG4gIHwgXCJTdGRsaWJcIiA6OiBuYW1lIC0+IHN0ZGxpYl9saW5rIH5uYW1lIHRcbiAgfCBfIC0+XG4gICAgbGV0IHBrZ19saW5rID0gUGFja2FnZS5saW5rIHQucGtnIGluXG4gICAgbGV0IHJlYyBhbGlnbiBuIHlzID1cbiAgICAgIG1hdGNoIHlzIHdpdGhcbiAgICAgIHwgXyB3aGVuIG4gPSAwIC0+IFtdXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IHkgOjogeXMgLT4geSA6OiBhbGlnbiAobiAtIDEpIHlzXG4gICAgaW5cbiAgICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGggZnVsbG5hbWUgaW5cbiAgICBsZXQgbGVuZ3RoID1cbiAgICAgIG1hdGNoIFN0cmluZy5pbmRleF9vcHQgdC51cmwgJyMnIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsZW5ndGggKyAxXG4gICAgICB8IFNvbWUgaWR4IC0+XG4gICAgICAgIGxldCB0Z3QgPSBTdHJpbmcuc3ViIHQudXJsIGlkeCAoU3RyaW5nLmxlbmd0aCB0LnVybCAtIGlkeCkgaW5cbiAgICAgICAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgICAgICAgU3RyaW5nLml0ZXJcbiAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgJy4nIC0+IGluY3IgY291bnRcbiAgICAgICAgICAgIHwgXyAtPiAoKSlcbiAgICAgICAgICB0Z3QgO1xuICAgICAgICBsZW5ndGggLSAhY291bnRcbiAgICBpblxuICAgIGxldCBwYXRoID0gYWxpZ24gbGVuZ3RoIChMaXN0LnJldiAoU3RyaW5nLnNwbGl0X29uX2NoYXIgJy8nIHQudXJsKSkgaW5cbiAgICBsZXQgcGF0aCA9IFN0cmluZy5jb25jYXQgXCIvXCIgKExpc3QucmV2IHBhdGgpIGluXG4gICAgcGtnX2xpbmsgXiBcIi9kb2MvXCIgXiBwYXRoXG5cbmxldCB2IH5uYW1lIH5raW5kIH5jb3N0IH5yaHMgfmRvY19odG1sIH51cmwgfnBrZyAoKSA9XG4gIHsgbmFtZSA9IG5vbl9lbXB0eV9zdHJpbmcgbmFtZVxuICA7IGtpbmRcbiAgOyB1cmwgPSBub25fZW1wdHlfc3RyaW5nIHVybFxuICA7IGNvc3RcbiAgOyBkb2NfaHRtbCA9IG5vbl9lbXB0eV9zdHJpbmcgZG9jX2h0bWxcbiAgOyBwa2dcbiAgOyByaHMgPSBPcHRpb24ubWFwIG5vbl9lbXB0eV9zdHJpbmcgcmhzXG4gIH1cbiIsInR5cGUgdGVybWluYWxzID1cbiAgfCBFbXB0eVxuICB8IFRlcm1pbmFscyBvZiBFbnRyeS50IGFycmF5XG4gIHwgU3VtbWFyeSBvZiBFbnRyeS50IGFycmF5XG5cbnR5cGUgbm9kZSA9XG4gIHsgc3RhcnQgOiBpbnRcbiAgOyBsZW4gOiBpbnRcbiAgOyBzaXplIDogaW50XG4gIDsgdGVybWluYWxzIDogdGVybWluYWxzXG4gIDsgY2hpbGRyZW4gOiBub2RlIGFycmF5IG9wdGlvblxuICB9XG5cbnR5cGUgdCA9XG4gIHsgc3RyIDogc3RyaW5nXG4gIDsgdCA6IG5vZGVcbiAgfVxuXG5sZXQgZW1wdHkgPSB7IHN0YXJ0ID0gMDsgbGVuID0gMDsgc2l6ZSA9IDA7IGNoaWxkcmVuID0gTm9uZTsgdGVybWluYWxzID0gRW1wdHkgfVxuXG5sZXQgZW1wdHkgKCkgPVxuICAoKiBhdm9pZCBhbmNpZW50IHNlZ2ZhdWx0aW5nIG9uIHN0YXRpY2FsbHkgYWxsb2NhdGVkIHZhbHVlcyAqKVxuICBPYmoub2JqIEBAIE9iai5kdXAgQEAgT2JqLnJlcHIgZW1wdHlcblxubGV0IHNpemUgdCA9IHQudC5zaXplXG5cbmxldCBtaW5pbXVtIHsgdDsgXyB9ID1cbiAgbWF0Y2ggdC50ZXJtaW5hbHMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IFRlcm1pbmFscyBhcnIgfCBTdW1tYXJ5IGFyciAtPiBhcnIuKDApXG5cbmxldCBhcnJheV9maW5kIH5zdHIgY2hyIGFyciA9XG4gIGxldCByZWMgZ28gaSA9XG4gICAgaWYgaSA+PSBBcnJheS5sZW5ndGggYXJyXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBhcnIuKGkpIGluXG4gICAgICBpZiBjaHIgPSBzdHIuW25vZGUuc3RhcnQgLSAxXSB0aGVuIFNvbWUgbm9kZSBlbHNlIGdvIChpICsgMSlcbiAgICBlbmRcbiAgaW5cbiAgZ28gMFxuXG5sZXQgYXJyYXlfZmluZCB+c3RyIGNociA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhcnIgLT4gYXJyYXlfZmluZCB+c3RyIGNociBhcnJcblxubGV0IGxjcCBpX3N0ciBpIGpfc3RyIGogal9sZW4gPVxuICBsZXQgal9zdG9wID0gaiArIGpfbGVuIGluXG4gIGxldCByZWMgZ29fbGNwIGkgaiA9XG4gICAgaWYgaSA+PSBTdHJpbmcubGVuZ3RoIGlfc3RyIHx8IGogPj0gal9zdG9wXG4gICAgdGhlbiBpXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IGlfY2hyLCBqX2NociA9IGlfc3RyLltpXSwgal9zdHIuW2pdIGluXG4gICAgICBpZiBpX2NociA8PiBqX2NociB0aGVuIGkgZWxzZSBnb19sY3AgKGkgKyAxKSAoaiArIDEpXG4gICAgZW5kXG4gIGluXG4gIGxldCBpJyA9IGdvX2xjcCBpIGogaW5cbiAgaScgLSBpXG5cbmxldCByZWMgZmluZCB+c3RyIG5vZGUgcGF0dGVybiBpID1cbiAgaWYgaSA+PSBTdHJpbmcubGVuZ3RoIHBhdHRlcm5cbiAgdGhlbiBTb21lIG5vZGVcbiAgZWxzZSBiZWdpblxuICAgIG1hdGNoIGFycmF5X2ZpbmQgfnN0ciBwYXR0ZXJuLltpXSBub2RlLmNoaWxkcmVuIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBjaGlsZCAtPiBmaW5kX2xjcCB+c3RyIGNoaWxkIHBhdHRlcm4gKGkgKyAxKVxuICBlbmRcblxuYW5kIGZpbmRfbGNwIH5zdHIgY2hpbGQgcGF0dGVybiBpID1cbiAgbGV0IG4gPSBsY3AgcGF0dGVybiBpIHN0ciBjaGlsZC5zdGFydCBjaGlsZC5sZW4gaW5cbiAgaWYgaSArIG4gPSBTdHJpbmcubGVuZ3RoIHBhdHRlcm5cbiAgdGhlbiBTb21lIHsgY2hpbGQgd2l0aCBzdGFydCA9IGNoaWxkLnN0YXJ0ICsgbjsgbGVuID0gY2hpbGQubGVuIC0gbiB9XG4gIGVsc2UgaWYgbiA9IGNoaWxkLmxlblxuICB0aGVuIGZpbmQgfnN0ciBjaGlsZCBwYXR0ZXJuIChpICsgbilcbiAgZWxzZSBOb25lXG5cbmxldCBmaW5kIHQgcGF0dGVybiA9XG4gIG1hdGNoIGZpbmRfbGNwIH5zdHI6dC5zdHIgdC50IHBhdHRlcm4gMCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBjaGlsZCAtPiBTb21lIHsgc3RyID0gdC5zdHI7IHQgPSBjaGlsZCB9XG5cbmxldCBhZHZhbmNlIG5vZGUgPVxuICBhc3NlcnQgKG5vZGUubGVuID49IDEpIDtcbiAgeyBub2RlIHdpdGggc3RhcnQgPSBub2RlLnN0YXJ0ICsgMTsgbGVuID0gbm9kZS5sZW4gLSAxIH1cblxubGV0IHN0ZXBiYWNrIG5vZGUgPVxuICBhc3NlcnQgKG5vZGUubGVuID49IDApIDtcbiAgeyBub2RlIHdpdGggc3RhcnQgPSBub2RlLnN0YXJ0IC0gMTsgbGVuID0gbm9kZS5sZW4gKyAxIH1cblxubGV0IHJlYyBmaW5kX3NraXAgfnNwYWNlcyB0IHBhdHRlcm4geWllbGQgPVxuICBsZXQgc2tpcCAoKSA9XG4gICAgbGV0IG5vZGUgPSB0LnQgaW5cbiAgICBpZiBub2RlLmxlbiA+PSAxXG4gICAgdGhlbiBiZWdpblxuICAgICAgbGV0IHNwYWNlcyA9IHNwYWNlcyArIGlmIHQuc3RyLltub2RlLnN0YXJ0XSA9ICcgJyB0aGVuIDEgZWxzZSAwIGluXG4gICAgICBpZiBzcGFjZXMgPiAxXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGZpbmRfc2tpcCB+c3BhY2VzIHsgdCB3aXRoIHQgPSBhZHZhbmNlIHQudCB9IHBhdHRlcm4geWllbGRcbiAgICBlbmRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBtYXRjaCBub2RlLmNoaWxkcmVuIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIGNoaWxkcmVuIC0+XG4gICAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgICAoZnVuIGNoaWxkIC0+IGZpbmRfc2tpcCB+c3BhY2VzIHsgdCB3aXRoIHQgPSBzdGVwYmFjayBjaGlsZCB9IHBhdHRlcm4geWllbGQpXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICBlbmRcbiAgaW5cbiAgaWYgc3BhY2VzID0gMFxuICB0aGVuIHNraXAgKClcbiAgZWxzZSBpZiBzcGFjZXMgPSAxICYmIHBhdHRlcm4gPSBUeXBlX3BvbGFyaXR5LnBvbHlcbiAgdGhlbiBiZWdpblxuICAgIG1hdGNoIGZpbmQgdCBwYXR0ZXJuIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgaGVyZSAtPiB5aWVsZCBoZXJlXG4gIGVuZFxuICBlbHNlIGJlZ2luXG4gICAgc2tpcCAoKSA7XG4gICAgbWF0Y2ggZmluZCB0IHBhdHRlcm4gd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBoZXJlIC0+IHlpZWxkIGhlcmVcbiAgZW5kXG5cbmxldCBmaW5kX3N0YXIgdCBwYXR0ZXJuIHlpZWxkID1cbiAgbGV0IHJlYyBnbyB0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHlpZWxkIHRcbiAgICB8IHAgOjogcHMgLT4gZmluZF9za2lwIH5zcGFjZXM6MCB0IHAgQEAgZnVuIHQgLT4gZ28gdCBwc1xuICBpblxuICBtYXRjaCBTdHJpbmcuc3BsaXRfb25fY2hhciAnICcgcGF0dGVybiB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCBwIDo6IHBzIC0+IGJlZ2luXG4gICAgbWF0Y2ggZmluZCB0IHAgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB0IC0+IGdvIHQgcHNcbiAgZW5kXG5cbmxldCBmaW5kX3N0YXIgdCBwYXR0ZXJuID1cbiAgbGV0IGZvdW5kID0gcmVmIFtdIGluXG4gIGZpbmRfc3RhciB0IHBhdHRlcm4gKGZ1biB0IC0+IGZvdW5kIDo9IHQgOjogIWZvdW5kKSA7XG4gICFmb3VuZFxuIl19
