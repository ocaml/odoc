// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cmo, use-js-string=true, version=5.8.2

//# unitInfo: Provides: Dune__exe__Tyxml
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst$0 = ">",
    cst_span$1 = "span",
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst_lt = "&lt;",
    cst_gt = "&gt;",
    cst_commat = "&commat;",
    cst_quot = "&quot;",
    cst_amp = "&amp;",
    cst_apos = "&apos;",
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, [0, '"'], 0],
    _b_ = [0, 'class="'],
    _c_ = [0, cst$1],
    _d_ = [2, 0],
    _e_ = [0, [0, cst$0], 0],
    _f_ = [0, "<\/"],
    _g_ = [0, cst$0],
    _h_ = [0, "<"],
    cst_code = "code",
    cst_span = cst_span$1,
    cst_span$0 = cst_span$1;
   function string_of_list(lst){
    var t = [2, lst], buf = caml_call1(Stdlib_Buffer[1], 16);
    function go(param){
     switch(param[0]){
       case 0:
        var s = param[1]; return caml_call2(Stdlib_Buffer[16], buf, s);
       case 1:
        var
         s$0 = param[1],
         add = caml_call1(Stdlib_Buffer[16], buf),
         len = runtime.caml_ml_string_length(s$0),
         max_idx = len - 1 | 0,
         flush =
           function(start, i){
            var _q_ = start < len ? 1 : 0;
            return _q_
                    ? caml_call4
                      (Stdlib_Buffer[18], buf, s$0, start, i - start | 0)
                    : _q_;
           },
         loop$0 =
           function(counter, start, i){
            var i$0 = i;
            for(;;){
             if(max_idx < i$0) return flush(start, i$0);
             var match = runtime.caml_string_get(s$0, i$0);
             if(40 <= match){
              var switcher = match - 60 | 0;
              if(4 >= switcher >>> 0)
               switch(switcher){
                 case 0:
                  if(counter >= 50)
                   return caml_trampoline_return
                           (escape, [0, cst_lt, start, i$0]);
                  var counter$0 = counter + 1 | 0;
                  return escape(counter$0, cst_lt, start, i$0);
                 case 2:
                  if(counter >= 50)
                   return caml_trampoline_return
                           (escape, [0, cst_gt, start, i$0]);
                  var counter$1 = counter + 1 | 0;
                  return escape(counter$1, cst_gt, start, i$0);
                 case 4:
                  if(counter >= 50)
                   return caml_trampoline_return
                           (escape, [0, cst_commat, start, i$0]);
                  var counter$2 = counter + 1 | 0;
                  return escape(counter$2, cst_commat, start, i$0);
               }
             }
             else if(34 <= match)
              switch(match - 34 | 0){
                case 0:
                 if(counter >= 50)
                  return caml_trampoline_return
                          (escape, [0, cst_quot, start, i$0]);
                 var counter$3 = counter + 1 | 0;
                 return escape(counter$3, cst_quot, start, i$0);
                case 4:
                 if(counter >= 50)
                  return caml_trampoline_return
                          (escape, [0, cst_amp, start, i$0]);
                 var counter$4 = counter + 1 | 0;
                 return escape(counter$4, cst_amp, start, i$0);
                case 5:
                 if(counter >= 50)
                  return caml_trampoline_return
                          (escape, [0, cst_apos, start, i$0]);
                 var counter$5 = counter + 1 | 0;
                 return escape(counter$5, cst_apos, start, i$0);
              }
             var i$1 = i$0 + 1 | 0;
             i$0 = i$1;
            }
           },
         loop =
           function(start, i){return caml_trampoline(loop$0(0, start, i));},
         escape =
           function(counter, amperstr, start, i){
            flush(start, i);
            caml_call1(add, amperstr);
            var next = i + 1 | 0;
            if(counter >= 50)
             return caml_trampoline_return(loop$0, [0, next, next]);
            var counter$0 = counter + 1 | 0;
            return loop$0(counter$0, next, next);
           };
        return loop(0, 0);
       default: var xs = param[1]; return caml_call2(Stdlib_List[18], go, xs);
     }
    }
    go(t);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function a_class(lst){
    return [2,
            [0, _b_, [0, [1, caml_call2(Stdlib_String[7], cst, lst)], _a_]]];
   }
   function block(name, xs, body){
    var
     name$0 = [0, name],
     _o_ = [0, _g_, [0, [2, body], [0, _f_, [0, name$0, _e_]]]],
     _p_ = xs ? [2, [0, _c_, xs]] : _d_;
    return [2, [0, _h_, [0, name$0, [0, _p_, _o_]]]];
   }
   function code(_m_, _n_){return block(cst_code, _m_, _n_);}
   function span(_k_, _l_){return block(cst_span, _k_, _l_);}
   function div(_i_, _j_){return block(cst_span$0, _i_, _j_);}
   function txt(s){return [1, s];}
   function data(s){return [0, s];}
   var
    Unsafe = [0, data],
    Html = [0, string_of_list, a_class, code, span, div, txt, Unsafe],
    Dune_exe_Tyxml = [0, Html];
   runtime.caml_register_global(21, Dune_exe_Tyxml, "Dune__exe__Tyxml");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIubWFpbi5lb2Jqcy9qc29vL2R1bmVfX2V4ZV9fVHl4bWwuY21vLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN0cmluZ19vZl9saXN0IiwibHN0IiwidCIsImJ1ZiIsImdvIiwicyIsInMkMCIsImFkZCIsImxlbiIsIm1heF9pZHgiLCJmbHVzaCIsInN0YXJ0IiwiaSIsImxvb3AkMCIsImkkMCIsImVzY2FwZSIsImkkMSIsImxvb3AiLCJhbXBlcnN0ciIsIm5leHQiLCJ4cyIsImFfY2xhc3MiLCJibG9jayIsIm5hbWUiLCJib2R5IiwibmFtZSQwIiwiY29kZSIsInNwYW4iLCJkaXYiLCJ0eHQiLCJkYXRhIl0sInNvdXJjZXMiOlsiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9qc29vL3R5eG1sLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTZETUEsZUFBZUM7SUFBTSxJQVZYQyxRQVVLRCxNQXZDR0UsTUE4QlY7YUFDRkM7S0FBSzs7WUFDTEMsY0FBSyxPQUFBLDhCQWhDT0YsS0FnQ1pFOztRQTlCRTtTQUZjQztTQUVwQkMsTUFBTSw4QkFGVUo7U0FHaEJLLE1BQUosOEJBSHdCRjtTQUlwQkcsVUFEQUQ7U0FFQUU7b0JBQU1DLE9BQU1DO1lBQ2QsVUFEUUQsUUFGTkg7OzswQ0FIZ0JMLEtBQUlHLEtBS2RLLE9BQU1DLElBQU5EOztXQUN3RDtTQUUxREU7NkJBQUtGLE9BQU1DO1lBQ2pCLElBRGlCRSxNQUFBRjtZQUNqQjtnQkFMRUgsVUFJZUssS0FFWixPQUxISixNQUdTQyxPQUFNRzthQUlULFlBQUEsd0JBWmNSLEtBUUxROztjQUlUOzs7O2tCQUVHO21CQUFBLE9BQUE7NEJBT1RDLG9CQWJTSixPQUFNRzs7a0JBTU4sT0FPVEMsMEJBYlNKLE9BQU1HOztrQkFPTjttQkFBQSxPQUFBOzRCQU1UQyxvQkFiU0osT0FBTUc7O2tCQU9OLE9BTVRDLDBCQWJTSixPQUFNRzs7a0JBVU47bUJBQUEsT0FBQTs0QkFHVEMsd0JBYlNKLE9BQU1HOztrQkFVTixPQUdUQyw4QkFiU0osT0FBTUc7Ozs7OztpQkFTTjtrQkFBQSxPQUFBOzJCQUlUQyxzQkFiU0osT0FBTUc7O2lCQVNOLE9BSVRDLDRCQWJTSixPQUFNRzs7aUJBS047a0JBQUEsT0FBQTsyQkFRVEMscUJBYlNKLE9BQU1HOztpQkFLTixPQVFUQywyQkFiU0osT0FBTUc7O2lCQVFMO2tCQUFBLE9BQUE7MkJBS1ZDLHNCQWJTSixPQUFNRzs7aUJBUUwsT0FLVkMsNEJBYlNKLE9BQU1HOzthQVdSLElBWFFFLE1BQUFGO2FBQUFBLE1BQUFFOztXQVlkO1NBWkdDO29CQUFLTixPQUFNQyxHLHVCQUFYQyxVQUFLRixPQUFNQztTQWFmRzs2QkFBT0csVUFBU1AsT0FBTUM7WUFoQnRCRixNQWdCZ0JDLE9BQU1DO1lBRXhCLFdBckJFTCxLQW1CT1c7WUFFVCxJQUNJQyxPQUhvQlA7WUFJeEI7YUFBQSxPQUFBLHVCQWpCTUMsWUFnQkZNLE1BQUFBOztZQUNKLE9BakJNTixrQkFnQkZNLE1BQUFBO1dBQ1U7UUFFaEIsT0FuQlFGO29CQTBCR0csZUFBTSxPQUFBLDRCQUhUaEIsSUFHR2dCOztJQUFxQjtJQUh4QmhCLEdBRklGO0lBT1osT0FBQSw2QkFwQ29CQztHQXVDeUI7WUFJM0NrQixRQUFRcEI7SUFBTTs2QkFBNkIsa0NBQW5DQTtHQUFzRTtZQU05RXFCLE1BQU1DLE1BQU1ILElBQUVJO0lBQ2hCO0tBQUlDLGFBRElGOzRCQUFRQyxvQkFDWkM7V0FEVUwsa0JBQUFBO0lBRWQsd0JBRElLO0dBQzRFO0dBRXZFLFNBQVBDLGUsT0FKQUo7R0FLTyxTQUFQSyxlLE9BTEFMO0dBTU0sU0FBTk0sYyxPQU5BTjtZQU9BTyxJQUFJeEIsR0FBSSxXQUFKQSxHQUFTO1lBR1h5QixLQUFLekIsR0FBSSxXQUFKQSxHQUFTO0dBREo7SUFBQSxhQUNWeUI7SUFqRUYsV0E2Q0E5QixnQkFJQXFCLFNBVUFLLE1BQ0FDLE1BQ0FDLEtBQ0FDOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgSHRtbCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgc3RyaW5nX29mX2xpc3QgOiB0IGxpc3QgLT4gc3RyaW5nXG5cbiAgdHlwZSBhdHRyXG5cbiAgdmFsIGFfY2xhc3MgOiBzdHJpbmcgbGlzdCAtPiBhdHRyXG4gIHZhbCBjb2RlIDogYTphdHRyIGxpc3QgLT4gdCBsaXN0IC0+IHRcbiAgdmFsIHNwYW4gOiBhOmF0dHIgbGlzdCAtPiB0IGxpc3QgLT4gdFxuICB2YWwgZGl2IDogYTphdHRyIGxpc3QgLT4gdCBsaXN0IC0+IHRcbiAgdmFsIHR4dCA6IHN0cmluZyAtPiB0XG5cbiAgbW9kdWxlIFVuc2FmZSA6IHNpZ1xuICAgIHZhbCBkYXRhIDogc3RyaW5nIC0+IHRcbiAgZW5kXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFJhdyBvZiBzdHJpbmdcbiAgICB8IFR4dCBvZiBzdHJpbmdcbiAgICB8IENvbmNhdCBvZiB0IGxpc3RcblxuICBsZXQgYWRkX2VzY2FwZV9zdHJpbmcgYnVmIHMgPVxuICAgICgqIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC9odG1sLWVuY29kaW5nLW9mLXN0cmluZy80Mjg5LzQgKilcbiAgICBsZXQgYWRkID0gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBtYXhfaWR4ID0gbGVuIC0gMSBpblxuICAgIGxldCBmbHVzaCBzdGFydCBpID1cbiAgICAgIGlmIHN0YXJ0IDwgbGVuIHRoZW4gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgc3RhcnQgKGkgLSBzdGFydClcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBzdGFydCBpID1cbiAgICAgIGlmIGkgPiBtYXhfaWR4XG4gICAgICB0aGVuIGZsdXNoIHN0YXJ0IGlcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggU3RyaW5nLmdldCBzIGkgd2l0aFxuICAgICAgICB8ICcmJyAtPiBlc2NhcGUgXCImYW1wO1wiIHN0YXJ0IGlcbiAgICAgICAgfCAnPCcgLT4gZXNjYXBlIFwiJmx0O1wiIHN0YXJ0IGlcbiAgICAgICAgfCAnPicgLT4gZXNjYXBlIFwiJmd0O1wiIHN0YXJ0IGlcbiAgICAgICAgfCAnXFwnJyAtPiBlc2NhcGUgXCImYXBvcztcIiBzdGFydCBpXG4gICAgICAgIHwgJ1wiJyAtPiBlc2NhcGUgXCImcXVvdDtcIiBzdGFydCBpXG4gICAgICAgIHwgJ0AnIC0+IGVzY2FwZSBcIiZjb21tYXQ7XCIgc3RhcnQgaVxuICAgICAgICB8IF8gLT4gbG9vcCBzdGFydCAoaSArIDEpXG4gICAgICBlbmRcbiAgICBhbmQgZXNjYXBlIGFtcGVyc3RyIHN0YXJ0IGkgPVxuICAgICAgZmx1c2ggc3RhcnQgaSA7XG4gICAgICBhZGQgYW1wZXJzdHIgO1xuICAgICAgbGV0IG5leHQgPSBpICsgMSBpblxuICAgICAgbG9vcCBuZXh0IG5leHRcbiAgICBpblxuICAgIGxvb3AgMCAwXG5cbiAgbGV0IHRvX3N0cmluZyB0ID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICAgIGxldCByZWMgZ28gPSBmdW5jdGlvblxuICAgICAgfCBSYXcgcyAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgc1xuICAgICAgfCBUeHQgcyAtPiBhZGRfZXNjYXBlX3N0cmluZyBidWYgc1xuICAgICAgfCBDb25jYXQgeHMgLT4gTGlzdC5pdGVyIGdvIHhzXG4gICAgaW5cbiAgICBnbyB0IDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IHN0cmluZ19vZl9saXN0IGxzdCA9IHRvX3N0cmluZyAoQ29uY2F0IGxzdClcblxuICB0eXBlIGF0dHIgPSB0XG5cbiAgbGV0IGFfY2xhc3MgbHN0ID0gQ29uY2F0IFsgUmF3IFwiY2xhc3M9XFxcIlwiOyBUeHQgKFN0cmluZy5jb25jYXQgXCIgXCIgbHN0KTsgUmF3IFwiXFxcIlwiIF1cblxuICBsZXQgYXR0cnMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gQ29uY2F0IFtdXG4gICAgfCB4cyAtPiBDb25jYXQgKFJhdyBcIiBcIiA6OiB4cylcblxuICBsZXQgYmxvY2sgbmFtZSB+YSBib2R5ID1cbiAgICBsZXQgbmFtZSA9IFJhdyBuYW1lIGluXG4gICAgQ29uY2F0IFsgUmF3IFwiPFwiOyBuYW1lOyBhdHRycyBhOyBSYXcgXCI+XCI7IENvbmNhdCBib2R5OyBSYXcgXCI8L1wiOyBuYW1lOyBSYXcgXCI+XCIgXVxuXG4gIGxldCBjb2RlID0gYmxvY2sgXCJjb2RlXCJcbiAgbGV0IHNwYW4gPSBibG9jayBcInNwYW5cIlxuICBsZXQgZGl2ID0gYmxvY2sgXCJzcGFuXCJcbiAgbGV0IHR4dCBzID0gVHh0IHNcblxuICBtb2R1bGUgVW5zYWZlID0gc3RydWN0XG4gICAgbGV0IGRhdGEgcyA9IFJhdyBzXG4gIGVuZFxuZW5kXG4iXX0=
