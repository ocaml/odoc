// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.2

//# unitInfo: Provides: Query__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Query = [0], Query$0 = [0, Query];
   runtime.caml_register_global(0, Query$0, "Query__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Type_parser
//# unitInfo: Requires: Db__Typexpr, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Db_Typexpr = global_data.Db__Typexpr,
    Stdlib_List = global_data.Stdlib__List,
    Error =
      [248,
       "Query__Type_parser.MenhirBasics.Error",
       runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "sherlodoc/query/type_parser.ml", 285, 4];
   function eRR(s){throw caml_maybe_attach_backtrace(Error, 1);}
   function menhir_fail(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function menhir_run_01$0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s){
    var tok = caml_call1(menhir_lexer, menhir_lexbuf), v = [1, w, 0];
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typ0,
              [0, menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s, tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typ0
            (counter$0,
             menhir_stack,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_run_01
   (menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s){
    return caml_trampoline
            (menhir_run_01$0
              (0, menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s));
   }
   function menhir_goto_typ0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, t, menhir_s, tok){
    var v = [0, t, 0];
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typs,
              [0, menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s, tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typs
            (counter$0,
             menhir_stack,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_goto_typs
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, ts, menhir_s, tok){
    if(typeof tok === "number")
     switch(tok){
       case 1:
       case 6: break;
       default:
        var v = caml_call1(Db_Typexpr[1], ts);
        if(counter >= 50)
         return caml_trampoline_return
                 (menhir_goto_typ1,
                  [0,
                   menhir_stack,
                   menhir_lexbuf,
                   menhir_lexer,
                   v,
                   menhir_s,
                   tok]);
        var counter$0 = counter + 1 | 0;
        return menhir_goto_typ1
                (counter$0,
                 menhir_stack,
                 menhir_lexbuf,
                 menhir_lexer,
                 v,
                 menhir_s,
                 tok);
     }
    else if(0 === tok[0]){
     var
      v_0 = tok[1],
      menhir_stack$0 = [0, menhir_stack, menhir_s, ts],
      menhir_stack$1 = [0, menhir_stack$0, v_0],
      tok$0 = caml_call1(menhir_lexer, menhir_lexbuf);
     if(typeof tok$0 === "number")
      switch(tok$0){
        case 1:
        case 6: break;
        default:
         var v_2 = 0;
         if(counter >= 50)
          return caml_trampoline_return
                  (menhir_run_09,
                   [0, menhir_stack$1, menhir_lexbuf, menhir_lexer, v_2, tok$0]);
         var counter$2 = counter + 1 | 0;
         return menhir_run_09
                 (counter$2,
                  menhir_stack$1,
                  menhir_lexbuf,
                  menhir_lexer,
                  v_2,
                  tok$0);
      }
     else if(0 === tok$0[0]){
      var v_1 = tok$0[1];
      a:
      {
       var menhir_stack$2 = menhir_stack$1, v$0 = v_1, menhir_s$0 = 2;
       for(;;){
        var
         menhir_stack$3 = [0, menhir_stack$2, menhir_s$0, v$0],
         tok$1 = caml_call1(menhir_lexer, menhir_lexbuf);
        if(typeof tok$1 === "number") break;
        if(0 !== tok$1[0]) break a;
        var v_0$0 = tok$1[1];
        menhir_stack$2 = menhir_stack$3;
        v$0 = v_0$0;
        menhir_s$0 = 3;
       }
       switch(tok$1){
         case 1:
         case 6: break;
         default:
          var menhir_stack$4 = menhir_stack$3, xs$0 = 0;
          for(;;){
           var
            x = menhir_stack$4[3],
            menhir_s$1 = menhir_stack$4[2],
            menhir_stack$5 = menhir_stack$4[1],
            xs = [0, x, xs$0];
           if(2 === menhir_s$1){
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_09,
                      [0, menhir_stack$5, menhir_lexbuf, menhir_lexer, xs, tok$1]);
            var counter$1 = counter + 1 | 0;
            return menhir_run_09
                    (counter$1,
                     menhir_stack$5,
                     menhir_lexbuf,
                     menhir_lexer,
                     xs,
                     tok$1);
           }
           if(3 !== menhir_s$1) return menhir_fail(0);
           menhir_stack$4 = menhir_stack$5;
           xs$0 = xs;
          }
       }
      }
      return eRR(0);
     }
     return eRR(0);
    }
    return eRR(0);
   }
   function menhir_run_09
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, ws, tok){
    var
     w = menhir_stack[2],
     menhir_stack$0 = menhir_stack[1],
     ts = menhir_stack$0[3],
     menhir_s = menhir_stack$0[2],
     menhir_stack$1 = menhir_stack$0[1],
     v =
       caml_call3
        (Stdlib_List[26],
         function(acc, w){return [1, w, [0, acc, 0]];},
         [1, w, ts],
         ws);
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typ1,
              [0,
               menhir_stack$1,
               menhir_lexbuf,
               menhir_lexer,
               v,
               menhir_s,
               tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typ1
            (counter$0,
             menhir_stack$1,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_goto_typ1
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, v$1, menhir_s, tok){
    if(typeof tok === "number")
     switch(tok){
       case 0:
        var
         menhir_stack$0 = [0, menhir_stack, menhir_s, v$1],
         menhir_s$0 = 5,
         tok$0 = caml_call1(menhir_lexer, menhir_lexbuf);
        if(typeof tok$0 === "number")
         switch(tok$0){
           case 1:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_03$0,
                      [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
            var counter$6 = counter + 1 | 0;
            return menhir_run_03$0
                    (counter$6,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0);
           case 6:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_04$0,
                      [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
            var counter$5 = counter + 1 | 0;
            return menhir_run_04$0
                    (counter$5,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0);
           default:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_reduce_13$0,
                      [0,
                       menhir_stack$0,
                       menhir_lexbuf,
                       menhir_lexer,
                       menhir_s$0,
                       tok$0]);
            var counter$4 = counter + 1 | 0;
            return menhir_reduce_13$0
                    (counter$4,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0,
                     tok$0);
         }
        if(0 === tok$0[0]){
         var v$2 = tok$0[1];
         if(counter >= 50)
          return caml_trampoline_return
                  (menhir_run_01$0,
                   [0,
                    menhir_stack$0,
                    menhir_lexbuf,
                    menhir_lexer,
                    v$2,
                    menhir_s$0]);
         var counter$8 = counter + 1 | 0;
         return menhir_run_01$0
                 (counter$8,
                  menhir_stack$0,
                  menhir_lexbuf,
                  menhir_lexer,
                  v$2,
                  menhir_s$0);
        }
        var v$3 = tok$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (menhir_run_02$0,
                  [0,
                   menhir_stack$0,
                   menhir_lexbuf,
                   menhir_lexer,
                   v$3,
                   menhir_s$0]);
        var counter$7 = counter + 1 | 0;
        return menhir_run_02$0
                (counter$7,
                 menhir_stack$0,
                 menhir_lexbuf,
                 menhir_lexer,
                 v$3,
                 menhir_s$0);
       case 1:
       case 6: break;
       default:
        var
         v = [0, v$1, 0],
         menhir_stack$1 = menhir_stack,
         xs = v,
         menhir_s$1 = menhir_s;
        for(;;)
         switch(menhir_s$1){
           case 0:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_17,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       xs,
                       menhir_s$1,
                       tok]);
            var counter$0 = counter + 1 | 0;
            return menhir_run_17
                    (counter$0,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     xs,
                     menhir_s$1,
                     tok);
           case 1:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_17,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       xs,
                       menhir_s$1,
                       tok]);
            var counter$1 = counter + 1 | 0;
            return menhir_run_17
                    (counter$1,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     xs,
                     menhir_s$1,
                     tok);
           case 4:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_17,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       xs,
                       menhir_s$1,
                       tok]);
            var counter$2 = counter + 1 | 0;
            return menhir_run_17
                    (counter$2,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     xs,
                     menhir_s$1,
                     tok);
           case 5:
            var
             x = menhir_stack$1[3],
             menhir_s$2 = menhir_stack$1[2],
             menhir_stack$2 = menhir_stack$1[1],
             v$0 = [0, x, xs];
            menhir_stack$1 = menhir_stack$2;
            xs = v$0;
            menhir_s$1 = menhir_s$2;
            break;
           case 6:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_17,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       xs,
                       menhir_s$1,
                       tok]);
            var counter$3 = counter + 1 | 0;
            return menhir_run_17
                    (counter$3,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     xs,
                     menhir_s$1,
                     tok);
           default: return menhir_fail(0);
         }
     }
    return menhir_fail(0);
   }
   function menhir_run_02$0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s){
    var tok = caml_call1(menhir_lexer, menhir_lexbuf), v = [3, w];
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typ0,
              [0, menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s, tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typ0
            (counter$0,
             menhir_stack,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_run_02
   (menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s){
    return caml_trampoline
            (menhir_run_02$0
              (0, menhir_stack, menhir_lexbuf, menhir_lexer, w, menhir_s));
   }
   function menhir_run_03$0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s){
    var menhir_stack$0 = menhir_stack, menhir_s$0 = menhir_s;
    for(;;){
     var
      menhir_stack$1 = [0, menhir_stack$0, menhir_s$0],
      menhir_s$1 = 1,
      tok = caml_call1(menhir_lexer, menhir_lexbuf);
     if(typeof tok !== "number"){
      if(0 === tok[0]){
       var v = tok[1];
       if(counter >= 50)
        return caml_trampoline_return
                (menhir_run_01$0,
                 [0,
                  menhir_stack$1,
                  menhir_lexbuf,
                  menhir_lexer,
                  v,
                  menhir_s$1]);
       var counter$3 = counter + 1 | 0;
       return menhir_run_01$0
               (counter$3,
                menhir_stack$1,
                menhir_lexbuf,
                menhir_lexer,
                v,
                menhir_s$1);
      }
      var v$0 = tok[1];
      if(counter >= 50)
       return caml_trampoline_return
               (menhir_run_02$0,
                [0,
                 menhir_stack$1,
                 menhir_lexbuf,
                 menhir_lexer,
                 v$0,
                 menhir_s$1]);
      var counter$2 = counter + 1 | 0;
      return menhir_run_02$0
              (counter$2,
               menhir_stack$1,
               menhir_lexbuf,
               menhir_lexer,
               v$0,
               menhir_s$1);
     }
     switch(tok){
       case 1:
        menhir_stack$0 = menhir_stack$1; menhir_s$0 = menhir_s$1; break;
       case 3:
        return eRR(0);
       case 6:
        if(counter >= 50)
         return caml_trampoline_return
                 (menhir_run_04$0,
                  [0, menhir_stack$1, menhir_lexbuf, menhir_lexer, menhir_s$1]);
        var counter$1 = counter + 1 | 0;
        return menhir_run_04$0
                (counter$1,
                 menhir_stack$1,
                 menhir_lexbuf,
                 menhir_lexer,
                 menhir_s$1);
       default:
        if(counter >= 50)
         return caml_trampoline_return
                 (menhir_reduce_13$0,
                  [0,
                   menhir_stack$1,
                   menhir_lexbuf,
                   menhir_lexer,
                   menhir_s$1,
                   tok]);
        var counter$0 = counter + 1 | 0;
        return menhir_reduce_13$0
                (counter$0,
                 menhir_stack$1,
                 menhir_lexbuf,
                 menhir_lexer,
                 menhir_s$1,
                 tok);
     }
    }
   }
   function menhir_run_03(menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s){
    return caml_trampoline
            (menhir_run_03$0
              (0, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s));
   }
   function menhir_run_04$0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s){
    var tok = caml_call1(menhir_lexer, menhir_lexbuf), v = 0;
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typ0,
              [0, menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s, tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typ0
            (counter$0,
             menhir_stack,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_run_04(menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s){
    return caml_trampoline
            (menhir_run_04$0
              (0, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s));
   }
   function menhir_reduce_13$0
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s, tok){
    var v = 0;
    if(counter >= 50)
     return caml_trampoline_return
             (menhir_goto_typ1,
              [0, menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s, tok]);
    var counter$0 = counter + 1 | 0;
    return menhir_goto_typ1
            (counter$0,
             menhir_stack,
             menhir_lexbuf,
             menhir_lexer,
             v,
             menhir_s,
             tok);
   }
   function menhir_reduce_13
   (menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s, tok){
    return caml_trampoline
            (menhir_reduce_13$0
              (0, menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s, tok));
   }
   function menhir_run_17
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, xs, menhir_s, tok){
    var t = caml_call1(Db_Typexpr[1], xs);
    if(typeof tok === "number")
     switch(tok){
       case 5:
        var
         menhir_stack$0 = [0, menhir_stack, menhir_s, t],
         menhir_s$0 = 4,
         tok$0 = caml_call1(menhir_lexer, menhir_lexbuf);
        if(typeof tok$0 === "number")
         switch(tok$0){
           case 1:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_03$0,
                      [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
            var counter$4 = counter + 1 | 0;
            return menhir_run_03$0
                    (counter$4,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0);
           case 6:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_04$0,
                      [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
            var counter$3 = counter + 1 | 0;
            return menhir_run_04$0
                    (counter$3,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0);
           default:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_reduce_13$0,
                      [0,
                       menhir_stack$0,
                       menhir_lexbuf,
                       menhir_lexer,
                       menhir_s$0,
                       tok$0]);
            var counter$2 = counter + 1 | 0;
            return menhir_reduce_13$0
                    (counter$2,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     menhir_s$0,
                     tok$0);
         }
        if(0 === tok$0[0]){
         var v$0 = tok$0[1];
         if(counter >= 50)
          return caml_trampoline_return
                  (menhir_run_01$0,
                   [0,
                    menhir_stack$0,
                    menhir_lexbuf,
                    menhir_lexer,
                    v$0,
                    menhir_s$0]);
         var counter$6 = counter + 1 | 0;
         return menhir_run_01$0
                 (counter$6,
                  menhir_stack$0,
                  menhir_lexbuf,
                  menhir_lexer,
                  v$0,
                  menhir_s$0);
        }
        var v$1 = tok$0[1];
        if(counter >= 50)
         return caml_trampoline_return
                 (menhir_run_02$0,
                  [0,
                   menhir_stack$0,
                   menhir_lexbuf,
                   menhir_lexer,
                   v$1,
                   menhir_s$0]);
        var counter$5 = counter + 1 | 0;
        return menhir_run_02$0
                (counter$5,
                 menhir_stack$0,
                 menhir_lexbuf,
                 menhir_lexer,
                 v$1,
                 menhir_s$0);
       case 0:
       case 1:
       case 6: break;
       default:
        var menhir_stack$1 = menhir_stack, v$2 = t, menhir_s$1 = menhir_s;
        for(;;)
         switch(menhir_s$1){
           case 0:
            if(typeof tok === "number" && 3 === tok) return v$2;
            return eRR(0);
           case 1:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_18,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       v$2,
                       menhir_s$1,
                       tok]);
            var counter$0 = counter + 1 | 0;
            return menhir_run_18
                    (counter$0,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     v$2,
                     menhir_s$1,
                     tok);
           case 4:
            var
             a = menhir_stack$1[3],
             menhir_s$2 = menhir_stack$1[2],
             menhir_stack$2 = menhir_stack$1[1],
             v = [0, a, v$2];
            menhir_stack$1 = menhir_stack$2;
            v$2 = v;
            menhir_s$1 = menhir_s$2;
            break;
           case 6:
            if(counter >= 50)
             return caml_trampoline_return
                     (menhir_run_18,
                      [0,
                       menhir_stack$1,
                       menhir_lexbuf,
                       menhir_lexer,
                       v$2,
                       menhir_s$1,
                       tok]);
            var counter$1 = counter + 1 | 0;
            return menhir_run_18
                    (counter$1,
                     menhir_stack$1,
                     menhir_lexbuf,
                     menhir_lexer,
                     v$2,
                     menhir_s$1,
                     tok);
           default: return menhir_fail(0);
         }
     }
    return menhir_fail(0);
   }
   function menhir_run_18
   (counter, menhir_stack, menhir_lexbuf, menhir_lexer, v$1, menhir_s, tok){
    if(typeof tok === "number"){
     var switcher = tok - 2 | 0;
     if(2 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var
          v = [0, v$1, 0],
          menhir_stack$1 = menhir_stack,
          xs = v,
          menhir_s$1 = menhir_s;
         for(;;){
          if(1 === menhir_s$1){
           var
            tok$1 = caml_call1(menhir_lexer, menhir_lexbuf),
            menhir_s$2 = menhir_stack$1[2],
            menhir_stack$2 = menhir_stack$1[1];
           if(counter >= 50)
            return caml_trampoline_return
                    (menhir_goto_typs,
                     [0,
                      menhir_stack$2,
                      menhir_lexbuf,
                      menhir_lexer,
                      xs,
                      menhir_s$2,
                      tok$1]);
           var counter$4 = counter + 1 | 0;
           return menhir_goto_typs
                   (counter$4,
                    menhir_stack$2,
                    menhir_lexbuf,
                    menhir_lexer,
                    xs,
                    menhir_s$2,
                    tok$1);
          }
          if(6 > menhir_s$1) return menhir_fail(0);
          var
           x = menhir_stack$1[3],
           menhir_s$3 = menhir_stack$1[2],
           menhir_stack$3 = menhir_stack$1[1],
           v$0 = [0, x, xs];
          menhir_stack$1 = menhir_stack$3;
          xs = v$0;
          menhir_s$1 = menhir_s$3;
         }
         break;
        case 1: break;
        default:
         var
          menhir_stack$0 = [0, menhir_stack, menhir_s, v$1],
          menhir_s$0 = 6,
          tok$0 = caml_call1(menhir_lexer, menhir_lexbuf);
         if(typeof tok$0 === "number")
          switch(tok$0){
            case 1:
             if(counter >= 50)
              return caml_trampoline_return
                      (menhir_run_03$0,
                       [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
             var counter$2 = counter + 1 | 0;
             return menhir_run_03$0
                     (counter$2,
                      menhir_stack$0,
                      menhir_lexbuf,
                      menhir_lexer,
                      menhir_s$0);
            case 3:
             return eRR(0);
            case 6:
             if(counter >= 50)
              return caml_trampoline_return
                      (menhir_run_04$0,
                       [0, menhir_stack$0, menhir_lexbuf, menhir_lexer, menhir_s$0]);
             var counter$1 = counter + 1 | 0;
             return menhir_run_04$0
                     (counter$1,
                      menhir_stack$0,
                      menhir_lexbuf,
                      menhir_lexer,
                      menhir_s$0);
            default:
             if(counter >= 50)
              return caml_trampoline_return
                      (menhir_reduce_13$0,
                       [0,
                        menhir_stack$0,
                        menhir_lexbuf,
                        menhir_lexer,
                        menhir_s$0,
                        tok$0]);
             var counter$0 = counter + 1 | 0;
             return menhir_reduce_13$0
                     (counter$0,
                      menhir_stack$0,
                      menhir_lexbuf,
                      menhir_lexer,
                      menhir_s$0,
                      tok$0);
          }
         if(0 === tok$0[0]){
          var v$2 = tok$0[1];
          if(counter >= 50)
           return caml_trampoline_return
                   (menhir_run_01$0,
                    [0,
                     menhir_stack$0,
                     menhir_lexbuf,
                     menhir_lexer,
                     v$2,
                     menhir_s$0]);
          var counter$5 = counter + 1 | 0;
          return menhir_run_01$0
                  (counter$5,
                   menhir_stack$0,
                   menhir_lexbuf,
                   menhir_lexer,
                   v$2,
                   menhir_s$0);
         }
         var v$3 = tok$0[1];
         if(counter >= 50)
          return caml_trampoline_return
                  (menhir_run_02$0,
                   [0,
                    menhir_stack$0,
                    menhir_lexbuf,
                    menhir_lexer,
                    v$3,
                    menhir_s$0]);
         var counter$3 = counter + 1 | 0;
         return menhir_run_02$0
                 (counter$3,
                  menhir_stack$0,
                  menhir_lexbuf,
                  menhir_lexer,
                  v$3,
                  menhir_s$0);
      }
    }
    return eRR(0);
   }
   function main(menhir_lexer, menhir_lexbuf){
    var
     menhir_stack = 0,
     menhir_s = 0,
     tok = caml_call1(menhir_lexer, menhir_lexbuf);
    if(typeof tok === "number")
     switch(tok){
       case 1:
        return menhir_run_03
                (menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s);
       case 6:
        return menhir_run_04
                (menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s);
       case 2:
       case 4:
        return eRR(0);
       default:
        return menhir_reduce_13
                (menhir_stack, menhir_lexbuf, menhir_lexer, menhir_s, tok);
     }
    if(0 === tok[0]){
     var v = tok[1];
     return menhir_run_01
             (menhir_stack, menhir_lexbuf, menhir_lexer, v, menhir_s);
    }
    var v$0 = tok[1];
    return menhir_run_02
            (menhir_stack, menhir_lexbuf, menhir_lexer, v$0, menhir_s);
   }
   var Query_Type_parser = [0, Error, main];
   runtime.caml_register_global(15, Query_Type_parser, "Query__Type_parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Type_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\xf6\xffT\0\xc0\0\xf9\xff\x14\x01\xfb\xff\xfc\xff\xfd\xff\0\0\xff\xff\xfe\xff",
       "\xff\xff\xff\xff\b\0\x07\0\xff\xff\x05\0\xff\xff\xff\xff\xff\xff\x01\0\xff\xff\xff\xff",
       "\xff\xff\0\0\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\b\0\x07\0\x04\0\0\0\x06\0\t\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\x0b\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\x05\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\0\0\0\0\x01\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\0\0\0\0\0\0\0\0\x03\0\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\x02\0\0\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\t\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x03\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function token$0(counter, lexbuf){
    var _a_ = 0;
    if(counter >= 50)
     return caml_trampoline_return(ocaml_lex_token_rec$0, [0, lexbuf, _a_]);
    var counter$0 = counter + 1 | 0;
    return ocaml_lex_token_rec$0(counter$0, lexbuf, _a_);
   }
   function token(lexbuf){return caml_trampoline(token$0(0, lexbuf));}
   function ocaml_lex_token_rec$0(counter, lexbuf, ocaml_lex_state){
    var ocaml_lex_state$0 = ocaml_lex_state;
    for(;;){
     var
      ocaml_lex_state$1 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state$0, lexbuf);
     if(9 >= ocaml_lex_state$1 >>> 0)
      switch(ocaml_lex_state$1){
        case 0:
         if(counter >= 50)
          return caml_trampoline_return(token$0, [0, lexbuf]);
         var counter$0 = counter + 1 | 0;
         return token$0(counter$0, lexbuf);
        case 1:
         return 5;
        case 2:
         return 1;
        case 3:
         return 2;
        case 4:
         return 4;
        case 5:
         return 6;
        case 6:
         return 0;
        case 7:
         var
          p =
            caml_call3
             (Stdlib_Lexing[16], lexbuf, lexbuf[5] + 1 | 0, lexbuf[6]);
         return [1, p];
        case 8:
         var w = caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5], lexbuf[6]);
         return [0, w];
        default: return 3;
      }
     caml_call1(lexbuf[1], lexbuf);
     ocaml_lex_state$0 = ocaml_lex_state$1;
    }
   }
   function ocaml_lex_token_rec(lexbuf, ocaml_lex_state){
    return caml_trampoline(ocaml_lex_token_rec$0(0, lexbuf, ocaml_lex_state));
   }
   var Query_Type_lexer = [0, ocaml_lex_tables, token, ocaml_lex_token_rec];
   runtime.caml_register_global(2, Query_Type_lexer, "Query__Type_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Name_cost
//# unitInfo: Requires: Stdlib__Char, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, 46, [0, 40, [0, 41, 0]]],
    _b_ = [0, 0, 0, 0];
   function prefix_at(sub, s, j$3){
    var case$0 = 0, i = 0, j = j$3;
    for(;;){
     if(caml_ml_string_length(sub) <= i) return [0, case$0];
     var _e_ = caml_string_get(s, j);
     if(caml_string_get(sub, i) === _e_){
      var j$0 = j + 1 | 0, i$0 = i + 1 | 0;
      i = i$0;
      j = j$0;
     }
     else{
      var _f_ = caml_string_get(s, j), _g_ = caml_call1(Stdlib_Char[3], _f_);
      if(caml_string_get(sub, i) === _g_){
       var j$1 = j + 1 | 0, i$1 = i + 1 | 0, case$1 = case$0 + 3 | 0;
       case$0 = case$1;
       i = i$1;
       j = j$1;
      }
      else{
       var _h_ = caml_string_get(s, j), _i_ = caml_string_get(sub, i);
       if(caml_call1(Stdlib_Char[3], _i_) !== _h_) return 0;
       var j$2 = j + 1 | 0, i$2 = i + 1 | 0, case$2 = case$0 + 10 | 0;
       case$0 = case$2;
       i = i$2;
       j = j$2;
      }
     }
    }
   }
   function find_all(sub, s){
    var j = 0, acc = 0;
    for(;;){
     if(caml_ml_string_length(s) < (j + caml_ml_string_length(sub) | 0))
      return acc;
     var match = prefix_at(sub, s, j);
     if(match)
      var cost = match[1], acc$0 = [0, [0, j, cost], acc];
     else
      var acc$0 = acc;
     var j$0 = j + 1 | 0;
     j = j$0;
     acc = acc$0;
    }
   }
   function is_substring(sub, s){return 0 !== find_all(sub, s) ? 1 : 0;}
   function word_boundary(s, i){
    if(0 > i) return 0;
    if(caml_ml_string_length(s) > i){
     var _d_ = caml_string_get(s, i);
     if(! caml_call2(Stdlib_List[37], _d_, _a_))
      return 95 === caml_string_get(s, i) ? 3 : 10;
    }
    return 1;
   }
   function best_match(opt, sub, str){
    var after = opt ? opt[1] : 0, _c_ = find_all(sub, str);
    return caml_call3
            (Stdlib_List[26],
             function(acc, param){
              var
               case_cost = param[2],
               i = param[1],
               left = word_boundary(str, i - 1 | 0),
               right =
                 word_boundary(str, i + caml_ml_string_length(sub) | 0) / 3
                 | 0,
               is_after = after <= i ? 0 : 10,
               cost = ((case_cost + left | 0) + right | 0) + is_after | 0;
              if(acc){var cost$0 = acc[1][2]; if(cost$0 < cost) return acc;}
              return [0, [0, i, cost]];
             },
             0,
             _c_);
   }
   function best_matches(words, str){
    var
     match =
       caml_call3
        (Stdlib_List[26],
         function(param, sub){
          var
           not_found = param[3],
           found = param[2],
           i = param[1],
           match = best_match([0, i], sub, str);
          if(! match)
           return [0,
                   i,
                   found,
                   (not_found + caml_ml_string_length(sub) | 0) + 50 | 0];
          var match$0 = match[1], cost = match$0[2], i$0 = match$0[1];
          return [0,
                  i$0 + caml_ml_string_length(sub) | 0,
                  found + cost | 0,
                  not_found];
         },
         _b_,
         words),
     not_found = match[3],
     found = match[2];
    return found + not_found | 0;
   }
   var
    Query_Name_cost =
      [0,
       prefix_at,
       find_all,
       is_substring,
       word_boundary,
       best_match,
       best_matches];
   runtime.caml_register_global(4, Query_Name_cost, "Query__Name_cost");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Type_distance
//# unitInfo: Requires: Db__Type_polarity, Query__Name_cost, Stdlib, Stdlib__Array, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Query_Name_cost = global_data.Query__Name_cost,
    Db_Type_polarity = global_data.Db__Type_polarity;
   function rev_concat(lst){
    return caml_call3
            (Stdlib_List[26],
             function(acc, xs){return caml_call2(Stdlib_List[13], xs, acc);},
             0,
             lst);
   }
   function _a_(prefix, t){
    if(typeof t === "number") return 0 === t ? [0, [0, 1, prefix], 0] : 0;
    switch(t[0]){
      case 0:
       var
        b = t[2],
        a = t[1],
        prefix_left = [0, 2, prefix],
        prefix_right = [0, 3, prefix],
        _u_ = _a_(prefix_right, b),
        _v_ = _a_(prefix_left, a);
       return caml_call2(Stdlib_List[13], _v_, _u_);
      case 1:
       var args = t[2], name = t[1], prefix$0 = [0, [0, name], prefix];
       if(! args) return [0, prefix$0, 0];
       var length = caml_call1(Stdlib_List[1], args);
       return rev_concat
               (caml_call2
                 (Stdlib_List[21],
                  function(i, arg){
                   var prefix = [0, [2, i, length], prefix$0];
                   return _a_(prefix, arg);
                  },
                  args));
      case 2:
       var args$0 = t[1], length$0 = caml_call1(Stdlib_List[1], args$0);
       return rev_concat
               (caml_call1
                 (caml_call1
                   (Stdlib_List[21],
                    function(i, arg){
                     var prefix$0 = [0, [1, i, length$0], prefix];
                     return _a_(prefix$0, arg);
                    }),
                  args$0));
      default: return [0, [0, 0, prefix], 0];
    }
   }
   function paths_of_type(t){
    var _t_ = _a_(0, t);
    return caml_call1(caml_call1(Stdlib_List[20], Stdlib_List[10]), _t_);
   }
   function v(query_paths, entry){
    var entry_paths = paths_of_type(entry);
    if(query_paths && entry_paths){
     var
      arr$0 =
        caml_call2
         (Stdlib_List[20],
          function(xs){
           return caml_call2
                   (Stdlib_List[20],
                    function(ys){
                     var
                      len_xs = caml_call1(Stdlib_List[1], xs),
                      len_ys = caml_call1(Stdlib_List[1], ys),
                      cache =
                        caml_call3
                         (Stdlib_Array[2], 1 + len_xs | 0, 1 + len_ys | 0, -1),
                      inv = Db_Type_polarity[1][2];
                     function memo(xsgn, ysgn, i, j, xs, ys){
                      var
                       r =
                         caml_check_bound(caml_check_bound(cache, i)[1 + i], j)
                          [1 + j];
                      if(0 <= r) return r;
                      var r$0 = go(xsgn, ysgn, i, j, xs, ys);
                      caml_check_bound(caml_check_bound(cache, i)[1 + i], j)
                       [1 + j]
                      = r$0;
                      return r$0;
                     }
                     function go(xsgn, ysgn, i, j, xs, ys){
                      if(! xs) return ys ? 0 : 0;
                      var x = xs[1];
                      a:
                      {
                       b:
                       {
                        c:
                        {
                         d:
                         {
                          e:
                          {
                           if(typeof x === "number")
                            switch(x){
                              case 0:
                               if(! xs[2]){
                                if(! ys) break c;
                                var _q_ = ys[1];
                                if
                                 (typeof _q_ === "number"
                                  && 2 > _q_ && ! ys[2] && xsgn === ysgn)
                                 return 0;
                               }
                               break;
                              case 1:
                               if(! xs[2] && xsgn === ysgn) return 0; break;
                              case 2:
                               if(! ys) break e;
                               var _r_ = ys[1];
                               if(typeof _r_ === "number" && 2 === _r_){
                                var ys$9 = ys[2], xs$7 = xs[2], _s_ = caml_call1(inv, ysgn);
                                return memo
                                        (caml_call1(inv, xsgn),
                                         _s_,
                                         i + 1 | 0,
                                         j + 1 | 0,
                                         xs$7,
                                         ys$9);
                               }
                               break;
                            }
                           if(ys){
                            var ys$0 = ys[2], y = ys[1], xs$0 = xs[2];
                            if(runtime.caml_equal(x, y) && xsgn === ysgn)
                             return memo(xsgn, ysgn, i + 1 | 0, j + 1 | 0, xs$0, ys$0);
                            if(typeof x === "number"){if(2 === x) break e;}
                            else
                             f:
                             switch(x[0]){
                               case 0:
                                var match = ys[1], xs$4 = xs[2], x$0 = x[1];
                                if(typeof match === "number")
                                 switch(match){case 2: break f;case 3: break d;}
                                else if(0 === match[0]){
                                 var ys$6 = ys[2], y$0 = match[1];
                                 if(xsgn !== ysgn) break a;
                                 var match$0 = caml_call3(Query_Name_cost[5], 0, x$0, y$0);
                                 if(! match$0)
                                  return 10 + memo(xsgn, ysgn, i, j + 1 | 0, xs, ys$6) | 0;
                                 var cost = match$0[1][2];
                                 return (cost / 3 | 0)
                                        + memo(xsgn, ysgn, i + 1 | 0, j + 1 | 0, xs$4, ys$6)
                                        | 0;
                                }
                                break a;
                               case 1:
                                var _o_ = ys[1], xs$5 = xs[2];
                                if(typeof _o_ === "number")
                                 switch(_o_){case 2: break f;case 3: break d;}
                                else if(1 === _o_[0]){
                                 var ys$7 = ys[2];
                                 return 1
                                        + memo(xsgn, ysgn, i + 1 | 0, j + 1 | 0, xs$5, ys$7)
                                        | 0;
                                }
                                break b;
                               default:
                                var _p_ = ys[1], xs$6 = xs[2];
                                if(typeof _p_ === "number")
                                 switch(_p_){case 2: break f;case 3: break d;}
                                else if(2 === _p_[0]){
                                 var ys$8 = ys[2];
                                 return 1
                                        + memo(xsgn, ysgn, i + 1 | 0, j + 1 | 0, xs$6, ys$8)
                                        | 0;
                                }
                                break a;
                             }
                            var _j_ = ys[1];
                            if(typeof _j_ === "number" && 2 === _j_){
                             var ys$1 = ys[2];
                             return 1
                                    + memo(xsgn, caml_call1(inv, ysgn), i, j + 1 | 0, xs, ys$1)
                                    | 0;
                            }
                           }
                          }
                          var _k_ = xs[1];
                          if(typeof _k_ !== "number") break c;
                          if(2 === _k_){
                           var xs$1 = xs[2];
                           return 1
                                  + memo(caml_call1(inv, xsgn), ysgn, i + 1 | 0, j, xs$1, ys)
                                  | 0;
                          }
                         }
                         if(ys){
                          var _l_ = ys[1];
                          if(typeof _l_ === "number" && 3 <= _l_){
                           var ys$2 = ys[2];
                           return memo(xsgn, ysgn, i, j + 1 | 0, xs, ys$2);
                          }
                         }
                         var _m_ = xs[1];
                         if(typeof _m_ === "number" && 3 === _m_){
                          var xs$3 = xs[2];
                          return memo(xsgn, ysgn, i + 1 | 0, j, xs$3, ys);
                         }
                        }
                        if(! ys) return 10000;
                       }
                       if(typeof xs[1] !== "number"){
                        var xs$2 = xs[2];
                        return 1 + memo(xsgn, ysgn, i + 1 | 0, j, xs$2, ys) | 0;
                       }
                      }
                      var _n_ = ys[1];
                      if(typeof _n_ === "number") return 10000;
                      switch(_n_[0]){
                        case 0:
                         var ys$3 = ys[2];
                         return 10 + memo(xsgn, ysgn, i, j + 1 | 0, xs, ys$3) | 0;
                        case 1:
                         var ys$4 = ys[2];
                         return 1 + memo(xsgn, ysgn, i, j + 1 | 0, xs, ys$4) | 0;
                        default:
                         var ys$5 = ys[2];
                         return memo(xsgn, ysgn, i, j + 1 | 0, xs, ys$5);
                      }
                     }
                     var pos = 0;
                     return go(pos, pos, 0, 0, xs, ys);
                    },
                    entry_paths);
          },
          query_paths);
     if(! arr$0) return 0;
     var
      _b_ = caml_call1(Stdlib_List[6], arr$0),
      used = caml_make_vect(caml_call1(Stdlib_List[1], _b_), 0),
      _c_ = caml_call1(Stdlib_Array[11], arr$0),
      arr =
        caml_call1
         (caml_call1
           (Stdlib_Array[14],
            function(lst){
             var
              lst$0 =
                caml_call2
                 (Stdlib_List[21], function(i, x){return [0, x, i];}, lst);
             return caml_call2(Stdlib_List[59], caml_compare, lst$0);
            }),
          _c_);
     caml_call2(Stdlib_Array[35], caml_compare, arr);
     var
      heuristics = caml_make_vect(arr.length + 0 | 0, 0),
      _d_ = heuristics.length - 3 | 0;
     if(_d_ >= 0){
      var i = _d_;
      for(;;){
       var
        _e_ = caml_check_bound(arr, i)[1 + i],
        best$0 = caml_call1(Stdlib_List[6], _e_)[1],
        _f_ = i + 1 | 0,
        _g_ = caml_check_bound(heuristics, _f_)[1 + _f_] + best$0 | 0;
       caml_check_bound(heuristics, i)[1 + i] = _g_;
       var _h_ = i - 1 | 0;
       if(0 === i) break;
       i = _h_;
      }
     }
     var
      best = [0, 1000],
      limit = [0, 0],
      go =
        function(rem, acc, i){
         limit[1]++;
         if(10000 < limit[1]) return 0;
         if(0 >= rem){
          var score$0 = acc + (1000 * (arr.length - 1 - i | 0) | 0) | 0;
          best[1] = caml_call2(Stdlib[16], score$0, best[1]);
          return 1;
         }
         if(arr.length - 1 <= i){
          var score = acc + (5 * rem | 0) | 0;
          best[1] = caml_call2(Stdlib[16], score, best[1]);
          return 1;
         }
         var _i_ = best[1];
         if(_i_ <= (acc + caml_check_bound(heuristics, i)[1 + i] | 0))
          return 1;
         var param = caml_check_bound(arr, i)[1 + i];
         for(;;){
          if(! param) return 1;
          var
           rest = param[2],
           match = param[1],
           j = match[2],
           cost = match[1];
          if(caml_check_bound(used, j)[1 + j])
           var continue$0 = 1;
          else{
           caml_check_bound(used, j)[1 + j] = 1;
           var continue$1 = go(rem - 1 | 0, acc + cost | 0, i + 1 | 0);
           used[1 + j] = 0;
           var continue$0 = continue$1;
          }
          if(! continue$0) return 0;
          param = rest;
         }
        };
     go(used.length - 1, 0, 0);
     return best[1];
    }
    return 0;
   }
   var Query_Type_distance = [0, paths_of_type, v];
   runtime.caml_register_global
    (5, Query_Type_distance, "Query__Type_distance");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Query_parser
//# unitInfo: Requires: Db__Typexpr, Query__Type_lexer, Query__Type_parser, Stdlib, Stdlib__Lexing, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = " ",
    cst$1 = " : ",
    cst = "",
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Db_Typexpr = global_data.Db__Typexpr,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Query_Type_lexer = global_data.Query__Type_lexer,
    Query_Type_parser = global_data.Query__Type_parser,
    cst_parsing_error = " : <parsing error>";
   function type_of_string(str$0){
    var i = 0, open_parens = 0, close_parens = 0;
    for(;;){
     if(caml_ml_string_length(str$0) <= i){
      var
       _i_ = caml_call2(Stdlib_String[1], open_parens, 41),
       _j_ = caml_call2(Stdlib[28], str$0, _i_),
       _k_ = caml_call2(Stdlib_String[1], close_parens, 40),
       str = caml_call2(Stdlib[28], _k_, _j_),
       lexbuf = caml_call2(Stdlib_Lexing[3], 0, str);
      try{
       var
        _l_ =
          [0,
           5795659,
           caml_call2(Query_Type_parser[2], Query_Type_lexer[2], lexbuf)];
       return _l_;
      }
      catch(_m_){return 901335932;}
     }
     var match = caml_string_get(str$0, i);
     if(40 === match){
      var open_parens$0 = open_parens + 1 | 0, i$0 = i + 1 | 0;
      i = i$0;
      open_parens = open_parens$0;
     }
     else if(41 === match)
      if(0 < open_parens){
       var open_parens$1 = open_parens - 1 | 0, i$1 = i + 1 | 0;
       i = i$1;
       open_parens = open_parens$1;
      }
      else{
       var close_parens$0 = close_parens + 1 | 0, i$2 = i + 1 | 0;
       i = i$2;
       close_parens = close_parens$0;
      }
     else{var i$3 = i + 1 | 0; i = i$3;}
    }
   }
   function of_string(str){
    var match = caml_call2(Stdlib_String[37], str, 58);
    if(match)
     var
      loc = match[1],
      str_name = caml_call3(Stdlib_String[16], str, 0, loc),
      str_typ =
        caml_call3
         (Stdlib_String[16],
          str,
          loc + 1 | 0,
          (caml_ml_string_length(str) - loc | 0) - 1 | 0),
      typ = type_of_string(str_typ),
      query_name = str_name;
    else{
     var _d_ = 1 <= caml_ml_string_length(str) ? 1 : 0;
     a:
     {
      if(_d_){
       var _e_ = 39 === caml_string_get(str, 0) ? 1 : 0;
       if(_e_)
        var _f_ = _e_;
       else{
        var _g_ = caml_call2(Stdlib_String[15], str, 45);
        if(! _g_){var _h_ = caml_call2(Stdlib_String[15], str, 40); break a;}
        var _f_ = _g_;
       }
      }
      else
       var _f_ = _d_;
      var _h_ = _f_;
     }
     if(_h_)
      var typ = type_of_string(str), query_name = cst;
     else
      var typ = 601868557, query_name = str;
    }
    var
     _c_ = caml_call2(Stdlib_String[17], 32, query_name),
     name =
       caml_call2
        (Stdlib_List[44],
         function(s){return 0 < caml_ml_string_length(s) ? 1 : 0;},
         _c_);
    return [0, name, typ];
   }
   function to_string(param){
    var
     typ = param[2],
     name = param[1],
     words = caml_call2(Stdlib_String[7], cst$0, name);
    if(typeof typ === "number")
     return 901335932 <= typ
             ? caml_call2(Stdlib[28], words, cst_parsing_error)
             : words;
    var
     typ$0 = typ[2],
     _a_ = caml_call1(Db_Typexpr[3], typ$0),
     _b_ = caml_call2(Stdlib[28], cst$1, _a_);
    return caml_call2(Stdlib[28], words, _b_);
   }
   var Query_Query_parser = [0, of_string, to_string];
   runtime.caml_register_global(11, Query_Query_parser, "Query__Query_parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Dynamic_cost
//# unitInfo: Requires: Db__Entry, Query__Name_cost, Query__Type_distance
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Query_Name_cost = global_data.Query__Name_cost,
    Db_Entry = global_data.Db__Entry,
    Query_Type_distance = global_data.Query__Type_distance,
    _a_ = [0, 1000];
   function of_query(param){
    var typ = param[2], name = param[1];
    a:
    {
     if(typeof typ !== "number" && 5795659 === typ[1]){
      var t = typ[2], type_paths = [0, caml_call1(Query_Type_distance[1], t)];
      break a;
     }
     var type_paths = 0;
    }
    return [0, name, type_paths];
   }
   function type_distance(query_type, entry){
    var match = caml_call1(Db_Entry[1][2], entry[4]);
    if(! query_type) return 0;
    var query_paths = query_type[1];
    if(! match) return _a_;
    var entry_type = match[1];
    return [0, caml_call2(Query_Type_distance[2], query_paths, entry_type)];
   }
   function score(query, entry){
    var
     name_matches = caml_call2(Query_Name_cost[6], query[1], entry[1]),
     match = type_distance(query[2], entry);
    if(match) var cost = match[1], type_cost = cost; else var type_cost = 0;
    return 5 * (name_matches + type_cost | 0) | 0;
   }
   var Query_Dynamic_cost = [0, of_query, type_distance, score];
   runtime.caml_register_global(4, Query_Dynamic_cost, "Query__Dynamic_cost");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Io
//# unitInfo: Requires: Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List;
   function Seq(Io){
    function of_seq(s, param){
     var match = caml_call1(s, 0);
     if(! match) return caml_call1(Io[1], 0);
     var xs = match[2], x = match[1];
     return caml_call1(Io[1], [0, x, function(_g_){return of_seq(xs, _g_);}]);
    }
    function take(n, xs, param){
     if(0 === n) return caml_call1(Io[1], 0);
     var _d_ = caml_call1(xs, 0);
     return caml_call1
             (caml_call1(Io[2], _d_),
              function(param){
               if(! param) return 0;
               var xs = param[2], x = param[1], _e_ = n - 1 | 0;
               return [0, x, function(_f_){return take(_e_, xs, _f_);}];
              });
    }
    function _a_(acc, s){
     var _b_ = caml_call1(s, 0);
     return caml_call1
             (caml_call1(Io[3], _b_),
              function(param){
               if(param){
                var xs = param[2], x = param[1];
                return _a_([0, x, acc], xs);
               }
               var _c_ = caml_call1(Stdlib_List[10], acc);
               return caml_call1(Io[1], _c_);
              });
    }
    function to_list(s){return _a_(0, s);}
    return [0, of_seq, take, to_list];
   }
   var Query_Io = [0, Seq];
   runtime.caml_register_global(1, Query_Io, "Query__Io");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Top_results
//# unitInfo: Requires: Db__Entry, Query__Dynamic_cost, Query__Io, Stdlib__List, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Query_Io = global_data.Query__Io,
    Query_Dynamic_cost = global_data.Query__Dynamic_cost,
    Db_Entry = global_data.Db__Entry,
    Stdlib_Set = global_data.Stdlib__Set,
    Bests = caml_call1(Stdlib_Set[1], [0, Db_Entry[6]]),
    empty = [0, 0, Bests[1]];
   function update_entry(query, entry){
    var extra_cost = caml_call2(Query_Dynamic_cost[3], query, entry);
    return [0,
            entry[1],
            entry[2],
            entry[3],
            entry[4],
            entry[5] + extra_cost | 0,
            entry[6],
            entry[7]];
   }
   function Make(IO){
    var Seq = caml_call1(Query_Io[1], IO);
    function of_seq(query, limit, seq){
     function go(total_seen, t, seq){
      if((limit + 10 | 0) <= total_seen) return caml_call1(IO[1], t);
      var _c_ = caml_call1(seq, 0);
      return caml_call1
              (caml_call1(IO[3], _c_),
               function(param){
                if(! param) return caml_call1(IO[1], t);
                var xs = param[2], elt$1 = param[1];
                if(t[1] < limit)
                 var
                  elt = update_entry(query, elt$1),
                  _d_ = caml_call2(Bests[2], elt, t[2]),
                  match = [0, [0, t[1] + 1 | 0, _d_]];
                else{
                 var worst = caml_call1(Bests[13], t[2]);
                 if(worst[5] < elt$1[5])
                  var match = [1, t];
                 else{
                  var elt$0 = update_entry(query, elt$1);
                  if(worst[5] < elt$0[5])
                   var match = [0, t];
                  else
                   var
                    _e_ = caml_call2(Bests[4], worst, t[2]),
                    _f_ = caml_call1(caml_call1(Bests[2], elt$0), _e_),
                    match = [0, [0, t[1], _f_]];
                 }
                }
                if(0 === match[0]){
                 var t$0 = match[1];
                 return go(total_seen + 1 | 0, t$0, xs);
                }
                var t$1 = match[1];
                return caml_call1(IO[1], t$1);
               });
     }
     var _a_ = go(0, empty, seq);
     return caml_call1
             (caml_call1(IO[2], _a_),
              function(t){
               var _b_ = caml_call1(Bests[40], t[2]);
               return caml_call1(Stdlib_List[65], _b_);
              });
    }
    return [0, Seq, of_seq];
   }
   var Query_Top_results = [0, Make];
   runtime.caml_register_global(5, Query_Top_results, "Query__Top_results");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Priority_queue
//# unitInfo: Requires: Db__Entry, Db__String_automata, Stdlib__Array, Stdlib__List, Stdlib__Option
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_sherlodoc_query_priority_q = "sherlodoc/query/priority_queue.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_notequal = runtime.caml_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Db_String_automata = global_data.Db__String_automata,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Db_Entry = global_data.Db__Entry,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Array = global_data.Stdlib__Array,
    _a_ = [0, cst_sherlodoc_query_priority_q, 33, 14],
    _b_ = [0, cst_sherlodoc_query_priority_q, 81, 13],
    _c_ = [0, cst_sherlodoc_query_priority_q, 94, 6],
    _d_ = [0, cst_sherlodoc_query_priority_q, 95, 6],
    _e_ = [0, cst_sherlodoc_query_priority_q, 121, 10];
   function size(param){
    if(typeof param === "number") return 0;
    switch(param[0]){
      case 0:
       var arr = param[2], i = param[1]; return arr.length - 1 - i | 0;
      case 1:
       var s = param[2]; return caml_call1(Db_String_automata[5], s);
      default:
       var xs = param[2];
       return caml_call3
               (Stdlib_List[26],
                function(acc, x){return acc + size(x) | 0;},
                0,
                xs);
    }
   }
   function minimum(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]){
     var arr = param[2], i = param[1];
     return [0, caml_check_bound(arr, i)[1 + i]];
    }
    var elt = param[1];
    return [0, elt];
   }
   function of_sorted_array(arr){return [0, 0, arr];}
   function of_automata(s){
    var elt = caml_call1(Db_String_automata[4], s);
    return [1, elt, s];
   }
   function of_list(lst){
    var
     lst$0 =
       caml_call2
        (Stdlib_List[44], function(_k_){return caml_notequal(0, _k_);}, lst);
    function min(x){
     var match = minimum(x);
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var elt = match[1];
     return elt;
    }
    function compare(a, b){
     var _i_ = min(b), _j_ = min(a);
     return caml_call2(Db_Entry[6], _j_, _i_);
    }
    var lst$1 = caml_call2(Stdlib_List[59], compare, lst$0);
    if(! lst$1) return 0;
    var hd = lst$1[1];
    return [2, min(hd), lst$1];
   }
   function insert_sort(x, lst){
    var match = minimum(x);
    if(! match) return lst;
    var min_elt = match[1];
    function insert(lst){
     var lst$0 = lst;
     for(;;){
      if(! lst$0) return [0, x, 0];
      var lst$1 = lst$0[2], y = lst$0[1], match = minimum(y);
      if(match){
       var min_y = match[1];
       return 0 < caml_call2(Db_Entry[6], min_elt, min_y)
               ? [0, y, insert(lst$1)]
               : [0, x, lst$0];
      }
      lst$0 = lst$1;
     }
    }
    return insert(lst);
   }
   function pop_until(cond, t$2){
    var t$3 = t$2;
    for(;;){
     if(typeof t$3 === "number") return 0;
     switch(t$3[0]){
       case 0:
        var
         arr$0 = t$3[2],
         i = t$3[1],
         search =
           function(i, j){
            var i$0 = i, j$0 = j;
            for(;;){
             if(caml_call1(cond, caml_check_bound(arr$0, i$0)[1 + i$0]))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
             if(! caml_call1(cond, caml_check_bound(arr$0, j$0)[1 + j$0]))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
             var m = (i$0 + j$0 | 0) / 2 | 0;
             if(i$0 === m) return [0, j$0, arr$0];
             if(caml_call1(cond, caml_check_bound(arr$0, m)[1 + m]))
              j$0 = m;
             else
              i$0 = m;
            }
           },
         j = i,
         step = 1;
        for(;;){
         if(arr$0.length - 1 <= j){
          var last = arr$0.length - 2 | 0, j_prev = j - (step / 2 | 0) | 0;
          return caml_call1(cond, caml_check_bound(arr$0, last)[1 + last])
                  ? search(j_prev, last)
                  : 0;
         }
         if(caml_call1(cond, caml_check_bound(arr$0, j)[1 + j]))
          return i === j ? t$3 : search(j - (step / 2 | 0) | 0, j);
         var step$0 = step * 2 | 0, j$0 = j + step | 0;
         j = j$0;
         step = step$0;
        }
        break;
       case 1:
        var min_elt$0 = t$3[1];
        if(caml_call1(cond, min_elt$0)) return t$3;
        var automata = t$3[2], t$1 = automata[2], terminals = t$1[4];
        a:
        {
         if(typeof terminals !== "number" && 1 === terminals[0]){var arr = terminals[1], t$4 = [0, 0, arr]; break a;}
         if(typeof terminals === "number")
          var terminals$0 = 0;
         else{
          if(0 !== terminals[0])
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          var terminals$1 = terminals[1], terminals$0 = [0, 0, terminals$1];
         }
         let automata$0 = automata;
         var
          lift =
            function(child){return of_automata([0, automata$0[1], child]);},
          _f_ = caml_call2(Stdlib_Option[3], t$1[5], [0]),
          _g_ = caml_call1(caml_call1(Stdlib_Array[14], lift), _f_),
          children = caml_call1(Stdlib_Array[10], _g_),
          all = insert_sort(terminals$0, children),
          sorted_lst =
            caml_call2
             (Stdlib_List[44],
              function(_h_){return caml_notequal(0, _h_);},
              all);
         if(sorted_lst)
          if(sorted_lst[2])
           var t$4 = [2, min_elt$0, sorted_lst];
          else
           var t = sorted_lst[1], t$4 = t;
         else
          var t$4 = 0;
        }
        t$3 = t$4;
        break;
       default:
        var min_elt$1 = t$3[1];
        if(caml_call1(cond, min_elt$1)) return t$3;
        var
         lst$1 = t$3[2],
         pop_union =
           function(i, param){
            if(! param) return 0;
            var xs = param[2], x = param[1], x$0 = pop_until(cond, x);
            if(x !== x$0) return insert_sort(x$0, pop_union(i + 1 | 0, xs));
            if(0 < i) return [0, x, xs];
            throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
           },
         lst$2 = pop_union(0, lst$1),
         lst = lst$2;
        for(;;){
         if(! lst) return 0;
         var t$0 = lst[1];
         if(! lst[2]) return t$0;
         var lst$0 = lst[2], match = minimum(t$0);
         if(match){var min_elt = match[1]; return [2, min_elt, lst];}
         lst = lst$0;
        }
     }
    }
   }
   function pop_lt(elt, t){
    function cmp_lt(x){return 0 <= caml_call2(Db_Entry[6], x, elt) ? 1 : 0;}
    return pop_until(cmp_lt, t);
   }
   function pop_lte(elt, t){
    function cmp_lte(x){return 0 < caml_call2(Db_Entry[6], x, elt) ? 1 : 0;}
    return pop_until(cmp_lte, t);
   }
   var
    Query_Priority_queue =
      [0,
       minimum,
       of_automata,
       of_sorted_array,
       of_list,
       pop_lt,
       pop_lte,
       size];
   runtime.caml_register_global
    (11, Query_Priority_queue, "Query__Priority_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query__Succ
//# unitInfo: Requires: Db__Entry, Query__Priority_queue, Stdlib, Stdlib__Int, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_inter_all$1 = "inter all",
    cst_union_all$1 = "union all",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 1, 0],
    empty = [0, 0, 0],
    Query_Priority_queue = global_data.Query__Priority_queue,
    Db_Entry = global_data.Db__Entry,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, 1],
    cst_inter_all = cst_inter_all$1,
    cst_inter_all$0 = cst_inter_all$1,
    cst_union_all = cst_union_all$1,
    cst_union_all$0 = cst_union_all$1,
    _b_ = [0, "sherlodoc/query/succ.ml", 129, 9];
   function make_pq(t){
    return [0, [0, t], caml_call1(Query_Priority_queue[7], t)];
   }
   function of_automata(t){
    return make_pq(caml_call1(Query_Priority_queue[2], t));
   }
   function of_automatas(ts){
    var _e_ = caml_call2(Stdlib_List[20], Query_Priority_queue[2], ts);
    return make_pq(caml_call1(Query_Priority_queue[4], _e_));
   }
   function of_array(arr){
    return make_pq(caml_call1(Query_Priority_queue[3], arr));
   }
   function inter(a, b){
    var x = a[1], y = b[1];
    a:
    {
     if(typeof x === "number" && ! x) break a;
     if(typeof y !== "number"){
      if(typeof x === "number") return b;
      if(x === y) return a;
      var s = a[2] <= b[2] ? [1, x, y] : [1, y, x];
      return [0, s, caml_call2(Stdlib[16], a[2], b[2])];
     }
     if(y) return a;
    }
    return empty;
   }
   function union(a, b){
    var x = a[1], y = b[1];
    a:
    {
     if(typeof x === "number" && x) break a;
     if(typeof y !== "number"){
      if(typeof x === "number") return b;
      if(x === y) return a;
      var s = b[2] <= a[2] ? [2, x, y] : [2, y, x];
      return [0, s, a[2] + b[2] | 0];
     }
     if(! y) return a;
    }
    return all;
   }
   function join_with(fn, param){
    if(! param) return 0;
    var match = param[2], x = param[1];
    if(! match) return [0, x, 0];
    var xs = match[2], b = match[1], _d_ = join_with(fn, xs);
    return [0, caml_call2(fn, x, b), _d_];
   }
   function perfect(default$0, fn, xs){
    var xs$0 = xs;
    for(;;){
     if(! xs$0) return default$0;
     if(! xs$0[2]){var x = xs$0[1]; return x;}
     var xs$1 = join_with(fn, xs$0);
     xs$0 = xs$1;
    }
   }
   function inter_of_list(xs){
    var
     xs$0 =
       caml_call2
        (Stdlib_List[59],
         function(a, b){return caml_call2(Stdlib_Int[9], a[2], b[2]);},
         xs);
    return perfect(all, inter, xs$0);
   }
   function union_of_list(xs){
    var
     xs$0 =
       caml_call2
        (Stdlib_List[59],
         function(a, b){return caml_call2(Stdlib_Int[9], b[2], a[2]);},
         xs);
    return perfect(empty, union, xs$0);
   }
   function succ(strictness, t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return 0 === t$0
              ? 0
              : typeof
                strictness
                === "number"
                ? 1
                : 0 === strictness[0] ? _a_ : 1;
     switch(t$0[0]){
       case 0:
        var pqueue = t$0[1];
        if(typeof strictness === "number")
         var pqueue$0 = pqueue;
        else if(0 === strictness[0])
         var
          elt$0 = strictness[1],
          pqueue$0 = caml_call2(Query_Priority_queue[5], elt$0, pqueue);
        else
         var
          elt$1 = strictness[1],
          pqueue$0 = caml_call2(Query_Priority_queue[6], elt$1, pqueue);
        var match = caml_call1(Query_Priority_queue[1], pqueue$0);
        if(! match) return 0;
        if(typeof strictness !== "number" && 0 === strictness[0]){
         var e$0 = match[1], elt = strictness[1];
         if(caml_call2(Db_Entry[7], e$0, elt)) return [0, [0, pqueue$0]];
        }
        var e = match[1];
        return [1, e, [0, pqueue$0]];
       case 1:
        var r = t$0[2], l = t$0[1], match$0 = succ(strictness, l);
        if(typeof match$0 === "number")
         return 0 === match$0 ? 0 : caml_call1(Stdlib[2], cst_inter_all);
        if(0 !== match$0[0]){
         var l$1 = match$0[2], elt$3 = match$0[1];
         return [1, elt$3, [1, l$1, r]];
        }
        var l$0 = match$0[1], match$1 = succ(strictness, r);
        if(typeof match$1 === "number")
         return 0 === match$1 ? 0 : caml_call1(Stdlib[2], cst_inter_all$0);
        if(0 === match$1[0]){var r$0 = match$1[1]; return [0, [1, l$0, r$0]];}
        var r$1 = match$1[2], elt$2 = match$1[1];
        return [1, elt$2, [1, l$0, r$1]];
       default:
        var r$2 = t$0[2], l$2 = t$0[1], match$2 = succ(strictness, l$2);
        if(typeof match$2 !== "number"){
         if(0 === match$2[0]){
          var l$3 = match$2[1];
          return [0, [2, l$3, r$2]];
         }
         var
          l$4 = match$2[2],
          elt_l = match$2[1],
          match$3 = succ(strictness, r$2);
         if(typeof match$3 === "number")
          return 0 === match$3
                  ? [1, elt_l, l$4]
                  : caml_call1(Stdlib[2], cst_union_all$0);
         if(0 === match$3[0]){
          var r$3 = match$3[1];
          return [0, [2, l$4, r$3]];
         }
         var elt_r = match$3[1], r$4 = match$3[2];
         if(0 >= caml_call2(Db_Entry[6], elt_l, elt_r))
          return [1, elt_l, [2, l$4, r$4]];
         var r$5 = match$3[2];
         return [1, elt_r, [2, l$4, r$5]];
        }
        if(0 !== match$2) return caml_call1(Stdlib[2], cst_union_all);
        t$0 = r$2;
     }
    }
   }
   function succ_loop(opt, strictness, t){
    var opt$0 = opt, strictness$0 = strictness, t$0 = t;
    for(;;){
     var count = opt$0 ? opt$0[1] : 0, match = succ(strictness$0, t$0);
     if(typeof match === "number") return 0 === match ? 0 : 0;
     if(0 === match[0]){
      if(typeof strictness$0 !== "number" && 0 === strictness$0[0]){
       var t$1 = match[1], elt = strictness$0[1];
       return [0, [0, elt, t$1]];
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     }
     var
      t$2 = match[2],
      elt$0 = match[1],
      strictness$1 = [0, elt$0],
      opt$1 = [0, count + 1 | 0];
     opt$0 = opt$1;
     strictness$0 = strictness$1;
     t$0 = t$2;
    }
   }
   function to_seq(param){
    var t = param[1], state = [0, 0];
    function go(param){
     var _c_ = state[1];
     if(_c_)
      var
       match$0 = _c_[1],
       t$0 = match$0[2],
       previous_elt = match$0[1],
       result = succ_loop(0, [1, previous_elt], t$0);
     else
      var result = succ_loop(0, 0, t);
     if(result){
      var elt = result[1][1];
      state[1] = result;
      var match = [0, elt];
     }
     else
      var match = 0;
     if(! match) return 0;
     var x = match[1];
     return [0, x, go];
    }
    return go;
   }
   var
    Query_Succ =
      [0,
       to_seq,
       empty,
       of_automata,
       of_automatas,
       inter,
       union,
       inter_of_list,
       union_of_list,
       of_array];
   runtime.caml_register_global(14, Query_Succ, "Query__Succ");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Query
//# unitInfo: Requires: Db__Storage, Db__String_automata, Db__Type_polarity, Query__Dynamic_cost, Query__Query_parser, Query__Succ, Query__Top_results, Query__Type_lexer, Query__Type_parser, Stdlib__Lexing, Stdlib__List, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Query_Dynamic_cost = global_data.Query__Dynamic_cost,
    Query_Top_results = global_data.Query__Top_results,
    Query_Query_parser = global_data.Query__Query_parser,
    Query_Succ = global_data.Query__Succ,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Db_String_automata = global_data.Db__String_automata,
    Db_Storage = global_data.Db__Storage,
    Db_Type_polarity = global_data.Db__Type_polarity,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Query_Type_lexer = global_data.Query__Type_lexer,
    Query_Type_parser = global_data.Query__Type_parser;
   function of_string(str){
    var lexbuf = caml_call2(Stdlib_Lexing[3], 0, str);
    return [0, caml_call2(Query_Type_parser[2], Query_Type_lexer[2], lexbuf)];
   }
   var Type_parser = [0, of_string], Private = [0, Type_parser];
   function find_types(shard, typ){
    var
     _f_ = caml_call2(Db_Type_polarity[2], 0, typ),
     _g_ =
       caml_call2
        (Stdlib_Seq[31],
         function(param){
          var word = param[1];
          return 0 < runtime.caml_ml_string_length(word) ? 1 : 0;
         },
         _f_),
     polarities = caml_call1(Stdlib_List[65], _g_),
     _h_ =
       caml_call2
        (Stdlib_List[20],
         function(param){
          var
           polarity = param[3],
           count = param[2],
           name = param[1],
           st_occ = polarity ? shard[3] : shard[2],
           _i_ =
             caml_call3
              (Db_Storage[1][24],
               function(occurrences, st, acc){
                if(occurrences < count) return acc;
                var ts = caml_call2(Db_String_automata[3], st, name);
                return caml_call2(Stdlib_List[13], ts, acc);
               },
               st_occ,
               0);
          return caml_call1(Query_Succ[4], _i_);
         },
         polarities);
    return caml_call1(Query_Succ[7], _h_);
   }
   function find_names(shard, names){
    var
     names$0 = caml_call2(Stdlib_List[20], Stdlib_String[27], names),
     db_names = shard[1],
     candidates =
       caml_call2
        (Stdlib_List[20],
         function(name){
          var match = caml_call2(Db_String_automata[2], db_names, name);
          if(! match) return Query_Succ[2];
          var trie = match[1];
          return caml_call1(Query_Succ[3], trie);
         },
         names$0);
    return caml_call1(Query_Succ[7], candidates);
   }
   function pretty(params){
    var _e_ = caml_call1(Query_Query_parser[1], params[1]);
    return caml_call1(Query_Query_parser[2], _e_);
   }
   function Make(Io){
    var Tr = caml_call1(Query_Top_results[1], Io);
    function search(shards, opt, params){
     var
      dynamic_sort = opt ? opt[1] : 1,
      limit = params[3],
      query = caml_call1(Query_Query_parser[1], params[1]),
      _b_ =
        caml_call2
         (Stdlib_List[20],
          function(shard){
           var typ = query[2], name = query[1];
           if(! name){
            if(typeof typ === "number") return Query_Succ[2];
            var typ$1 = typ[2];
            return find_types(shard, typ$1);
           }
           if(typeof typ !== "number" && 5795659 === typ[1]){
            var
             typ$0 = typ[2],
             results_name = find_names(shard, name),
             results_typ = find_types(shard, typ$0);
            return caml_call2(Query_Succ[5], results_name, results_typ);
           }
           return find_names(shard, name);
          },
          shards),
      results = caml_call1(Query_Succ[8], _b_),
      results$0 = caml_call1(Query_Succ[1], results),
      packages = params[2],
      results$1 =
        packages
         ? caml_call2
           (Stdlib_Seq[31],
            function(param){
             var pkg = param[7], _d_ = caml_call1(Stdlib_String[9], pkg[1]);
             return caml_call2(Stdlib_List[34], _d_, packages);
            },
            results$0)
         : results$0,
      results$2 = caml_call1(Tr[1][1], results$1);
     if(dynamic_sort){
      var query$0 = caml_call1(Query_Dynamic_cost[1], query);
      return caml_call3(Tr[2], query$0, limit, results$2);
     }
     var _c_ = caml_call2(Tr[1][2], limit, results$2);
     return caml_call1(Tr[1][3], _c_);
    }
    return [0, , search];
   }
   function return$0(x){return x;}
   function map(x, f){return caml_call1(f, x);}
   function bind(x, f){return caml_call1(f, x);}
   var
    Blocking = Make([0, return$0, map, bind]),
    Query =
      [0,
       pretty,
       function(_a_){return [0, Make(_a_)[2]];},
       [0, Blocking[2]],
       Private];
   runtime.caml_register_global(13, Query, "Query");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIucXVlcnkub2Jqcy9qc29vL2RlZmF1bHQvcXVlcnkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVSUiIsInMiLCJtZW5oaXJfZmFpbCIsIm1lbmhpcl9ydW5fMDEkMCIsIm1lbmhpcl9zdGFjayIsIm1lbmhpcl9sZXhidWYiLCJtZW5oaXJfbGV4ZXIiLCJ3IiwibWVuaGlyX3MiLCJ0b2siLCJ2IiwibWVuaGlyX2dvdG9fdHlwMCIsIm1lbmhpcl9ydW5fMDEiLCJ0IiwibWVuaGlyX2dvdG9fdHlwcyIsInRzIiwibWVuaGlyX2dvdG9fdHlwMSIsInZfMCIsIm1lbmhpcl9zdGFjayQwIiwibWVuaGlyX3N0YWNrJDEiLCJ0b2skMCIsInZfMiIsIm1lbmhpcl9ydW5fMDkiLCJ2XzEiLCJtZW5oaXJfc3RhY2skMiIsInYkMCIsIm1lbmhpcl9zJDAiLCJtZW5oaXJfc3RhY2skMyIsInRvayQxIiwidl8wJDAiLCJtZW5oaXJfc3RhY2skNCIsInhzJDAiLCJ4IiwibWVuaGlyX3MkMSIsIm1lbmhpcl9zdGFjayQ1IiwieHMiLCJ3cyIsImFjYyIsInYkMSIsIm1lbmhpcl9ydW5fMDMkMCIsIm1lbmhpcl9ydW5fMDQkMCIsIm1lbmhpcl9yZWR1Y2VfMTMkMCIsInYkMiIsInYkMyIsIm1lbmhpcl9ydW5fMDIkMCIsIm1lbmhpcl9ydW5fMTciLCJtZW5oaXJfcyQyIiwibWVuaGlyX3J1bl8wMiIsIm1lbmhpcl9ydW5fMDMiLCJtZW5oaXJfcnVuXzA0IiwibWVuaGlyX3JlZHVjZV8xMyIsIm1lbmhpcl9ydW5fMTgiLCJhIiwibWVuaGlyX3MkMyIsIm1haW4iLCJvY2FtbF9sZXhfdGFibGVzIiwidG9rZW4kMCIsImxleGJ1ZiIsIm9jYW1sX2xleF90b2tlbl9yZWMkMCIsInRva2VuIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsInAiLCJvY2FtbF9sZXhfdG9rZW5fcmVjIiwicHJlZml4X2F0Iiwic3ViIiwiaiQzIiwiY2FzZSQwIiwiaSIsImoiLCJqJDAiLCJpJDAiLCJqJDEiLCJpJDEiLCJjYXNlJDEiLCJqJDIiLCJpJDIiLCJjYXNlJDIiLCJmaW5kX2FsbCIsImNvc3QiLCJhY2MkMCIsImlzX3N1YnN0cmluZyIsIndvcmRfYm91bmRhcnkiLCJiZXN0X21hdGNoIiwic3RyIiwiYWZ0ZXIiLCJjYXNlX2Nvc3QiLCJsZWZ0IiwicmlnaHQiLCJpc19hZnRlciIsImNvc3QkMCIsImJlc3RfbWF0Y2hlcyIsIndvcmRzIiwibm90X2ZvdW5kIiwiZm91bmQiLCJyZXZfY29uY2F0IiwibHN0IiwicHJlZml4IiwiYiIsInByZWZpeF9sZWZ0IiwicHJlZml4X3JpZ2h0IiwiYXJncyIsIm5hbWUiLCJwcmVmaXgkMCIsImxlbmd0aCIsImFyZyIsImFyZ3MkMCIsImxlbmd0aCQwIiwicGF0aHNfb2ZfdHlwZSIsInF1ZXJ5X3BhdGhzIiwiZW50cnkiLCJlbnRyeV9wYXRocyIsImFyciQwIiwieXMiLCJsZW5feHMiLCJsZW5feXMiLCJjYWNoZSIsImludiIsIm1lbW8iLCJ4c2duIiwieXNnbiIsInIiLCJyJDAiLCJnbyIsInlzJDkiLCJ4cyQ3IiwieXMkMCIsInkiLCJ4cyQ0IiwieCQwIiwieXMkNiIsInkkMCIsInhzJDUiLCJ5cyQ3IiwieHMkNiIsInlzJDgiLCJ5cyQxIiwieHMkMSIsInlzJDIiLCJ4cyQzIiwieHMkMiIsInlzJDMiLCJ5cyQ0IiwieXMkNSIsInBvcyIsInVzZWQiLCJhcnIiLCJsc3QkMCIsImhldXJpc3RpY3MiLCJiZXN0JDAiLCJiZXN0IiwibGltaXQiLCJyZW0iLCJzY29yZSQwIiwic2NvcmUiLCJyZXN0IiwiY29udGludWUkMCIsImNvbnRpbnVlJDEiLCJ0eXBlX29mX3N0cmluZyIsInN0ciQwIiwib3Blbl9wYXJlbnMiLCJjbG9zZV9wYXJlbnMiLCJvcGVuX3BhcmVucyQwIiwib3Blbl9wYXJlbnMkMSIsImNsb3NlX3BhcmVucyQwIiwiaSQzIiwib2Zfc3RyaW5nIiwibG9jIiwic3RyX25hbWUiLCJzdHJfdHlwIiwidHlwIiwicXVlcnlfbmFtZSIsInRvX3N0cmluZyIsInR5cCQwIiwib2ZfcXVlcnkiLCJ0eXBlX3BhdGhzIiwidHlwZV9kaXN0YW5jZSIsInF1ZXJ5X3R5cGUiLCJlbnRyeV90eXBlIiwicXVlcnkiLCJuYW1lX21hdGNoZXMiLCJ0eXBlX2Nvc3QiLCJvZl9zZXEiLCJ0YWtlIiwibiIsInRvX2xpc3QiLCJlbXB0eSIsInVwZGF0ZV9lbnRyeSIsImV4dHJhX2Nvc3QiLCJzZXEiLCJ0b3RhbF9zZWVuIiwiZWx0JDEiLCJlbHQiLCJ3b3JzdCIsImVsdCQwIiwidCQwIiwidCQxIiwic2l6ZSIsIm1pbmltdW0iLCJvZl9zb3J0ZWRfYXJyYXkiLCJvZl9hdXRvbWF0YSIsIm9mX2xpc3QiLCJtaW4iLCJjb21wYXJlIiwibHN0JDEiLCJoZCIsImluc2VydF9zb3J0IiwibWluX2VsdCIsImluc2VydCIsIm1pbl95IiwicG9wX3VudGlsIiwiY29uZCIsInQkMyIsInNlYXJjaCIsIm0iLCJzdGVwIiwibGFzdCIsImpfcHJldiIsInN0ZXAkMCIsIm1pbl9lbHQkMCIsImF1dG9tYXRhIiwidGVybWluYWxzIiwidGVybWluYWxzJDAiLCJ0ZXJtaW5hbHMkMSIsImF1dG9tYXRhJDAiLCJsaWZ0IiwiY2hpbGQiLCJjaGlsZHJlbiIsImFsbCIsInNvcnRlZF9sc3QiLCJtaW5fZWx0JDEiLCJwb3BfdW5pb24iLCJsc3QkMiIsInBvcF9sdCIsImNtcF9sdCIsInBvcF9sdGUiLCJjbXBfbHRlIiwibWFrZV9wcSIsIm9mX2F1dG9tYXRhcyIsIm9mX2FycmF5IiwiaW50ZXIiLCJ1bmlvbiIsImpvaW5fd2l0aCIsImZuIiwicGVyZmVjdCIsImRlZmF1bHQkMCIsImludGVyX29mX2xpc3QiLCJ1bmlvbl9vZl9saXN0Iiwic3VjYyIsInN0cmljdG5lc3MiLCJwcXVldWUiLCJwcXVldWUkMCIsImUkMCIsImUiLCJsIiwibCQxIiwiZWx0JDMiLCJsJDAiLCJyJDEiLCJlbHQkMiIsInIkMiIsImwkMiIsImwkMyIsImwkNCIsImVsdF9sIiwiciQzIiwiZWx0X3IiLCJyJDQiLCJyJDUiLCJzdWNjX2xvb3AiLCJzdHJpY3RuZXNzJDAiLCJjb3VudCIsInQkMiIsInRvX3NlcSIsInN0YXRlIiwicHJldmlvdXNfZWx0IiwicmVzdWx0IiwiZmluZF90eXBlcyIsInNoYXJkIiwid29yZCIsInBvbGFyaXRpZXMiLCJwb2xhcml0eSIsInN0X29jYyIsIm9jY3VycmVuY2VzIiwic3QiLCJmaW5kX25hbWVzIiwibmFtZXMiLCJuYW1lcyQwIiwiZGJfbmFtZXMiLCJjYW5kaWRhdGVzIiwidHJpZSIsInByZXR0eSIsInBhcmFtcyIsInNoYXJkcyIsImR5bmFtaWNfc29ydCIsInR5cCQxIiwicmVzdWx0c19uYW1lIiwicmVzdWx0c190eXAiLCJyZXN1bHRzIiwicmVzdWx0cyQwIiwicGFja2FnZXMiLCJyZXN1bHRzJDEiLCJwa2ciLCJyZXN1bHRzJDIiLCJxdWVyeSQwIiwicmV0dXJuJDAiLCJtYXAiLCJmIiwiYmluZCJdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Vfcm9vdC9zaGVybG9kb2MvcXVlcnkvcXVlcnlfXy5tbC1nZW4iLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHkiLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9xdWVyeS9uYW1lX2Nvc3QubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3R5cGVfZGlzdGFuY2UubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3F1ZXJ5X3BhcnNlci5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zaGVybG9kb2MvcXVlcnkvZHluYW1pY19jb3N0Lm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9xdWVyeS9pby5tbCIsIi93b3Jrc3BhY2Vfcm9vdC9zaGVybG9kb2MvcXVlcnkvdG9wX3Jlc3VsdHMubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc2hlcmxvZG9jL3F1ZXJ5L3ByaW9yaXR5X3F1ZXVlLm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9xdWVyeS9zdWNjLm1sIiwiL3dvcmtzcGFjZV9yb290L3NoZXJsb2RvYy9xdWVyeS9xdWVyeS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQWdDaUIsdUNBQUE7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dDN0JmOzs7OztJQUFBOzs7OztZQUVJQSxJQUNFQyxHQUNGLE1BQUEsc0NBQVc7WUFrUmJDO0lBRUEsTUFDQTtHQUFZO1lBZ0JOQzthQUNGQyxjQUFjQyxlQUFlQyxjQUUzQkMsR0FGNENDO0lBQ2hELElBQUlDLE1BQU8sV0FEb0JILGNBQWZELGdCQUdaSyxRQURBSDtJQUVKO0tBQUEsT0FBQTtjQUVBSTtrQkFORVAsY0FBY0MsZUFBZUMsY0FHM0JJLEdBSDRDRixVQUM1Q0M7O0lBR0osT0FFQUU7O2FBTkVQO2FBQWNDO2FBQWVDO2FBRzNCSTthQUg0Q0Y7YUFDNUNDO0dBRzBFO1lBTDFFRztJQUNGUixjQUFjQyxlQUFlQyxjQUUzQkMsR0FGNENDO0k7YUFENUNMO2tCQUNGQyxjQUFjQyxlQUFlQyxjQUUzQkMsR0FGNENDOztZQU1oREc7YUFDRVAsY0FBY0MsZUFBZUMsY0FDM0JPLEdBRDRDTCxVQUFVQztJQ2hRckQsSURrUURDLFFBREFHO0lBRUo7S0FBQSxPQUFBO2NBRUFDO2tCQUxFVixjQUFjQyxlQUFlQyxjQUUzQkksR0FGNENGLFVBQVVDOztJQUcxRCxPQUVBSzs7YUFMRVY7YUFBY0M7YUFBZUM7YUFFM0JJO2FBRjRDRjthQUFVQztHQUdvQjtZQUU5RUs7YUFDRVYsY0FtQ2NDLGVBQWVDLGNBbkNjUyxJQUFHUCxVQUFVQztJQUMxRCxVQUQwREE7WUFBQUE7Ozs7UUNuUnBELElEbVNFQyxJ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RW9SLEdBQUksT0FBQSxXQUFKQSxHQUFGcFIsR0FBUzs7d0JBRmRrUixVQUNBQyxLQUNBRTs7O09BdENKakI7cUI7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBRdWVyeS5EeW5hbWljX2Nvc3QgKilcbm1vZHVsZSBEeW5hbWljX2Nvc3QgPSBRdWVyeV9fRHluYW1pY19jb3N0XG5cbigqKiBAY2Fub25pY2FsIFF1ZXJ5LklvICopXG5tb2R1bGUgSW8gPSBRdWVyeV9fSW9cblxuKCoqIEBjYW5vbmljYWwgUXVlcnkuTmFtZV9jb3N0ICopXG5tb2R1bGUgTmFtZV9jb3N0ID0gUXVlcnlfX05hbWVfY29zdFxuXG4oKiogQGNhbm9uaWNhbCBRdWVyeS5Qcmlvcml0eV9xdWV1ZSAqKVxubW9kdWxlIFByaW9yaXR5X3F1ZXVlID0gUXVlcnlfX1ByaW9yaXR5X3F1ZXVlXG5cbigqKiBAY2Fub25pY2FsIFF1ZXJ5LlF1ZXJ5X3BhcnNlciAqKVxubW9kdWxlIFF1ZXJ5X3BhcnNlciA9IFF1ZXJ5X19RdWVyeV9wYXJzZXJcblxuKCoqIEBjYW5vbmljYWwgUXVlcnkuU3VjYyAqKVxubW9kdWxlIFN1Y2MgPSBRdWVyeV9fU3VjY1xuXG4oKiogQGNhbm9uaWNhbCBRdWVyeS5Ub3BfcmVzdWx0cyAqKVxubW9kdWxlIFRvcF9yZXN1bHRzID0gUXVlcnlfX1RvcF9yZXN1bHRzXG5cbigqKiBAY2Fub25pY2FsIFF1ZXJ5LlR5cGVfZGlzdGFuY2UgKilcbm1vZHVsZSBUeXBlX2Rpc3RhbmNlID0gUXVlcnlfX1R5cGVfZGlzdGFuY2VcblxuKCoqIEBjYW5vbmljYWwgUXVlcnkuVHlwZV9sZXhlciAqKVxubW9kdWxlIFR5cGVfbGV4ZXIgPSBRdWVyeV9fVHlwZV9sZXhlclxuXG4oKiogQGNhbm9uaWNhbCBRdWVyeS5UeXBlX3BhcnNlciAqKVxubW9kdWxlIFR5cGVfcGFyc2VyID0gUXVlcnlfX1R5cGVfcGFyc2VyXG5cbm1vZHVsZSBRdWVyeV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJcbm1vZHVsZSBNZW5oaXJCYXNpY3MgPSBzdHJ1Y3RcbiAgXG4gIGV4Y2VwdGlvbiBFcnJvclxuICBcbiAgbGV0IF9lUlIgPVxuICAgIGZ1biBfcyAtPlxuICAgICAgcmFpc2UgRXJyb3JcbiAgXG4gIHR5cGUgdG9rZW4gPSBcbiAgICB8IFdPUkQgb2YgKFxuIyAxNyBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgKHN0cmluZylcbiMgMTUgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICApXG4gICAgfCBTVEFSXG4gICAgfCBQT0xZIG9mIChcbiMgMTggXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgIChzdHJpbmcpXG4jIDIxIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgUEFSRU5TX09QRU5cbiAgICB8IFBBUkVOU19DTE9TRVxuICAgIHwgRU9GXG4gICAgfCBDT01NQVxuICAgIHwgQVJST1dcbiAgICB8IEFOWVxuICBcbmVuZFxuXG5pbmNsdWRlIE1lbmhpckJhc2ljc1xuXG4jIDQgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgXG4gIG1vZHVsZSBQcmludGYgPSBzdHJ1Y3RcbiAgICAoKiBXaXRob3V0IHRoZSBmb2xsb3dpbmcgcGxhY2Vob2xkZXIsIFttZW5oaXJfZmFpbF0gaW5kdWNlc1xuICAgICAgIGEgbGFyZ2UgZGVwZW5kZW5jeSB0byBbY2FtbGludGVybmFsRm9ybWF0XSBpbiB0aGUganMgYnVuZGxlLiAqKVxuICAgIGxldCBlcHJpbnRmIF8gPSAoKVxuICBlbmRcblxuICBvcGVuIERiLlR5cGV4cHJcblxuIyA0NCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG5cbnR5cGUgKCdzLCAncikgX21lbmhpcl9zdGF0ZSA9IFxuICB8IE1lbmhpclN0YXRlMDAgOiAoJ3MsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGVcbiAgICAoKiogU3RhdGUgMDAuXG4gICAgICAgIFN0YWNrIHNoYXBlIDogLlxuICAgICAgICBTdGFydCBzeW1ib2w6IG1haW4uICopXG5cbiAgfCBNZW5oaXJTdGF0ZTAzIDogKCgncywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9jZWxsMV9QQVJFTlNfT1BFTiwgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZVxuICAgICgqKiBTdGF0ZSAwMy5cbiAgICAgICAgU3RhY2sgc2hhcGUgOiBQQVJFTlNfT1BFTi5cbiAgICAgICAgU3RhcnQgc3ltYm9sOiBtYWluLiAqKVxuXG4gIHwgTWVuaGlyU3RhdGUwNiA6ICgoJ3MsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfY2VsbDFfdHlwcyBfbWVuaGlyX2NlbGwwX1dPUkQsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGVcbiAgICAoKiogU3RhdGUgMDYuXG4gICAgICAgIFN0YWNrIHNoYXBlIDogdHlwcyBXT1JELlxuICAgICAgICBTdGFydCBzeW1ib2w6IG1haW4uICopXG5cbiAgfCBNZW5oaXJTdGF0ZTA3IDogKCgncywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9jZWxsMV9XT1JELCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlXG4gICAgKCoqIFN0YXRlIDA3LlxuICAgICAgICBTdGFjayBzaGFwZSA6IFdPUkQuXG4gICAgICAgIFN0YXJ0IHN5bWJvbDogbWFpbi4gKilcblxuICB8IE1lbmhpclN0YXRlMTEgOiAoKCdzLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX2NlbGwxX3R5cDIsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGVcbiAgICAoKiogU3RhdGUgMTEuXG4gICAgICAgIFN0YWNrIHNoYXBlIDogdHlwMi5cbiAgICAgICAgU3RhcnQgc3ltYm9sOiBtYWluLiAqKVxuXG4gIHwgTWVuaGlyU3RhdGUxMyA6ICgoJ3MsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfY2VsbDFfdHlwMSwgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZVxuICAgICgqKiBTdGF0ZSAxMy5cbiAgICAgICAgU3RhY2sgc2hhcGUgOiB0eXAxLlxuICAgICAgICBTdGFydCBzeW1ib2w6IG1haW4uICopXG5cbiAgfCBNZW5oaXJTdGF0ZTE5IDogKCgncywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9jZWxsMV90eXAsIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGVcbiAgICAoKiogU3RhdGUgMTkuXG4gICAgICAgIFN0YWNrIHNoYXBlIDogdHlwLlxuICAgICAgICBTdGFydCBzeW1ib2w6IG1haW4uICopXG5cblxuYW5kICgncywgJ3IpIF9tZW5oaXJfY2VsbDFfdHlwID0gXG4gIHwgTWVuaGlyQ2VsbDFfdHlwIG9mICdzICogKCdzLCAncikgX21lbmhpcl9zdGF0ZSAqIChEYi5UeXBleHByLnQpXG5cbmFuZCAoJ3MsICdyKSBfbWVuaGlyX2NlbGwxX3R5cDEgPSBcbiAgfCBNZW5oaXJDZWxsMV90eXAxIG9mICdzICogKCdzLCAncikgX21lbmhpcl9zdGF0ZSAqIChEYi5UeXBleHByLnQpXG5cbmFuZCAoJ3MsICdyKSBfbWVuaGlyX2NlbGwxX3R5cDIgPSBcbiAgfCBNZW5oaXJDZWxsMV90eXAyIG9mICdzICogKCdzLCAncikgX21lbmhpcl9zdGF0ZSAqIChEYi5UeXBleHByLnQpXG5cbmFuZCAoJ3MsICdyKSBfbWVuaGlyX2NlbGwxX3R5cHMgPSBcbiAgfCBNZW5oaXJDZWxsMV90eXBzIG9mICdzICogKCdzLCAncikgX21lbmhpcl9zdGF0ZSAqIChEYi5UeXBleHByLnQgbGlzdClcblxuYW5kICgncywgJ3IpIF9tZW5oaXJfY2VsbDFfUEFSRU5TX09QRU4gPSBcbiAgfCBNZW5oaXJDZWxsMV9QQVJFTlNfT1BFTiBvZiAncyAqICgncywgJ3IpIF9tZW5oaXJfc3RhdGVcblxuYW5kICgncywgJ3IpIF9tZW5oaXJfY2VsbDFfV09SRCA9IFxuICB8IE1lbmhpckNlbGwxX1dPUkQgb2YgJ3MgKiAoJ3MsICdyKSBfbWVuaGlyX3N0YXRlICogKFxuIyAxNyBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgKHN0cmluZylcbiMgMTAyIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbilcblxuYW5kICdzIF9tZW5oaXJfY2VsbDBfV09SRCA9IFxuICB8IE1lbmhpckNlbGwwX1dPUkQgb2YgJ3MgKiAoXG4jIDE3IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1seVwiXG4gICAgICAoc3RyaW5nKVxuIyAxMDkgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuKVxuXG5hbmQgX21lbmhpcl9ib3hfbWFpbiA9IFxuICB8IE1lbmhpckJveF9tYWluIG9mIChEYi5UeXBleHByLnQpIFtAQHVuYm94ZWRdXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8wMSA9XG4gIGZ1biAoKSAtPlxuICAgIChcbiMgMjE2IFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAxMjAgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICAgICA6IChzdHJpbmcgbGlzdCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8wMiA9XG4gIGZ1biB4IHhzIC0+XG4gICAgKFxuIyAyMTkgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IDo6IHhzIClcbiMgMTI4IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoc3RyaW5nIGxpc3QpKVxuXG5sZXQgX21lbmhpcl9hY3Rpb25fMDMgPVxuICBmdW4geCAtPlxuICAgIChcbiMgNTggXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBbeF0gKVxuIyAxMzYgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICAgICA6IChEYi5UeXBleHByLnQgbGlzdCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8wNCA9XG4gIGZ1biB4IHhzIC0+XG4gICAgKFxuIyA1OSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHg6OnhzIClcbiMgMTQ0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50IGxpc3QpKVxuXG5sZXQgX21lbmhpcl9hY3Rpb25fMDUgPVxuICBmdW4geCAtPlxuICAgIChcbiMgNTggXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBbeF0gKVxuIyAxNTIgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICAgICA6IChEYi5UeXBleHByLnQgbGlzdCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8wNiA9XG4gIGZ1biB4IHhzIC0+XG4gICAgKFxuIyA1OSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIHg6OnhzIClcbiMgMTYwIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50IGxpc3QpKVxuXG5sZXQgX21lbmhpcl9hY3Rpb25fMDcgPVxuICBmdW4gdCAtPlxuICAgIChcbiMgMjYgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgKCB0IClcbiMgMTY4IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50KSlcblxubGV0IF9tZW5oaXJfYWN0aW9uXzA4ID1cbiAgZnVuIHQgLT5cbiAgICAoXG4jIDMwIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggdCApXG4jIDE3NiBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG4gICAgIDogKERiLlR5cGV4cHIudCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8wOSA9XG4gIGZ1biBhIGIgLT5cbiAgICAoXG4jIDMxIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICggQXJyb3cgKGEsIGIpIClcbiMgMTg0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50KSlcblxubGV0IF9tZW5oaXJfYWN0aW9uXzEwID1cbiAgZnVuICgpIC0+XG4gICAgKFxuIyA0NyBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAoIEFueSApXG4jIDE5MiBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG4gICAgIDogKERiLlR5cGV4cHIudCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8xMSA9XG4gIGZ1biB3IC0+XG4gICAgKFxuIyA0OCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIFBvbHkgdyApXG4jIDIwMCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG4gICAgIDogKERiLlR5cGV4cHIudCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8xMiA9XG4gIGZ1biB3IC0+XG4gICAgKFxuIyA0OSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIENvbnN0ciAodywgW10pIClcbiMgMjA4IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50KSlcblxubGV0IF9tZW5oaXJfYWN0aW9uXzEzID1cbiAgZnVuICgpIC0+XG4gICAgKFxuIyAzOSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICggQW55IClcbiMgMjE2IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50KSlcblxubGV0IF9tZW5oaXJfYWN0aW9uXzE0ID1cbiAgZnVuIHRzIC0+XG4gICAgKFxuIyA0MCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgKCB0dXBsZSB0cyApXG4jIDIyNCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG4gICAgIDogKERiLlR5cGV4cHIudCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8xNSA9XG4gIGZ1biB0cyB3IHdzIC0+XG4gICAgKFxuIyA0MSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgTGlzdC5mb2xkX2xlZnQgKGZ1biBhY2MgdyAtPiBDb25zdHIgKHcsIFthY2NdKSkgKENvbnN0ciAodywgdHMpKSB3c1xuICAgIClcbiMgMjM0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfcGFyc2VyLm1sXCJcbiAgICAgOiAoRGIuVHlwZXhwci50KSlcblxubGV0IF9tZW5oaXJfYWN0aW9uXzE2ID1cbiAgZnVuIHhzIC0+XG4gICAgKFxuIyAzNSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICggdHVwbGUgeHMgKVxuIyAyNDIgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICAgICA6IChEYi5UeXBleHByLnQpKVxuXG5sZXQgX21lbmhpcl9hY3Rpb25fMTcgPVxuICBmdW4gdCAtPlxuICAgIChcbiMgNTMgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgKCBbdF0gKVxuIyAyNTAgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWxcIlxuICAgICA6IChEYi5UeXBleHByLnQgbGlzdCkpXG5cbmxldCBfbWVuaGlyX2FjdGlvbl8xOCA9XG4gIGZ1biB0cyAtPlxuICAgIChcbiMgNTQgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCB0cyApXG4jIDI1OCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX3BhcnNlci5tbFwiXG4gICAgIDogKERiLlR5cGV4cHIudCBsaXN0KSlcblxubGV0IF9tZW5oaXJfcHJpbnRfdG9rZW4gOiB0b2tlbiAtPiBzdHJpbmcgPVxuICBmdW4gX3RvayAtPlxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgQU5ZIC0+XG4gICAgICAgIFwiQU5ZXCJcbiAgICB8IEFSUk9XIC0+XG4gICAgICAgIFwiQVJST1dcIlxuICAgIHwgQ09NTUEgLT5cbiAgICAgICAgXCJDT01NQVwiXG4gICAgfCBFT0YgLT5cbiAgICAgICAgXCJFT0ZcIlxuICAgIHwgUEFSRU5TX0NMT1NFIC0+XG4gICAgICAgIFwiUEFSRU5TX0NMT1NFXCJcbiAgICB8IFBBUkVOU19PUEVOIC0+XG4gICAgICAgIFwiUEFSRU5TX09QRU5cIlxuICAgIHwgUE9MWSBfIC0+XG4gICAgICAgIFwiUE9MWVwiXG4gICAgfCBTVEFSIC0+XG4gICAgICAgIFwiU1RBUlwiXG4gICAgfCBXT1JEIF8gLT5cbiAgICAgICAgXCJXT1JEXCJcblxubGV0IF9tZW5oaXJfZmFpbCA6IHVuaXQgLT4gJ2EgPVxuICBmdW4gKCkgLT5cbiAgICBQcmludGYuZXByaW50ZiBcIkludGVybmFsIGZhaWx1cmUgLS0gcGxlYXNlIGNvbnRhY3QgdGhlIHBhcnNlciBnZW5lcmF0b3IncyBkZXZlbG9wZXJzLlxcbiUhXCI7XG4gICAgYXNzZXJ0IGZhbHNlXG5cbmluY2x1ZGUgc3RydWN0XG4gIFxuICBbQEBAb2NhbWwud2FybmluZyBcIi00LTM3XCJdXG4gIFxuICBsZXQgX21lbmhpcl9ydW5fMjMgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX3YgX3RvayAtPlxuICAgICAgbWF0Y2ggKF90b2sgOiBNZW5oaXJCYXNpY3MudG9rZW4pIHdpdGhcbiAgICAgIHwgRU9GIC0+XG4gICAgICAgICAgbGV0IHQgPSBfdiBpblxuICAgICAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzA3IHQgaW5cbiAgICAgICAgICBNZW5oaXJCb3hfbWFpbiBfdlxuICAgICAgfCBfIC0+XG4gICAgICAgICAgX2VSUiAoKVxuICBcbiAgbGV0IHJlYyBfbWVuaGlyX3J1bl8wMSA6IHR5cGUgIHR0dl9zdGFjay4gdHR2X3N0YWNrIC0+IF8gLT4gXyAtPiBfIC0+ICh0dHZfc3RhY2ssIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGUgLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgLT5cbiAgICAgIGxldCBfdG9rID0gX21lbmhpcl9sZXhlciBfbWVuaGlyX2xleGJ1ZiBpblxuICAgICAgbGV0IHcgPSBfdiBpblxuICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMTIgdyBpblxuICAgICAgX21lbmhpcl9nb3RvX3R5cDAgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gIFxuICBhbmQgX21lbmhpcl9nb3RvX3R5cDAgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3RvayAtPlxuICAgICAgbGV0IHQgPSBfdiBpblxuICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMTcgdCBpblxuICAgICAgX21lbmhpcl9nb3RvX3R5cHMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gIFxuICBhbmQgX21lbmhpcl9nb3RvX3R5cHMgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3RvayAtPlxuICAgICAgbWF0Y2ggKF90b2sgOiBNZW5oaXJCYXNpY3MudG9rZW4pIHdpdGhcbiAgICAgIHwgV09SRCBfdl8wIC0+XG4gICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBNZW5oaXJDZWxsMV90eXBzIChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gTWVuaGlyQ2VsbDBfV09SRCAoX21lbmhpcl9zdGFjaywgX3ZfMCkgaW5cbiAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgICAgICAobWF0Y2ggKF90b2sgOiBNZW5oaXJCYXNpY3MudG9rZW4pIHdpdGhcbiAgICAgICAgICB8IFdPUkQgX3ZfMSAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wNyBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3ZfMSBNZW5oaXJTdGF0ZTA2XG4gICAgICAgICAgfCBBUlJPVyB8IENPTU1BIHwgRU9GIHwgUEFSRU5TX0NMT1NFIHwgU1RBUiAtPlxuICAgICAgICAgICAgICBsZXQgX3ZfMiA9IF9tZW5oaXJfYWN0aW9uXzAxICgpIGluXG4gICAgICAgICAgICAgIF9tZW5oaXJfcnVuXzA5IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdl8yIF90b2tcbiAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgX2VSUiAoKSlcbiAgICAgIHwgQVJST1cgfCBDT01NQSB8IEVPRiB8IFBBUkVOU19DTE9TRSB8IFNUQVIgLT5cbiAgICAgICAgICBsZXQgdHMgPSBfdiBpblxuICAgICAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzE0IHRzIGluXG4gICAgICAgICAgX21lbmhpcl9nb3RvX3R5cDEgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBfZVJSICgpXG4gIFxuICBhbmQgX21lbmhpcl9ydW5fMDcgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIC0+XG4gICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE1lbmhpckNlbGwxX1dPUkQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YpIGluXG4gICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgIG1hdGNoIChfdG9rIDogTWVuaGlyQmFzaWNzLnRva2VuKSB3aXRoXG4gICAgICB8IFdPUkQgX3ZfMCAtPlxuICAgICAgICAgIF9tZW5oaXJfcnVuXzA3IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdl8wIE1lbmhpclN0YXRlMDdcbiAgICAgIHwgQVJST1cgfCBDT01NQSB8IEVPRiB8IFBBUkVOU19DTE9TRSB8IFNUQVIgLT5cbiAgICAgICAgICBsZXQgX3ZfMSA9IF9tZW5oaXJfYWN0aW9uXzAxICgpIGluXG4gICAgICAgICAgX21lbmhpcl9ydW5fMDggX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92XzEgX3Rva1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX2VSUiAoKVxuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzA4IDogdHlwZSAgdHR2X3N0YWNrLiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX2NlbGwxX1dPUkQgLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF90b2sgLT5cbiAgICAgIGxldCBNZW5oaXJDZWxsMV9XT1JEIChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIHgpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgbGV0IHhzID0gX3YgaW5cbiAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzAyIHggeHMgaW5cbiAgICAgIF9tZW5oaXJfZ290b19saXN0X1dPUkRfIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICBcbiAgYW5kIF9tZW5oaXJfZ290b19saXN0X1dPUkRfIDogdHlwZSAgdHR2X3N0YWNrLiB0dHZfc3RhY2sgLT4gXyAtPiBfIC0+IF8gLT4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZSAtPiBfIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIF90b2sgLT5cbiAgICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgICB8IE1lbmhpclN0YXRlMDYgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wOSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX3Rva1xuICAgICAgfCBNZW5oaXJTdGF0ZTA3IC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMDggX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF90b2tcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzA5IDogdHlwZSAgdHR2X3N0YWNrLiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX2NlbGwxX3R5cHMgX21lbmhpcl9jZWxsMF9XT1JEIC0+IF8gLT4gXyAtPiBfIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfdG9rIC0+XG4gICAgICBsZXQgTWVuaGlyQ2VsbDBfV09SRCAoX21lbmhpcl9zdGFjaywgdykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICBsZXQgTWVuaGlyQ2VsbDFfdHlwcyAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCB0cykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICBsZXQgd3MgPSBfdiBpblxuICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMTUgdHMgdyB3cyBpblxuICAgICAgX21lbmhpcl9nb3RvX3R5cDEgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gIFxuICBhbmQgX21lbmhpcl9nb3RvX3R5cDEgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3RvayAtPlxuICAgICAgbWF0Y2ggKF90b2sgOiBNZW5oaXJCYXNpY3MudG9rZW4pIHdpdGhcbiAgICAgIHwgU1RBUiAtPlxuICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gTWVuaGlyQ2VsbDFfdHlwMSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGUxMyBpblxuICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9sZXhlciBfbWVuaGlyX2xleGJ1ZiBpblxuICAgICAgICAgIChtYXRjaCAoX3RvayA6IE1lbmhpckJhc2ljcy50b2tlbikgd2l0aFxuICAgICAgICAgIHwgV09SRCBfdiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wMSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICAgICAgfCBQT0xZIF92IC0+XG4gICAgICAgICAgICAgIF9tZW5oaXJfcnVuXzAyIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3NcbiAgICAgICAgICB8IFBBUkVOU19PUEVOIC0+XG4gICAgICAgICAgICAgIF9tZW5oaXJfcnVuXzAzIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfbWVuaGlyX3NcbiAgICAgICAgICB8IEFOWSAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wNCBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zXG4gICAgICAgICAgfCBBUlJPVyB8IENPTU1BIHwgRU9GIHwgUEFSRU5TX0NMT1NFIHwgU1RBUiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3JlZHVjZV8xMyBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zIF90b2spXG4gICAgICB8IEFSUk9XIHwgQ09NTUEgfCBFT0YgfCBQQVJFTlNfQ0xPU0UgLT5cbiAgICAgICAgICBsZXQgeCA9IF92IGluXG4gICAgICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMDUgeCBpblxuICAgICAgICAgIF9tZW5oaXJfZ290b19saXN0MV90eXAxX1NUQVJfIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX21lbmhpcl9mYWlsICgpXG4gIFxuICBhbmQgX21lbmhpcl9ydW5fMDIgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIC0+XG4gICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgIGxldCB3ID0gX3YgaW5cbiAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzExIHcgaW5cbiAgICAgIF9tZW5oaXJfZ290b190eXAwIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzAzIDogdHlwZSAgdHR2X3N0YWNrLiB0dHZfc3RhY2sgLT4gXyAtPiBfIC0+ICh0dHZfc3RhY2ssIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGUgLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfbWVuaGlyX3MgLT5cbiAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gTWVuaGlyQ2VsbDFfUEFSRU5TX09QRU4gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTAzIGluXG4gICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgIG1hdGNoIChfdG9rIDogTWVuaGlyQmFzaWNzLnRva2VuKSB3aXRoXG4gICAgICB8IFdPUkQgX3YgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wMSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICB8IFBPTFkgX3YgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wMiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICB8IFBBUkVOU19PUEVOIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMDMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfc1xuICAgICAgfCBBTlkgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wNCBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zXG4gICAgICB8IEFSUk9XIHwgQ09NTUEgfCBQQVJFTlNfQ0xPU0UgfCBTVEFSIC0+XG4gICAgICAgICAgX21lbmhpcl9yZWR1Y2VfMTMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfcyBfdG9rXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBfZVJSICgpXG4gIFxuICBhbmQgX21lbmhpcl9ydW5fMDQgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZSAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfcyAtPlxuICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2xleGVyIF9tZW5oaXJfbGV4YnVmIGluXG4gICAgICBsZXQgX3YgPSBfbWVuaGlyX2FjdGlvbl8xMCAoKSBpblxuICAgICAgX21lbmhpcl9nb3RvX3R5cDAgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gIFxuICBhbmQgX21lbmhpcl9yZWR1Y2VfMTMgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZSAtPiBfIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zIF90b2sgLT5cbiAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzEzICgpIGluXG4gICAgICBfbWVuaGlyX2dvdG9fdHlwMSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIF90b2tcbiAgXG4gIGFuZCBfbWVuaGlyX2dvdG9fbGlzdDFfdHlwMV9TVEFSXyA6IHR5cGUgIHR0dl9zdGFjay4gdHR2X3N0YWNrIC0+IF8gLT4gXyAtPiBfIC0+ICh0dHZfc3RhY2ssIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGUgLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rIC0+XG4gICAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgICAgfCBNZW5oaXJTdGF0ZTAwIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMTcgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gICAgICB8IE1lbmhpclN0YXRlMDMgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8xNyBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIF90b2tcbiAgICAgIHwgTWVuaGlyU3RhdGUxOSAtPlxuICAgICAgICAgIF9tZW5oaXJfcnVuXzE3IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICAgICAgfCBNZW5oaXJTdGF0ZTExIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMTcgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gICAgICB8IE1lbmhpclN0YXRlMTMgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8xNSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX3Rva1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX21lbmhpcl9mYWlsICgpXG4gIFxuICBhbmQgX21lbmhpcl9ydW5fMTcgOiB0eXBlICB0dHZfc3RhY2suIHR0dl9zdGFjayAtPiBfIC0+IF8gLT4gXyAtPiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX3N0YXRlIC0+IF8gLT4gX21lbmhpcl9ib3hfbWFpbiA9XG4gICAgZnVuIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3RvayAtPlxuICAgICAgbGV0IHhzID0gX3YgaW5cbiAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzE2IHhzIGluXG4gICAgICBtYXRjaCAoX3RvayA6IE1lbmhpckJhc2ljcy50b2tlbikgd2l0aFxuICAgICAgfCBBUlJPVyAtPlxuICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gTWVuaGlyQ2VsbDFfdHlwMiAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGUxMSBpblxuICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9sZXhlciBfbWVuaGlyX2xleGJ1ZiBpblxuICAgICAgICAgIChtYXRjaCAoX3RvayA6IE1lbmhpckJhc2ljcy50b2tlbikgd2l0aFxuICAgICAgICAgIHwgV09SRCBfdiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wMSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICAgICAgfCBQT0xZIF92IC0+XG4gICAgICAgICAgICAgIF9tZW5oaXJfcnVuXzAyIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3NcbiAgICAgICAgICB8IFBBUkVOU19PUEVOIC0+XG4gICAgICAgICAgICAgIF9tZW5oaXJfcnVuXzAzIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfbWVuaGlyX3NcbiAgICAgICAgICB8IEFOWSAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wNCBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zXG4gICAgICAgICAgfCBBUlJPVyB8IENPTU1BIHwgRU9GIHwgUEFSRU5TX0NMT1NFIHwgU1RBUiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3JlZHVjZV8xMyBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zIF90b2spXG4gICAgICB8IENPTU1BIHwgRU9GIHwgUEFSRU5TX0NMT1NFIC0+XG4gICAgICAgICAgbGV0IHQgPSBfdiBpblxuICAgICAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzA4IHQgaW5cbiAgICAgICAgICBfbWVuaGlyX2dvdG9fdHlwIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX21lbmhpcl9mYWlsICgpXG4gIFxuICBhbmQgX21lbmhpcl9nb3RvX3R5cCA6IHR5cGUgIHR0dl9zdGFjay4gdHR2X3N0YWNrIC0+IF8gLT4gXyAtPiBfIC0+ICh0dHZfc3RhY2ssIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfc3RhdGUgLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rIC0+XG4gICAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgICAgfCBNZW5oaXJTdGF0ZTAwIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMjMgX21lbmhpcl9zdGFjayBfdiBfdG9rXG4gICAgICB8IE1lbmhpclN0YXRlMTkgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8xOCBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIF90b2tcbiAgICAgIHwgTWVuaGlyU3RhdGUwMyAtPlxuICAgICAgICAgIF9tZW5oaXJfcnVuXzE4IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICAgICAgfCBNZW5oaXJTdGF0ZTExIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMTYgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF90b2tcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzE4IDogdHlwZSAgdHR2X3N0YWNrLiB0dHZfc3RhY2sgLT4gXyAtPiBfIC0+IF8gLT4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZSAtPiBfIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zIF90b2sgLT5cbiAgICAgIG1hdGNoIChfdG9rIDogTWVuaGlyQmFzaWNzLnRva2VuKSB3aXRoXG4gICAgICB8IENPTU1BIC0+XG4gICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBNZW5oaXJDZWxsMV90eXAgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YpIGluXG4gICAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlMTkgaW5cbiAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgICAgICAobWF0Y2ggKF90b2sgOiBNZW5oaXJCYXNpY3MudG9rZW4pIHdpdGhcbiAgICAgICAgICB8IFdPUkQgX3YgLT5cbiAgICAgICAgICAgICAgX21lbmhpcl9ydW5fMDEgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfc1xuICAgICAgICAgIHwgUE9MWSBfdiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wMiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICAgICAgfCBQQVJFTlNfT1BFTiAtPlxuICAgICAgICAgICAgICBfbWVuaGlyX3J1bl8wMyBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zXG4gICAgICAgICAgfCBBTlkgLT5cbiAgICAgICAgICAgICAgX21lbmhpcl9ydW5fMDQgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfc1xuICAgICAgICAgIHwgQVJST1cgfCBDT01NQSB8IFBBUkVOU19DTE9TRSB8IFNUQVIgLT5cbiAgICAgICAgICAgICAgX21lbmhpcl9yZWR1Y2VfMTMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfcyBfdG9rXG4gICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIF9lUlIgKCkpXG4gICAgICB8IFBBUkVOU19DTE9TRSAtPlxuICAgICAgICAgIGxldCB4ID0gX3YgaW5cbiAgICAgICAgICBsZXQgX3YgPSBfbWVuaGlyX2FjdGlvbl8wMyB4IGluXG4gICAgICAgICAgX21lbmhpcl9nb3RvX2xpc3QxX3R5cF9DT01NQV8gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfc1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX2VSUiAoKVxuICBcbiAgYW5kIF9tZW5oaXJfZ290b19saXN0MV90eXBfQ09NTUFfIDogdHlwZSAgdHR2X3N0YWNrLiB0dHZfc3RhY2sgLT4gXyAtPiBfIC0+IF8gLT4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9zdGF0ZSAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyAtPlxuICAgICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICAgIHwgTWVuaGlyU3RhdGUwMyAtPlxuICAgICAgICAgIF9tZW5oaXJfcnVuXzIxIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdlxuICAgICAgfCBNZW5oaXJTdGF0ZTE5IC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMjAgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92XG4gICAgICB8IF8gLT5cbiAgICAgICAgICBfbWVuaGlyX2ZhaWwgKClcbiAgXG4gIGFuZCBfbWVuaGlyX3J1bl8yMSA6IHR5cGUgIHR0dl9zdGFjay4gKHR0dl9zdGFjaywgX21lbmhpcl9ib3hfbWFpbikgX21lbmhpcl9jZWxsMV9QQVJFTlNfT1BFTiAtPiBfIC0+IF8gLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IC0+XG4gICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgIGxldCBNZW5oaXJDZWxsMV9QQVJFTlNfT1BFTiAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgIGxldCB0cyA9IF92IGluXG4gICAgICBsZXQgX3YgPSBfbWVuaGlyX2FjdGlvbl8xOCB0cyBpblxuICAgICAgX21lbmhpcl9nb3RvX3R5cHMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfcyBfdG9rXG4gIFxuICBhbmQgX21lbmhpcl9ydW5fMjAgOiB0eXBlICB0dHZfc3RhY2suICh0dHZfc3RhY2ssIF9tZW5oaXJfYm94X21haW4pIF9tZW5oaXJfY2VsbDFfdHlwIC0+IF8gLT4gXyAtPiBfIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgLT5cbiAgICAgIGxldCBNZW5oaXJDZWxsMV90eXAgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgeCkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICBsZXQgeHMgPSBfdiBpblxuICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMDQgeCB4cyBpblxuICAgICAgX21lbmhpcl9nb3RvX2xpc3QxX3R5cF9DT01NQV8gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF9tZW5oaXJfc1xuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzE2IDogdHlwZSAgdHR2X3N0YWNrLiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX2NlbGwxX3R5cDIgLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF90b2sgLT5cbiAgICAgIGxldCBNZW5oaXJDZWxsMV90eXAyIChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIGEpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgbGV0IGIgPSBfdiBpblxuICAgICAgbGV0IF92ID0gX21lbmhpcl9hY3Rpb25fMDkgYSBiIGluXG4gICAgICBfbWVuaGlyX2dvdG9fdHlwIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICBcbiAgYW5kIF9tZW5oaXJfcnVuXzE1IDogdHlwZSAgdHR2X3N0YWNrLiAodHR2X3N0YWNrLCBfbWVuaGlyX2JveF9tYWluKSBfbWVuaGlyX2NlbGwxX3R5cDEgLT4gXyAtPiBfIC0+IF8gLT4gXyAtPiBfbWVuaGlyX2JveF9tYWluID1cbiAgICBmdW4gX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF92IF90b2sgLT5cbiAgICAgIGxldCBNZW5oaXJDZWxsMV90eXAxIChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIHgpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgbGV0IHhzID0gX3YgaW5cbiAgICAgIGxldCBfdiA9IF9tZW5oaXJfYWN0aW9uXzA2IHggeHMgaW5cbiAgICAgIF9tZW5oaXJfZ290b19saXN0MV90eXAxX1NUQVJfIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfdiBfbWVuaGlyX3MgX3Rva1xuICBcbiAgbGV0IF9tZW5oaXJfcnVuXzAwIDogdHlwZSAgdHR2X3N0YWNrLiB0dHZfc3RhY2sgLT4gXyAtPiBfIC0+IF9tZW5oaXJfYm94X21haW4gPVxuICAgIGZ1biBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgLT5cbiAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTAwIGluXG4gICAgICBsZXQgX3RvayA9IF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9sZXhidWYgaW5cbiAgICAgIG1hdGNoIChfdG9rIDogTWVuaGlyQmFzaWNzLnRva2VuKSB3aXRoXG4gICAgICB8IFdPUkQgX3YgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wMSBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICB8IFBPTFkgX3YgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wMiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX3YgX21lbmhpcl9zXG4gICAgICB8IFBBUkVOU19PUEVOIC0+XG4gICAgICAgICAgX21lbmhpcl9ydW5fMDMgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIF9tZW5oaXJfc1xuICAgICAgfCBBTlkgLT5cbiAgICAgICAgICBfbWVuaGlyX3J1bl8wNCBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfbGV4YnVmIF9tZW5oaXJfbGV4ZXIgX21lbmhpcl9zXG4gICAgICB8IEFSUk9XIHwgRU9GIHwgU1RBUiAtPlxuICAgICAgICAgIF9tZW5oaXJfcmVkdWNlXzEzIF9tZW5oaXJfc3RhY2sgX21lbmhpcl9sZXhidWYgX21lbmhpcl9sZXhlciBfbWVuaGlyX3MgX3Rva1xuICAgICAgfCBfIC0+XG4gICAgICAgICAgX2VSUiAoKVxuICBcbmVuZFxuXG5sZXQgbWFpbiA9XG4gIGZ1biBfbWVuaGlyX2xleGVyIF9tZW5oaXJfbGV4YnVmIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoKSBpblxuICAgIGxldCBNZW5oaXJCb3hfbWFpbiB2ID0gX21lbmhpcl9ydW5fMDAgX21lbmhpcl9zdGFjayBfbWVuaGlyX2xleGJ1ZiBfbWVuaGlyX2xleGVyIGluXG4gICAgdlxuIiwiKCogVHlwZSBleHByZXNzaW9ucyBwYXJzZXIsIHdpdGggZXJyb3IgY29ycmVjdGlvblxuICAgdG8gc3VwcG9ydCBpbmNvbXBsZXRlIC8gcGFydGlhbGx5IHdyaXR0ZW4gdXNlciBxdWVyaWVzLiAqKVxuXG4le1xuICBtb2R1bGUgUHJpbnRmID0gc3RydWN0XG4gICAgKCogV2l0aG91dCB0aGUgZm9sbG93aW5nIHBsYWNlaG9sZGVyLCBbbWVuaGlyX2ZhaWxdIGluZHVjZXNcbiAgICAgICBhIGxhcmdlIGRlcGVuZGVuY3kgdG8gW2NhbWxpbnRlcm5hbEZvcm1hdF0gaW4gdGhlIGpzIGJ1bmRsZS4gKilcbiAgICBsZXQgZXByaW50ZiBfID0gKClcbiAgZW5kXG5cbiAgb3BlbiBEYi5UeXBleHByXG4lfVxuXG4ldG9rZW4gRU9GXG4ldG9rZW4gUEFSRU5TX09QRU4gUEFSRU5TX0NMT1NFXG4ldG9rZW4gQVJST1cgQ09NTUEgQU5ZIFNUQVJcbiV0b2tlbjxzdHJpbmc+IFdPUkRcbiV0b2tlbjxzdHJpbmc+IFBPTFlcblxuJXN0YXJ0IG1haW5cbiV0eXBlPERiLlR5cGV4cHIudD4gbWFpblxuXG4lJVxuXG5tYWluOlxuICB8IHQ9dHlwIEVPRiB7IHQgfVxuICA7XG5cbnR5cDpcbiAgfCB0PXR5cDIgeyB0IH1cbiAgfCBhPXR5cDIgQVJST1cgYj10eXAgeyBBcnJvdyAoYSwgYikgfVxuICA7XG5cbnR5cDI6XG4gIHwgeHM9bGlzdDEodHlwMSwgU1RBUikgeyB0dXBsZSB4cyB9XG4gIDtcblxudHlwMTpcbiAgfCB7IEFueSB9XG4gIHwgdHM9dHlwcyB7IHR1cGxlIHRzIH1cbiAgfCB0cz10eXBzIHc9V09SRCB3cz1saXN0KFdPUkQpIHtcbiAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gYWNjIHcgLT4gQ29uc3RyICh3LCBbYWNjXSkpIChDb25zdHIgKHcsIHRzKSkgd3NcbiAgICB9XG4gIDtcblxudHlwMDpcbiAgfCBBTlkgeyBBbnkgfVxuICB8IHc9UE9MWSB7IFBvbHkgdyB9XG4gIHwgdz1XT1JEIHsgQ29uc3RyICh3LCBbXSkgfVxuICA7XG5cbnR5cHM6XG4gIHwgdD10eXAwIHsgW3RdIH1cbiAgfCBQQVJFTlNfT1BFTiB0cz1saXN0MSh0eXAsIENPTU1BKSBQQVJFTlNfQ0xPU0UgeyB0cyB9XG4gIDtcblxubGlzdDEodGVybSwgc2VwYXJhdG9yKTpcbiAgfCB4PXRlcm0geyBbeF0gfVxuICB8IHg9dGVybSBzZXBhcmF0b3IgeHM9bGlzdDEodGVybSwgc2VwYXJhdG9yKSB7IHg6OnhzIH1cbiAgO1xuIiwiIyAxIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsXCJcbiBcbiAgb3BlbiBUeXBlX3BhcnNlclxuXG4jIDYgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwyNDZcXDI1NVxcMDg0XFwwMDBcXDE5MlxcMDAwXFwyNDlcXDI1NVxcMDIwXFwwMDFcXDI1MVxcMjU1XFwyNTJcXDI1NVxcXG4gICAgXFwyNTNcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTRcXDI1NVwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmsgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA4XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDEwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwOFxcMDAwXFwwMDdcXDAwMFxcMDA0XFwwMDBcXDAwMFxcMDAwXFwwMDZcXDAwMFxcMDA5XFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDExXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwOVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAyXFwwMDBcXDI1NVxcMjU1XFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMlxcMDAwXFwyNTVcXDI1NVxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwwMDJcXDAwMFxcMDAyXFwwMDBcXDAwMlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDNcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDNcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAzXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFxcbiAgICBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcXG4gICAgXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDAzXFwwMDBcXFxuICAgIFxcMDAzXFwwMDBcXDAwM1xcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgdG9rZW4gbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3Rva2VuX3JlYyBsZXhidWYgMFxuYW5kIF9fb2NhbWxfbGV4X3Rva2VuX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDYgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgKCB0b2tlbiBsZXhidWYgKVxuIyAxNzQgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDcgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICggQVJST1cgKVxuIyAxNzkgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDggXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgKCBQQVJFTlNfT1BFTiApXG4jIDE4NCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgOSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sbFwiXG4gICAgICAoIFBBUkVOU19DTE9TRSApXG4jIDE4OSBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgMTAgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgKCBDT01NQSApXG4jIDE5NCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgMTEgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgKCBBTlkgKVxuIyAxOTkgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG5cbiAgfCA2IC0+XG4jIDEyIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsXCJcbiAgICAgICggU1RBUiApXG4jIDIwNCBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sXCJcblxuICB8IDcgLT5cbmxldFxuIyAxMyBcInNoZXJsb2RvYy9xdWVyeS90eXBlX2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcFxuIyAyMTAgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMSkgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTMgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUE9MWSBwIClcbiMgMjE0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxcIlxuXG4gIHwgOCAtPlxubGV0XG4jIDE0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdcbiMgMjIwIFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE0IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBXT1JEIHcgKVxuIyAyMjQgXCJzaGVybG9kb2MvcXVlcnkvdHlwZV9sZXhlci5tbFwiXG5cbiAgfCA5IC0+XG4jIDE1IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxsXCJcbiAgICAgICggRU9GIClcbiMgMjI5IFwic2hlcmxvZG9jL3F1ZXJ5L3R5cGVfbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF90b2tlbl9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIntcbiAgb3BlbiBUeXBlX3BhcnNlclxufVxuXG5ydWxlIHRva2VuID0gcGFyc2VcbnwgJyAnIHsgdG9rZW4gbGV4YnVmIH1cbnwgXCItXCIgfCBcIi0+XCIgeyBBUlJPVyB9ICgqIG1pbnVzIHNpZ24gaXMgaW50ZXJwcmV0ZWQgYXMgYW4gYXJyb3cgdG8gc3VwcG9ydCBwYXJ0aWFsbHkgd3JpdHRlbiBxdWVyaWVzICopXG58IFwiKFwiIHsgUEFSRU5TX09QRU4gfVxufCBcIilcIiB7IFBBUkVOU19DTE9TRSB9XG58IFwiLFwiIHsgQ09NTUEgfVxufCAnXycgeyBBTlkgfVxufCAnKicgeyBTVEFSIH1cbnwgXCInXCIgKFsnYSctJ3onICdBJy0nWicgJzAnLSc5JyAnXFwnJyAnXyddKiBhcyBwKSB7IFBPTFkgcCB9XG58IFsnYSctJ3onICdBJy0nWicgJzAnLSc5JyAnXFwnJyAnXycgJy4nXSsgYXMgdyB7IFdPUkQgdyB9XG58IGVvZiB7IEVPRiB9XG4iLCJsZXQgcmVjIHByZWZpeF9hdCB+Y2FzZSB+c3ViIGkgcyBqID1cbiAgaWYgaSA+PSBTdHJpbmcubGVuZ3RoIHN1YlxuICB0aGVuIFNvbWUgY2FzZVxuICBlbHNlIGlmIHN1Yi5baV0gPSBzLltqXVxuICB0aGVuIHByZWZpeF9hdCB+Y2FzZSB+c3ViIChpICsgMSkgcyAoaiArIDEpXG4gIGVsc2UgaWYgc3ViLltpXSA9IENoYXIubG93ZXJjYXNlX2FzY2lpIHMuW2pdXG4gIHRoZW4gcHJlZml4X2F0IH5jYXNlOihjYXNlICsgMykgfnN1YiAoaSArIDEpIHMgKGogKyAxKVxuICBlbHNlIGlmIENoYXIubG93ZXJjYXNlX2FzY2lpIHN1Yi5baV0gPSBzLltqXVxuICB0aGVuIHByZWZpeF9hdCB+Y2FzZTooY2FzZSArIDEwKSB+c3ViIChpICsgMSkgcyAoaiArIDEpXG4gIGVsc2UgTm9uZVxuXG5sZXQgcHJlZml4X2F0IH5zdWIgcyBqID0gcHJlZml4X2F0IH5jYXNlOjAgfnN1YiAwIHMgalxuXG5sZXQgZmluZF9hbGwgfnN1YiBzID1cbiAgbGV0IHJlYyBnbyBqIGFjYyA9XG4gICAgaWYgaiArIFN0cmluZy5sZW5ndGggc3ViID4gU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgYWNjID1cbiAgICAgICAgbWF0Y2ggcHJlZml4X2F0IH5zdWIgcyBqIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGFjY1xuICAgICAgICB8IFNvbWUgY29zdCAtPiAoaiwgY29zdCkgOjogYWNjXG4gICAgICBpblxuICAgICAgZ28gKGogKyAxKSBhY2NcbiAgICBlbmRcbiAgaW5cbiAgZ28gMCBbXVxuXG5sZXQgaXNfc3Vic3RyaW5nIH5zdWIgcyA9IGZpbmRfYWxsIH5zdWIgcyA8PiBbXVxuXG5sZXQgd29yZF9ib3VuZGFyeSBzIGkgPVxuICBpZiBpIDwgMFxuICB0aGVuIDBcbiAgZWxzZSBpZiBpID49IFN0cmluZy5sZW5ndGggcyB8fCBMaXN0Lm1lbSBzLltpXSBbICcuJzsgJygnOyAnKScgXVxuICB0aGVuIDFcbiAgZWxzZSBpZiBzLltpXSA9ICdfJ1xuICB0aGVuIDNcbiAgZWxzZSAxMFxuXG5sZXQgYmVzdF9tYXRjaCA/KGFmdGVyID0gMCkgfnN1YiBzdHIgPVxuICBMaXN0LmZvbGRfbGVmdFxuICAgIChmdW4gYWNjIChpLCBjYXNlX2Nvc3QpIC0+XG4gICAgICBsZXQgbGVmdCA9IHdvcmRfYm91bmRhcnkgc3RyIChpIC0gMSkgaW5cbiAgICAgIGxldCByaWdodCA9IHdvcmRfYm91bmRhcnkgc3RyIChpICsgU3RyaW5nLmxlbmd0aCBzdWIpIC8gMyBpblxuICAgICAgbGV0IGlzX2FmdGVyID0gaWYgaSA+PSBhZnRlciB0aGVuIDAgZWxzZSAxMCBpblxuICAgICAgbGV0IGNvc3QgPSBjYXNlX2Nvc3QgKyBsZWZ0ICsgcmlnaHQgKyBpc19hZnRlciBpblxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgU29tZSAoXywgY29zdCcpIHdoZW4gY29zdCcgPCBjb3N0IC0+IGFjY1xuICAgICAgfCBfIC0+IFNvbWUgKGksIGNvc3QpKVxuICAgIE5vbmVcbiAgICAoZmluZF9hbGwgfnN1YiBzdHIpXG5cbmxldCBiZXN0X21hdGNoZXMgd29yZHMgc3RyID1cbiAgbGV0IF8sIGZvdW5kLCBub3RfZm91bmQgPVxuICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAoZnVuIChpLCBmb3VuZCwgbm90X2ZvdW5kKSBzdWIgLT5cbiAgICAgICAgbWF0Y2ggYmVzdF9tYXRjaCB+YWZ0ZXI6aSB+c3ViIHN0ciB3aXRoXG4gICAgICAgIHwgU29tZSAoaSwgY29zdCkgLT4gaSArIFN0cmluZy5sZW5ndGggc3ViLCBmb3VuZCArIGNvc3QsIG5vdF9mb3VuZFxuICAgICAgICB8IE5vbmUgLT4gaSwgZm91bmQsIG5vdF9mb3VuZCArIFN0cmluZy5sZW5ndGggc3ViICsgNTApXG4gICAgICAoMCwgMCwgMClcbiAgICAgIHdvcmRzXG4gIGluXG4gIGZvdW5kICsgbm90X2ZvdW5kXG4iLCJ0eXBlIHN0ZXAgPVxuICB8IFR5cGUgb2Ygc3RyaW5nXG4gIHwgUG9seVxuICB8IEFueVxuICB8IEFycm93X2xlZnRcbiAgfCBBcnJvd19yaWdodFxuICB8IFByb2R1Y3Qgb2ZcbiAgICAgIHsgcG9zIDogaW50XG4gICAgICA7IGxlbmd0aCA6IGludFxuICAgICAgfVxuICB8IEFyZ3VtZW50IG9mXG4gICAgICB7IHBvcyA6IGludFxuICAgICAgOyBsZW5ndGggOiBpbnRcbiAgICAgIH1cblxubW9kdWxlIFNpZ24gPSBEYi5UeXBlX3BvbGFyaXR5LlNpZ25cblxudHlwZSB0ID0gc3RlcCBsaXN0IGxpc3RcblxubGV0IHJldl9jb25jYXQgbHN0ID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBhY2MgeHMgLT4gTGlzdC5yZXZfYXBwZW5kIHhzIGFjYykgW10gbHN0XG5cbmxldCByZWMgcGF0aHNfb2ZfdHlwZSB+cHJlZml4IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBEYi5UeXBleHByLlBvbHkgXyAtPiBbIFBvbHkgOjogcHJlZml4IF1cbiAgfCBBbnkgLT4gWyBBbnkgOjogcHJlZml4IF1cbiAgfCBBcnJvdyAoYSwgYikgLT5cbiAgICBsZXQgcHJlZml4X2xlZnQgPSBBcnJvd19sZWZ0IDo6IHByZWZpeCBpblxuICAgIGxldCBwcmVmaXhfcmlnaHQgPSBBcnJvd19yaWdodCA6OiBwcmVmaXggaW5cbiAgICBMaXN0LnJldl9hcHBlbmRcbiAgICAgIChwYXRoc19vZl90eXBlIH5wcmVmaXg6cHJlZml4X2xlZnQgYSlcbiAgICAgIChwYXRoc19vZl90eXBlIH5wcmVmaXg6cHJlZml4X3JpZ2h0IGIpXG4gIHwgQ29uc3RyIChuYW1lLCBhcmdzKSAtPlxuICAgIGxldCBwcmVmaXggPSBUeXBlIG5hbWUgOjogcHJlZml4IGluXG4gICAgYmVnaW5cbiAgICAgIG1hdGNoIGFyZ3Mgd2l0aFxuICAgICAgfCBbXSAtPiBbIHByZWZpeCBdXG4gICAgICB8IF8gLT5cbiAgICAgICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgICAgICAgcmV2X2NvbmNhdFxuICAgICAgICBAQCBMaXN0Lm1hcGlcbiAgICAgICAgICAgICAoZnVuIGkgYXJnIC0+XG4gICAgICAgICAgICAgICBsZXQgcHJlZml4ID0gQXJndW1lbnQgeyBwb3MgPSBpOyBsZW5ndGggfSA6OiBwcmVmaXggaW5cbiAgICAgICAgICAgICAgIHBhdGhzX29mX3R5cGUgfnByZWZpeCBhcmcpXG4gICAgICAgICAgICAgYXJnc1xuICAgIGVuZFxuICB8IFR1cGxlIGFyZ3MgLT5cbiAgICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGggYXJncyBpblxuICAgIHJldl9jb25jYXRcbiAgICBAQCBMaXN0Lm1hcGkgKGZ1biBpIGFyZyAtPlxuICAgICAgbGV0IHByZWZpeCA9IFByb2R1Y3QgeyBwb3MgPSBpOyBsZW5ndGggfSA6OiBwcmVmaXggaW5cbiAgICAgIHBhdGhzX29mX3R5cGUgfnByZWZpeCBhcmcpXG4gICAgQEAgYXJnc1xuICB8IFVuaGFuZGxlZCAtPiBbXVxuXG5sZXQgcGF0aHNfb2ZfdHlwZSB0ID0gTGlzdC5tYXAgTGlzdC5yZXYgQEAgcGF0aHNfb2ZfdHlwZSB+cHJlZml4OltdIHRcblxuKCogKilcblxubGV0IHNraXBfZW50cnkgXyA9IDEwXG5cbmxldCBkaXN0YW5jZSB4cyB5cyA9XG4gIGxldCBsZW5feHMgPSBMaXN0Lmxlbmd0aCB4cyBpblxuICBsZXQgbGVuX3lzID0gTGlzdC5sZW5ndGggeXMgaW5cbiAgbGV0IGNhY2hlID0gQXJyYXkubWFrZV9tYXRyaXggKDEgKyBsZW5feHMpICgxICsgbGVuX3lzKSAoLTEpIGluXG4gIGxldCBpbnYgPSBEYi5UeXBlX3BvbGFyaXR5LlNpZ24ubm90IGluXG4gIGxldCByZWMgbWVtbyB+eHNnbiB+eXNnbiBpIGogeHMgeXMgPVxuICAgIGxldCByID0gY2FjaGUuKGkpLihqKSBpblxuICAgIGlmIHIgPj0gMFxuICAgIHRoZW4gclxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gZ28gfnhzZ24gfnlzZ24gaSBqIHhzIHlzIGluXG4gICAgICBjYWNoZS4oaSkuKGopIDwtIHIgO1xuICAgICAgclxuICAgIGVuZFxuICBhbmQgZ28gfnhzZ24gfnlzZ24gaSBqIHhzIHlzID1cbiAgICBtYXRjaCB4cywgeXMgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IDBcbiAgICB8IFsgQW55IF0sIF8gd2hlbiB4c2duID0geXNnbiAtPiAwXG4gICAgfCBbIFBvbHkgXSwgWyAoQW55IHwgUG9seSkgXSB3aGVuIHhzZ24gPSB5c2duIC0+IDBcbiAgICB8IEFycm93X2xlZnQgOjogeHMsIEFycm93X2xlZnQgOjogeXMgLT5cbiAgICAgIG1lbW8gfnhzZ246KGludiB4c2duKSB+eXNnbjooaW52IHlzZ24pIChpICsgMSkgKGogKyAxKSB4cyB5c1xuICAgIHwgeCA6OiB4cywgeSA6OiB5cyB3aGVuIHggPSB5ICYmIHhzZ24gPSB5c2duIC0+IG1lbW8gfnhzZ24gfnlzZ24gKGkgKyAxKSAoaiArIDEpIHhzIHlzXG4gICAgfCBfLCBBcnJvd19sZWZ0IDo6IHlzIC0+IDEgKyBtZW1vIH54c2duIH55c2duOihpbnYgeXNnbikgaSAoaiArIDEpIHhzIHlzXG4gICAgfCBBcnJvd19sZWZ0IDo6IHhzLCBfIC0+IDEgKyBtZW1vIH54c2duOihpbnYgeHNnbikgfnlzZ24gKGkgKyAxKSBqIHhzIHlzXG4gICAgfCBfLCBBcnJvd19yaWdodCA6OiB5cyAtPiBtZW1vIH54c2duIH55c2duIGkgKGogKyAxKSB4cyB5c1xuICAgIHwgQXJyb3dfcmlnaHQgOjogeHMsIF8gLT4gbWVtbyB+eHNnbiB+eXNnbiAoaSArIDEpIGogeHMgeXNcbiAgICB8IF8sIFtdIC0+IDEwXzAwMFxuICAgIHwgUHJvZHVjdCBfIDo6IHhzLCBQcm9kdWN0IF8gOjogeXMgLT4gMSArIG1lbW8gfnhzZ24gfnlzZ24gKGkgKyAxKSAoaiArIDEpIHhzIHlzXG4gICAgfCBBcmd1bWVudCBfIDo6IHhzLCBBcmd1bWVudCBfIDo6IHlzIC0+IDEgKyBtZW1vIH54c2duIH55c2duIChpICsgMSkgKGogKyAxKSB4cyB5c1xuICAgIHwgUHJvZHVjdCBfIDo6IHhzLCB5cyAtPiAxICsgbWVtbyB+eHNnbiB+eXNnbiAoaSArIDEpIGogeHMgeXNcbiAgICB8IHhzLCBQcm9kdWN0IF8gOjogeXMgLT4gMSArIG1lbW8gfnhzZ24gfnlzZ24gaSAoaiArIDEpIHhzIHlzXG4gICAgfCBUeXBlIHggOjogeHMnLCBUeXBlIHkgOjogeXMnIHdoZW4geHNnbiA9IHlzZ24gLT4gYmVnaW5cbiAgICAgIGxldCBza2lwX3kgPSBza2lwX2VudHJ5IHkgaW5cbiAgICAgIG1hdGNoIE5hbWVfY29zdC5iZXN0X21hdGNoIH5zdWI6eCB5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBza2lwX3kgKyBtZW1vIH54c2duIH55c2duIGkgKGogKyAxKSB4cyB5cydcbiAgICAgIHwgU29tZSAoXywgY29zdCkgLT4gKGNvc3QgLyAzKSArIG1lbW8gfnhzZ24gfnlzZ24gKGkgKyAxKSAoaiArIDEpIHhzJyB5cydcbiAgICBlbmRcbiAgICB8IHhzLCBUeXBlIHkgOjogeXMnIC0+IHNraXBfZW50cnkgeSArIG1lbW8gfnhzZ24gfnlzZ24gaSAoaiArIDEpIHhzIHlzJ1xuICAgIHwgeHMsIEFyZ3VtZW50IF8gOjogeXMnIC0+IG1lbW8gfnhzZ24gfnlzZ24gaSAoaiArIDEpIHhzIHlzJ1xuICAgIHwgXywgKEFueSB8IFBvbHkpIDo6IF8gLT4gMTBfMDAwXG4gIGluXG4gIGxldCBwb3MgPSBEYi5UeXBlX3BvbGFyaXR5LlNpZ24uUG9zIGluXG4gIGdvIH54c2duOnBvcyB+eXNnbjpwb3MgMCAwIHhzIHlzXG5cbmxldCBtaW5pbWl6ZSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gMFxuICB8IGFyciAtPlxuICAgIGxldCB1c2VkID0gQXJyYXkubWFrZSAoTGlzdC5sZW5ndGggKExpc3QuaGQgYXJyKSkgZmFsc2UgaW5cbiAgICBsZXQgYXJyID1cbiAgICAgIEFycmF5Lm1hcCAoZnVuIGxzdCAtPlxuICAgICAgICBsZXQgbHN0ID0gTGlzdC5tYXBpIChmdW4gaSB4IC0+IHgsIGkpIGxzdCBpblxuICAgICAgICBMaXN0LnNvcnQgU3RkbGliLmNvbXBhcmUgbHN0KVxuICAgICAgQEAgQXJyYXkub2ZfbGlzdCBhcnJcbiAgICBpblxuICAgIEFycmF5LnNvcnQgKGZ1biB4cyB5cyAtPiBTdGRsaWIuY29tcGFyZSB4cyB5cykgYXJyIDtcbiAgICBsZXQgaGV1cmlzdGljcyA9IEFycmF5Lm1ha2UgKEFycmF5Lmxlbmd0aCBhcnIgKyAxKSAwIGluXG4gICAgZm9yIGkgPSBBcnJheS5sZW5ndGggaGV1cmlzdGljcyAtIDIgZG93bnRvIDAgZG9cbiAgICAgIGxldCBiZXN0ID0gZnN0IChMaXN0LmhkIGFyci4oaSkpIGluXG4gICAgICBoZXVyaXN0aWNzLihpKSA8LSBoZXVyaXN0aWNzLihpICsgMSkgKyBiZXN0XG4gICAgZG9uZSA7XG4gICAgbGV0IGJlc3QgPSByZWYgMTAwMCBpblxuICAgIGxldCBsaW1pdCA9IHJlZiAwIGluXG4gICAgbGV0IHJlYyBnbyByZW0gYWNjIGkgPVxuICAgICAgaW5jciBsaW1pdCA7XG4gICAgICBpZiAhbGltaXQgPiAxMF8wMDBcbiAgICAgIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgcmVtIDw9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgKCogZW50cnkgdHlwZSBpcyBzbWFsbGVyIHRoYW4gcXVlcnkgdHlwZSAqKVxuICAgICAgICBsZXQgc2NvcmUgPSBhY2MgKyAoMTAwMCAqIChBcnJheS5sZW5ndGggYXJyIC0gaSkpIGluXG4gICAgICAgIGJlc3QgOj0gbWluIHNjb3JlICFiZXN0IDtcbiAgICAgICAgdHJ1ZVxuICAgICAgZW5kXG4gICAgICBlbHNlIGlmIGkgPj0gQXJyYXkubGVuZ3RoIGFyclxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICAoKiBxdWVyeSB0eXBlIGlzIHNtYWxsZXIgdGhhbiBlbnRyeSB0eXBlICopXG4gICAgICAgIGxldCBzY29yZSA9IGFjYyArICg1ICogcmVtKSBpblxuICAgICAgICBiZXN0IDo9IG1pbiBzY29yZSAhYmVzdCA7XG4gICAgICAgIHRydWVcbiAgICAgIGVuZFxuICAgICAgZWxzZSBpZiBhY2MgKyBoZXVyaXN0aWNzLihpKSA+PSAhYmVzdFxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgfCBbXSAtPiB0cnVlXG4gICAgICAgICAgfCAoY29zdCwgaikgOjogcmVzdCAtPlxuICAgICAgICAgICAgbGV0IGNvbnRpbnVlID1cbiAgICAgICAgICAgICAgaWYgdXNlZC4oailcbiAgICAgICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgICB1c2VkLihqKSA8LSB0cnVlIDtcbiAgICAgICAgICAgICAgICBsZXQgY29udGludWUgPSBnbyAocmVtIC0gMSkgKGFjYyArIGNvc3QpIChpICsgMSkgaW5cbiAgICAgICAgICAgICAgICB1c2VkLihqKSA8LSBmYWxzZSA7XG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgY29udGludWUgdGhlbiBmaW5kIHJlc3QgZWxzZSBmYWxzZVxuICAgICAgICBpblxuICAgICAgICBmaW5kIGFyci4oaSlcbiAgICAgIGVuZFxuICAgIGluXG4gICAgbGV0IF8gPSBnbyAoQXJyYXkubGVuZ3RoIHVzZWQpIDAgMCBpblxuICAgICFiZXN0XG5cbmxldCB2IH5xdWVyeV9wYXRocyB+ZW50cnkgPVxuICBsZXQgZW50cnlfcGF0aHMgPSBwYXRoc19vZl90eXBlIGVudHJ5IGluXG4gIG1hdGNoIGVudHJ5X3BhdGhzLCBxdWVyeV9wYXRocyB3aXRoXG4gIHwgXywgW10gfCBbXSwgXyAtPiAwXG4gIHwgXyAtPlxuICAgIGxldCBhcnIgPSBMaXN0Lm1hcCAoZnVuIHAgLT4gTGlzdC5tYXAgKGRpc3RhbmNlIHApIGVudHJ5X3BhdGhzKSBxdWVyeV9wYXRocyBpblxuICAgIG1pbmltaXplIGFyclxuIiwibGV0IGJhbGFuY2VfcGFyZW5zIHN0ciA9XG4gIGxldCByZWMgZ28gaSBvcGVuX3BhcmVucyBjbG9zZV9wYXJlbnMgPVxuICAgIGlmIGkgPj0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICB0aGVuIG9wZW5fcGFyZW5zLCBjbG9zZV9wYXJlbnNcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgfCAnKCcgLT4gZ28gKGkgKyAxKSAob3Blbl9wYXJlbnMgKyAxKSBjbG9zZV9wYXJlbnNcbiAgICAgIHwgJyknIHdoZW4gb3Blbl9wYXJlbnMgPiAwIC0+IGdvIChpICsgMSkgKG9wZW5fcGFyZW5zIC0gMSkgY2xvc2VfcGFyZW5zXG4gICAgICB8ICcpJyAtPiBnbyAoaSArIDEpIG9wZW5fcGFyZW5zIChjbG9zZV9wYXJlbnMgKyAxKVxuICAgICAgfCBfIC0+IGdvIChpICsgMSkgb3Blbl9wYXJlbnMgY2xvc2VfcGFyZW5zKVxuICBpblxuICBsZXQgb3Blbl9wYXJlbnMsIGNsb3NlX3BhcmVucyA9IGdvIDAgMCAwIGluXG4gIFN0cmluZy5tYWtlIGNsb3NlX3BhcmVucyAnKCcgXiBzdHIgXiBTdHJpbmcubWFrZSBvcGVuX3BhcmVucyAnKSdcblxubGV0IHR5cGVfb2Zfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBiYWxhbmNlX3BhcmVucyBzdHIgaW5cbiAgbGV0IGxleGJ1ZiA9IExleGluZy5mcm9tX3N0cmluZyBzdHIgaW5cbiAgdHJ5IGB0eXAgKFR5cGVfcGFyc2VyLm1haW4gVHlwZV9sZXhlci50b2tlbiBsZXhidWYpIHdpdGhcbiAgfCBfIC0+IGBwYXJzZV9lcnJvclxuXG5sZXQgbmFpdmVfb2Zfc3RyaW5nIHN0ciA9XG4gIExpc3QuZmlsdGVyIChmdW4gcyAtPiBTdHJpbmcubGVuZ3RoIHMgPiAwKSAoU3RyaW5nLnNwbGl0X29uX2NoYXIgJyAnIHN0cilcblxubGV0IGd1ZXNzX3R5cGVfc2VhcmNoIHN0ciA9XG4gIFN0cmluZy5sZW5ndGggc3RyID49IDFcbiAgJiYgKHN0ci5bMF0gPSAnXFwnJyB8fCBTdHJpbmcuY29udGFpbnMgc3RyICctJyB8fCBTdHJpbmcuY29udGFpbnMgc3RyICcoJylcblxudHlwZSB0ID1cbiAgeyBuYW1lIDogc3RyaW5nIGxpc3RcbiAgOyB0eXAgOiBbIGB0eXAgb2YgRGIuVHlwZXhwci50IHwgYG5vX3R5cCB8IGBwYXJzZV9lcnJvciBdXG4gIH1cblxubGV0IG9mX3N0cmluZyBzdHIgPVxuICBsZXQgcXVlcnlfbmFtZSwgdHlwID1cbiAgICBtYXRjaCBTdHJpbmcuaW5kZXhfb3B0IHN0ciAnOicgd2l0aFxuICAgIHwgTm9uZSAtPiBpZiBndWVzc190eXBlX3NlYXJjaCBzdHIgdGhlbiBcIlwiLCB0eXBlX29mX3N0cmluZyBzdHIgZWxzZSBzdHIsIGBub190eXBcbiAgICB8IFNvbWUgbG9jIC0+XG4gICAgICBsZXQgc3RyX25hbWUgPSBTdHJpbmcuc3ViIHN0ciAwIGxvYyBpblxuICAgICAgbGV0IHN0cl90eXAgPSBTdHJpbmcuc3ViIHN0ciAobG9jICsgMSkgKFN0cmluZy5sZW5ndGggc3RyIC0gbG9jIC0gMSkgaW5cbiAgICAgIHN0cl9uYW1lLCB0eXBlX29mX3N0cmluZyBzdHJfdHlwXG4gIGluXG4gIGxldCBuYW1lID0gbmFpdmVfb2Zfc3RyaW5nIHF1ZXJ5X25hbWUgaW5cbiAgeyBuYW1lOyB0eXAgfVxuXG5sZXQgdG9fc3RyaW5nIHsgbmFtZTsgdHlwIH0gPVxuICBsZXQgd29yZHMgPSBTdHJpbmcuY29uY2F0IFwiIFwiIG5hbWUgaW5cbiAgbWF0Y2ggdHlwIHdpdGhcbiAgfCBgdHlwIHR5cCAtPiB3b3JkcyBeIFwiIDogXCIgXiBEYi5UeXBleHByLnNob3cgdHlwXG4gIHwgYHBhcnNlX2Vycm9yIC0+IHdvcmRzIF4gXCIgOiA8cGFyc2luZyBlcnJvcj5cIlxuICB8IGBub190eXAgLT4gd29yZHNcbiIsIm1vZHVsZSBFbnRyeSA9IERiLkVudHJ5XG5cbnR5cGUgcXVlcnkgPVxuICB7IG5hbWUgOiBzdHJpbmcgbGlzdFxuICA7IHR5cGVfcGF0aHMgOiBUeXBlX2Rpc3RhbmNlLnQgb3B0aW9uXG4gIH1cblxubGV0IG9mX3F1ZXJ5IHsgUXVlcnlfcGFyc2VyLm5hbWU7IHR5cCB9ID1cbiAgbGV0IHR5cGVfcGF0aHMgPVxuICAgIG1hdGNoIHR5cCB3aXRoXG4gICAgfCBgdHlwIHQgLT4gU29tZSAoVHlwZV9kaXN0YW5jZS5wYXRoc19vZl90eXBlIHQpXG4gICAgfCBfIC0+IE5vbmVcbiAgaW5cbiAgeyBuYW1lOyB0eXBlX3BhdGhzIH1cblxubGV0IHR5cGVfZGlzdGFuY2UgcXVlcnlfdHlwZSBlbnRyeSA9XG4gIG1hdGNoIHF1ZXJ5X3R5cGUsIEVudHJ5LktpbmQuZ2V0X3R5cGUgZW50cnkuRW50cnkua2luZCB3aXRoXG4gIHwgU29tZSBxdWVyeV9wYXRocywgU29tZSBlbnRyeV90eXBlIC0+XG4gICAgU29tZSAoVHlwZV9kaXN0YW5jZS52IH5xdWVyeV9wYXRocyB+ZW50cnk6ZW50cnlfdHlwZSlcbiAgfCBTb21lIF8sIE5vbmUgLT4gU29tZSAxMDAwXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzY29yZSBxdWVyeSBlbnRyeSA9XG4gIGxldCBuYW1lX21hdGNoZXMgPSBOYW1lX2Nvc3QuYmVzdF9tYXRjaGVzIHF1ZXJ5Lm5hbWUgZW50cnkuRGIuRW50cnkubmFtZSBpblxuICBsZXQgdHlwZV9jb3N0ID1cbiAgICBtYXRjaCB0eXBlX2Rpc3RhbmNlIHF1ZXJ5LnR5cGVfcGF0aHMgZW50cnkgd2l0aFxuICAgIHwgU29tZSBjb3N0IC0+IGNvc3RcbiAgICB8IE5vbmUgLT4gMFxuICBpblxuICA1ICogKG5hbWVfbWF0Y2hlcyArIHR5cGVfY29zdClcbiIsIm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgKCogYXZvaWRzIGEgZGVwZW5kZW5jeSBvbiBsd3QgZm9yIHNoZXJsb2RvYy5qcyAqKVxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gIHZhbCBtYXAgOiAnYSB0IC0+ICgnYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcbmVuZFxuXG5tb2R1bGUgU2VxIChJbyA6IFMpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZSBJby50XG5cbiAgYW5kICdhIG5vZGUgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mICdhICogJ2EgdFxuXG4gIGxldCByZWMgb2Zfc2VxIHMgKCkgPVxuICAgIG1hdGNoIHMgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiBJby5yZXR1cm4gTmlsXG4gICAgfCBDb25zICh4LCB4cykgLT4gSW8ucmV0dXJuIChDb25zICh4LCBvZl9zZXEgeHMpKVxuXG4gIGxldCByZWMgdGFrZSBuIHhzICgpID1cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gSW8ucmV0dXJuIE5pbFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIElvLm1hcCAoeHMgKCkpXG4gICAgICBAQCBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gTmlsXG4gICAgICB8IENvbnMgKHgsIHhzKSAtPiBDb25zICh4LCB0YWtlIChuIC0gMSkgeHMpXG4gICAgZW5kXG5cbiAgbGV0IHJlYyB0b19saXN0IGFjYyBzID1cbiAgICBJby5iaW5kIChzICgpKVxuICAgIEBAIGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gSW8ucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgfCBDb25zICh4LCB4cykgLT4gdG9fbGlzdCAoeCA6OiBhY2MpIHhzXG5cbiAgbGV0IHRvX2xpc3QgcyA9IHRvX2xpc3QgW10gc1xuZW5kXG4iLCJtb2R1bGUgQmVzdHMgPSBTZXQuTWFrZSAoRGIuRW50cnkpXG5cbnR5cGUgdCA9XG4gIHsgc2l6ZSA6IGludFxuICA7IGJlc3RzIDogQmVzdHMudFxuICB9XG5cbmxldCBlbXB0eSA9IHsgc2l6ZSA9IDA7IGJlc3RzID0gQmVzdHMuZW1wdHkgfVxuXG50eXBlIHN0ZXAgPVxuICB8IENvbnRpbnVlIG9mIHRcbiAgfCBTdG9wIG9mIHRcblxubGV0IHVwZGF0ZV9lbnRyeSBxdWVyeSBlbnRyeSA9XG4gIGxldCBleHRyYV9jb3N0ID0gRHluYW1pY19jb3N0LnNjb3JlIHF1ZXJ5IGVudHJ5IGluXG4gIERiLkVudHJ5LnsgZW50cnkgd2l0aCBjb3N0ID0gZW50cnkuY29zdCArIGV4dHJhX2Nvc3QgfVxuXG5sZXQgYWRkIH5xdWVyeSB+bGltaXQgZWx0IHQgPVxuICBpZiB0LnNpemUgPCBsaW1pdFxuICB0aGVuIGJlZ2luXG4gICAgbGV0IGVsdCA9IHVwZGF0ZV9lbnRyeSBxdWVyeSBlbHQgaW5cbiAgICBDb250aW51ZSB7IHNpemUgPSB0LnNpemUgKyAxOyBiZXN0cyA9IEJlc3RzLmFkZCBlbHQgdC5iZXN0cyB9XG4gIGVuZFxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHdvcnN0ID0gQmVzdHMubWF4X2VsdCB0LmJlc3RzIGluXG4gICAgaWYgRGIuRW50cnkuKGVsdC5jb3N0ID4gd29yc3QuY29zdClcbiAgICB0aGVuIFN0b3AgdFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBlbHQgPSB1cGRhdGVfZW50cnkgcXVlcnkgZWx0IGluXG4gICAgICBpZiBEYi5FbnRyeS4oZWx0LmNvc3QgPiB3b3JzdC5jb3N0KVxuICAgICAgdGhlbiBDb250aW51ZSB0XG4gICAgICBlbHNlIENvbnRpbnVlIHsgdCB3aXRoIGJlc3RzID0gQmVzdHMuYWRkIGVsdCBAQCBCZXN0cy5yZW1vdmUgd29yc3QgdC5iZXN0cyB9XG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgbWF4X3NlZWsgPSAxMFxuXG5tb2R1bGUgTWFrZSAoSU8gOiBJby5TKSA9IHN0cnVjdFxuICBtb2R1bGUgU2VxID0gSW8uU2VxIChJTylcblxuICBsZXQgb2Zfc2VxIH5xdWVyeSB+bGltaXQgc2VxID1cbiAgICBsZXQgcmVjIGdvIHRvdGFsX3NlZW4gdCBzZXEgPVxuICAgICAgaWYgdG90YWxfc2VlbiA+PSBsaW1pdCArIG1heF9zZWVrXG4gICAgICB0aGVuIElPLnJldHVybiB0XG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIElPLmJpbmQgKHNlcSAoKSlcbiAgICAgICAgQEAgZnVuY3Rpb25cbiAgICAgICAgfCBTZXEuTmlsIC0+IElPLnJldHVybiB0XG4gICAgICAgIHwgQ29ucyAoeCwgeHMpIC0+IGJlZ2luXG4gICAgICAgICAgbWF0Y2ggYWRkIH5xdWVyeSB+bGltaXQgeCB0IHdpdGhcbiAgICAgICAgICB8IFN0b3AgdCAtPiBJTy5yZXR1cm4gdFxuICAgICAgICAgIHwgQ29udGludWUgdCAtPiBnbyAodG90YWxfc2VlbiArIDEpIHQgeHNcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBpblxuICAgIElPLm1hcCAoZ28gMCBlbXB0eSBzZXEpIEBAIGZ1biB0IC0+IExpc3Qub2Zfc2VxIEBAIEJlc3RzLnRvX3NlcSB0LmJlc3RzXG5lbmRcbiIsIm1vZHVsZSBTdHJpbmdfYXV0b21hdGEgPSBEYi5TdHJpbmdfYXV0b21hdGFcbm1vZHVsZSBFbnRyeSA9IERiLkVudHJ5XG5cbnR5cGUgZWx0ID0gRW50cnkudFxuXG50eXBlIHQgPVxuICB8IEVtcHR5XG4gIHwgQXJyYXkgb2YgaW50ICogZWx0IGFycmF5XG4gIHwgQWxsIG9mIGVsdCAqIFN0cmluZ19hdXRvbWF0YS50XG4gIHwgVW5pb24gb2YgZWx0ICogdCBsaXN0XG5cbmxldCByZWMgc2l6ZSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IEFycmF5IChpLCBhcnIpIC0+IEFycmF5Lmxlbmd0aCBhcnIgLSBpXG4gIHwgQWxsIChfLCBzKSAtPiBTdHJpbmdfYXV0b21hdGEuc2l6ZSBzXG4gIHwgVW5pb24gKF8sIHhzKSAtPiBMaXN0LmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IGFjYyArIHNpemUgeCkgMCB4c1xuXG5sZXQgbWluaW11bSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IEFycmF5IChpLCBhcnIpIC0+IFNvbWUgYXJyLihpKVxuICB8IEFsbCAoZWx0LCBfKSB8IFVuaW9uIChlbHQsIF8pIC0+IFNvbWUgZWx0XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgYXJyID0gQXJyYXkgKDAsIGFycilcblxubGV0IG9mX2F1dG9tYXRhIHMgPVxuICBsZXQgZWx0ID0gU3RyaW5nX2F1dG9tYXRhLm1pbmltdW0gcyBpblxuICBBbGwgKGVsdCwgcylcblxubGV0IG9mX2xpc3QgbHN0ID1cbiAgbGV0IGxzdCA9IExpc3QuZmlsdGVyICgoIDw+ICkgRW1wdHkpIGxzdCBpblxuICBsZXQgbWluIHggPVxuICAgIG1hdGNoIG1pbmltdW0geCB3aXRoXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgU29tZSBlbHQgLT4gZWx0XG4gIGluXG4gIGxldCBjb21wYXJlIGEgYiA9IEVudHJ5LmNvbXBhcmUgKG1pbiBhKSAobWluIGIpIGluXG4gIG1hdGNoIExpc3Quc29ydCBjb21wYXJlIGxzdCB3aXRoXG4gIHwgW10gLT4gRW1wdHlcbiAgfCBoZCA6OiBfIGFzIGxzdCAtPiBVbmlvbiAobWluIGhkLCBsc3QpXG5cbmxldCBpbnNlcnRfc29ydCB4IGxzdCA9XG4gIG1hdGNoIG1pbmltdW0geCB3aXRoXG4gIHwgTm9uZSAtPiBsc3RcbiAgfCBTb21lIG1pbl9lbHQgLT5cbiAgICBsZXQgcmVjIGluc2VydCBsc3QgPVxuICAgICAgbWF0Y2ggbHN0IHdpdGhcbiAgICAgIHwgW10gLT4gWyB4IF1cbiAgICAgIHwgeSA6OiB5cyAtPiBiZWdpblxuICAgICAgICBtYXRjaCBtaW5pbXVtIHkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gaW5zZXJ0IHlzXG4gICAgICAgIHwgU29tZSBtaW5feSB3aGVuIEVudHJ5LmNvbXBhcmUgbWluX2VsdCBtaW5feSA8PSAwIC0+IHggOjogbHN0XG4gICAgICAgIHwgXyAtPiB5IDo6IGluc2VydCB5c1xuICAgICAgZW5kXG4gICAgaW5cbiAgICBpbnNlcnQgbHN0XG5cbmxldCB1bmlvbl93aXRoIH5taW5fZWx0IGxzdCA9XG4gIG1hdGNoIExpc3QuZmlsdGVyICgoIDw+ICkgRW1wdHkpIGxzdCB3aXRoXG4gIHwgW10gLT4gRW1wdHlcbiAgfCBbIHQgXSAtPiB0XG4gIHwgc29ydGVkX2xzdCAtPiBVbmlvbiAobWluX2VsdCwgc29ydGVkX2xzdClcblxubGV0IHJlYyB1bmlvbl9zb3J0ZWQgbHN0ID1cbiAgbWF0Y2ggbHN0IHdpdGhcbiAgfCBbXSAtPiBFbXB0eVxuICB8IFsgdCBdIC0+IHRcbiAgfCB4IDo6IHhzIC0+IGJlZ2luXG4gICAgbWF0Y2ggbWluaW11bSB4IHdpdGhcbiAgICB8IE5vbmUgLT4gdW5pb25fc29ydGVkIHhzXG4gICAgfCBTb21lIG1pbl9lbHQgLT4gVW5pb24gKG1pbl9lbHQsIGxzdClcbiAgZW5kXG5cbmxldCBleHBhbmRfYXV0b21hdGEgfm1pbl9lbHQgKHsgU3RyaW5nX2F1dG9tYXRhLnQ7IF8gfSBhcyBhdXRvbWF0YSkgPVxuICBtYXRjaCB0LnRlcm1pbmFscyB3aXRoXG4gIHwgU3RyaW5nX2F1dG9tYXRhLlN1bW1hcnkgYXJyIC0+IEFycmF5ICgwLCBhcnIpXG4gIHwgdGVybWluYWxzIC0+XG4gICAgbGV0IHRlcm1pbmFscyA9XG4gICAgICBtYXRjaCB0ZXJtaW5hbHMgd2l0aFxuICAgICAgfCBTdHJpbmdfYXV0b21hdGEuRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgVGVybWluYWxzIHRlcm1pbmFscyAtPiBBcnJheSAoMCwgdGVybWluYWxzKVxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGluXG4gICAgbGV0IGxpZnQgY2hpbGQgPSBvZl9hdXRvbWF0YSB7IGF1dG9tYXRhIHdpdGggU3RyaW5nX2F1dG9tYXRhLnQgPSBjaGlsZCB9IGluXG4gICAgbGV0IGNoaWxkcmVuID1cbiAgICAgIEFycmF5LnRvX2xpc3QgQEAgQXJyYXkubWFwIGxpZnQgQEAgT3B0aW9uLnZhbHVlIH5kZWZhdWx0Olt8fF0gdC5jaGlsZHJlblxuICAgIGluXG4gICAgbGV0IGFsbCA9IGluc2VydF9zb3J0IHRlcm1pbmFscyBjaGlsZHJlbiBpblxuICAgIHVuaW9uX3dpdGggfm1pbl9lbHQgYWxsXG5cbmxldCByZWMgcG9wX3VudGlsIGNvbmQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQXJyYXkgKGksIGFycikgYXMgdCAtPlxuICAgIGxldCByZWMgc2VhcmNoIGkgaiA9XG4gICAgICBhc3NlcnQgKG5vdCAoY29uZCBhcnIuKGkpKSkgO1xuICAgICAgYXNzZXJ0IChjb25kIGFyci4oaikpIDtcbiAgICAgIGxldCBtID0gKGkgKyBqKSAvIDIgaW5cbiAgICAgIGlmIGkgPSBtIHRoZW4gQXJyYXkgKGosIGFycikgZWxzZSBpZiBjb25kIGFyci4obSkgdGhlbiBzZWFyY2ggaSBtIGVsc2Ugc2VhcmNoIG0galxuICAgIGluXG4gICAgbGV0IHJlYyBzZWFyY2hfZnJvbSBqIHN0ZXAgPVxuICAgICAgaWYgaiA+PSBBcnJheS5sZW5ndGggYXJyXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBsYXN0ID0gQXJyYXkubGVuZ3RoIGFyciAtIDEgaW5cbiAgICAgICAgbGV0IGpfcHJldiA9IGogLSAoc3RlcCAvIDIpIGluXG4gICAgICAgIGlmIGNvbmQgYXJyLihsYXN0KSB0aGVuIHNlYXJjaCBqX3ByZXYgbGFzdCBlbHNlIEVtcHR5XG4gICAgICBlbmRcbiAgICAgIGVsc2UgaWYgY29uZCBhcnIuKGopXG4gICAgICB0aGVuIGlmIGkgPSBqIHRoZW4gdCBlbHNlIHNlYXJjaCAoaiAtIChzdGVwIC8gMikpIGpcbiAgICAgIGVsc2Ugc2VhcmNoX2Zyb20gKGogKyBzdGVwKSAoc3RlcCAqIDIpXG4gICAgaW5cbiAgICBzZWFyY2hfZnJvbSBpIDFcbiAgfCBBbGwgKG1pbl9lbHQsIF8pIGFzIHQgd2hlbiBjb25kIG1pbl9lbHQgLT4gdFxuICB8IEFsbCAobWluX2VsdCwgYXV0b21hdGEpIC0+IHBvcF91bnRpbCBjb25kIChleHBhbmRfYXV0b21hdGEgfm1pbl9lbHQgYXV0b21hdGEpXG4gIHwgVW5pb24gKG1pbl9lbHQsIF8pIGFzIHQgd2hlbiBjb25kIG1pbl9lbHQgLT4gdFxuICB8IFVuaW9uIChfLCBsc3QpIC0+XG4gICAgbGV0IHJlYyBwb3BfdW5pb24gaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IHggOjogeHMgLT5cbiAgICAgICAgbGV0IHgnID0gcG9wX3VudGlsIGNvbmQgeCBpblxuICAgICAgICBpZiB4ID09IHgnXG4gICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICBhc3NlcnQgKGkgPiAwKSA7XG4gICAgICAgICAgeCA6OiB4c1xuICAgICAgICBlbmRcbiAgICAgICAgZWxzZSBpbnNlcnRfc29ydCB4JyAocG9wX3VuaW9uIChpICsgMSkgeHMpXG4gICAgaW5cbiAgICBsZXQgbHN0ID0gcG9wX3VuaW9uIDAgbHN0IGluXG4gICAgdW5pb25fc29ydGVkIGxzdFxuXG5sZXQgcG9wX2x0IGVsdCB0ID1cbiAgbGV0IGNtcF9sdCB4ID0gRW50cnkuY29tcGFyZSB4IGVsdCA+PSAwIGluXG4gIHBvcF91bnRpbCBjbXBfbHQgdFxuXG5sZXQgcG9wX2x0ZSBlbHQgdCA9XG4gIGxldCBjbXBfbHRlIHggPSBFbnRyeS5jb21wYXJlIHggZWx0ID4gMCBpblxuICBwb3BfdW50aWwgY21wX2x0ZSB0XG4iLCJtb2R1bGUgRW50cnkgPSBEYi5FbnRyeVxuXG50eXBlIGVsdCA9IEVudHJ5LnRcblxudHlwZSBzID1cbiAgfCBFbXB0eVxuICB8IEFsbFxuICB8IFBxIG9mIFByaW9yaXR5X3F1ZXVlLnRcbiAgfCBJbnRlciBvZiBzICogc1xuICB8IFVuaW9uIG9mIHMgKiBzXG5cbnR5cGUgdCA9XG4gIHsgcyA6IHNcbiAgOyBzaXplIDogaW50XG4gIH1cblxubGV0IGFsbCA9IHsgcyA9IEFsbDsgc2l6ZSA9IDAgfVxubGV0IGVtcHR5ID0geyBzID0gRW1wdHk7IHNpemUgPSAwIH1cbmxldCBtYWtlX3BxIHQgPSB7IHMgPSBQcSB0OyBzaXplID0gUHJpb3JpdHlfcXVldWUuc2l6ZSB0IH1cbmxldCBvZl9hdXRvbWF0YSB0ID0gbWFrZV9wcSAoUHJpb3JpdHlfcXVldWUub2ZfYXV0b21hdGEgdClcbmxldCBvZl9hdXRvbWF0YXMgdHMgPSBtYWtlX3BxIFByaW9yaXR5X3F1ZXVlLihvZl9saXN0IChMaXN0Lm1hcCBvZl9hdXRvbWF0YSB0cykpXG5sZXQgb2ZfYXJyYXkgYXJyID0gbWFrZV9wcSAoUHJpb3JpdHlfcXVldWUub2Zfc29ydGVkX2FycmF5IGFycilcblxubGV0IGludGVyIGEgYiA9XG4gIG1hdGNoIGEucywgYi5zIHdpdGhcbiAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IGVtcHR5XG4gIHwgXywgQWxsIC0+IGFcbiAgfCBBbGwsIF8gLT4gYlxuICB8IHgsIHkgd2hlbiB4ID09IHkgLT4gYVxuICB8IHgsIHkgLT5cbiAgICBsZXQgcyA9IGlmIGEuc2l6ZSA8PSBiLnNpemUgdGhlbiBJbnRlciAoeCwgeSkgZWxzZSBJbnRlciAoeSwgeCkgaW5cbiAgICB7IHM7IHNpemUgPSBtaW4gYS5zaXplIGIuc2l6ZSB9XG5cbmxldCB1bmlvbiBhIGIgPVxuICBtYXRjaCBhLnMsIGIucyB3aXRoXG4gIHwgQWxsLCBfIHwgXywgQWxsIC0+IGFsbFxuICB8IF8sIEVtcHR5IC0+IGFcbiAgfCBFbXB0eSwgXyAtPiBiXG4gIHwgeCwgeSB3aGVuIHggPT0geSAtPiBhXG4gIHwgeCwgeSAtPlxuICAgIGxldCBzID0gaWYgYS5zaXplID49IGIuc2l6ZSB0aGVuIFVuaW9uICh4LCB5KSBlbHNlIFVuaW9uICh5LCB4KSBpblxuICAgIHsgczsgc2l6ZSA9IGEuc2l6ZSArIGIuc2l6ZSB9XG5cbmxldCByZWMgam9pbl93aXRoIGZuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IFsgeCBdIC0+IFsgeCBdXG4gIHwgYSA6OiBiIDo6IHhzIC0+IGZuIGEgYiA6OiBqb2luX3dpdGggZm4geHNcblxubGV0IHJlYyBwZXJmZWN0IH5kZWZhdWx0IGZuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBkZWZhdWx0XG4gIHwgWyB4IF0gLT4geFxuICB8IHhzIC0+IHBlcmZlY3QgfmRlZmF1bHQgZm4gKGpvaW5fd2l0aCBmbiB4cylcblxubGV0IGludGVyX29mX2xpc3QgeHMgPVxuICBsZXQgeHMgPSBMaXN0LnNvcnQgKGZ1biBhIGIgLT4gSW50LmNvbXBhcmUgYS5zaXplIGIuc2l6ZSkgeHMgaW5cbiAgcGVyZmVjdCB+ZGVmYXVsdDphbGwgaW50ZXIgeHNcblxubGV0IHVuaW9uX29mX2xpc3QgeHMgPVxuICBsZXQgeHMgPSBMaXN0LnNvcnQgKGZ1biBhIGIgLT4gSW50LmNvbXBhcmUgYi5zaXplIGEuc2l6ZSkgeHMgaW5cbiAgcGVyZmVjdCB+ZGVmYXVsdDplbXB0eSB1bmlvbiB4c1xuXG50eXBlIHN0cmljdG5lc3MgPVxuICB8IEZpcnN0XG4gIHwgR2Ugb2YgZWx0XG4gIHwgR3Qgb2YgZWx0XG5cbnR5cGUgcmVzdWx0ID1cbiAgfCBJc19lbXB0eVxuICB8IElzX2FsbFxuICB8IEZvdW5kX2VxIG9mIHNcbiAgfCBGb3VuZF9ndCBvZiBlbHQgKiBzXG5cbmxldCByZWMgc3VjYyB+c3RyaWN0bmVzcyB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gSXNfZW1wdHlcbiAgfCBBbGwgLT4gYmVnaW5cbiAgICBtYXRjaCBzdHJpY3RuZXNzIHdpdGhcbiAgICB8IEZpcnN0IC0+IElzX2FsbFxuICAgIHwgR3QgXyAtPiBJc19hbGxcbiAgICB8IEdlIF8gLT4gRm91bmRfZXEgQWxsXG4gIGVuZFxuICB8IFBxIHBxdWV1ZSAtPiBiZWdpblxuICAgIGxldCBwcXVldWUnID1cbiAgICAgIG1hdGNoIHN0cmljdG5lc3Mgd2l0aFxuICAgICAgfCBGaXJzdCAtPiBwcXVldWVcbiAgICAgIHwgR2UgZWx0IC0+IFByaW9yaXR5X3F1ZXVlLnBvcF9sdCBlbHQgcHF1ZXVlXG4gICAgICB8IEd0IGVsdCAtPiBQcmlvcml0eV9xdWV1ZS5wb3BfbHRlIGVsdCBwcXVldWVcbiAgICBpblxuICAgIG1hdGNoIHN0cmljdG5lc3MsIFByaW9yaXR5X3F1ZXVlLm1pbmltdW0gcHF1ZXVlJyB3aXRoXG4gICAgfCBfLCBOb25lIC0+IElzX2VtcHR5XG4gICAgfCBHZSBlbHQsIFNvbWUgZSB3aGVuIERiLkVudHJ5LmVxdWFsIGUgZWx0IC0+IEZvdW5kX2VxIChQcSBwcXVldWUnKVxuICAgIHwgXywgU29tZSBlIC0+IEZvdW5kX2d0IChlLCBQcSBwcXVldWUnKVxuICBlbmRcbiAgfCBVbmlvbiAobCwgcikgLT4gYmVnaW5cbiAgICBtYXRjaCBzdWNjIH5zdHJpY3RuZXNzIGwgd2l0aFxuICAgIHwgSXNfZW1wdHkgLT4gc3VjYyB+c3RyaWN0bmVzcyByXG4gICAgfCBJc19hbGwgLT4gZmFpbHdpdGggXCJ1bmlvbiBhbGxcIlxuICAgIHwgRm91bmRfZXEgbCAtPiBGb3VuZF9lcSAoVW5pb24gKGwsIHIpKVxuICAgIHwgRm91bmRfZ3QgKGVsdF9sLCBsJykgLT4gYmVnaW5cbiAgICAgIG1hdGNoIHN1Y2MgfnN0cmljdG5lc3MgciB3aXRoXG4gICAgICB8IElzX2VtcHR5IC0+IEZvdW5kX2d0IChlbHRfbCwgbCcpXG4gICAgICB8IElzX2FsbCAtPiBmYWlsd2l0aCBcInVuaW9uIGFsbFwiXG4gICAgICB8IEZvdW5kX2VxIHInIC0+IEZvdW5kX2VxIChVbmlvbiAobCcsIHInKSlcbiAgICAgIHwgRm91bmRfZ3QgKGVsdF9yLCByJykgd2hlbiBEYi5FbnRyeS5jb21wYXJlIGVsdF9sIGVsdF9yIDw9IDAgLT5cbiAgICAgICAgRm91bmRfZ3QgKGVsdF9sLCBVbmlvbiAobCcsIHInKSlcbiAgICAgIHwgRm91bmRfZ3QgKGVsdF9yLCByJykgLT4gRm91bmRfZ3QgKGVsdF9yLCBVbmlvbiAobCcsIHInKSlcbiAgICBlbmRcbiAgZW5kXG4gIHwgSW50ZXIgKGwsIHIpIC0+IGJlZ2luXG4gICAgbWF0Y2ggc3VjYyB+c3RyaWN0bmVzcyBsIHdpdGhcbiAgICB8IElzX2VtcHR5IC0+IElzX2VtcHR5XG4gICAgfCBJc19hbGwgLT4gZmFpbHdpdGggXCJpbnRlciBhbGxcIlxuICAgIHwgRm91bmRfZXEgbCcgLT4gYmVnaW5cbiAgICAgIG1hdGNoIHN1Y2MgfnN0cmljdG5lc3MgciB3aXRoXG4gICAgICB8IElzX2VtcHR5IC0+IElzX2VtcHR5XG4gICAgICB8IElzX2FsbCAtPiBmYWlsd2l0aCBcImludGVyIGFsbFwiXG4gICAgICB8IEZvdW5kX2VxIHInIC0+IEZvdW5kX2VxIChJbnRlciAobCcsIHInKSlcbiAgICAgIHwgRm91bmRfZ3QgKGVsdCwgcicpIC0+IEZvdW5kX2d0IChlbHQsIEludGVyIChsJywgcicpKVxuICAgIGVuZFxuICAgIHwgRm91bmRfZ3QgKGVsdCwgbCcpIC0+IEZvdW5kX2d0IChlbHQsIEludGVyIChsJywgcikpXG4gIGVuZFxuXG5sZXQgcmVjIHN1Y2NfbG9vcCA/KGNvdW50ID0gMCkgfnN0cmljdG5lc3MgdCA9XG4gIG1hdGNoIHN0cmljdG5lc3MsIHN1Y2MgfnN0cmljdG5lc3MgdCB3aXRoXG4gIHwgXywgSXNfZW1wdHkgLT4gTm9uZVxuICB8IF8sIElzX2FsbCAtPiBOb25lXG4gIHwgR2UgZWx0LCBGb3VuZF9lcSB0IC0+IFNvbWUgKGVsdCwgdClcbiAgfCBfLCBGb3VuZF9ndCAoZWx0LCB0KSAtPiBzdWNjX2xvb3AgfmNvdW50Oihjb3VudCArIDEpIH5zdHJpY3RuZXNzOihHZSBlbHQpIHRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZmlyc3QgdCA9IHN1Y2NfbG9vcCB+c3RyaWN0bmVzczpGaXJzdCB0XG5cbmxldCBzZXFfb2ZfZGlzcGVuc2VyIGZuID1cbiAgbGV0IHJlYyBnbyAoKSA9XG4gICAgbWF0Y2ggZm4gKCkgd2l0aFxuICAgIHwgTm9uZSAtPiBTZXEuTmlsXG4gICAgfCBTb21lIHggLT4gU2VxLkNvbnMgKHgsIGdvKVxuICBpblxuICBnb1xuXG5sZXQgdG9fc2VxIHsgcyA9IHQ7IF8gfSA9XG4gIGxldCBzdGF0ZSA9IHJlZiBOb25lIGluXG4gIGxldCBsb29wICgpID1cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIG1hdGNoICFzdGF0ZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmlyc3QgdFxuICAgICAgfCBTb21lIChwcmV2aW91c19lbHQsIHQpIC0+IHN1Y2NfbG9vcCB+c3RyaWN0bmVzczooR3QgcHJldmlvdXNfZWx0KSB0XG4gICAgaW5cbiAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChlbHQsIF8pIC0+XG4gICAgICBzdGF0ZSA6PSByZXN1bHQgO1xuICAgICAgU29tZSBlbHRcbiAgaW5cbiAgc2VxX29mX2Rpc3BlbnNlciBsb29wXG4iLCJtb2R1bGUgUGFyc2VyID0gUXVlcnlfcGFyc2VyXG5tb2R1bGUgRHluYW1pY19jb3N0ID0gRHluYW1pY19jb3N0XG5tb2R1bGUgU3RvcmFnZSA9IERiLlN0b3JhZ2Vcbm1vZHVsZSBUcmVlID0gRGIuU3RyaW5nX2F1dG9tYXRhXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBTdWNjID0gU3VjY1xuXG4gIG1vZHVsZSBUeXBlX3BhcnNlciA9IHN0cnVjdFxuICAgIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICAgIGxldCBsZXhidWYgPSBMZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBPayAoVHlwZV9wYXJzZXIubWFpbiBUeXBlX2xleGVyLnRva2VuIGxleGJ1ZilcbiAgZW5kXG5lbmRcblxubGV0IHBvbGFyaXRpZXMgdHlwID1cbiAgTGlzdC5vZl9zZXFcbiAgQEAgU2VxLmZpbHRlclxuICAgICAgIChmdW4gKHdvcmQsIF9jb3VudCwgXykgLT4gU3RyaW5nLmxlbmd0aCB3b3JkID4gMClcbiAgICAgICAoRGIuVHlwZV9wb2xhcml0eS5vZl90eXAgfmFueV9pc19wb2x5OmZhbHNlIHR5cClcblxubGV0IGZpbmRfdHlwZXMgfnNoYXJkIHR5cCA9XG4gIGxldCBwb2xhcml0aWVzID0gcG9sYXJpdGllcyB0eXAgaW5cbiAgU3VjYy5pbnRlcl9vZl9saXN0XG4gIEBAIExpc3QubWFwXG4gICAgICAgKGZ1biAobmFtZSwgY291bnQsIHBvbGFyaXR5KSAtPlxuICAgICAgICAgbGV0IHN0X29jYyA9XG4gICAgICAgICAgIG1hdGNoIHBvbGFyaXR5IHdpdGhcbiAgICAgICAgICAgfCBEYi5UeXBlX3BvbGFyaXR5LlNpZ24uUG9zIC0+IHNoYXJkLkRiLmRiX3Bvc190eXBlc1xuICAgICAgICAgICB8IE5lZyAtPiBzaGFyZC5EYi5kYl9uZWdfdHlwZXNcbiAgICAgICAgIGluXG4gICAgICAgICBTdWNjLm9mX2F1dG9tYXRhc1xuICAgICAgICAgQEAgRGIuT2NjdXJlbmNlcy5mb2xkXG4gICAgICAgICAgICAgIChmdW4gb2NjdXJyZW5jZXMgc3QgYWNjIC0+XG4gICAgICAgICAgICAgICAgaWYgb2NjdXJyZW5jZXMgPCBjb3VudFxuICAgICAgICAgICAgICAgIHRoZW4gYWNjXG4gICAgICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICAgICAgbGV0IHRzID0gVHJlZS5maW5kX3N0YXIgc3QgbmFtZSBpblxuICAgICAgICAgICAgICAgICAgTGlzdC5yZXZfYXBwZW5kIHRzIGFjY1xuICAgICAgICAgICAgICAgIGVuZClcbiAgICAgICAgICAgICAgc3Rfb2NjXG4gICAgICAgICAgICAgIFtdKVxuICAgICAgIHBvbGFyaXRpZXNcblxubGV0IGZpbmRfbmFtZXMgfnNoYXJkIG5hbWVzID1cbiAgbGV0IG5hbWVzID0gTGlzdC5tYXAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBuYW1lcyBpblxuICBsZXQgZGJfbmFtZXMgPSBEYi4oc2hhcmQuZGJfbmFtZXMpIGluXG4gIGxldCBjYW5kaWRhdGVzID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biBuYW1lIC0+XG4gICAgICAgIG1hdGNoIFRyZWUuZmluZCBkYl9uYW1lcyBuYW1lIHdpdGhcbiAgICAgICAgfCBTb21lIHRyaWUgLT4gU3VjYy5vZl9hdXRvbWF0YSB0cmllXG4gICAgICAgIHwgTm9uZSAtPiBTdWNjLmVtcHR5KVxuICAgICAgbmFtZXNcbiAgaW5cbiAgU3VjYy5pbnRlcl9vZl9saXN0IGNhbmRpZGF0ZXNcblxubGV0IHNlYXJjaCB+c2hhcmQgeyBRdWVyeV9wYXJzZXIubmFtZTsgdHlwIH0gPVxuICBtYXRjaCBuYW1lLCB0eXAgd2l0aFxuICB8IF8gOjogXywgYHR5cCB0eXAgLT5cbiAgICBsZXQgcmVzdWx0c19uYW1lID0gZmluZF9uYW1lcyB+c2hhcmQgbmFtZSBpblxuICAgIGxldCByZXN1bHRzX3R5cCA9IGZpbmRfdHlwZXMgfnNoYXJkIHR5cCBpblxuICAgIFN1Y2MuaW50ZXIgcmVzdWx0c19uYW1lIHJlc3VsdHNfdHlwXG4gIHwgXyA6OiBfLCBfIC0+IGZpbmRfbmFtZXMgfnNoYXJkIG5hbWVcbiAgfCBbXSwgYHR5cCB0eXAgLT4gZmluZF90eXBlcyB+c2hhcmQgdHlwXG4gIHwgW10sIChgbm9fdHlwIHwgYHBhcnNlX2Vycm9yKSAtPiBTdWNjLmVtcHR5XG5cbmxldCBzZWFyY2ggfnNoYXJkcyBxdWVyeSA9XG4gIFN1Y2MudW5pb25fb2ZfbGlzdCAoTGlzdC5tYXAgKGZ1biBzaGFyZCAtPiBzZWFyY2ggfnNoYXJkIHF1ZXJ5KSBzaGFyZHMpXG5cbnR5cGUgdCA9XG4gIHsgcXVlcnkgOiBzdHJpbmdcbiAgOyBwYWNrYWdlcyA6IHN0cmluZyBsaXN0XG4gIDsgbGltaXQgOiBpbnRcbiAgfVxuXG5sZXQgcHJldHR5IHBhcmFtcyA9IFBhcnNlci4odG9fc3RyaW5nIEBAIG9mX3N0cmluZyBwYXJhbXMucXVlcnkpXG5cbmxldCBtYXRjaF9wYWNrYWdlcyB+cGFja2FnZXMgeyBEYi5FbnRyeS5wa2c7IF8gfSA9XG4gIExpc3QuZXhpc3RzIChTdHJpbmcuZXF1YWwgcGtnLm5hbWUpIHBhY2thZ2VzXG5cbmxldCBtYXRjaF9wYWNrYWdlcyB+cGFja2FnZXMgcmVzdWx0cyA9XG4gIG1hdGNoIHBhY2thZ2VzIHdpdGhcbiAgfCBbXSAtPiByZXN1bHRzXG4gIHwgXyAtPiBTZXEuZmlsdGVyIChtYXRjaF9wYWNrYWdlcyB+cGFja2FnZXMpIHJlc3VsdHNcblxubGV0IHNlYXJjaCB+c2hhcmRzIHBhcmFtcyA9XG4gIGxldCBxdWVyeSA9IFBhcnNlci5vZl9zdHJpbmcgcGFyYW1zLnF1ZXJ5IGluXG4gIGxldCByZXN1bHRzID0gc2VhcmNoIH5zaGFyZHMgcXVlcnkgaW5cbiAgbGV0IHJlc3VsdHMgPSBTdWNjLnRvX3NlcSByZXN1bHRzIGluXG4gIHF1ZXJ5LCBtYXRjaF9wYWNrYWdlcyB+cGFja2FnZXM6cGFyYW1zLnBhY2thZ2VzIHJlc3VsdHNcblxubW9kdWxlIHR5cGUgSU8gPSBJby5TXG5cbm1vZHVsZSBNYWtlIChJbyA6IElPKSA9IHN0cnVjdFxuICBtb2R1bGUgVHIgPSBUb3BfcmVzdWx0cy5NYWtlIChJbylcblxuICBsZXQgc2VhcmNoIH5zaGFyZHMgPyhkeW5hbWljX3NvcnQgPSB0cnVlKSBwYXJhbXMgPVxuICAgIGxldCBsaW1pdCA9IHBhcmFtcy5saW1pdCBpblxuICAgIGxldCBxdWVyeSwgcmVzdWx0cyA9IHNlYXJjaCB+c2hhcmRzIHBhcmFtcyBpblxuICAgIGxldCByZXN1bHRzID0gVHIuU2VxLm9mX3NlcSByZXN1bHRzIGluXG4gICAgaWYgZHluYW1pY19zb3J0XG4gICAgdGhlbiBiZWdpblxuICAgICAgbGV0IHF1ZXJ5ID0gRHluYW1pY19jb3N0Lm9mX3F1ZXJ5IHF1ZXJ5IGluXG4gICAgICBUci5vZl9zZXEgfnF1ZXJ5IH5saW1pdCByZXN1bHRzXG4gICAgZW5kXG4gICAgZWxzZSBUci5TZXEudG9fbGlzdCBAQCBUci5TZXEudGFrZSBsaW1pdCByZXN1bHRzXG5lbmRcblxubW9kdWxlIEJsb2NraW5nID0gTWFrZSAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgIGxldCByZXR1cm4geCA9IHhcbiAgICBsZXQgbWFwIHggZiA9IGYgeFxuICAgIGxldCBiaW5kIHggZiA9IGYgeFxuICBlbmQpXG4iXX0=
