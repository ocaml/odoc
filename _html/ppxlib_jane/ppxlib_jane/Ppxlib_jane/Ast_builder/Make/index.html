<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (ppxlib_jane.ppxlib_jane.Ppxlib_jane.Ast_builder.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../../';
let search_urls = ['../../../../sherlodoc_db.js','../../../../../sherlodoc.js'];
</script><script src="../../../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../../../index.html">üè†</a> &#x00BB; <a href="../../../../index.html">ppxlib_jane</a> &#x00BB; Library <code>ppxlib_jane</code> &#x00BB; <a href="../../index.html">Ppxlib_jane</a> &#x00BB; <a href="../index.html">Ast_builder</a> &#x00BB; Make</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Ast_builder.Make</span></code><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make" class="source_link">Source</a></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../../../index.html">ppxlib_jane</a><ul><li>Library <code>ppxlib_jane</code><ul><li><a href="../../index.html">Ppxlib_jane</a><ul><li><a href="../index.html">Ast_builder</a><ul><li><a href="../module-type-S_with_implicit_loc/index.html">S_with_implicit_loc</a></li><li><a href="../Default/index.html">Default</a></li><li><a href="#" class="current_unit">Make</a></li></ul></li><li><a href="../../Jane_syntax/index.html">Jane_syntax</a></li><li><a href="../../For_testing/index.html">For_testing</a></li></ul></li></ul></li><li><a href="../../../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Loc"><a href="#argument-1-Loc" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Loc/index.html">Loc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="spec-doc"><p>We expose the types within the specific <code>Ast_builder.S</code> modules because those modules are designed to be opened.</p></div><div class="odoc-spec"><div class="spec type anchored" id="type-mode"><a href="#type-mode" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-mode" class="source_link">Source</a><code><span><span class="keyword">type</span> mode</span><span> = </span></code><ol><li id="type-mode.Local" class="def variant constructor anchored"><a href="#type-mode.Local" class="anchor"></a><code><span>| </span><span><span class="constructor">Local</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>local_ ty</code></p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The modes that can go on function arguments or return types</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-arrow_argument"><a href="#type-arrow_argument" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-arrow_argument" class="source_link">Source</a><code><span><span class="keyword">type</span> arrow_argument</span><span> = </span><span>{</span></code><ol><li id="type-arrow_argument.arg_label" class="def record field anchored"><a href="#type-arrow_argument.arg_label" class="anchor"></a><code><span>arg_label : <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Asttypes/index.html#type-arg_label">Ppxlib_ast.Asttypes.arg_label</a>;</span></code></li><li id="type-arrow_argument.arg_mode" class="def record field anchored"><a href="#type-arrow_argument.arg_mode" class="anchor"></a><code><span>arg_mode : <span><a href="#type-mode">mode</a> option</span>;</span></code></li><li id="type-arrow_argument.arg_type" class="def record field anchored"><a href="#type-arrow_argument.arg_type" class="anchor"></a><code><span>arg_type : <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Function arguments; a value of this type represents:</p><ul><li><code>arg_mode arg_type -&gt; ...</code> when <code>arg_label</code> is <a href="../../../../../ocaml-base-compiler/compiler-libs.common/Asttypes/index.html#type-arg_label.Nolabel" title="Asttypes.arg_label.Nolabel"><code>Nolabel</code></a>,</li><li><code>l:arg_mode arg_type -&gt; ...</code> when <code>arg_label</code> is <a href="../../../../../ocaml-base-compiler/compiler-libs.common/Asttypes/index.html#type-arg_label.Labelled" title="Asttypes.arg_label.Labelled"><code>Labelled</code></a>, and</li><li><code>?l:arg_mode arg_type -&gt; ...</code> when <code>arg_label</code> is <a href="../../../../../ocaml-base-compiler/compiler-libs.common/Asttypes/index.html#type-arg_label.Optional" title="Asttypes.arg_label.Optional"><code>Optional</code></a>.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-arrow_result"><a href="#type-arrow_result" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-arrow_result" class="source_link">Source</a><code><span><span class="keyword">type</span> arrow_result</span><span> = </span><span>{</span></code><ol><li id="type-arrow_result.result_mode" class="def record field anchored"><a href="#type-arrow_result.result_mode" class="anchor"></a><code><span>result_mode : <span><a href="#type-mode">mode</a> option</span>;</span></code></li><li id="type-arrow_result.result_type" class="def record field anchored"><a href="#type-arrow_result.result_type" class="anchor"></a><code><span>result_type : <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Function return types; a value of this type represents <code>... -&gt; result_mode result_type</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-modality"><a href="#type-modality" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-modality" class="source_link">Source</a><code><span><span class="keyword">type</span> modality</span><span> = </span></code><ol><li id="type-modality.Global" class="def variant constructor anchored"><a href="#type-modality.Global" class="anchor"></a><code><span>| </span><span><span class="constructor">Global</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>C of (..., global_ ty, ...)</code> or <code>{ ...; global_ l : ty; ... }</code>.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The modalities that can go on constructor fields</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-function_param_desc"><a href="#type-function_param_desc" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-function_param_desc" class="source_link">Source</a><code><span><span class="keyword">type</span> function_param_desc</span><span> = <a href="../../Jane_syntax/N_ary_functions/index.html#type-function_param_desc">Jane_syntax.N_ary_functions.function_param_desc</a></span><span> = </span></code><ol><li id="type-function_param_desc.Pparam_val" class="def variant constructor anchored"><a href="#type-function_param_desc.Pparam_val" class="anchor"></a><code><span>| </span><span><span class="constructor">Pparam_val</span> <span class="keyword">of</span> <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Asttypes/index.html#type-arg_label">Ppxlib_ast.Asttypes.arg_label</a>
  * <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> option</span>
  * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-pattern">Ppxlib_ast.Parsetree.pattern</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>In <code>Pparam_val (lbl, def, pat)</code>:</p><ul><li><code>lbl</code> is the parameter label</li><li><code>def</code> is the default argument for an optional parameter</li><li><code>pat</code> is the pattern that is matched against the argument. See comment on <code>Parsetree.Pexp_fun</code> for more detail.</li></ul><span class="comment-delim">*)</span></div></li><li id="type-function_param_desc.Pparam_newtype" class="def variant constructor anchored"><a href="#type-function_param_desc.Pparam_newtype" class="anchor"></a><code><span>| </span><span><span class="constructor">Pparam_newtype</span> <span class="keyword">of</span> <span>string <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Asttypes/index.html#type-loc">Ppxlib_ast.Asttypes.loc</a></span>
  * <span><span><span class="xref-unresolved">Ppxlib_jane__.Jane_asttypes.const_jkind</span> <a href="../../../../../ocaml-base-compiler/compiler-libs.common/Location/index.html#type-loc">Location.loc</a></span> option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>Pparam_newtype tv</code> represents a locally abstract type argument <code>(type tv)</code></p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>This type corresponds to <code>Parsetree.function_param</code> added in #12236; see the comment below introducing function arity.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-function_param"><a href="#type-function_param" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder_intf.ml.html#module-Types.type-function_param" class="source_link">Source</a><code><span><span class="keyword">type</span> function_param</span><span> = <a href="../../Jane_syntax/N_ary_functions/index.html#type-function_param">Jane_syntax.N_ary_functions.function_param</a></span><span> = </span><span>{</span></code><ol><li id="type-function_param.pparam_desc" class="def record field anchored"><a href="#type-function_param.pparam_desc" class="anchor"></a><code><span>pparam_desc : <a href="#type-function_param_desc">function_param_desc</a>;</span></code></li><li id="type-function_param.pparam_loc" class="def record field anchored"><a href="#type-function_param.pparam_loc" class="anchor"></a><code><span>pparam_loc : <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Location/index.html#type-t">Astlib.Location.t</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptyp_arrow"><a href="#val-ptyp_arrow" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-ptyp_arrow" class="source_link">Source</a><code><span><span class="keyword">val</span> ptyp_arrow : 
  <span><a href="#type-arrow_argument">arrow_argument</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-arrow_result">arrow_result</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a></span></code></div><div class="spec-doc"><p>Construct an arrow type with the provided argument and result, including the types, modes, and argument label (if any).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tarrow"><a href="#val-tarrow" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-tarrow" class="source_link">Source</a><code><span><span class="keyword">val</span> tarrow : 
  <span><span><a href="#type-arrow_argument">arrow_argument</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-arrow_result">arrow_result</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a></span></code></div><div class="spec-doc"><p>Construct a multi-argument arrow type with the provided arguments and result.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if the input list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tarrow_maybe"><a href="#val-tarrow_maybe" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-tarrow_maybe" class="source_link">Source</a><code><span><span class="keyword">val</span> tarrow_maybe : 
  <span><span><a href="#type-arrow_argument">arrow_argument</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a></span></code></div><div class="spec-doc"><p>As <code>tarrow</code>, but will return the result if the input list is empty rather than erroring; this means the result type cannot have a mode annotation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_mode"><a href="#val-get_mode" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Default.val-get_mode" class="source_link">Source</a><code><span><span class="keyword">val</span> get_mode : 
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-mode">mode</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a></span></code></div><div class="spec-doc"><p>Splits a possibly-mode-annotated function argument or result into a pair of its mode and the unannotated type. If the resulting mode is <code>None</code>, then the type is returned unchanged.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pcstr_tuple"><a href="#val-pcstr_tuple" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-pcstr_tuple" class="source_link">Source</a><code><span><span class="keyword">val</span> pcstr_tuple : 
  <span><span><span>(<span><a href="#type-modality">modality</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-constructor_arguments">Ppxlib_ast.Parsetree.constructor_arguments</a></span></code></div><div class="spec-doc"><p>Construct a <code>Pcstr_tuple</code>, a representation for the contents of a tupled variant constructor, that attaches the provided modalities to each field.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pcstr_record"><a href="#val-pcstr_record" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-pcstr_record" class="source_link">Source</a><code><span><span class="keyword">val</span> pcstr_record : 
  <span><span><span>(<span><a href="#type-modality">modality</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-label_declaration">Ppxlib_ast.Parsetree.label_declaration</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-constructor_arguments">Ppxlib_ast.Parsetree.constructor_arguments</a></span></code></div><div class="spec-doc"><p>Construct a <code>Pcstr_record</code>, a representation for the contents of a variant constructor with an inlined record, that attaches the provided modalities to each label.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if the input list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptype_record"><a href="#val-ptype_record" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-ptype_record" class="source_link">Source</a><code><span><span class="keyword">val</span> ptype_record : 
  <span><span><span>(<span><a href="#type-modality">modality</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-label_declaration">Ppxlib_ast.Parsetree.label_declaration</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-type_kind">Ppxlib_ast.Parsetree.type_kind</a></span></code></div><div class="spec-doc"><p>Construct a <code>Ptype_record</code>, a representation of a record type, that attaches the provided modalities to each label.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if the input list is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_tuple_field_modality"><a href="#val-get_tuple_field_modality" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Default.val-get_tuple_field_modality" class="source_link">Source</a><code><span><span class="keyword">val</span> get_tuple_field_modality : 
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-modality">modality</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-core_type">Ppxlib_ast.Parsetree.core_type</a></span></code></div><div class="spec-doc"><p>Splits a possibly-modality-annotated field of a tupled variant constructor into a pair of its modality and the unannotated field. If the resulting mode is <code>None</code>, then the field is returned unchanged.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_label_declaration_modality"><a href="#val-get_label_declaration_modality" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Default.val-get_label_declaration_modality" class="source_link">Source</a><code><span><span class="keyword">val</span> get_label_declaration_modality : 
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-label_declaration">Ppxlib_ast.Parsetree.label_declaration</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-modality">modality</a> option</span> * <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-label_declaration">Ppxlib_ast.Parsetree.label_declaration</a></span></code></div><div class="spec-doc"><p>Splits a possibly-modality-annotated label declaration into a pair of its modality and the unannotated label declaration. If the resulting modality is <code>None</code>, then the label declaration is returned unchanged.</p></div></div><p>Many comments below make reference to the Jane Street compiler's treatment of function arity. These comments refer to a parsetree change made to upstream OCaml in https://github.com/ocaml/ocaml/pull/12236, but that Jane Street has mirrored internally already.</p><p>The treatment of arity can be summarized as follows:</p><ul><li>In a previous version of OCaml, a function's runtime arity was inferred at a late stage of the compiler, after typechecking, where it fuses together nested lambdas.</li><li>In the new version of OCaml (both upstream OCaml after #12236 and the internal Jane Street compiler), a function's runtime arity is purely a syntactic notion: it's the number of parameters in a <code>fun x1 ... xn -&gt; body</code> construct, with some special allowances for function cases.</li></ul><p>Why is arity important? In native code, application sites of a function to <code>n</code> syntactic arguments will trigger a fast path (where arguments are passed in registers) only if the function's runtime arity is <code>n</code>.</p><p>As a result, ppxes must take more care than before to generate functions of the correct arity. Now, a nested function like <code>fun x -&gt; fun y -&gt; e</code> has arity 1 (returning still another function of arity 1) instead of arity 2. All bindings below that construct functions are documented as to the arity of the returned function.</p><p>Some examples of arity:</p><ul><li>2-ary function: <code>fun x y -&gt; e</code></li><li>1-ary function returning 1-ary function: <code>fun x -&gt; fun y -&gt; e</code></li><li>3-ary function: <code>fun x y -&gt; function P1 -&gt; e1 | P2 -&gt; e2</code></li><li>2-ary function returning 1-ary function: <code>fun x y -&gt; (function P1 -&gt; e1 | P2 -&gt; e2)</code></li><li>2-ary function returning 1-ary function: <code>fun x -&gt; function P1 -&gt; function P2 -&gt; e</code></li></ul><p>Notably, unparenthesized <code>function</code> has a special meaning when used as a direct body of <code>fun</code>: the <code>function</code> becomes part of the arity of the outer <code>fun</code>. The same does not apply for multiple nested <code>function</code>s, even if they each have a single case; the nested <code>function</code>s are treated as unary. (See the last example.)</p><div class="odoc-spec"><div class="spec value anchored" id="val-eabstract"><a href="#val-eabstract" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-eabstract" class="source_link">Source</a><code><span><span class="keyword">val</span> eabstract : 
  <span><span class="optlabel">?coalesce_fun_arity</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-pattern">Ppxlib_ast.Parsetree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a></span></code></div><div class="spec-doc"><p>Create a function with unlabeled parameters and an expression body. Like <code>Ppxlib.Ast_builder.eapply</code>, but for constructing functions.</p><p><code>coalesce_fun_arity</code> is relevant for the Jane Street compiler. By default, <code>coalesce_fun_arity</code> is <code>true</code>.</p><p>Suppose there is a call <code>eabstract pats body ~coalesce_fun_arity</code></p><ul><li>If <code>colaesce_fun_arity</code> is <code>true</code>, the arity of the returned function is the same as the arity of: <code>add_fun_params (List.map params ~f:(Fun.param Nolabel)) body</code></li><li>If <code>coalesce_fun_arity</code> is <code>false</code>, then the arity of the returned function is the length of <code>pats</code>.</li></ul><p>In other words, <code>coalesce_fun_arity = true</code> allows you to build up the arity of an already-constructed function rather than necessarily creating a new function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unary_function"><a href="#val-unary_function" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-unary_function" class="source_link">Source</a><code><span><span class="keyword">val</span> unary_function : 
  <span><span class="optlabel">?attrs</span>:<a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-attributes">Ppxlib_ast.Parsetree.attributes</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-case">Ppxlib_ast.Parsetree.case</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a></span></code></div><div class="spec-doc"><p><code>unary_function cases</code> is <code>function &lt;cases&gt;</code>. When used with the Jane Street compiler, the function's runtime arity is 1, so the fast path for function application happens only when application sites of the resulting function receive 1 argument. To create a function with multiple argument that pattern-matches on the last one, use <code>add_param</code> or <code>add_params</code> to add more parameters. Alternatively, use <code>pexp_function</code> to provide all parameters at once.</p><p>The attributes of the resulting expression will be the <code>attrs</code> argument together with any attributes added by the Jane Street compiler.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fun_param"><a href="#val-fun_param" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-fun_param" class="source_link">Source</a><code><span><span class="keyword">val</span> fun_param : 
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Asttypes/index.html#type-arg_label">Ppxlib_ast.Asttypes.arg_label</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-pattern">Ppxlib_ast.Parsetree.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-function_param">function_param</a></span></code></div><div class="spec-doc"><p><code>fun_param lbl pat</code> is <code>Pparam_val (lbl, None, pat)</code>. This gives a more self-documenting way of constructing the usual case: value parameters without optional argument defaults.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_fun_param"><a href="#val-add_fun_param" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-add_fun_param" class="source_link">Source</a><code><span><span class="keyword">val</span> add_fun_param : 
  <span><span class="optlabel">?attrs</span>:<a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-attributes">Ppxlib_ast.Parsetree.attributes</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Asttypes/index.html#type-arg_label">Ppxlib_ast.Asttypes.arg_label</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-pattern">Ppxlib_ast.Parsetree.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a></span></code></div><div class="spec-doc"><p>Say an expression is a &quot;function&quot; if it is a <code>Pexp_fun</code> or a <code>Pexp_function</code>. All functions have parameters and arity.</p><p>Suppose <code>add_param lbl def pat e ==&gt; e'</code>. Then, letting <code>param = Pparam_val (lbl, def, pat)</code>,</p><ul><li>If <code>e</code> is a function with arity <code>n</code>, then <code>e'</code> is a function with arity <code>n+1</code>. <code>param</code> is added at the outermost layer. For example, if <code>e = fun &lt;params&gt; -&gt; &lt;body&gt;</code>, then <code>e' = fun &lt;param :: params&gt; -&gt; body</code>. The attributes on the resulting expression will be the <code>attrs</code> argument together with any attributes already present on <code>e</code>.</li><li>If <code>e</code> is not a function, then <code>e'</code> is a function with arity <code>1</code>, namely: <code>fun &lt;param&gt; -&gt; &lt;e&gt;</code>. The attributes of the resulting expression will be the <code>attrs</code> argument together with any attributes added by the Jane Street compiler.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_fun_params"><a href="#val-add_fun_params" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Make.val-add_fun_params" class="source_link">Source</a><code><span><span class="keyword">val</span> add_fun_params : 
  <span><span class="optlabel">?attrs</span>:<a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-attributes">Ppxlib_ast.Parsetree.attributes</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-function_param">function_param</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a></span></code></div><div class="spec-doc"><p><code>add_params params e</code> is <code>List.fold_right params ~init:e ~f:add_param</code>. Note the <code>fold_right</code>: if <code>e</code> is <code>fun &lt;params'&gt; -&gt; &lt;body&gt;</code>, then <code>add_params params e</code> is <code>fun &lt;params @ params'&gt; -&gt; &lt;body&gt;</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-coalesce_fun_arity"><a href="#val-coalesce_fun_arity" class="anchor"></a><a href="../../../../src/ppxlib_jane/ast_builder.ml.html#module-Default.val-coalesce_fun_arity" class="source_link">Source</a><code><span><span class="keyword">val</span> coalesce_fun_arity : 
  <span><a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../ppxlib/ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html#type-expression">Ppxlib_ast.Parsetree.expression</a></span></code></div><div class="spec-doc"><p>This operation is a no-op, except as interpreted by the Jane Street compiler. If <code>e</code> is a function with arity <code>n</code> with an expression body that itself is a function with arity <code>m</code>, then <code>coalesce_fun_arity e</code> is a function of arity <code>n + m</code>.</p><p>You should usually call <code>coalesce_fun_arity</code> on metaquot fun expressions whose body may be a function, e.g.:</p><p><code>coalesce_fun_arity [%expr fun x y -&gt; [%e possibly_function]]</code></p></div></div></div></body></html>
