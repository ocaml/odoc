<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Csexp (csexp.csexp.Csexp)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../sherlodoc_db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">csexp</a> &#x00BB; Library <code>csexp</code> &#x00BB; Csexp</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Csexp</span></code><a href="../../src/csexp/csexp.ml.html" class="source_link">Source</a></h1><p>Canonical S-expressions</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../index.html">csexp</a><ul><li>Library <code>csexp</code><ul><li><a href="#" class="current_unit">Csexp</a><ul><li><a href="module-type-Sexp/index.html">Sexp</a></li><li><a href="module-type-S/index.html">S</a></li><li><a href="Make/index.html">Make</a></li><li><a href="Parser/index.html">Parser</a></li><li><a href="module-type-Input/index.html">Input</a></li><li><a href="Make_parser/index.html">Make_parser</a></li></ul></li></ul></li><li><a href="../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><p>This module provides minimal support for reading and writing S-expressions in canonical form.</p><p>https://en.wikipedia.org/wiki/Canonical_S-expressions</p><p>Note that because the canonical representation of S-expressions is so simple, this module doesn't go out of his way to provide a fully generic parser and printer and instead just provides a few simple functions. If you are using fancy input sources, simply copy the parser and adapt it. The format is so simple that it's pretty difficult to get it wrong by accident.</p><p>To avoid a dependency on a particular S-expression library, the only module of this library is parameterised by the type of S-expressions.</p><pre class="language-ocaml"><code>let rec print = function
  | Atom str -&gt; Printf.printf &quot;%d:%s&quot; (String.length s)
  | List l -&gt; List.iter print l</code></pre><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Sexp"><a href="#module-type-Sexp" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-type-Sexp" class="source_link">Source</a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Sexp/index.html">Sexp</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-S"><a href="#module-type-S" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-type-S" class="source_link">Source</a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Sexp/index.html">Sexp</a> : <a href="module-type-Sexp/index.html">Sexp</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-sexp">sexp</a> := <a href="Make/argument-1-Sexp/index.html#type-t">Sexp.t</a></span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-Sexp/index.html">Sexp</a></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-T.type-t" class="source_link">Source</a><code><span><span class="keyword">type</span> t</span><span> = </span></code><ol><li id="type-t.Atom" class="def variant constructor anchored"><a href="#type-t.Atom" class="anchor"></a><code><span>| </span><span><span class="constructor">Atom</span> <span class="keyword">of</span> string</span></code></li><li id="type-t.List" class="def variant constructor anchored"><a href="#type-t.List" class="anchor"></a><code><span>| </span><span><span class="constructor">List</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span></span></code></li></ol></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-sexp">sexp</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-parse_string" class="source_link">Source</a><code><span><span class="keyword">val</span> parse_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, int * string)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>parse_string s</code> parses a single S-expression encoded in canonical form in <code>s</code>. It is an error for <code>s</code> to contain a S-expression followed by more data. In case of error, the offset of the error as well as an error message is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_string_many"><a href="#val-parse_string_many" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-parse_string_many" class="source_link">Source</a><code><span><span class="keyword">val</span> parse_string_many : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> list</span>, int * string)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>parse_string s</code> parses a sequence of S-expressions encoded in canonical form in <code>s</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input"><a href="#val-input" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-input" class="source_link">Source</a><code><span><span class="keyword">val</span> input : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, string)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p>Read exactly one canonical S-expressions from the given channel. Note that this function never raises <code>End_of_file</code>. Instead, it returns <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input_opt"><a href="#val-input_opt" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-input_opt" class="source_link">Source</a><code><span><span class="keyword">val</span> input_opt : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> option</span>, string)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p>Same as <code>input</code> but returns <code>Ok None</code> if the end of file has already been reached. If some more characters are available but the end of file is reached before reading a complete S-expression, this function returns <code>Error</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input_many"><a href="#val-input_many" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-input_many" class="source_link">Source</a><code><span><span class="keyword">val</span> input_many : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-in_channel">in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-t">t</a> list</span>, string)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p>Read many S-expressions until the end of input is reached.</p></div></div><h3 id="serialising"><a href="#serialising" class="anchor"></a>Serialising</h3><div class="odoc-spec"><div class="spec value anchored" id="val-serialised_length"><a href="#val-serialised_length" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-serialised_length" class="source_link">Source</a><code><span><span class="keyword">val</span> serialised_length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The length of the serialised representation of a S-expression</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-to_string" class="source_link">Source</a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string sexp</code> converts S-expression <code>sexp</code> to a string in canonical form.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-to_buffer" class="source_link">Source</a><code><span><span class="keyword">val</span> to_buffer : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Buffer/index.html#type-t">Buffer.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>to_buffer buf sexp</code> outputs the S-expression <code>sexp</code> converted to its canonical form to buffer <code>buf</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.val-to_channel" class="source_link">Source</a><code><span><span class="keyword">val</span> to_channel : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>output oc sexp</code> outputs the S-expression <code>sexp</code> converted to its canonical form to channel <code>oc</code>.</p></div></div><h4 id="low-level-parser"><a href="#low-level-parser" class="anchor"></a>Low level parser</h4><p>For efficiently parsing from sources other than strings or input channel. For instance in Lwt or Async programs.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Parser"><a href="#module-Parser" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.module-Parser" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Parser/index.html">Parser</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The <code>Parser</code> module offers an API that is a balance between sharing the common logic of parsing canonical S-expressions while allowing to write parsers that are as efficient as possible, both in terms of speed and allocations. A carefully written parser using this API will be:</p></div></div><h4 id="deprecated-low-level-parser"><a href="#deprecated-low-level-parser" class="anchor"></a>Deprecated low-level parser</h4><p>The above are deprecated as the <a href="module-type-Input/index.html"><code>Input</code></a> signature does not allow to distinguish between IO errors and end of input conditions. Additionally, the use of monads tend to produce parsers that allocates a lot.</p><p>It is recommended to use the <a href="Parser/index.html"><code>Parser</code></a> module instead.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Input"><a href="#module-type-Input" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.module-type-Input" class="source_link">Source</a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Input/index.html">Input</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make_parser"><a href="#module-Make_parser" class="anchor"></a><a href="../../src/csexp/csexp.ml.html#module-Make.module-Make_parser" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Make_parser/index.html">Make_parser</a></span><span> (<a href="Make_parser/argument-1-Input/index.html">Input</a> : <a href="module-type-Input/index.html">Input</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div></div></body></html>
