<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fpath (fpath.fpath.Fpath)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../sherlodoc_db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">fpath</a> &#x00BB; Library <code>fpath</code> &#x00BB; Fpath</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Fpath</span></code></h1><p>File system paths, file <a href="#file_exts" title="file_exts">extensions</a>, path <a href="Set/index.html" title="Set">sets</a> and <a href="Map/index.html" title="Map">maps</a>.</p><p>A (file system) <em>path</em> specifies a file or a directory in a file system hierarchy. A path has three parts:</p><ol><li>An optional, platform-dependent, <a href="#val-split_volume" title="split_volume">volume</a>.</li><li>An optional root directory separator <a href="#val-dir_sep"><code>dir_sep</code></a> whose presence distinguishes <em>absolute</em> paths (<code>&quot;/a&quot;</code>) from <em>relative</em> ones (<code>&quot;a&quot;</code>)</li><li>A non-empty list of <a href="#val-dir_sep"><code>dir_sep</code></a> separated segments. Segments are non empty strings except for maybe the last one. The latter distinguishes <em>directory paths</em> (<code>&quot;a/b/&quot;</code>) from <em>file paths</em> (<code>&quot;a/b&quot;</code>).</li></ol><p>The path segments <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are <a href="#val-is_rel_seg" title="is_rel_seg"><em>relative path segments</em></a> that respectively denote the current and parent directory. The <a href="#val-basename" title="basename"><em>basename</em></a> of a path is its last non-empty segment if it is not a relative path segment or the empty string otherwise.</p><p>Consult a few <a href="#tips" title="tips">important tips</a>.</p><p><b>Note.</b> <code>Fpath</code> processes paths without accessing the file system.</p><p><em>v0.7.3 - <a href="https://erratique.ch/software/fpath">homepage</a></em></p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#segs">Separators and segments</a></li><li><a href="#paths">Paths</a></li><li><a href="#filedir">File and directory paths</a></li><li><a href="#parentbase">Base and parent paths</a></li><li><a href="#norm">Normalization</a></li><li><a href="#prefixes">Prefixes</a></li><li><a href="#rootrel">Roots and relativization</a></li><li><a href="#predicates">Predicates and comparison</a></li><li><a href="#conversions">Conversions and pretty printing</a></li><li><a href="#file_exts">File extensions</a></li><li><a href="#sets_maps">Path sets and maps</a></li><li><a href="#tips">Tips</a></li><li><a href="#ex">Examples</a><ul><li><a href="#ex_add_seg"><code>add_seg</code></a></li><li><a href="#ex_append"><code>append</code></a></li><li><a href="#ex_segs"><code>segs</code></a></li><li><a href="#ex_is_dir_path"><code>is_dir_path</code></a></li><li><a href="#ex_is_file_path"><code>is_file_path</code></a></li><li><a href="#ex_to_dir_path"><code>to_dir_path</code></a></li><li><a href="#ex_filename"><code>filename</code></a></li><li><a href="#ex_split_base"><code>split_base</code></a></li><li><a href="#ex_basename"><code>basename</code></a></li><li><a href="#ex_parent"><code>parent</code></a></li><li><a href="#ex_rem_empty_seg"><code>rem_empty_seg</code></a></li><li><a href="#ex_normalize"><code>normalize</code></a></li><li><a href="#ex_is_prefix"><code>is_prefix</code></a></li><li><a href="#ex_find_prefix"><code>find_prefix</code></a></li><li><a href="#ex_rem_prefix"><code>rem_prefix</code></a></li><li><a href="#ex_relativize"><code>relativize</code></a></li><li><a href="#ex_is_rooted"><code>is_rooted</code></a></li><li><a href="#ex_is_root"><code>is_root</code></a></li><li><a href="#ex_get_ext"><code>get_ext</code></a></li><li><a href="#ex_has_ext"><code>has_ext</code></a></li><li><a href="#ex_exists_ext"><code>exists_ext</code></a></li><li><a href="#ex_add_ext"><code>add_ext</code></a></li><li><a href="#ex_rem_ext"><code>rem_ext</code></a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../index.html">fpath</a><ul><li>Library <code>fpath</code><ul><li><a href="#" class="current_unit">Fpath</a><ul><li><a href="Set/index.html">Set</a></li><li><a href="Map/index.html">Map</a></li></ul></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="segs"><a href="#segs" class="anchor"></a>Separators and segments</h2><div class="odoc-spec"><div class="spec value anchored" id="val-dir_sep"><a href="#val-dir_sep" class="anchor"></a><code><span><span class="keyword">val</span> dir_sep : string</span></code></div><div class="spec-doc"><p><code>dir_sep</code> is the platform dependent natural directory separator. This is <code>&quot;/&quot;</code> on POSIX and <code>&quot;\\&quot;</code> on Windows.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_seg"><a href="#val-is_seg" class="anchor"></a><code><span><span class="keyword">val</span> is_seg : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_seg s</code> is <code>true</code> iff <code>s</code> does not contain <a href="#val-dir_sep"><code>dir_sep</code></a> or <code>'/'</code> or a <code>0x00</code> byte.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_rel_seg"><a href="#val-is_rel_seg" class="anchor"></a><code><span><span class="keyword">val</span> is_rel_seg : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_rel_seg s</code> is true iff <code>s</code> is a relative segment, that is <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code>.</p></div></div><h2 id="paths"><a href="#paths" class="anchor"></a>Paths</h2><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for paths.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-v"><a href="#val-v" class="anchor"></a><code><span><span class="keyword">val</span> v : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>v s</code> is the string <code>s</code> as a path.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>s</code> is not a <a href="#val-of_string" title="of_string">valid path</a>. Use <a href="#val-of_string"><code>of_string</code></a> to deal with untrusted input.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seg"><a href="#val-add_seg" class="anchor"></a><code><span><span class="keyword">val</span> add_seg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_seg p seg</code> adds segment <code>seg</code> to the segments of <code>p</code> if <code>p</code>'s last segment is non-empty or replaces the last empty segment with <code>seg</code>. <a href="#ex_add_seg" title="ex_add_seg">Examples</a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <a href="#val-is_seg"><code>is_seg</code></a><code> seg</code> is <code>false</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p / seg</code> is <a href="#val-add_seg"><code>add_seg</code></a><code> p seg</code>. Left associative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>append p q</code> appends <code>q</code> to <code>p</code> as follows:</p><ul><li>If <code>q</code> is absolute or has a non-empty <a href="#val-split_volume" title="split_volume">volume</a> then <code>q</code> is returned.</li><li>Otherwise appends <code>q</code>'s segments to <code>p</code> using <a href="#val-add_seg"><code>add_seg</code></a>.</li></ul><p><a href="#ex_append" title="ex_append">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(//)"><a href="#val-(//)" class="anchor"></a><code><span><span class="keyword">val</span> (//) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p // p'</code> is <a href="#val-append"><code>append</code></a><code> p p'</code>. Left associative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_volume"><a href="#val-split_volume" class="anchor"></a><code><span><span class="keyword">val</span> split_volume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split_volume p</code> is the pair <code>(vol, q)</code> where <code>vol</code> is the platform dependent volume of <code>p</code> or the empty string if there is none and <code>q</code> the path <code>p</code> without its volume, that is its optional root <a href="#val-dir_sep"><code>dir_sep</code></a> and segments.</p><p>On POSIX if <code>vol</code> is non-empty then it <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_267">can</a> only be <code>&quot;/&quot;</code> (e.g. in <code>v &quot;//a/b&quot;</code>). On Windows <code>vol</code> may be one of the following prefixes parsed before an absolute root <a href="#val-dir_sep"><code>dir_sep</code></a>, except in the first case where a relative path can follow:</p><pre class="language-ocaml"><code>$(drive):
\\$(server)\$(share)
\\?\$(drive):
\\?\$(server)\$(share)
\\?\UNC\$(server)\$(share)
\\.\$(device)</code></pre><p>The following invariant holds:</p><ul><li><code>equal p (v @@ vol ^ (to_string q))</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-segs"><a href="#val-segs" class="anchor"></a><code><span><span class="keyword">val</span> segs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>segs p</code> is <code>p</code>'s <em>non-empty</em> list of segments. Absolute paths have an initial empty string added, this allows to recover the path's string with <a href="../../../ocaml-base-compiler/stdlib/Stdlib/String/index.html#concat" title="concat">Concatenating</a><code> ~sep:dir_sep</code>. <a href="#ex_segs" title="ex_segs">Examples.</a></p><p>The following invariant holds:</p><ul><li><code>equal p (v @@ (fst @@ split_volume p) ^ (String.concat ~sep:dir_sep (segs p)))</code></li></ul></div></div><h2 id="filedir"><a href="#filedir" class="anchor"></a>File and directory paths</h2><p><b>Note.</b> The following functions use syntactic semantic properties of paths. Given a path, these properties can be different from the one your file system attributes to it.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_dir_path"><a href="#val-is_dir_path" class="anchor"></a><code><span><span class="keyword">val</span> is_dir_path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_dir_path p</code> is <code>true</code> iff <code>p</code> represents a directory. This means that <code>p</code>'s last segment is either empty (<code>&quot;&quot;</code>) or <a href="#val-is_rel_seg" title="is_rel_seg">relative</a>. The property is invariant with respect to <a href="#val-normalize" title="normalize">normalization</a>. <a href="#ex_is_dir_path" title="ex_is_dir_path">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_file_path"><a href="#val-is_file_path" class="anchor"></a><code><span><span class="keyword">val</span> is_file_path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_file_path p</code> is <code>true</code> iff <code>p</code> represents a file. This is the negation of <a href="#val-is_dir_path"><code>is_dir_path</code></a>. This means that <code>p</code>'s last segment is neither empty (<code>&quot;&quot;</code>) nor <a href="#val-is_rel_seg" title="is_rel_seg">relative</a>. The property is invariant with respect to <a href="#val-normalize" title="normalize">normalization</a>. <a href="#ex_is_file_path" title="ex_is_file_path">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_dir_path"><a href="#val-to_dir_path" class="anchor"></a><code><span><span class="keyword">val</span> to_dir_path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>to_dir_path p</code> is <a href="#val-add_seg"><code>add_seg</code></a><code> p &quot;&quot;</code>. It ensure that the result represents a <a href="#val-is_dir_path" title="is_dir_path">directory</a> and, if converted to a string, that it ends with a <a href="#val-dir_sep"><code>dir_sep</code></a>. <a href="#ex_to_dir_path" title="ex_to_dir_path">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filename"><a href="#val-filename" class="anchor"></a><code><span><span class="keyword">val</span> filename : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>filename p</code> is the file name of <code>p</code>. This is the last segment of <code>p</code> if <code>p</code> is a <a href="#val-is_file_path" title="is_file_path">file path</a> and the empty string otherwise. The result is invariant with respect to <a href="#val-normalize" title="normalize">normalization</a>. See also <a href="#val-basename"><code>basename</code></a>. <a href="#ex_filename" title="ex_filename">Examples</a>.</p></div></div><h2 id="parentbase"><a href="#parentbase" class="anchor"></a>Base and parent paths</h2><div class="odoc-spec"><div class="spec value anchored" id="val-split_base"><a href="#val-split_base" class="anchor"></a><code><span><span class="keyword">val</span> split_base : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split_base p</code> splits <code>p</code> into a directory <code>d</code> and a <em>relative</em> base path <code>b</code> such that:</p><ul><li><code>b</code> is a relative path that contains the segments of <code>p</code> that start at the last non-empty segment. This means that <code>b</code> has a <em>single</em> non-empty segment, and preserves <a href="#val-is_dir_path" title="is_dir_path">directoryness</a> of <code>p</code>. If <code>p</code> is a <a href="#val-is_root" title="is_root">root path</a> there are no such segments and <code>b</code> is <code>&quot;./&quot;</code>.</li><li><code>d</code> is a <a href="#val-is_dir_path" title="is_dir_path">directory</a> such that <code>d // b</code> represents the same path as <code>p</code>. They may however differ syntactically when converted to a string.</li></ul><p><a href="#ex_split_base" title="ex_split_base">Examples</a>.</p><p><b>Note.</b> <a href="#val-normalize" title="normalize">Normalizing</a> <code>p</code> before using the function ensures that <code>b</code> is a <a href="#val-is_rel_seg" title="is_rel_seg">relative segment</a> iff <code>p</code> cannot be named (like in <code>&quot;.&quot;</code>, <code>&quot;../../&quot;</code>, <code>&quot;/&quot;</code>, etc.).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-base"><a href="#val-base" class="anchor"></a><code><span><span class="keyword">val</span> base : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>base p</code> is <code>snd (split_base p)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-basename"><a href="#val-basename" class="anchor"></a><code><span><span class="keyword">val</span> basename : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>basename p</code> is <code>p</code>'s last non-empty segment if non-relative or the empty string otherwise. The latter occurs only on <a href="#val-is_root" title="is_root">root paths</a> and on paths whose last non-empty segment is a <a href="#val-is_rel_seg" title="is_rel_seg">relative segment</a>. See also <a href="#val-filename"><code>filename</code></a> and <a href="#val-base"><code>base</code></a>. <a href="#ex_basename" title="ex_basename">Examples</a>.</p><p><b>Note.</b> <a href="#val-normalize" title="normalize">Normalizing</a> <code>p</code> before using the function ensures the empty string is only returned iff <code>p</code> cannot be named (like in <code>&quot;.&quot;</code>, <code>&quot;../../&quot;</code>, <code>&quot;/&quot;</code>, etc.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parent"><a href="#val-parent" class="anchor"></a><code><span><span class="keyword">val</span> parent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>parent p</code> is a <a href="#val-is_dir_path" title="is_dir_path">directory path</a> that contains <code>p</code>. If <code>p</code> is a <a href="#val-is_root" title="is_root">root path</a> this is <code>p</code> itself. <a href="#ex_parent" title="ex_parent">Examples</a>.</p><p><b>Warning.</b> <code>parent p // base p</code> may not represent <code>p</code>, use <a href="#val-split_base"><code>split_base</code></a> for this.</p></div></div><h2 id="norm"><a href="#norm" class="anchor"></a>Normalization</h2><div class="odoc-spec"><div class="spec value anchored" id="val-rem_empty_seg"><a href="#val-rem_empty_seg" class="anchor"></a><code><span><span class="keyword">val</span> rem_empty_seg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rem_empty_seg p</code> removes an existing last empty segment of <code>p</code> if <code>p</code> is not a <a href="#val-is_root" title="is_root">root path</a>. This ensure that if <code>p</code> is converted to a string it will not have a trailing <a href="#val-dir_sep"><code>dir_sep</code></a> unless <code>p</code> is a root path. Note that this may affect <code>p</code>'s <a href="#val-is_dir_path" title="is_dir_path">directoryness</a>. <a href="#ex_rem_empty_seg" title="ex_rem_empty_seg">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span><span class="keyword">val</span> normalize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>normalize p</code> is a path that represents the same path as <code>p</code>, <a href="#val-is_dir_path" title="is_dir_path">directoryness</a> included, and that has the following properties:</p><ul><li>If <code>p</code> is absolute the resulting path has no <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> segments.</li><li>If <code>p</code> is relative the resulting path is either <code>&quot;./&quot;</code> or it has no <code>&quot;.&quot;</code> segments and <code>&quot;..&quot;</code> segments may only appear as initial segments.</li><li>If <code>p</code> is a <a href="#val-is_dir_path" title="is_dir_path">directory</a> it always end with an empty segment; this means it doesn't end with <code>&quot;.&quot;</code> or <code>&quot;..&quot;</code>.</li></ul><p><a href="#ex_normalize" title="ex_normalize">Examples</a>.</p><p><b>Warning.</b> Like file and directory path <a href="#filedir" title="filedir">functions</a> this function does not consult the file system and is purely based on the syntactic semantic of paths which can be different from the one of your concrete file system attributes. For example in presence of symbolic links the resulting path may not point to the same entity. Use the normalization functions of your OS system library to ensure correct behaviour with respect to a concrete file system.</p></div></div><h2 id="prefixes"><a href="#prefixes" class="anchor"></a>Prefixes</h2><p><b>Warning.</b> The syntactic <a href="#val-is_prefix" title="is_prefix">prefix relation</a> between paths does not, in general, entail directory containement. The following examples show this:</p><pre class="language-ocaml"><code>is_prefix (v &quot;..&quot;) (v &quot;../..&quot;) = true
is_prefix (v &quot;..&quot;) (v &quot;.&quot;) = false</code></pre><p>However, on <a href="#val-normalize" title="normalize">normalized</a>, <a href="#val-is_abs" title="is_abs">absolute</a> paths, the prefix relation does entail directory containement. See also <a href="#val-is_rooted"><code>is_rooted</code></a>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-is_prefix"><a href="#val-is_prefix" class="anchor"></a><code><span><span class="keyword">val</span> is_prefix : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_prefix prefix p</code> is <code>true</code> if <code>prefix</code> is a prefix of <code>p</code>. This checks that:</p><ul><li><code>prefix</code> has the same optional volume as <code>p</code>.</li><li><code>prefix</code> has the same optional root directory separator as <code>p</code>.</li><li>The list of segments of <code>prefix</code> is a prefix of those of <code>p</code>, ignoring the last empty segment of <code>prefix</code> if the number of non-empty segments of <code>p</code> is strictly larger than those of <code>prefix</code>. This means that <code>is_prefix (v &quot;a/&quot;) (v &quot;a/b&quot;)</code> is <code>true</code> but <code>is_prefix (v &quot;a/&quot;) (v &quot;a&quot;)</code> is <code>false</code></li></ul><p><a href="#ex_is_prefix" title="ex_is_prefix">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_prefix"><a href="#val-find_prefix" class="anchor"></a><code><span><span class="keyword">val</span> find_prefix : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>find_prefix p p'</code> is <code>Some prefix</code> if there exists <code>prefix</code> such that <code>prefix</code> is the longest path with <code>is_prefix prefix p &amp;&amp; is_prefix prefix p' = true</code> and <code>None</code> otherwise. Note that if both <code>p</code> and <code>p'</code> are absolute and have the same volume then a prefix always exists: the <a href="#val-is_root" title="is_root">root path</a> of their volume. <a href="#ex_find_prefix" title="ex_find_prefix">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rem_prefix"><a href="#val-rem_prefix" class="anchor"></a><code><span><span class="keyword">val</span> rem_prefix : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>rem_prefix prefix p</code> is:</p><ul><li><code>None</code> if <code>prefix</code> is not a <a href="#val-is_prefix" title="is_prefix">prefix</a> of <code>p</code> or if <code>prefix</code> and <code>p</code> are <a href="#val-equal" title="equal">equal</a>.</li><li><code>Some q</code> otherwise where <code>q</code> is <code>p</code> without the prefix <code>prefix</code> and preserves <code>p</code>'s <a href="#val-is_dir_path" title="is_dir_path">directoryness</a>. This means that <code>q</code> is a always <a href="#val-is_rel" title="is_rel">relative</a> and that the path <code>prefix // q</code> and <code>p</code> represent the same paths. They may however differ syntactically when converted to a string.</li></ul><p><a href="#ex_rem_prefix" title="ex_rem_prefix">Examples</a>.</p></div></div><h2 id="rootrel"><a href="#rootrel" class="anchor"></a>Roots and relativization</h2><div class="odoc-spec"><div class="spec value anchored" id="val-relativize"><a href="#val-relativize" class="anchor"></a><code><span><span class="keyword">val</span> relativize : <span><span class="label">root</span>:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p><code>relativize ~root p</code> is:</p><ul><li><code>Some q</code> if there exists a <span class="xref-unresolved" title="is_relative">relative</span> path <code>q</code> such that <code>root // q</code> and <code>p</code> represent the same paths, <a href="#val-is_dir_path" title="is_dir_path">directoryness</a> included. They may however differ syntactically when converted to a string. Note that <code>q</code> is <a href="#val-normalize" title="normalize">normalized</a>.</li><li><code>None</code> otherwise.</li></ul><p><a href="#ex_relativize" title="ex_relativize">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_rooted"><a href="#val-is_rooted" class="anchor"></a><code><span><span class="keyword">val</span> is_rooted : <span><span class="label">root</span>:<a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_rooted root p</code> is <code>true</code> iff the path <code>p</code> is the <a href="#val-is_dir_path" title="is_dir_path"><em>directory</em></a> <code>root</code> or contained in <code>root</code> and that <code>p</code> can be <a href="#val-relativize" title="relativize">relativized</a> w.r.t. <code>root</code> (the normalized relative path will have no parent directory segments). <a href="#ex_is_rooted" title="ex_is_rooted">Examples</a>.</p></div></div><h2 id="predicates"><a href="#predicates" class="anchor"></a>Predicates and comparison</h2><div class="odoc-spec"><div class="spec value anchored" id="val-is_rel"><a href="#val-is_rel" class="anchor"></a><code><span><span class="keyword">val</span> is_rel : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_rel p</code> is <code>true</code> iff <code>p</code> is a relative path, i.e. the root directory separator is missing in <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_abs"><a href="#val-is_abs" class="anchor"></a><code><span><span class="keyword">val</span> is_abs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_abs p</code> is <code>true</code> iff <code>p</code> is an absolute path, i.e. the root directory separator is present in <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_root"><a href="#val-is_root" class="anchor"></a><code><span><span class="keyword">val</span> is_root : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_root p</code> is <code>true</code> iff <code>p</code> is a root directory, i.e. <code>p</code> has the root directory separator and a single, empty, segment. <a href="#ex_is_root" title="ex_is_root">Examples</a>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;/a/..&quot;</code> or <code>&quot;/..&quot;</code>. <a href="#val-normalize" title="normalize">Normalizing</a> the path before testing avoids this problem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_current_dir"><a href="#val-is_current_dir" class="anchor"></a><code><span><span class="keyword">val</span> is_current_dir : <span><span class="optlabel">?prefix</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_current_dir p</code> is true iff <code>p</code> is the current relative directory, i.e. either <code>&quot;.&quot;</code> or <code>&quot;./&quot;</code>. If <code>prefix</code> is <code>true</code> (defaults to <code>false</code>) simply checks that <code>p</code> is <a href="#val-is_rel" title="is_rel">relative</a> and its first segment is <code>&quot;.&quot;</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;./a/..&quot;</code> or <code>&quot;./.&quot;</code>. <a href="#val-normalize" title="normalize">Normalizing</a> the path before testing avoids this problem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_parent_dir"><a href="#val-is_parent_dir" class="anchor"></a><code><span><span class="keyword">val</span> is_parent_dir : <span><span class="optlabel">?prefix</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_parent_dir p</code> is <code>true</code> iff <code>p</code> is the relative parent directory, i.e. either <code>&quot;..&quot;</code> or <code>&quot;../&quot;</code>. If <code>prefix</code> is <code>true</code> (defaults to <code>false</code>), simply checks that <code>p</code> is <a href="#val-is_rel" title="is_rel">relative</a> and its first segment is <code>&quot;..&quot;</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;./a/../..&quot;</code> or <code>&quot;./..&quot;</code>. <a href="#val-normalize" title="normalize">Normalizing</a> the path before testing avoids this problem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_dotfile"><a href="#val-is_dotfile" class="anchor"></a><code><span><span class="keyword">val</span> is_dotfile : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_dotfile p</code> is <code>true</code> iff <code>p</code>'s <a href="#val-basename" title="basename">basename</a> is non empty and starts with a <code>'.'</code>.</p><p><b>Warning.</b> By definition this is a syntactic test. For example it will return <code>false</code> on <code>&quot;.ssh/.&quot;</code>. <a href="#val-normalize" title="normalize">Normalizing</a> the path before testing avoids this problem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal p p'</code> is <code>true</code> if <code>p</code> and <code>p'</code> have the same volume are both relative or absolute and have the same segments.</p><p><b>Warning.</b> By definition this is a syntactic test. For example <code>equal (v &quot;./&quot;) (v &quot;a/..&quot;)</code> is <code>false</code>. <a href="#val-normalize" title="normalize">Normalizing</a> the paths before testing avoids this problem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>compare p p'</code> is a total order on paths compatible with <a href="#val-equal"><code>equal</code></a>.</p></div></div><h2 id="conversions"><a href="#conversions" class="anchor"></a>Conversions and pretty printing</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string p</code> is the path <code>p</code> as a string. The result can be safely converted back with <a href="#val-v"><code>v</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <span>[ <span>`Msg of string</span> ]</span>)</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#type-result">result</a></span></span></code></div><div class="spec-doc"><p><code>of_string s</code> is the string <code>s</code> as a path. The following transformations are performed on the string:</p><ul><li>On Windows any <code>'/'</code> occurence is converted to <code>'\\'</code> before any processing occurs.</li><li>Non-initial empty segments are suppressed; <code>&quot;a//b&quot;</code> becomes <code>&quot;a/b&quot;</code>, <code>&quot;//a////b//&quot;</code> becomes <code>&quot;//a/b/&quot;</code>, etc.</li><li>On Windows empty absolute UNC paths are completed to their root. For example <code>&quot;\\\\server\\share&quot;</code> becomes <code>&quot;\\\\server\\share\\&quot;</code>, but incomplete UNC volumes like <code>&quot;\\\\a&quot;</code> return <code>Error</code>.</li></ul><p><code>Error (`Msg (strf &quot;%S: invalid path&quot; s))</code> is returned if</p><ul><li><code>s</code> or the path following the <a href="#val-split_volume" title="split_volume">volume</a> is empty (<code>&quot;&quot;</code>), except on Windows UNC paths, see above.</li><li><code>s</code> has null byte (<code>'\x00'</code>).</li><li>On Windows, <code>s</code> is an invalid UNC path (e.g. <code>&quot;\\\\&quot;</code> or <code>&quot;\\\\a&quot;</code>)</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp ppf p</code> prints path <code>p</code> on <code>ppf</code> using <a href="#val-to_string"><code>to_string</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dump"><a href="#val-dump" class="anchor"></a><code><span><span class="keyword">val</span> dump : <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Format/index.html#type-formatter">Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>dump ppf p</code> prints path <code>p</code> on <code>ppf</code> using <code>String.dump</code>.</p></div></div><h2 id="file_exts"><a href="#file_exts" class="anchor"></a>File extensions</h2><p>The <em>file extension</em> (resp. <em>multiple file extension</em>) of a path segment is the suffix that starts at the last (resp. first) occurence of a <code>'.'</code> that is preceeded by at least one non <code>'.'</code> character. If there is no such occurence in the segment, the extension is empty. With these definitions, <code>&quot;.&quot;</code>, <code>&quot;..&quot;</code>, <code>&quot;...&quot;</code> and dot files like <code>&quot;.ocamlinit&quot;</code> or <code>&quot;..ocamlinit&quot;</code> have no extension, but <code>&quot;.emacs.d&quot;</code> and <code>&quot;..emacs.d&quot;</code> do have one.</p><p><b>Warning.</b> The following functions act on paths whose <a href="#val-basename" title="basename">basename</a> is non empty and do nothing otherwise. <a href="#val-normalize" title="normalize">Normalizing</a> <code>p</code> before using the functions ensures that the functions do nothing iff <code>p</code> cannot be named, see <a href="#val-basename"><code>basename</code></a>.</p><div class="odoc-spec"><div class="spec type anchored" id="type-ext"><a href="#type-ext" class="anchor"></a><code><span><span class="keyword">type</span> ext</span><span> = string</span></code></div><div class="spec-doc"><p>The type for file extensions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_ext"><a href="#val-get_ext" class="anchor"></a><code><span><span class="keyword">val</span> get_ext : <span><span class="optlabel">?multi</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ext">ext</a></span></code></div><div class="spec-doc"><p><code>get_ext p</code> is <code>p</code>'s <a href="#val-basename" title="basename">basename</a> file extension or the empty string if there is no extension. If <code>multi</code> is <code>true</code> (defaults to <code>false</code>), returns the multiple file extension. <a href="#ex_get_ext" title="ex_get_ext">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_ext"><a href="#val-has_ext" class="anchor"></a><code><span><span class="keyword">val</span> has_ext : <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_ext e p</code> is <code>true</code> iff <code>get_ext p = e || get_ext ~multi:true p = e</code>. If <code>e</code> doesn't start with a <code>'.'</code> one is prefixed before making the test. <a href="#ex_has_ext" title="ex_has_ext">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_ext"><a href="#val-mem_ext" class="anchor"></a><code><span><span class="keyword">val</span> mem_ext : <span><span><a href="#type-ext">ext</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem_ext exts p</code> is <code>List.mem (get_ext p) exts || List.mem (get_ext ~multi:true p) exts</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_ext"><a href="#val-exists_ext" class="anchor"></a><code><span><span class="keyword">val</span> exists_ext : <span><span class="optlabel">?multi</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists_ext ~multi p</code> is <code>true</code> iff <code>p</code>'s <a href="#val-basename" title="basename">basename</a> file extension is not empty. If <code>multi</code> is <code>true</code> (default to <code>false</code>) returns <code>true</code> iff <code>p</code> has <em>more than one</em> extension. <a href="#ex_exists_ext" title="ex_exists_ext">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_ext"><a href="#val-add_ext" class="anchor"></a><code><span><span class="keyword">val</span> add_ext : <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_ext ext p</code> is <code>p</code> with the string <code>ext</code> concatenated to <code>p</code>'s <a href="#val-basename" title="basename">basename</a>, if non empty. If <code>ext</code> doesn't start with a <code>'.'</code> one is prefixed to it before concatenation except if <code>ext</code> is <code>&quot;&quot;</code>. <a href="#ex_add_ext" title="ex_add_ext">Examples</a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <a href="#val-is_seg"><code>is_seg</code></a><code> ext</code> is <code>false</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rem_ext"><a href="#val-rem_ext" class="anchor"></a><code><span><span class="keyword">val</span> rem_ext : <span><span class="optlabel">?multi</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rem_ext p</code> is <code>p</code> with the extension of <code>p</code>'s <a href="#val-basename" title="basename">basename</a> removed. If <code>multi</code> is <code>true</code> (default to <code>false</code>), the multiple file extension is removed. <a href="#ex_rem_ext" title="ex_rem_ext">Examples</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_ext"><a href="#val-set_ext" class="anchor"></a><code><span><span class="keyword">val</span> set_ext : <span><span class="optlabel">?multi</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>set_ext ?multi ext p</code> is <code>add_ext ext (rem_ext ?multi p)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_ext"><a href="#val-split_ext" class="anchor"></a><code><span><span class="keyword">val</span> split_ext : <span><span class="optlabel">?multi</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-ext">ext</a></span></code></div><div class="spec-doc"><p><code>split_ext ?multi p</code> is <code>(rem_ext ?multi p, get_ext ?multi p)</code>. If this is <code>(q, ext)</code> the following invariant holds:</p><ul><li><code>equal p (add_ext q ext)</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p + ext</code> is <code>add_ext ext p</code>. Left associative.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-+)"><a href="#val-(-+)" class="anchor"></a><code><span><span class="keyword">val</span> (-+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ext">ext</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>p -+ ext</code> is <code>set_ext ext p</code>. Left associative.</p></div></div><h2 id="sets_maps"><a href="#sets_maps" class="anchor"></a>Path sets and maps</h2><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-set"><a href="#type-set" class="anchor"></a><code><span><span class="keyword">type</span> set</span></code></div><div class="spec-doc"><p>The type for path sets. Membership is determined according to <a href="#val-equal"><code>equal</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Path sets.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Path maps.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-map"><a href="#type-map" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a map</span></span><span> = <span><span class="type-var">'a</span> <a href="Map/index.html#type-t">Map.t</a></span></span></code></div><div class="spec-doc"><p>The type for maps from paths to values of type <code>'a</code>. Paths are compared with <a href="#val-compare"><code>compare</code></a>.</p></div></div><h2 id="tips"><a href="#tips" class="anchor"></a>Tips</h2><ul><li>The documentation sometimes talks about <em>the last non-empty segment of a path</em>. This usually means that we don't care whether the path is a <a href="#val-is_file_path" title="is_file_path">file path</a> (e.g. <code>&quot;a&quot;</code>) or a <a href="#val-is_dir_path" title="is_dir_path">directory path</a> (e.g. <code>&quot;a/&quot;</code>).</li><li>Windows accepts both <code>'\\'</code> and <code>'/'</code> as directory separator. However <code>Fpath</code> on Windows converts <code>'/'</code> to <code>'\\'</code> on the fly. Therefore you should either use <code>'/'</code> for defining constant paths you inject with <a href="#val-v"><code>v</code></a> or better, construct them directly with <a href="#val-(/)"><code>(/)</code></a>. <a href="#val-to_string"><code>to_string</code></a> then converts paths to strings using the platform's specific directory separator <a href="#val-dir_sep"><code>dir_sep</code></a>.</li><li>Avoid platform specific <a href="#val-split_volume" title="split_volume">volumes</a> or hard-coding file hierarchy conventions in your constants.</li><li>Do not assume there is a single root path and that it is <code>&quot;/&quot;</code>. On Windows each <a href="#val-split_volume" title="split_volume">volume</a> can have a root path. Use <a href="#val-is_root"><code>is_root</code></a> on <a href="#val-normalize" title="normalize">normalized</a> paths to detect roots.</li><li>Do not use <a href="#val-to_string"><code>to_string</code></a> to construct URIs, <a href="#val-to_string"><code>to_string</code></a> uses <a href="#val-dir_sep"><code>dir_sep</code></a> to separate segments, on Windows this is <code>'\\'</code> which is not what URIs expect. Access path segments directly with <a href="#val-segs"><code>segs</code></a>; note that you will need to percent encode these.</li></ul><h2 id="ex"><a href="#ex" class="anchor"></a>Examples</h2><h3 id="ex_add_seg"><a href="#ex_add_seg" class="anchor"></a><a href="#val-add_seg"><code>add_seg</code></a></h3><ul><li><code>equal (add_seg (v &quot;/a&quot;) &quot;b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/&quot;) &quot;b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/b&quot;) &quot;&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (add_seg (v &quot;/a/b/&quot;) &quot;&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (add_seg (v &quot;/&quot;) &quot;&quot;) (v &quot;/&quot;)</code></li><li><code>equal (add_seg (v &quot;/&quot;) &quot;a&quot;) (v &quot;/a&quot;)</code></li><li><code>equal (add_seg (v &quot;.&quot;) &quot;&quot;) (v &quot;./&quot;)</code></li><li><code>equal (add_seg (v &quot;.&quot;) &quot;a&quot;) (v &quot;./a&quot;)</code></li><li><code>equal (add_seg (v &quot;..&quot;) &quot;&quot;) (v &quot;../&quot;)</code></li><li><code>equal (add_seg (v &quot;..&quot;) &quot;a&quot;) (v &quot;../a&quot;)</code></li></ul><h3 id="ex_append"><a href="#ex_append" class="anchor"></a><a href="#val-append"><code>append</code></a></h3><ul><li><code>equal (append (v &quot;/a/b/&quot;) (v &quot;e/f&quot;)) (v &quot;/a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;/a/b&quot;) (v &quot;e/f&quot;)) (v &quot;/a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;/a/b/&quot;) (v &quot;/e/f&quot;)) (v &quot;/e/f&quot;)</code></li><li><code>equal (append (v &quot;a/b/&quot;) (v &quot;e/f&quot;)) (v &quot;a/b/e/f&quot;)</code></li><li><code>equal (append (v &quot;a/b&quot;) (v &quot;C:e&quot;)) (v &quot;C:e&quot;)</code> (Windows)</li></ul><h3 id="ex_segs"><a href="#ex_segs" class="anchor"></a><a href="#val-segs"><code>segs</code></a></h3><ul><li><code>segs (v &quot;/a/b/&quot;) = [&quot;&quot;; &quot;a&quot;; &quot;b&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;/a/b&quot;) = [&quot;&quot;; &quot;a&quot;; &quot;b&quot;]</code></li><li><code>segs (v &quot;a/b/&quot;) = [&quot;a&quot;; &quot;b&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;a/b&quot;) = [&quot;a&quot;; &quot;b&quot;]</code></li><li><code>segs (v &quot;a&quot;) = [&quot;a&quot;]</code></li><li><code>segs (v &quot;/&quot;) = [&quot;&quot;; &quot;&quot;]</code></li><li><code>segs (v &quot;\\\\.\\dev\\&quot;) = [&quot;&quot;;&quot;&quot;]</code> (Windows)</li><li><code>segs (v &quot;\\\\server\\share\\a&quot;) = [&quot;&quot;;&quot;a&quot;]</code> (Windows)</li><li><code>segs (v &quot;C:a&quot;) = [&quot;a&quot;]</code> (Windows)</li><li><code>segs (v &quot;C:\\a&quot;) = [&quot;&quot;;&quot;a&quot;]</code> (Windows)</li></ul><h3 id="ex_is_dir_path"><a href="#ex_is_dir_path" class="anchor"></a><a href="#val-is_dir_path"><code>is_dir_path</code></a></h3><ul><li><code>is_dir_path (v &quot;.&quot;) = true</code></li><li><code>is_dir_path (v &quot;..&quot;) = true</code></li><li><code>is_dir_path (v &quot;../&quot;) = true</code></li><li><code>is_dir_path (v &quot;/&quot;) = true</code></li><li><code>is_dir_path (v &quot;/a/b/&quot;) = true</code></li><li><code>is_dir_path (v &quot;/a/b&quot;) = false</code></li><li><code>is_dir_path (v &quot;a/&quot;) = true</code></li><li><code>is_dir_path (v &quot;a&quot;) = false</code></li><li><code>is_dir_path (v &quot;a/.&quot;) = true</code></li><li><code>is_dir_path (v &quot;a/..&quot;) = true</code></li><li><code>is_dir_path (v &quot;a/..b&quot;) = false</code></li><li><code>is_dir_path (v &quot;C:\\&quot;) = true</code> (Windows)</li><li><code>is_dir_path (v &quot;C:a&quot;) = false</code> (Windows)</li></ul><h3 id="ex_is_file_path"><a href="#ex_is_file_path" class="anchor"></a><a href="#val-is_file_path"><code>is_file_path</code></a></h3><ul><li><code>is_file_path (v &quot;.&quot;) = false</code></li><li><code>is_file_path (v &quot;..&quot;) = false</code></li><li><code>is_file_path (v &quot;../&quot;) = false</code></li><li><code>is_file_path (v &quot;/&quot;) = false</code></li><li><code>is_file_path (v &quot;/a/b/&quot;) = false</code></li><li><code>is_file_path (v &quot;/a/b&quot;) = true</code></li><li><code>is_file_path (v &quot;a/&quot;) = false</code></li><li><code>is_file_path (v &quot;a&quot;) = true</code></li><li><code>is_file_path (v &quot;a/.&quot;) = false</code></li><li><code>is_file_path (v &quot;a/..&quot;) = false</code></li><li><code>is_file_path (v &quot;a/..b&quot;) = true</code></li><li><code>is_file_path (v &quot;C:\\&quot;) = false</code> (Windows)</li><li><code>is_file_path (v &quot;C:a&quot;) = true</code> (Windows)</li></ul><h3 id="ex_to_dir_path"><a href="#ex_to_dir_path" class="anchor"></a><a href="#val-to_dir_path"><code>to_dir_path</code></a></h3><ul><li><code>equal (to_dir_path @@ v &quot;.&quot;) (v &quot;./&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;..&quot;) (v &quot;../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;../&quot;) (v &quot;../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/a/b/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;/a/b&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/.&quot;) (v &quot;a/./&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/..&quot;) (v &quot;a/../&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;a/..b&quot;) (v &quot;a/..b/&quot;)</code></li><li><code>equal (to_dir_path @@ v &quot;\\\\server\\share\\&quot;) (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (to_dir_path @@ v &quot;C:a&quot;) (v &quot;C:a\\&quot;)</code> (Windows)</li><li><code>equal (to_dir_path @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li></ul><h3 id="ex_filename"><a href="#ex_filename" class="anchor"></a><a href="#val-filename"><code>filename</code></a></h3><ul><li><code>filename (v &quot;.&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;./&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;../&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;../..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/a/b/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;/a/b&quot;) = &quot;b&quot;</code></li><li><code>filename (v &quot;a/&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a&quot;) = &quot;a&quot;</code></li><li><code>filename (v &quot;a/.&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a/..&quot;) = &quot;&quot;</code></li><li><code>filename (v &quot;a/..b&quot;) = &quot;..b&quot;</code></li><li><code>filename (v &quot;C:\\&quot;) = &quot;&quot;</code> (Windows)</li><li><code>filename (v &quot;C:a&quot;) = &quot;a&quot;</code> (Windows)</li></ul><h3 id="ex_split_base"><a href="#ex_split_base" class="anchor"></a><a href="#val-split_base"><code>split_base</code></a></h3><ul><li><code>(split_base @@ v &quot;.&quot;) = (v &quot;./&quot;), (v &quot;.&quot;)</code></li><li><code>(split_base @@ v &quot;./&quot;) = (v &quot;./&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;..&quot;) = (v &quot;./&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;../&quot;) = (v &quot;./&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;../../&quot;) = (v &quot;../&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;.././&quot;) = (v &quot;../&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;../../../&quot;) = (v &quot;../../&quot;), (v &quot;../&quot;)</code></li><li><code>(split_base @@ v &quot;/&quot;) = (v &quot;/&quot;), (v &quot;./&quot;)</code></li><li><code>(split_base @@ v &quot;/a/b/&quot;) = (v &quot;/a/&quot;), (v &quot;b/&quot;)</code></li><li><code>(split_base @@ v &quot;/a/b&quot;) = (v &quot;/a/&quot;), (v &quot;b&quot;)</code></li><li><code>(split_base @@ v &quot;a/&quot;) = (v &quot;./&quot;), (v &quot;a/&quot;)</code></li><li><code>(split_base @@ v &quot;a&quot;) = (v &quot;./&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;a/b&quot;) = (v &quot;a/&quot;), (v &quot;b&quot;)</code></li><li><code>(split_base @@ v &quot;a/b/&quot;) = (v &quot;a/b/&quot;), (v &quot;b/&quot;)</code></li><li><code>(split_base @@ v &quot;a/.&quot;) = (v &quot;a/&quot;), (v &quot;.&quot;)</code></li><li><code>(split_base @@ v &quot;a/..&quot;) = (v &quot;a/&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;a/../..&quot;) = (v &quot;a/../&quot;), (v &quot;..&quot;)</code></li><li><code>(split_base @@ v &quot;a/..b&quot;) = (v &quot;a/&quot;), (v &quot;..b&quot;)</code></li><li><code>(split_base @@ v &quot;./a&quot;) = (v &quot;./&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;./a/&quot;) = (v &quot;./&quot;), (v &quot;a/&quot;)</code></li><li><code>(split_base @@ v &quot;../a&quot;) = (v &quot;../&quot;), (v &quot;a&quot;)</code></li><li><code>(split_base @@ v &quot;../a/&quot;) = (v &quot;../&quot;), (v &quot;a/&quot;)</code></li></ul><h3 id="ex_basename"><a href="#ex_basename" class="anchor"></a><a href="#val-basename"><code>basename</code></a></h3><ul><li><code>basename (v &quot;.&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;..&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;../&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;../../&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;/a/b/&quot;) = &quot;b&quot;</code></li><li><code>basename (v &quot;/a/b&quot;) = &quot;b&quot;</code></li><li><code>basename (v &quot;a/&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;a/.&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/./&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/..&quot;) = &quot;&quot;</code></li><li><code>basename (v &quot;a/..b&quot;) = &quot;..b&quot;</code></li><li><code>basename (v &quot;./a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;../a&quot;) = &quot;a&quot;</code></li><li><code>basename (v &quot;C:\\&quot;) = &quot;&quot;</code> (Windows)</li><li><code>basename (v &quot;C:a&quot;) = &quot;a&quot;</code> (Windows)</li></ul><h3 id="ex_parent"><a href="#ex_parent" class="anchor"></a><a href="#val-parent"><code>parent</code></a></h3><ul><li><code>equal (parent @@ v &quot;.&quot;) (v &quot;./../&quot;)</code></li><li><code>equal (parent @@ v &quot;..&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;../&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;../../&quot;) (v &quot;../../../&quot;)</code></li><li><code>equal (parent @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (parent @@ v &quot;/a/b/&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (parent @@ v &quot;/a/b&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (parent @@ v &quot;a/&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;a&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;a/.&quot;) (v &quot;a/./../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/./&quot;) (v &quot;a/./../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/..&quot;) (v &quot;a/../../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/../&quot;) (v &quot;a/../../&quot;)</code></li><li><code>equal (parent @@ v &quot;a/..b&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (parent @@ v &quot;./a&quot;) (v &quot;./&quot;)</code></li><li><code>equal (parent @@ v &quot;../a&quot;) (v &quot;../&quot;)</code></li><li><code>equal (parent @@ v &quot;../../a&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (parent @@ v &quot;\\\\server\\share\\&quot;) (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (parent @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (parent @@ v &quot;C:a&quot;) (v &quot;C:.\\&quot;)</code> (Windows)</li></ul><h3 id="ex_rem_empty_seg"><a href="#ex_rem_empty_seg" class="anchor"></a><a href="#val-rem_empty_seg"><code>rem_empty_seg</code></a></h3><ul><li><code>equal (rem_empty_seg @@ v &quot;.&quot;) (v &quot;.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;..&quot;) (v &quot;..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../&quot;) (v &quot;..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../../&quot;) (v &quot;../..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/a/b/&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/&quot;) (v &quot;a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/.&quot;) (v &quot;a/.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/./&quot;) (v &quot;a/.&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/..&quot;) (v &quot;a/..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/../&quot;) (v &quot;a/..&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;a/..b&quot;) (v &quot;a/..b&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;./a&quot;) (v &quot;./a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../a&quot;) (v &quot;../a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;../../a&quot;) (v &quot;../../a&quot;)</code></li><li><code>equal (rem_empty_seg @@ v &quot;\\\\server\\share\\&quot;) (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (rem_empty_seg @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (rem_empty_seg @@ v &quot;C:a\\&quot;) (v &quot;C:a&quot;)</code> (Windows)</li></ul><h3 id="ex_normalize"><a href="#ex_normalize" class="anchor"></a><a href="#val-normalize"><code>normalize</code></a></h3><ul><li><code>equal (normalize @@ v &quot;.&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;..&quot;) (v &quot;../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../&quot;) (v &quot;../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (normalize @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/.&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/./&quot;) (v &quot;a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/..&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/../&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;a/..b&quot;) (v &quot;a/..b&quot;)</code></li><li><code>equal (normalize @@ v &quot;./a&quot;) (v &quot;a&quot;)</code></li><li><code>equal (normalize @@ v &quot;../a&quot;) (v &quot;../a&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../a&quot;) (v &quot;../../a&quot;)</code></li><li><code>equal (normalize @@ v &quot;./a/..&quot;) (v &quot;./&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/./..&quot;) (v &quot;/a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/../..&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/../..&quot;) (v &quot;/&quot;)</code></li><li><code>equal (normalize @@ v &quot;./../..&quot;) (v &quot;../../&quot;)</code></li><li><code>equal (normalize @@ v &quot;../../a/&quot;) (v &quot;../../a/&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/c/./../../g&quot;) (v &quot;/a/g&quot;)</code></li><li><code>equal (normalize @@ v &quot;/a/b/c/./../../g/&quot;) (v &quot;/a/g/&quot;)</code></li><li><code>equal (normalize @@ v &quot;\\\\?\\UNC\\server\\share\\..&quot;) (v &quot;\\\\?\\UNC\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;\\\\server\\share\\&quot;) (v &quot;\\\\server\\share\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;C:\\&quot;) (v &quot;C:\\&quot;)</code> (Windows)</li><li><code>equal (normalize @@ v &quot;C:a\\&quot;) (v &quot;C:a\\&quot;)</code> (Windows)</li></ul><h3 id="ex_is_prefix"><a href="#ex_is_prefix" class="anchor"></a><a href="#val-is_prefix"><code>is_prefix</code></a></h3><ul><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/b&quot;) = true</code></li><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/bc&quot;) = false</code></li><li><code>is_prefix (v &quot;/a/b&quot;) (v &quot;/a/b/&quot;) = true</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c&quot;) = true</code></li><li><code>is_prefix (v &quot;.&quot;) (v &quot;./&quot;) = true</code></li><li><code>is_prefix (v &quot;..&quot;) (v &quot;.&quot;) = false</code></li><li><code>is_prefix (v &quot;C:a&quot;) (v &quot;a&quot;) = false</code> (Windows)</li></ul><h3 id="ex_find_prefix"><a href="#ex_find_prefix" class="anchor"></a><a href="#val-find_prefix"><code>find_prefix</code></a></h3><ul><li><code>find_prefix (v &quot;a/b/c&quot;) (v &quot;a/b/d&quot;)</code> is <code>Some (v &quot;a/b/&quot;)</code></li><li><code>find_prefix (v &quot;a/b/c&quot;) (v &quot;a/b/cd&quot;)</code> is <code>Some (v &quot;a/b/&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>Some (v &quot;a/b&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some (v &quot;a/b&quot;)</code></li><li><code>find_prefix (v &quot;a/b&quot;) (v &quot;e/f&quot;)</code> is <code>None</code></li><li><code>find_prefix (v &quot;/a/b&quot;) (v &quot;/e/f&quot;)</code> is <code>Some (v &quot;/&quot;)</code></li><li><code>find_prefix (v &quot;/a/b&quot;) (v &quot;e/f&quot;)</code> is <code>None</code></li><li><code>find_prefix (v &quot;C:\\a&quot;) (v &quot;\\a&quot;)</code> is <code>None</code> (Windows)</li></ul><h3 id="ex_rem_prefix"><a href="#ex_rem_prefix" class="anchor"></a><a href="#val-rem_prefix"><code>rem_prefix</code></a></h3><ul><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>None</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some &quot;./&quot;</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>rem_prefix (v &quot;a/b&quot;) (v &quot;a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>rem_prefix (v &quot;a/b/&quot;) (v &quot;a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>rem_prefix (v &quot;C:\\a&quot;) (v &quot;C:\\a\\b&quot;)</code> is <code>Some (v &quot;b&quot;)</code> (Windows)</li></ul><h3 id="ex_relativize"><a href="#ex_relativize" class="anchor"></a><a href="#val-relativize"><code>relativize</code></a></h3><ul><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;c&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/c/&quot;)</code> is <code>Some (v &quot;c/&quot;)</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;/a/b&quot;) (v &quot;/a/b/&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;/c&quot;)</code> is <code>None</code>.</li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;c&quot;)</code> is <code>Some (v &quot;../../c&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;c/&quot;)</code> is <code>Some (v &quot;../../c/&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b/c&quot;)</code> is <code>Some (v &quot;c&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;a/b&quot;) (v &quot;a/b/&quot;)</code> is <code>Some (v &quot;.&quot;)</code></li><li><code>relativize ~root:(v &quot;../&quot;) (v &quot;./&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;../b/c&quot;)</code> is <code>Some (v &quot;../b/c&quot;)</code></li><li><code>relativize ~root:(v &quot;../../a&quot;) (v &quot;../b&quot;)</code> is <code>None</code></li><li><code>relativize ~root:(v &quot;../a&quot;) (v &quot;../../b&quot;)</code> is <code>(Some &quot;../../b&quot;)</code></li></ul><h3 id="ex_is_rooted"><a href="#ex_is_rooted" class="anchor"></a><a href="#val-is_rooted"><code>is_rooted</code></a></h3><ul><li><code>is_rooted ~root:(v &quot;a/b&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;a/b&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;a/b/&quot;) (v &quot;a/b&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;a/b/&quot;) (v &quot;a/b/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a/&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;a/../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;./&quot;) (v &quot;..&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;./&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;a&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;../&quot;) (v &quot;../a&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;../a&quot;) (v &quot;./&quot;) = false</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/a/..&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/a/../&quot;) = true</code></li><li><code>is_rooted ~root:(v &quot;/a&quot;) (v &quot;/..&quot;) = true</code></li></ul><h3 id="ex_is_root"><a href="#ex_is_root" class="anchor"></a><a href="#val-is_root"><code>is_root</code></a></h3><ul><li><code>is_root (v &quot;/&quot;) = true</code></li><li><code>is_root (v &quot;/a&quot;) = false</code></li><li><code>is_root (v &quot;/a/..&quot;) = false</code></li><li><code>is_root (v &quot;//&quot;) = true</code> (POSIX)</li><li><code>is_root (v &quot;\\\\.\\dev\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;\\\\.\\dev\\a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;\\\\server\\share\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;\\\\server\\share\\a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;C:\\&quot;) = true</code> (Windows)</li><li><code>is_root (v &quot;C:a&quot;) = false</code> (Windows)</li><li><code>is_root (v &quot;C:\\a&quot;) = false</code> (Windows)</li></ul><h3 id="ex_get_ext"><a href="#ex_get_ext" class="anchor"></a><a href="#val-get_ext"><code>get_ext</code></a></h3><ul><li><code>get_ext (v &quot;/&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/..&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/...&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/b.&quot;) = &quot;.&quot;</code></li><li><code>get_ext (v &quot;a/b.mli&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext ~multi:true (v &quot;a/b.mli&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext (v &quot;a/b.mli/&quot;) = &quot;.mli&quot;</code></li><li><code>get_ext (v &quot;a/.ocamlinit&quot;) = &quot;&quot;</code></li><li><code>get_ext (v &quot;a/.emacs.d&quot;) = &quot;.d&quot;</code></li><li><code>get_ext (v &quot;a/.emacs.d/&quot;) = &quot;.d&quot;</code></li><li><code>get_ext ~multi:true (v &quot;a/.emacs.d&quot;) = &quot;.d&quot;</code></li><li><code>get_ext (v &quot;a.tar.gz&quot;) = &quot;.gz&quot;</code></li><li><code>get_ext ~multi:true  (v &quot;a.tar.gz&quot;) = &quot;.tar.gz&quot;</code></li></ul><h3 id="ex_has_ext"><a href="#ex_has_ext" class="anchor"></a><a href="#val-has_ext"><code>has_ext</code></a></h3><ul><li><code>has_ext &quot;mli&quot; (v &quot;a/b.mli&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/b.mli&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/b.mli/&quot;) = true</code></li><li><code>has_ext &quot;.mli&quot; (v &quot;a/bmli&quot;) = false</code></li><li><code>has_ext &quot;mli&quot; (v &quot;a/bmli&quot;) = false</code></li><li><code>has_ext &quot;.tar.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;tar.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;.gz&quot; (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>has_ext &quot;.tar&quot; (v &quot;a/f.tar.gz&quot;) = false</code></li><li><code>has_ext &quot;.cache&quot; (v &quot;a/.cache&quot;) = false</code></li><li><code>has_ext &quot;&quot; (v &quot;a/b&quot;) = false</code></li><li><code>has_ext &quot;&quot; (v &quot;a/b.&quot;) = true</code></li><li><code>has_ext &quot;.&quot; (v &quot;a/b.&quot;) = true</code></li></ul><h3 id="ex_exists_ext"><a href="#ex_exists_ext" class="anchor"></a><a href="#val-exists_ext"><code>exists_ext</code></a></h3><ul><li><code>exists_ext (v &quot;a/f&quot;) = false</code></li><li><code>exists_ext (v &quot;a/f.&quot;) = true</code></li><li><code>exists_ext (v &quot;a/f.gz&quot;) = true</code></li><li><code>exists_ext ~multi:true (v &quot;a/f.gz&quot;) = false</code></li><li><code>exists_ext (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>exists_ext ~multi:true (v &quot;a/f.tar.gz&quot;) = true</code></li><li><code>exists_ext (v &quot;a/f.tar.gz/&quot;) = true</code></li><li><code>exists_ext (v &quot;.emacs.d&quot;) = true</code></li><li><code>exists_ext (v &quot;.emacs.d/&quot;) = true</code></li><li><code>exists_ext (v &quot;.ocamlinit&quot;) = false</code></li></ul><h3 id="ex_add_ext"><a href="#ex_add_ext" class="anchor"></a><a href="#val-add_ext"><code>add_ext</code></a></h3><ul><li><code>equal (add_ext &quot;mli&quot; (v &quot;a/b&quot;)) (v &quot;a/b.mli&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b&quot;)) (v &quot;a/b.mli&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b/&quot;)) (v &quot;a/b.mli/&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;/&quot;)) (v &quot;/&quot;)</code></li><li><code>equal (add_ext &quot;.mli&quot; (v &quot;a/b/..&quot;)) (v &quot;a/b/..&quot;)</code></li><li><code>equal (add_ext &quot;.&quot; (v &quot;a/b&quot;)) (v &quot;a/b.&quot;)</code></li><li><code>equal (add_ext &quot;&quot; (v &quot;a/b&quot;)) (v &quot;a/b&quot;)</code></li><li><code>equal (add_ext &quot;tar.gz&quot; (v &quot;a/f&quot;)) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;.tar.gz&quot; (v &quot;a/f&quot;)) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;gz&quot; (v &quot;a/f.tar&quot;) ) (v &quot;a/f.tar.gz&quot;)</code></li><li><code>equal (add_ext &quot;.gz&quot; (v &quot;a/f.tar&quot;) ) (v &quot;a/f.tar.gz&quot;)</code></li></ul><h3 id="ex_rem_ext"><a href="#ex_rem_ext" class="anchor"></a><a href="#val-rem_ext"><code>rem_ext</code></a></h3><ul><li><code>equal (rem_ext @@ v &quot;/&quot;) (v &quot;/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli&quot;) (v &quot;/a/b&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/&quot;) (v &quot;/a/b/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/..&quot;) (v &quot;/a/b.mli/..&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;/a/b.mli/.&quot;) (v &quot;/a/b.mli/.&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.ocamlinit&quot;) (v &quot;a/.ocamlinit&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.emacs.d&quot;) (v &quot;a/.emacs&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;a/.emacs.d/&quot;) (v &quot;a/.emacs/&quot;)</code></li><li><code>equal (rem_ext @@ v &quot;f.tar.gz&quot;) (v &quot;f.tar&quot;)</code></li><li><code>equal (rem_ext ~multi:true @@ v &quot;f.tar.gz&quot;) (v &quot;f&quot;)</code></li><li><code>equal (rem_ext ~multi:true @@ v &quot;f.tar.gz/&quot;) (v &quot;f/&quot;)</code></li></ul></div></body></html>
