<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (ocamlgraph.ocamlgraph.Graph.Merge.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../../';
let search_urls = ['../../../../sherlodoc_db.js','../../../../../sherlodoc.js'];
</script><script src="../../../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../../../index.html">üè†</a> &#x00BB; <a href="../../../../index.html">ocamlgraph</a> &#x00BB; Library <code>ocamlgraph</code> &#x00BB; <a href="../../index.html">Graph</a> &#x00BB; <a href="../index.html">Merge</a> &#x00BB; S</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module type <code><span>Merge.S</span></code><a href="../../../../src/ocamlgraph/merge.ml.html#module-type-S" class="source_link">Source</a></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../../../index.html">ocamlgraph</a><ul><li>Library <code>ocamlgraph</code><ul><li><a href="../../index.html">Graph</a><ul><li><a href="../../Sig/index.html">Sig</a></li><li><a href="../../Sig_pack/index.html">Sig_pack</a></li><li><a href="../../Dot_ast/index.html">Dot_ast</a></li><li><a href="../../Util/index.html">Util</a></li><li><a href="../../Blocks/index.html">Blocks</a></li><li><a href="../../Persistent/index.html">Persistent</a></li><li><a href="../../Imperative/index.html">Imperative</a></li><li><a href="../../Delaunay/index.html">Delaunay</a></li><li><a href="../../Builder/index.html">Builder</a></li><li><a href="../../Classic/index.html">Classic</a></li><li><a href="../../Rand/index.html">Rand</a></li><li><a href="../../Oper/index.html">Oper</a></li><li><a href="../../Components/index.html">Components</a></li><li><a href="../../Path/index.html">Path</a></li><li><a href="../../Cycles/index.html">Cycles</a></li><li><a href="../../Nonnegative/index.html">Nonnegative</a></li><li><a href="../../Traverse/index.html">Traverse</a></li><li><a href="../../Coloring/index.html">Coloring</a></li><li><a href="../../Topological/index.html">Topological</a></li><li><a href="../../Kruskal/index.html">Kruskal</a></li><li><a href="../../Flow/index.html">Flow</a></li><li><a href="../../Prim/index.html">Prim</a></li><li><a href="../../Dominator/index.html">Dominator</a></li><li><a href="../../Graphviz/index.html">Graphviz</a></li><li><a href="../../Gml/index.html">Gml</a></li><li><a href="../../Dot/index.html">Dot</a></li><li><a href="../../Pack/index.html">Pack</a></li><li><a href="../../Gmap/index.html">Gmap</a></li><li><a href="../../Minsep/index.html">Minsep</a></li><li><a href="../../Cliquetree/index.html">Cliquetree</a></li><li><a href="../../Mcs_m/index.html">Mcs_m</a></li><li><a href="../../Md/index.html">Md</a></li><li><a href="../../Strat/index.html">Strat</a></li><li><a href="../../Fixpoint/index.html">Fixpoint</a></li><li><a href="../../Leaderlist/index.html">Leaderlist</a></li><li><a href="../../Contraction/index.html">Contraction</a></li><li><a href="../../Graphml/index.html">Graphml</a></li><li><a href="../index.html">Merge</a><ul><li><a href="#" class="current_unit">S</a></li><li><a href="../B/index.html">B</a></li><li><a href="../P/index.html">P</a></li><li><a href="../I/index.html">I</a></li></ul></li><li><a href="../../Mincut/index.html">Mincut</a></li><li><a href="../../Clique/index.html">Clique</a></li><li><a href="../../WeakTopological/index.html">WeakTopological</a></li><li><a href="../../ChaoticIteration/index.html">ChaoticIteration</a></li><li><a href="../../XDotDraw/index.html">XDotDraw</a></li><li><a href="../../XDot/index.html">XDot</a></li><li><a href="../../DGraphModel/index.html">DGraphModel</a></li><li><a href="../../DGraphTreeLayout/index.html">DGraphTreeLayout</a></li><li><a href="../../DGraphSubTree/index.html">DGraphSubTree</a></li><li><a href="../../DGraphTreeModel/index.html">DGraphTreeModel</a></li><li><a href="../../DGraphRandModel/index.html">DGraphRandModel</a></li></ul></li></ul></li><li><a href="../../../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-graph"><a href="#type-graph" class="anchor"></a><code><span><span class="keyword">type</span> graph</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-vertex"><a href="#type-vertex" class="anchor"></a><code><span><span class="keyword">type</span> vertex</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-edge"><a href="#type-edge" class="anchor"></a><code><span><span class="keyword">type</span> edge</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-edge_label"><a href="#type-edge_label" class="anchor"></a><code><span><span class="keyword">type</span> edge_label</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_vertex"><a href="#val-merge_vertex" class="anchor"></a><code><span><span class="keyword">val</span> merge_vertex : <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-vertex">vertex</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>If no element of <code>vl</code> belongs to <code>g</code> then <code>merge_vertex g (v::vl)</code> is the graph <code>g</code>. Otherwise the collection of vertices of <code>merge_vertex g (v::vl)</code> is the collection of vertices of <code>g</code> from which all the elements of <code>vl</code> were removed and to which <code>v</code> was added. Any edge of <code>merge_vertex g (v::vl)</code> is an edge of <code>g</code> whose source (destination) was changed to <code>v</code> if it belongs to <code>vl</code>. The function <code>merge_vertex</code> always returns a graph with a smaller collection of vertices and a smaller collection of edges (in the weak sense). However the labels appearing in <code>merge_vertex g v::vl</code> are exactly the ones appearing in <code>g</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_edges_e"><a href="#val-merge_edges_e" class="anchor"></a><code><span><span class="keyword">val</span> merge_edges_e : <span><span class="optlabel">?src</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?dst</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-edge">edge</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>If no element of <code>el</code> belongs to <code>g</code> then <code>merge_edges_e g (e::el)</code> is the graph <code>g</code>. Otherwise the collection of vertices of <code>merge_edges_e g (e::el)</code> is precisely the collection of vertices of <code>g</code> from which the sources and the destinations of all the elements of <code>el</code> were removed and to which the vertices <code>v</code> and <code>w</code> were added. If <code>dst</code> was provided then <code>v</code> is <code>src</code> otherwise it is the source of <code>e</code>. If <code>dst</code> was provided then <code>w</code> is <code>y</code> otherwise it is the destination of <code>e</code>. The collection of edges of <code>merge_edges_e g e::el</code> is precisely the collection of edges of <code>g</code> from which all the elements of <code>el</code> were removed and to which an edge from <code>v</code> to <code>w</code> sharing the label of <code>e</code> was added; the edges of <code>g</code> being understood up to the fact their source and destination were updated. Note <code>v=w</code> if and only if the source of some element of <code>el</code> matches the destination of some element of <code>el</code> (possibly the same).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_edges_with_label"><a href="#val-merge_edges_with_label" class="anchor"></a><code><span><span class="keyword">val</span> merge_edges_with_label : 
  <span><span class="optlabel">?src</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?dst</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?label</span>:<a href="#type-edge_label">edge_label</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-edge_label">edge_label</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>The graph <code>merge_edges_with_label ?src ?tgt ?label g l</code> is the graph <code>merge_edges_e ?src ?dst g el</code> with <code>el</code> being the list of all edges of <code>g</code> carrying the label <code>l</code>. If the optional value <code>label</code> is provided then the edge to which all the elements of <code>el</code> are identified carries the label <code>label</code>. Otherwise it carries the label <code>l</code>. In particular <code>merge_edges_with_label ?src ?tgt ?label g l</code> is the graph <code>g</code> if and only if there is at most one edge of <code>g</code> carrying the label <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_isolabelled_edges"><a href="#val-merge_isolabelled_edges" class="anchor"></a><code><span><span class="keyword">val</span> merge_isolabelled_edges : <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>The graph <code>merge_isolabelled_edges g</code> is obtained from <code>g</code> by identifying two vertices when they are the sources (destinations) of two edges sharing the same label. Therefore two distinct edges of the returned graph cannot carry the same label. In particular if all the edges share the same label then the returned graph is either empty (if <code>g</code> is so) or a single vertex (if <code>g</code> has no edge and at least one vertex) or a single vertex and a single edge (if <code>g</code> has both a vertex and an edge). A label is carried by some edge of <code>merge_isolabelled_edges g</code> if and only if it is carried by some edge of <code>g</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_ends"><a href="#val-merge_ends" class="anchor"></a><code><span><span class="keyword">val</span> merge_ends : <span><span class="optlabel">?strict</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?specified_vertex</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>A vertex <code>v</code> of <code>g</code> is called an end if every edge of <code>g</code> arriving to <code>v</code> also starts from <code>v</code>. It is called a strict end if no edge of <code>g</code> arrives to it. The graph <code>merge_ends g</code> is the graph <code>merge_vertex vl</code> where <code>vl</code> is the list of (strict) ends of <code>g</code>. The vertex substituted to the ends can be specified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_starts"><a href="#val-merge_starts" class="anchor"></a><code><span><span class="keyword">val</span> merge_starts : <span><span class="optlabel">?strict</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?specified_vertex</span>:<a href="#type-vertex">vertex</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>A vertex <code>v</code> of <code>g</code> is called a start if every edge of <code>g</code> starting from <code>v</code> also arrives to <code>v</code>. It is called a strict start if no edge of <code>g</code> starts from it. The graph <code>merge_starts g</code> is the graph <code>merge_vertex vl</code> where <code>vl</code> is the list of (strict) starts of <code>g</code>. The vertex substituted to the starts can be specified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_scc"><a href="#val-merge_scc" class="anchor"></a><code><span><span class="keyword">val</span> merge_scc : 
  <span><span class="optlabel">?loop_killer</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?specified_vertex</span>:<span>(<span><span><a href="#type-vertex">vertex</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-vertex">vertex</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-graph">graph</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-graph">graph</a></span></code></div><div class="spec-doc"><p>The vertex of every strongly connected component are identified. If the option <code>loop_killer</code> is set to <code>true</code> then all the edges between identified vertices are removed. The option <code>specified_vertex</code> allows to choose the vertex that replaces the elements of a strongly connected component.</p></div></div></div></body></html>
