<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sedlexing (sedlex.sedlex.Sedlexing)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../sherlodoc_db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../../index.html">Up</a> ‚Äì <a href="../../../index.html">üè†</a> &#x00BB; <a href="../../index.html">sedlex</a> &#x00BB; Library <code>sedlex</code> &#x00BB; Sedlexing</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Sedlexing</span></code><a href="../../src/sedlex/sedlexing.ml.html" class="source_link">Source</a></h1><p>Runtime support for lexers generated by <code>sedlex</code>.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#creating-generic-lexbufs">Creating generic lexbufs</a></li><li><a href="#interface-for-lexers-semantic-actions">Interface for lexers semantic actions</a></li><li><a href="#internal-interface">Internal interface</a></li><li><a href="#support-for-common-encodings">Support for common encodings</a></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../index.html">sedlex</a><ul><li>Library <code>sedlex</code><ul><li><a href="#" class="current_unit">Sedlexing</a><ul><li><a href="Latin1/index.html">Latin1</a></li><li><a href="Utf8/index.html">Utf8</a></li><li><a href="Utf16/index.html">Utf16</a></li></ul></li></ul></li><li>Library <code>sedlex.ppx</code><ul><li><a href="../../sedlex.ppx/Sedlex_ppx/index.html">Sedlex_ppx</a></li></ul></li><li>Library <code>sedlex.utils</code><ul><li><a href="../../sedlex.utils/Sedlex_utils/index.html">Sedlex_utils</a></li></ul></li><li><a href="../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><p>This module is roughly equivalent to the module Lexing from the OCaml standard library, except that its lexbuffers handle Unicode code points (OCaml type: <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t"><code>Uchar.t</code></a> in the range <code>0..0x10ffff</code>) instead of bytes (OCaml type: <code>char</code>).</p><p>It is possible to have sedlex-generated lexers work on a custom implementation for lex buffers. To do this, define a module <code>L</code> which implements the <code>start</code>, <code>next</code>, <code>mark</code> and <code>backtrack</code> functions (See the Internal Interface section below for a specification). They need not work on a type named <code>lexbuf</code>: you can use the type name you want. Then, just do in your sedlex-processed source, bind this module to the name <code>Sedlexing</code> (for instance, with a local module definition: <code>let module Sedlexing = L in ...</code>.</p><p>Of course, you'll probably want to define functions like <code>lexeme</code> to be used in the lexers semantic actions.</p><div class="odoc-spec"><div class="spec type anchored" id="type-lexbuf"><a href="#type-lexbuf" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#type-lexbuf" class="source_link">Source</a><code><span><span class="keyword">type</span> lexbuf</span></code></div><div class="spec-doc"><p>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated lexers. The lexer buffer holds the internal information for the scanners, including the code points of the token currently scanned, its position from the beginning of the input stream, and the current position of the lexer.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-InvalidCodepoint"><a href="#exception-InvalidCodepoint" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#exception-InvalidCodepoint" class="source_link">Source</a><code><span><span class="keyword">exception</span> </span><span><span class="exception">InvalidCodepoint</span> <span class="keyword">of</span> int</span></code></div><div class="spec-doc"><p>Raised by some functions to signal that some code point is not compatible with a specified encoding.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-MalFormed"><a href="#exception-MalFormed" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#exception-MalFormed" class="source_link">Source</a><code><span><span class="keyword">exception</span> </span><span><span class="exception">MalFormed</span></span></code></div><div class="spec-doc"><p>Raised by functions in the <code>Utf8</code> and <code>Utf16</code> modules to report strings which do not comply to the encoding.</p></div></div><h6 id="creating-generic-lexbufs"><a href="#creating-generic-lexbufs" class="anchor"></a>Creating generic lexbufs</h6><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-create" class="source_link">Source</a><code><span><span class="keyword">val</span> create : 
  <span><span class="optlabel">?bytes_per_char</span>:<span>(<span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-lexbuf">lexbuf</a></span></code></div><div class="spec-doc"><p>Create a generic lexer buffer. When the lexer needs more characters, it will call the given function, giving it an array of Uchars <code>a</code>, a position <code>pos</code> and a code point count <code>n</code>. The function should put <code>n</code> code points or less in <code>a</code>, starting at position <code>pos</code>, and return the number of characters provided. A return value of 0 means end of input. <code>bytes_per_char</code> argument is optional. If unspecified, byte positions are the same as code point position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_position"><a href="#val-set_position" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-set_position" class="source_link">Source</a><code><span><span class="keyword">val</span> set_position : 
  <span><span class="optlabel">?bytes_position</span>:<a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>set the initial tracked input position, in code point, for <code>lexbuf</code>. If unspecified, byte postion is set to the same value as code point position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_filename"><a href="#val-set_filename" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-set_filename" class="source_link">Source</a><code><span><span class="keyword">val</span> set_filename : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_filename lexbuf file</code> sets the filename to <code>file</code> in <code>lexbuf</code>. It also sets the <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position.pos_fname"><code>Lexing.position.pos_fname</code></a> field in returned <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position"><code>Lexing.position</code></a> records.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_gen"><a href="#val-from_gen" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-from_gen" class="source_link">Source</a><code><span><span class="keyword">val</span> from_gen : <span><span class="optlabel">?bytes_per_char</span>:<span>(<span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <a href="../../../gen/gen/Gen/index.html#type-t">Gen.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lexbuf">lexbuf</a></span></code></div><div class="spec-doc"><p>Create a lexbuf from a stream of Unicode code points. <code>bytes_per_char</code> is optional. If unspecified, byte positions are the same as code point positions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_int_array"><a href="#val-from_int_array" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-from_int_array" class="source_link">Source</a><code><span><span class="keyword">val</span> from_int_array : <span><span class="optlabel">?bytes_per_char</span>:<span>(<span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>int array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lexbuf">lexbuf</a></span></code></div><div class="spec-doc"><p>Create a lexbuf from an array of Unicode code points. <code>bytes_per_char</code> is optional. If unspecified, byte positions are the same as code point positions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_uchar_array"><a href="#val-from_uchar_array" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-from_uchar_array" class="source_link">Source</a><code><span><span class="keyword">val</span> from_uchar_array : 
  <span><span class="optlabel">?bytes_per_char</span>:<span>(<span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-lexbuf">lexbuf</a></span></code></div><div class="spec-doc"><p>Create a lexbuf from an array of Unicode code points. <code>bytes_per_char</code> is optional. If unspecified, byte positions are the same as code point positions.</p></div></div><h6 id="interface-for-lexers-semantic-actions"><a href="#interface-for-lexers-semantic-actions" class="anchor"></a>Interface for lexers semantic actions</h6><p>The following functions can be called from the semantic actions of lexer definitions. They give access to the character string matched by the regular expression associated with the semantic action.</p><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_start"><a href="#val-lexeme_start" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_start" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_start : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_start lexbuf</code> returns the offset in the input stream of the first code point of the matched string. The first code point of the stream has offset 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_bytes_start"><a href="#val-lexeme_bytes_start" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_bytes_start" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_bytes_start : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_start lexbuf</code> returns the offset in the input stream of the first byte of the matched string. The first code point of the stream has offset 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_end"><a href="#val-lexeme_end" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_end" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_end : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_end lexbuf</code> returns the offset in the input stream of the character following the last code point of the matched string. The first character of the stream has offset 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_bytes_end"><a href="#val-lexeme_bytes_end" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_bytes_end" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_bytes_end : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_end lexbuf</code> returns the offset in the input stream of the byte following the last code point of the matched string. The first character of the stream has offset 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-loc"><a href="#val-loc" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-loc" class="source_link">Source</a><code><span><span class="keyword">val</span> loc : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>Sedlexing.loc lexbuf</code> returns the pair <code>(Sedlexing.lexeme_start lexbuf,Sedlexing.lexeme_end lexbuf)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes_loc"><a href="#val-bytes_loc" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-bytes_loc" class="source_link">Source</a><code><span><span class="keyword">val</span> bytes_loc : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>Sedlexing.bytes_loc lexbuf</code> returns the pair <code>(Sedlexing.lexeme_bytes_start lexbuf,Sedlexing.lexeme_bytes_end lexbuf)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_length"><a href="#val-lexeme_length" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_length" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_length : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_length lexbuf</code> returns the difference <code>(Sedlexing.lexeme_end lexbuf) - (Sedlexing.lexeme_start lexbuf)</code>, that is, the length (in code points) of the matched string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_bytes_length"><a href="#val-lexeme_bytes_length" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_bytes_length" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_bytes_length : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_length lexbuf</code> returns the difference <code>(Sedlexing.lexeme_bytes_end lexbuf) - (Sedlexing.lexeme_bytes_start lexbuf)</code>, that is, the length (in bytes) of the matched string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexing_positions"><a href="#val-lexing_positions" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexing_positions" class="source_link">Source</a><code><span><span class="keyword">val</span> lexing_positions : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> * <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a></span></code></div><div class="spec-doc"><p><code>Sedlexing.lexing_positions lexbuf</code> returns the start and end positions, in code points, of the current token, using a record of type <code>Lexing.position</code>. This is intended for consumption by parsers like those generated by <code>Menhir</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexing_bytes_positions"><a href="#val-lexing_bytes_positions" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexing_bytes_positions" class="source_link">Source</a><code><span><span class="keyword">val</span> lexing_bytes_positions : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> * <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a></span></code></div><div class="spec-doc"><p><code>Sedlexing.lexing_bytes_positions lexbuf</code> returns the start and end positions, in bytes, of the current token, using a record of type <code>Lexing.position</code>. This is intended for consumption by parsers like those generated by <code>Menhir</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-new_line"><a href="#val-new_line" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-new_line" class="source_link">Source</a><code><span><span class="keyword">val</span> new_line : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Sedlexing.new_line lexbuf</code> increments the line count and sets the beginning of line to the current position, as though a newline character had been encountered in the input.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme"><a href="#val-lexeme" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> array</span></span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme lexbuf</code> returns the string matched by the regular expression as an array of Unicode code point.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lexeme_char"><a href="#val-lexeme_char" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-lexeme_char" class="source_link">Source</a><code><span><span class="keyword">val</span> lexeme_char : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a></span></code></div><div class="spec-doc"><p><code>Sedlexing.lexeme_char lexbuf pos</code> returns code point number <code>pos</code> in the matched string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_lexeme"><a href="#val-sub_lexeme" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-sub_lexeme" class="source_link">Source</a><code><span><span class="keyword">val</span> sub_lexeme : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> array</span></span></code></div><div class="spec-doc"><p><code>Sedlexing.sub_lexeme lexbuf pos len</code> returns a substring of the string matched by the regular expression as an array of Unicode code point.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rollback"><a href="#val-rollback" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-rollback" class="source_link">Source</a><code><span><span class="keyword">val</span> rollback : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>Sedlexing.rollback lexbuf</code> puts <code>lexbuf</code> back in its configuration before the last lexeme was matched. It is then possible to use another lexer to parse the same characters again. The other functions above in this section should not be used in the semantic action after a call to <code>Sedlexing.rollback</code>.</p></div></div><h6 id="internal-interface"><a href="#internal-interface" class="anchor"></a>Internal interface</h6><p>These functions are used internally by the lexers. They could be used to write lexers by hand, or with a lexer generator different from <code>sedlex</code>. The lexer buffers have a unique internal slot that can store an integer. They also store a &quot;backtrack&quot; position.</p><div class="odoc-spec"><div class="spec value anchored" id="val-start"><a href="#val-start" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-start" class="source_link">Source</a><code><span><span class="keyword">val</span> start : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>start t</code> informs the lexer buffer that any code points until the current position can be discarded. The current position become the &quot;start&quot; position as returned by <code>Sedlexing.lexeme_start</code>. Moreover, the internal slot is set to <code>-1</code> and the backtrack position is set to the current position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next"><a href="#val-next" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-next" class="source_link">Source</a><code><span><span class="keyword">val</span> next : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../ocaml-base-compiler/stdlib/Stdlib/Uchar/index.html#type-t">Uchar.t</a> option</span></span></code></div><div class="spec-doc"><p><code>next lexbuf</code> extracts the next code point from the lexer buffer and increments to current position. If the input stream is exhausted, the function returns <code>None</code>. If a <code>'\n'</code> is encountered, the tracked line number is incremented.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-__private__next_int"><a href="#val-__private__next_int" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-__private__next_int" class="source_link">Source</a><code><span><span class="keyword">val</span> __private__next_int : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>__private__next_int lexbuf</code> extracts the next code point from the lexer buffer and increments to current position. If the input stream is exhausted, the function returns -1. If a <code>'\n'</code> is encountered, the tracked line number is incremented.</p><p>This is a private API, it should not be used by code using this module's API and can be removed at any time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mark"><a href="#val-mark" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-mark" class="source_link">Source</a><code><span><span class="keyword">val</span> mark : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>mark lexbuf i</code> stores the integer <code>i</code> in the internal slot. The backtrack position is set to the current position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-backtrack"><a href="#val-backtrack" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-backtrack" class="source_link">Source</a><code><span><span class="keyword">val</span> backtrack : <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>backtrack lexbuf</code> returns the value stored in the internal slot of the buffer, and performs backtracking (the current position is set to the value of the backtrack position).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_tokenizer"><a href="#val-with_tokenizer" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#val-with_tokenizer" class="source_link">Source</a><code><span><span class="keyword">val</span> with_tokenizer : 
  <span><span>(<span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'token</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-lexbuf">lexbuf</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'token</span> * <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a> * <a href="../../../ocaml-base-compiler/stdlib/Stdlib/Lexing/index.html#type-position">Lexing.position</a></span></code></div><div class="spec-doc"><p><code>with_tokenizer tokenizer lexbuf</code> given a lexer and a lexbuf, returns a generator of tokens annotated with positions. This generator can be used with the Menir parser generator's incremental API.</p></div></div><h6 id="support-for-common-encodings"><a href="#support-for-common-encodings" class="anchor"></a>Support for common encodings</h6><div class="odoc-spec"><div class="spec module anchored" id="module-Latin1"><a href="#module-Latin1" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#module-Latin1" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Latin1/index.html">Latin1</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Utf8"><a href="#module-Utf8" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#module-Utf8" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Utf8/index.html">Utf8</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Utf16"><a href="#module-Utf16" class="anchor"></a><a href="../../src/sedlex/sedlexing.ml.html#module-Utf16" class="source_link">Source</a><code><span><span class="keyword">module</span> <a href="Utf16/index.html">Utf16</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
