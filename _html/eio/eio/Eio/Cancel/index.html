<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cancel (eio.eio.Eio.Cancel)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../sherlodoc_db.js','../../../../sherlodoc.js'];
</script><script src="../../../../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../../../index.html">üè†</a> &#x00BB; <a href="../../../index.html">eio</a> &#x00BB; Library <code>eio</code> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Cancel</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Eio.Cancel</span></code><a href="../../../src/eio.core/eio__core.ml.html" class="source_link">Source</a></h1><p>Cancelling fibers.</p><p>This is the low-level interface to cancellation. Every <a href="../Switch/index.html"><code>Switch</code></a> includes a cancellation context and most users will just use that API instead.</p><p>Each domain has a tree of cancellation contexts, and every fiber is registered with one context. A fiber can switch to a different context (e.g. by calling <a href="#val-sub"><code>sub</code></a>). When a context is cancelled, all registered fibers have their current cancellation function (if any) called and removed. Child contexts are cancelled too, recursively, unless marked as protected.</p><p>Many operations also check that the current context hasn't been cancelled, so if a fiber is performing a non-cancellable operation it will still get cancelled soon afterwards. This check is typically done when starting an operation, not at the end. If an operation is cancelled after succeeding, but while still waiting on the run queue, it will still return the operation's result. A notable exception is <a href="../Fiber/index.html#val-yield"><code>Fiber.yield</code></a>, which checks at the end. You can also use <a href="../Fiber/index.html#val-check"><code>Fiber.check</code></a> to check manually.</p><p>Whether a fiber is cancelled through a cancellation function or by checking its context, it will receive a <a href="#exception-Cancelled"><code>Cancelled</code></a> exception. It is possible the exception will get lost (if something catches it and forgets to re-raise). It is also possible to get this exception even when not cancelled, for example by awaiting a promise which another fiber has resolved to a cancelled exception. When in doubt, use <code>Fiber.check ()</code> to find out if your fiber is really cancelled. Ideally this should be done any time you have caught an exception and are planning to ignore it, although if you forget then the next IO operation will typically abort anyway.</p><p>When handling a <code>Cancelled</code> exception, quick clean-up actions (such as releasing a mutex or deleting a temporary file) are OK, but operations that may block should be avoided. For example, a network connection should simply be closed, without attempting to send a goodbye message.</p><p>The purpose of the cancellation system is to stop fibers quickly, not to report errors. Use <a href="../Switch/index.html#val-fail"><code>Switch.fail</code></a> instead to record an error.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-global-toc"><ul><li><a href="../../../index.html">eio</a><ul><li>Library <code>eio</code><ul><li><a href="../index.html">Eio</a><ul><li><a href="../Std/index.html">Std</a></li><li><a href="../Switch/index.html">Switch</a></li><li><a href="../Fiber/index.html">Fiber</a></li><li><a href="#" class="current_unit">Cancel</a></li><li><a href="../Promise/index.html">Promise</a></li><li><a href="../Semaphore/index.html">Semaphore</a></li><li><a href="../Mutex/index.html">Mutex</a></li><li><a href="../Condition/index.html">Condition</a></li><li><a href="../Lazy/index.html">Lazy</a></li><li><a href="../Stream/index.html">Stream</a></li><li><a href="../Pool/index.html">Pool</a></li><li><a href="../Domain_manager/index.html">Domain_manager</a></li><li><a href="../Executor_pool/index.html">Executor_pool</a></li><li><a href="../Exn/index.html">Exn</a></li><li><a href="../Debug/index.html">Debug</a></li><li><a href="../Resource/index.html">Resource</a></li><li><a href="../Flow/index.html">Flow</a></li><li><a href="../Buf_read/index.html">Buf_read</a></li><li><a href="../Buf_write/index.html">Buf_write</a></li><li><a href="../Net/index.html">Net</a></li><li><a href="../Path/index.html">Path</a></li><li><a href="../File/index.html">File</a></li><li><a href="../Fs/index.html">Fs</a></li><li><a href="../Process/index.html">Process</a></li><li><a href="../Time/index.html">Time</a></li><li><a href="../Stdenv/index.html">Stdenv</a></li><li><a href="../Private/index.html">Private</a></li></ul></li></ul></li><li>Library <code>eio.core</code></li><li>Library <code>eio.mock</code><ul><li><a href="../../../eio.mock/Eio_mock/index.html">Eio_mock</a></li></ul></li><li>Library <code>eio.runtime_events</code><ul><li><a href="../../../eio.runtime_events/Eio_runtime_events/index.html">Eio_runtime_events</a></li></ul></li><li>Library <code>eio.unix</code><ul><li><a href="../../../eio.unix/Eio_unix/index.html">Eio_unix</a></li></ul></li><li>Library <code>eio.utils</code><ul><li><a href="../../../eio.utils/Eio_utils/index.html">Eio_utils</a></li></ul></li><li><a href="../../../src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#type-t" class="source_link">Source</a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>A cancellation context.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cancelled"><a href="#exception-Cancelled" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#exception-Cancelled" class="source_link">Source</a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cancelled</span> <span class="keyword">of</span> exn</span></code></div><div class="spec-doc"><p><code>Cancelled ex</code> indicates that the context was cancelled with exception <code>ex</code>. It is usually not necessary to report a <code>Cancelled</code> exception to the user, as the original problem will be handled elsewhere.</p><p>The nested exception is only intended for debug-level logging and should generally be ignored.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-sub" class="source_link">Source</a><code><span><span class="keyword">val</span> sub : <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>sub fn</code> installs a new cancellation context <code>t</code>, runs <code>fn t</code> inside it, and then restores the old context.</p><p>If the old context is cancelled while <code>fn</code> is running then <code>t</code> is cancelled too. <code>t</code> cannot be used after <code>sub</code> returns.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-protect"><a href="#val-protect" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-protect" class="source_link">Source</a><code><span><span class="keyword">val</span> protect : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>protect fn</code> runs <code>fn</code> in a new cancellation context that isn't cancelled when its parent is.</p><p>This can be used to clean up resources on cancellation. However, it is usually better to use <a href="../Switch/index.html#val-on_release"><code>Switch.on_release</code></a> (which calls this for you).</p><p>Note that <code>protect</code> does not check its parent context when it finishes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-check" class="source_link">Source</a><code><span><span class="keyword">val</span> check : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check t</code> checks that <code>t</code> hasn't been cancelled.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Cancelled"><code>Cancelled</code></a> <p>If the context has been cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_error"><a href="#val-get_error" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-get_error" class="source_link">Source</a><code><span><span class="keyword">val</span> get_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn option</span></span></code></div><div class="spec-doc"><p><code>get_error t</code> is like <code>check t</code> except that it returns the exception instead of raising it.</p><p>If <code>t</code> is finished, this returns (rather than raising) the <code>Invalid_argument</code> exception too.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-cancel" class="source_link">Source</a><code><span><span class="keyword">val</span> cancel : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel t ex</code> marks <code>t</code> and its child contexts as cancelled, recursively, and calls all registered fibers' cancellation functions, passing <code>Cancelled ex</code> as the argument.</p><p>All cancellation functions are run, even if some of them raise exceptions.</p><p>If <code>t</code> is already cancelled then this does nothing.</p><p>Note that the caller of this function is still responsible for handling the error somehow (e.g. reporting it to the user); it does not become the responsibility of the cancelled thread(s).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dump"><a href="#val-dump" class="anchor"></a><a href="../../../src/eio.core/cancel.ml.html#val-dump" class="source_link">Source</a><code><span><span class="keyword">val</span> dump : <span><a href="#type-t">t</a> <a href="../../../../fmt/fmt/Fmt/index.html#type-t">Fmt.t</a></span></span></code></div><div class="spec-doc"><p>Show the cancellation sub-tree rooted at <code>t</code>, for debugging.</p></div></div></div></body></html>
