<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>b00_manual (b0.b00_manual)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html">B0  <span class="version">v0.0.5</span></a> &#x00BB; B00 manual</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="b00-manual"><a href="#b00-manual" class="anchor"></a>B00 manual</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#howto">Howto model</a></li><li><a href="#design">Design considerations</a><ul><li><a href="#kernel_extract">Kernel extraction from B0</a></li><li><a href="#todo">TODO and resolve</a></li><li><a href="#rems">Handling removals</a></li><li><a href="#unpredictable_writes">Dealing with unpredictable written file paths</a></li><li><a href="#unpredictable_reads">Dealing with unpredictable read file paths</a><ul><li><a href="#gcc_m">Can we characterize precisely <code>gcc -M</code>'s input ?</a></li></ul></li><li><a href="#mutable_iter">Mutable writes and fix points</a><ul><li><a href="#clean_solution">A clean solution</a></li></ul></li></ul></li><li><a href="#design_answers">Design answers</a><ul><li><a href="#file_mode">Why arent't file permission of a read file not part of the build operation stamp ?</a></li><li><a href="#caching_failures">Why are failed operations not cached ?</a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html">B0  <span class="version">v0.0.5</span></a><ul><li><a href="#" class="current_unit">B00 manual</a></li><li><a href="cmdlet_manual.html">Cmdlet manual</a></li><li><a href="driver_dev.html">B0 driver development manual</a></li><li><a href="manual.html">B0 manual</a></li><li><a href="old_manual.html">B0 manual</a></li><li><a href="opam.html"><code>opam</code> support manual</a></li><li><a href="rationale.html">Why b0 ?</a></li><li><a href="release.html">B0 release support manual</a></li><li><a href="todo.html">Design considerations and todo</a></li><li><a href="unit_manual.html">Build unit manual</a></li><li>Library <code>b0</code><ul><li><a href="b0/B0_build/index.html">B0_build</a></li><li><a href="b0/B0_cli/index.html">B0_cli</a></li><li><a href="b0/B0_cmdlet/index.html">B0_cmdlet</a></li><li><a href="b0/B0_def/index.html">B0_def</a></li><li><a href="b0/B0_dir/index.html">B0_dir</a></li><li><a href="b0/B0_driver/index.html">B0_driver</a></li><li><a href="b0/B0_file/index.html">B0_file</a></li><li><a href="b0/B0_meta/index.html">B0_meta</a></li><li><a href="b0/B0_pack/index.html">B0_pack</a></li><li><a href="b0/B0_unit/index.html">B0_unit</a></li></ul></li><li>Library <code>b0.b0</code><ul><li><a href="b0.b0/B0_b0/index.html">B0_b0</a></li><li><a href="b0.b0/B0_cmd_build/index.html">B0_cmd_build</a></li><li><a href="b0.b0/B0_cmd_cmd/index.html">B0_cmd_cmd</a></li><li><a href="b0.b0/B0_cmd_cmdlet/index.html">B0_cmd_cmdlet</a></li><li><a href="b0.b0/B0_cmd_delete/index.html">B0_cmd_delete</a></li><li><a href="b0.b0/B0_cmd_file/index.html">B0_cmd_file</a></li><li><a href="b0.b0/B0_cmd_list/index.html">B0_cmd_list</a></li><li><a href="b0.b0/B0_cmd_log/index.html">B0_cmd_log</a></li><li><a href="b0.b0/B0_cmd_pack/index.html">B0_cmd_pack</a></li><li><a href="b0.b0/B0_cmd_root/index.html">B0_cmd_root</a></li><li><a href="b0.b0/B0_cmd_scope/index.html">B0_cmd_scope</a></li><li><a href="b0.b0/B0_cmd_unit/index.html">B0_cmd_unit</a></li><li><a href="b0.b0/B0_main/index.html">B0_main</a></li></ul></li><li>Library <code>b0.b00</code><ul><li><a href="b0.b00/B00/index.html">B00</a></li><li><a href="b0.b00/B000/index.html">B000</a></li><li><a href="b0.b00/B000_conv/index.html">B000_conv</a></li></ul></li><li>Library <code>b0.b00.kit</code><ul><li><a href="b0.b00.kit/B00_base64/index.html">B00_base64</a></li><li><a href="b0.b00.kit/B00_cli/index.html">B00_cli</a></li><li><a href="b0.b00.kit/B00_cmark/index.html">B00_cmark</a></li><li><a href="b0.b00.kit/B00_editor/index.html">B00_editor</a></li><li><a href="b0.b00.kit/B00_fexts/index.html">B00_fexts</a></li><li><a href="b0.b00.kit/B00_findex/index.html">B00_findex</a></li><li><a href="b0.b00.kit/B00_github/index.html">B00_github</a></li><li><a href="b0.b00.kit/B00_htmlg/index.html">B00_htmlg</a></li><li><a href="b0.b00.kit/B00_http/index.html">B00_http</a></li><li><a href="b0.b00.kit/B00_jsoo/index.html">B00_jsoo</a></li><li><a href="b0.b00.kit/B00_lines/index.html">B00_lines</a></li><li><a href="b0.b00.kit/B00_ocaml/index.html">B00_ocaml</a></li><li><a href="b0.b00.kit/B00_odoc/index.html">B00_odoc</a></li><li><a href="b0.b00.kit/B00_os/index.html">B00_os</a></li><li><a href="b0.b00.kit/B00_pager/index.html">B00_pager</a></li><li><a href="b0.b00.kit/B00_pdf_viewer/index.html">B00_pdf_viewer</a></li><li><a href="b0.b00.kit/B00_rsync/index.html">B00_rsync</a></li><li><a href="b0.b00.kit/B00_serialk_json/index.html">B00_serialk_json</a></li><li><a href="b0.b00.kit/B00_serialk_sexp/index.html">B00_serialk_sexp</a></li><li><a href="b0.b00.kit/B00_serialk_text/index.html">B00_serialk_text</a></li><li><a href="b0.b00.kit/B00_trace/index.html">B00_trace</a></li><li><a href="b0.b00.kit/B00_vcs/index.html">B00_vcs</a></li><li><a href="b0.b00.kit/B00_www_browser/index.html">B00_www_browser</a></li></ul></li><li>Library <code>b0.kit</code><ul><li><a href="b0.kit/B0_expect/index.html">B0_expect</a></li><li><a href="b0.kit/B0_jsoo/index.html">B0_jsoo</a></li><li><a href="b0.kit/B0_kit/index.html">B0_kit</a></li><li><a href="b0.kit/B0_ocaml/index.html">B0_ocaml</a></li><li><a href="b0.kit/B0_ocaml_eco/index.html">B0_ocaml_eco</a></li><li><a href="b0.kit/B0_opam/index.html">B0_opam</a></li><li><a href="b0.kit/B0_release/index.html">B0_release</a></li><li><a href="b0.kit/B0_srcs/index.html">B0_srcs</a></li></ul></li><li>Library <code>b0.std</code><ul><li><a href="b0.std/B0_std/index.html">B0_std</a></li></ul></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="howto"><a href="#howto" class="anchor"></a>Howto model</h2><ul><li>Start with thin build tool bindings. Model just a spawn. Make options for what allows you to model correctly the tool file outputs. (see e.g. the OCaml tool that need various bit of info to correctly model what will happen)</li></ul><h2 id="design"><a href="#design" class="anchor"></a>Design considerations</h2><h3 id="kernel_extract"><a href="#kernel_extract" class="anchor"></a>Kernel extraction from B0</h3><p>Concepts kept:</p><ul><li>Treat build operations as pure functions that affect the file system and memoize their results.</li><li>Parallelize build operations by synchronizing on the files they read and writes.</li><li>Tight control over tool lookup and build environment.</li></ul><p>Concepts dropped and to be seen how we can recover them at a higher level:</p><ul><li>Build aims for cross compilation (build/host OS distinction). This should be capturable as two separate <a href="b0.b00/B00/Memo/index.html"><code>B00.Memo</code></a>s.</li><li>Build units (named sets of build operation with metadata), <code>B000.Op.group</code> where now introduced though but they have only have UI semantics.</li><li>Build operation synchronisation, only files for now, we had unit-level. Did introduce <code>B00.Memo.Fut</code> for odig.</li><li>Build configuration.</li><li>Build unit/config definition localisation (multiple B0.ml files)</li><li>Build directory structuring</li><li>Forced clean builds. The <a href="b0.b00/B000/Trash/index.html"><code>B000.Trash</code></a> has been reintroduced now, but it can be used selectively. See also <a href="#rems" title="rems">Handling removals</a> discussion.</li><li>Build metadata, unit and file level, packages.</li></ul><h3 id="todo"><a href="#todo" class="anchor"></a>TODO and resolve</h3><ul><li>Memo.spawn redirections, consider supporting all the options of <a href="b0.std/B0_std/Os/Cmd/index.html#spawn" title="spawn">Non-blocking</a></li><li>The concept of response file in <a href="b0.b00/B00/Tool/index.html"><code>B00.Tool</code></a> should likely appear at the <a href="b0.b00/B000/Op/Spawn/index.html"><code>B000.Op.Spawn</code></a> level aswell so that we can simply have the sequence of <a href="b0.b00/B000/Op/index.html#type-t"><code>B000.Op.t</code></a> value for a potential build log (otherwise <a href="b0.b00/B000/Op/Spawn/index.html#val-args"><code>B000.Op.Spawn.args</code></a> becomes the line with the response file which is not meanigfull)</li></ul><h3 id="rems"><a href="#rems" class="anchor"></a>Handling removals</h3><p>Knowing files before the build starts doesn't fit the build model, besides removals is under the responsability of `Memo` clients (e.g. for now `odig` doesn't deal with it). The approach currently taken is the first one below. The second one could be considered but hampers correctness.</p><ol><li>Clean builds. Usually builds are performed in a dedicated directory, always delete the previous directory at the beginning of the build and restart from scratch. Deleting is slow and should not impede the build, hence the <a href="b0.b00/B00/Memo/index.html#val-trash"><code>B00.Memo.trash</code></a> that simply renames to a trash directory and the asynchronous deletion at the end of the build.</li><li>Diffing. If we know which files were generated in the previous run (easy to get from the build build log), we can remove stale artefacts after the new run has been completed (and do a clean build if you lost the info). This may however lead to incorrect builds (`-I` problems) where tool may pickup stale artefacts</li></ol><p><b>Note.</b> Somehow a good description of 1. is &quot;nix your build runs&quot;.</p><p><b>Note.</b> Now that we do longer use hard links we would have to hash. So what follows below likely becomes impractical.</p><p>A middle ground between the two could be the following. Currently we trash paths in a dedicated directory and delete it asynchronously at the end of the build as this may be slow. However we could track the renames to the path directory. When we revive from the cache to a given path one can check if the path exists in the trash with the same inode number, if it does we can rename it from there to the build rather than create a new link.</p><p>The nice thing of this approach is that at the end of the build we get in the trash exactly the things that really need to be deleted, rather than delete all the build all of the time (note that this is still more than say a `make` based build system because those overwrites paths).</p><h3 id="unpredictable_writes"><a href="#unpredictable_writes" class="anchor"></a>Dealing with unpredictable written file paths</h3><p>The system supports well tools with predictable file path writes. These tools either write to statically known file paths or allow to determine them by invoking another tool (e.g. <code>odoc {compile,html}-targets</code>). However the system should also be made to support tools with unpredictable file path writes because those are not uncommon.</p><p>A tool with predictable writes is invoked as follows:</p><pre class="language-ocaml"><code>Memo.spawn ~reads ~writes @@ tool cmd</code></pre><p>That is we know the written file paths before the tool gets to execute and we indicate them in <code>writes</code>. This serves three purposes:</p><ol><li>If the spawn is uncached, <code>writes</code> indicates the ordered list of file paths whose <em>contents</em> (output) is captured <em>after</em> the operation executed and ends up being associated to the spawn's hash (input).</li><li>If the spawn is cached, we use the spawn's hash (input) to retrieve the list of ordered file contents (outputs) and copy these to the given file paths, in order.</li><li>It allows the system to declare these files as ready to the scheduler <em>after</em> the tool executed or was revived from the cache.</li></ol><p>In the first case we don't really need the information beforehand and we can determine it after the spawn occured, just before caching, for example by scanning the file system (a <a href="b0.b00/B00/Memo/index.html#val-spawn" title="B00.Memo.spawn"><code>post_exec</code> hook</a> -- that executes after the build operation execution but before cache recording -- can be used for that). It's also quite clear the third purpose does not fundametally need the information beforehand.</p><p>However in the second case, when we want to revive the spawn, armed with the hash of the operation we retrieve the file contents, but we do not know which file paths need to be bound to the contents, since the only thing the file cache stores is an association <code>hash -&gt; contents list</code>. For tools with predictable file path writes, not mandating an actual path to bind to in the cache itself allows to revive build operations to different build paths (assuming their contents do not depend on their actual path location). This is used e.g. to share <code>.cmi</code>/<code>.cmti</code> file compilation between the doc and exec outcomes of <code>brzo</code> which happen in different build dirs or for caching in larger and larger contexts.</p><p>A tentative solution would be to produce an operation manifest. e.g. by writing some kind of <code>manifest</code> file in the <code>post_exec</code> hook with all the files that have been produced. The logic could then become something along these lines:</p><pre class="language-ocaml"><code>Memo.read manifest @@ function
| Some writes -&gt; Memo.spawn ~reads ~writes @@ tool cmd
| None -&gt;
   let post_exec o = ... (* set writes of op [o] and write [manifest] *) in
   Memo.spawn ~reads ~post_exec @@ tool cmd</code></pre><p>However this somehow assumes that <code>manifest</code> can be persisted across builds. That is not impossible to do but it is made difficult by the way <a href="#rems" title="rems">removals</a> are handled (clean builds). If we generate that file in the post execution hook it will be deleted when we come back later to rebuild, so we also need to either cache this file or store it in a build dir that is not deleted (but then we might lose the manifest info while the operation is still cached which is problematic). Another problem is that a name needs to be generated for the <code>manifest</code> file, a natural name would of course be the operation hash itself but in the above logic we need the name before the operation is specified and thus before the hash can be computed so it's a bit unfit given the way the API is currently designed.</p><p>These considerations seem to indicate that a good solution for the problem is to extend the <a href="b0.b00/B000/File_cache/index.html"><code>B000.File_cache</code></a> model to allow in some cases to also store the relative file paths associated to the file contents. That is we conceptually move from a file cache as:</p><pre class="language-ocaml"><code>key -&gt; contents list</code></pre><p>to</p><pre class="language-ocaml"><code>key -&gt; contents list * (Fpath.t list) option</code></pre><p>This leaves the current support for predictable writes (<a href="b0.b00/B000/File_cache/index.html#val-add"><code>B000.File_cache.add</code></a>, <a href="b0.b00/B000/File_cache/index.html#val-revive"><code>B000.File_cache.revive</code></a>) unchanged but allows to add the new operations:</p><pre class="language-ocaml"><code>manifest_add :
t -&gt; key -&gt; string -&gt; root:Fpath.t -&gt; Fpath.t list -&gt; (bool, string) result</code></pre><p>which stores the file contents and their corresponding paths relativised w.r.t to <code>root</code>.</p><pre class="language-ocaml"><code>manifest_revive :
t -&gt; key -&gt; root:Fpath.t -&gt; ((string * Fpath.t list) option, string) result</code></pre><p>which revives the relativised file paths by making them absolute with respect to <code>root</code>.</p><p>It is even quite simple to devise the system so that a <code>manifest_add</code> can be <a href="b0.b00/B000/File_cache/index.html#val-revive"><code>B000.File_cache.revive</code></a>d. But in general these tools with unpredictable writes the actual file names hierarchy is meanigful (e.g. hyperlinked HTML files) so it may not be that useful.</p><p>In any case these two low-level operations make it easy to add support for build operations with unpredicable writes at the higher level. Basically the support can happen at the generic <a href="b0.b00/B000/Op/index.html"><code>B000.Op</code></a> by adding a field to store an optional manifest <code>root</code>. If that field is specified the operation is handled using the new <a href="b0.b00/B000/File_cache/index.html#val-manifest_add"><code>B000.File_cache.manifest_add</code></a> or <a href="b0.b00/B000/File_cache/index.html#val-manifest_revive"><code>B000.File_cache.manifest_revive</code></a> functions above, if not we proceed as is currently the case using <a href="b0.b00/B000/File_cache/index.html#val-revive"><code>B000.File_cache.revive</code></a> and <a href="b0.b00/B000/File_cache/index.html#val-add"><code>B000.File_cache.add</code></a>.</p><h3 id="unpredictable_reads"><a href="#unpredictable_reads" class="anchor"></a>Dealing with unpredictable read file paths</h3><p>Alternate title dealing with underspecified inputs, prohibitive to characterize inputs.</p><p>The system supports well tools with predictable file path reads. These tools either read from statically known file paths or allow to determine (possibly an over-approximation of) them by invoking another dependency discovery tool (e.g. <code>odoc compile-deps</code>) or discovery logic implemented in the memo driver itself. However it may be difficult (or undecidable) to characterize which file will be read by a tool invocation or characterize precisely what influences a dependency discovery tool.</p><p>For example if we take <code>gcc -M</code> and invoke it on a c file (the output is hypothetic):</p><pre class="language-ocaml"><code>&gt; gcc -M unit.c
unit.h
/usr/include/stdio.h
/usr/include/i386/types.h</code></pre><p>In essence the above invocation reports all the recursive include files that may influence the compilation of <code>unit.c</code>. This is all nice we can do:</p><pre class="language-ocaml"><code>Memo.spawn ~reads:[&quot;unit.c&quot;] ~writes:[&quot;unit.deps&quot;] @@
gcc &quot;-M&quot; &quot;-MF&quot; &quot;unit.deps&quot; &quot;unit.c&quot;;
let incs = resolve_deps &quot;unit.deps&quot; in
Memo.spawn ~reads:(&quot;unit.c&quot; :: incs) ~writes:[&quot;unit.o&quot;] @@
gcc &quot;-c&quot; &quot;unit.c&quot;</code></pre><p>This properly checks that the cached <code>unit.o</code> is accurate but it can't check the fact that <code>unit.deps</code> is. The problem is that we only indicated that <code>&quot;unit.c&quot;</code> was influencing <code>unit.deps</code> but in fact these could change if any of files that was output in <code>unit.deps</code> changes (it's worse than that in practice, since a new file could be added in an include directory and change the result without the files of <code>unit.deps</code> actually changing but let's assume this is the case). We want to write the following <em>circular</em> definition:</p><pre class="language-ocaml"><code>let incs = resolve_deps &quot;unit.deps&quot; in
Memo.spawn ~reads:(&quot;unit.c&quot; :: incs) ~writes:[&quot;unit.deps&quot;]
@@ gcc &quot;-M&quot; &quot;-MF&quot; &quot;unit.deps&quot; &quot;unit.c&quot;</code></pre><p>and even that's not entirely accurate since the problem might be the removal of one of the files mentioned in <code>&quot;unit.deps&quot;</code>. So the spawn would wait forever on it.</p><p>With a little bit of work our function <code>resolve_deps</code> above we can be made to check that the files it mentions still exist and their state matches the one existing when <code>unit.deps</code> was produced. If the check fails then we can reinvoke:</p><pre class="language-ocaml"><code>Memo.spawn ~reads:[&quot;unit.c&quot;] ~writes:[&quot;unit.deps&quot;] @@
gcc &quot;-M&quot; &quot;-MF&quot; &quot;unit.deps&quot; &quot;unit.c&quot;;</code></pre><p>but the problem at that point is that <code>unit.c</code> itself may not have changed, so it will simply be revived from the the cache. The hash of that operation doesn't change because we cannot characterize it's input before actually running it. We need to be able to force the re-execution of this command (e.g. via <code>force_exec</code> flag given to <code>Memo.spawn</code>).</p><p>The conceptual model of <code>B0</code> relies on the fact that in most of the cases it is possible to characterize the inputs and outputs of build operations, armed with this, incremental rebuilds is just a mattter of memoizing the function <code>inputs -&gt; outputs</code>.</p><p>Now what this shows is that in some of the cases we are able to get information after the operation executed that allows us to characterize whether a build operation is up-to-date without being able to precisely or say reasonably characterize it's actual inputs.</p><p>The situation is similar to dealing with <span class="xref-unresolved" title="unpredicatable_writes">unpredicatable written file paths</span>.</p><p>A tool with predicatable reads is invoked as follows:</p><pre class="language-ocaml"><code>Memo.spawn ~reads ~writes @@ tool cmd</code></pre><p>That is we know the read file paths before the tool gets to execute and we indicate them in <code>reads</code>. This serves three purposes:</p><ul><li>First it helps the scheduler to figure out when the operation can be executed. It waits for all the <code>reads</code> to be ready to invoke th it's the <code>reads</code> we are not able to</li></ul><h4 id="gcc_m"><a href="#gcc_m" class="anchor"></a>Can we characterize precisely <code>gcc -M</code>'s input ?</h4><p>It should be possible to precisely characterize <code>gcc -M</code>'s inputs by indexing all include directories in order, hash all the data that might be looked up in these. This produced a <code>stamp</code> to be used with <code>Memp.spawn~stamp</code>.</p><h3 id="mutable_iter"><a href="#mutable_iter" class="anchor"></a>Mutable writes and fix points</h3><p>Some build procedures repeateadly mutate the same file until a condition is determined (L<sup>A</sup>T<sub>E</sub>X is a notorious example). This doesn't cope well with <code>b0</code>'s base system which assumes that build operations read and write stable files. In particular the model assumes:</p><ol><li>Once a file is written, it is <em>ready</em>.</li><li>Once a file is ready, its hash no longer changes.</li></ol><p>The first assumption is used for scheduling operations, once all the files that an operation declares to read are ready, the operation is allowed to execute. So if a file is mutated repeatedly, synchronizing operations may fire and read files that are not ready or whose state is inconsistent.</p><p>The second assumption is used internally, for example file path hashes are cached. This means that iterating a build operation that reads the same mutating file will hash the same and be revived from the cache rather than be re-executed.</p><h4 id="clean_solution"><a href="#clean_solution" class="anchor"></a>A clean solution</h4><p>An easy way to get out of this problem is to distinguish in the file read and writes declared by operations ready and unready files. Namely a build operation has ready reads, unready reads, ready writes and unready writes. With the following semantics:</p><ol><li>Unready reads are assumed to exist, they are not checked for build operation synchronization and always by-pass the hash cache. Their hash is computed at the moment an operation executes (as determined by the readyness of ready reads) and added to the operation stamp.</li><li>Unready writes are cached with the operation's output but not made ready.</li></ol><p>This was made to work in <a href="https://github.com/b0-system/b0/commit/67c5f6f23af1782ae4ba57628ebf264b559ebb95">this commit</a> which was later reverted. Internally the needed changes are quite simple, but it does complexify the API surface and makes build understanding more fiddly ‚Äì surprise, mutability is difficult. For example build logs as they are captured now do not show the finesse of mutations. At this point one should ask whether it is worth the cost of making the model less obvious to solve a case that remains an exception rather than the rule.</p><h2 id="design_answers"><a href="#design_answers" class="anchor"></a>Design answers</h2><p>A few explanation about design choices we may not remember in the future.</p><h3 id="file_mode"><a href="#file_mode" class="anchor"></a>Why arent't file permission of a read file not part of the build operation stamp ?</h3><p>It is clearly something that can influence tool outputs and failures. However so can any bit of file metadata (e.g. groups) in general and a boundary needs to be drawn. For possible wide area cache sharing scenarios it also feels better not to consider, say changes in <code>other</code> file permissions.</p><p>Related to the <a href="#caching_failures" title="caching_failures">answer</a> about caching failures.</p><h3 id="caching_failures"><a href="#caching_failures" class="anchor"></a>Why are failed operations not cached ?</h3><p>First let's define what caching build operations would likely mean. It would mean caching it's metadata bit, i.e. for tool spawns the user interface output and the exit code. Caching the actual (likely partial) file writes would be difficult to do since the actual file system state on tool error may be difficult to characterize.</p><p>Caching failed operations may report build errors more quicky for example if a build operation is slow in erroring and nothing changed as far as its operation stamp indicates.</p><p>One problem though is is that the failure may be due to a reason that is not captured by the operation stamp. In that case even though the problem may be resolved by the user, the operation stamp would not change and the operation would be revived as a failure rather than re-executed.</p><p>To give a concrete example, suppose an operation fails because of the file permissions of a file it reads. This file permission is not part of the build operation stamp (see <a href="#file_mode" title="file_mode">this answer</a>). So changing the file permission to make the build operation succeed would not only revive the old failure, but likely also output a puzzling error message unrelated to the current state of the system. The way out for the user is long head scratching ended by a clear of the cache for that operation. That doesn't feel like a great user experience.</p><p>It seems not caching failures leads to a better user experience for b0 based build systems, at least as long as <a href="#file_mode" title="file_mode">this</a> remains true. Also build failure information should be, most of the time, available in the build logs so it may not be necessary to reinvoke a long failing operation to get its error back.</p></div></body></html>
