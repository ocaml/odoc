<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>driver (ppxlib.driver)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.css"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['sherlodoc_db.js','../sherlodoc.js'];
</script><script src="../odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> ‚Äì <a href="../index.html">üè†</a> &#x00BB; <a href="index.html"><code>ppxlib</code>'s user manual</a> &#x00BB; How It Works</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Type '/' to search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><p> <div style="display: flex; justify-content:space-between"><div><a href="quick_intro.html" title="quick_intro">&lt; Introduction</a> </div><div><a href="writing-ppxs.html" title="writing-ppxs">Writing PPXs &gt;</a> </div></div></p><h1 id="how-it-works"><a href="#how-it-works" class="anchor"></a>How It Works</h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#general-concepts">General Concepts</a><ul><li><a href="#the-driver">The Driver</a><ul><li><a href="#exception_handling">Exception handling</a></li></ul></li><li><a href="#cookies">Cookies</a></li><li><a href="#integration-with-dune">Integration With Dune</a></li></ul></li><li><a href="#compat_mult_ver">Compatibility With Multiple OCaml Versions</a></li><li><a href="#derivers-and-extenders">Context-Free Transformations</a><ul><li><a href="#def_derivers">Derivers</a></li><li><a href="#def_extenders">Extenders</a></li><li><a href="#advantages">Advantages</a></li></ul></li><li><a href="#driver_execution">The Execution of the Driver</a><ul><li><a href="#the-linter-phase">The Linter Phase</a></li><li><a href="#the-preprocessing-phase">The Preprocessing Phase</a></li><li><a href="#the-first-instrumentation-phase">The First Instrumentation Phase</a></li><li><a href="#context-free-phase">The Context-Free Phase</a></li><li><a href="#global-transfo-phase">The Global Transformation Phase</a></li><li><a href="#the-last-instrumentation-phase">The Last Instrumentation Phase</a></li></ul></li></ul></nav><nav class="odoc-toc odoc-global-toc"><ul><li><a href="index.html"><code>ppxlib</code>'s user manual</a><ul><li><a href="ast-traversal.html">AST Traversals</a></li><li><a href="#" class="current_unit">How It Works</a></li><li><a href="examples.html">Examples</a></li><li><a href="generating-code.html">Generating AST Nodes</a></li><li><a href="good-practices.html">Good Practices</a></li><li><a href="matching-code.html">Destructing AST Nodes</a></li><li><a href="quick_intro.html">Introduction</a></li><li><a href="writing-ppxs.html">Writing a Transformation</a></li><li>Library <code>ppxlib</code><ul><li><a href="ppxlib/Ppxlib/index.html">Ppxlib</a></li></ul></li><li>Library <code>ppxlib.ast</code><ul><li><a href="ppxlib.ast/Ppxlib_ast/index.html">Ppxlib_ast</a></li></ul></li><li>Library <code>ppxlib.astlib</code><ul><li><a href="ppxlib.astlib/Astlib/index.html">Astlib</a></li></ul></li><li>Library <code>ppxlib.metaquot</code><ul><li><a href="ppxlib.metaquot/Ppxlib_metaquot/index.html">Ppxlib_metaquot</a></li></ul></li><li>Library <code>ppxlib.metaquot_lifters</code><ul><li><a href="ppxlib.metaquot_lifters/Ppxlib_metaquot_lifters/index.html">Ppxlib_metaquot_lifters</a></li></ul></li><li>Library <code>ppxlib.print_diff</code><ul><li><a href="ppxlib.print_diff/Ppxlib_print_diff/index.html">Ppxlib_print_diff</a></li></ul></li><li>Library <code>ppxlib.runner</code><ul><li><a href="ppxlib.runner/Ppxlib_runner/index.html">Ppxlib_runner</a></li></ul></li><li>Library <code>ppxlib.runner_as_ppx</code><ul><li><a href="ppxlib.runner_as_ppx/Ppxlib_runner_as_ppx/index.html">Ppxlib_runner_as_ppx</a></li></ul></li><li>Library <code>ppxlib.stdppx</code><ul><li><a href="ppxlib.stdppx/Stdppx/index.html">Stdppx</a></li></ul></li><li>Library <code>ppxlib.traverse</code><ul><li><a href="ppxlib.traverse/Ppxlib_traverse/index.html">Ppxlib_traverse</a></li></ul></li><li>Library <code>ppxlib.traverse_builtins</code><ul><li><a href="ppxlib.traverse_builtins/Ppxlib_traverse_builtins/index.html">Ppxlib_traverse_builtins</a></li></ul></li><li><a href="src/index.html">Sources</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="general-concepts"><a href="#general-concepts" class="anchor"></a>General Concepts</h2><h3 id="the-driver"><a href="#the-driver" class="anchor"></a>The Driver</h3><p><code>ppxlib</code> sits in between the PPXs authors and the compiler toolchain. For the PPX author, it provides an API to define the transformation and register it to <code>ppxlib</code>. Then, all registered transformations can be turned into a single executable, called the <em>driver</em>, that is responsible for applying all the transformations. The driver will be called by the compiler.</p><p>The PPX authors register their transformations using the <a href="ppxlib/Ppxlib/Driver/index.html#val-register_transformation" title="Ppxlib.Driver.register_transformation"><code>Driver.register_transformation</code></a> function, as explained in the <a href="writing-ppxs.html" title="writing-ppxs">Writing PPXs</a> section. The different arguments of this function corresponds to the <a href="#derivers-and-extenders" title="derivers-and-extenders">different kinds</a> of PPXs supported by <code>ppxlib</code> or the <a href="#driver_execution" title="driver_execution">phase</a>, at which time they will be executed.</p><p>The driver is created by calling either <a href="ppxlib/Ppxlib/Driver/index.html#val-standalone" title="Ppxlib.Driver.standalone"><code>Driver.standalone</code></a> or <a href="ppxlib/Ppxlib/Driver/index.html#val-run_as_ppx_rewriter" title="Ppxlib.Driver.run_as_ppx_rewriter"><code>Driver.run_as_ppx_rewriter</code></a>. Note that when used through Dune, none of these functions will need to be called by the PPX author. As we will see, Dune will be responsible for generating the driver after all required PPXs from different libraries have been registered. These functions will interpret the command line arguments and start the rewriting accordingly.</p><p>The <a href="ppxlib/Ppxlib/Driver/index.html#val-standalone" title="Ppxlib.Driver.standalone"><code>Driver.standalone</code></a> function creates an executable that parses an OCaml file, transforms it according to the registered transformations, and outputs the transformed file. This makes it suitable for use with the <code>-pp</code> <a href="https://v2.ocaml.org/releases/5.0/htmlman/comp.html#s:comp-options">option</a> of the OCaml compiler. It is a preprocessor for sources and is standalone in the sense that it can be called independently from the OCaml compiler (e.g., it includes an OCaml parser).</p><p>On the other hand, the <a href="ppxlib/Ppxlib/Driver/index.html#val-run_as_ppx_rewriter" title="Ppxlib.Driver.run_as_ppx_rewriter"><code>Driver.run_as_ppx_rewriter</code></a>-generated driver is a proper PPX, as it will read and output a <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> marshalled value directly. This version is suitable for use with the <code>-ppx</code> <a href="https://v2.ocaml.org/releases/5.0/htmlman/comp.html#s:comp-options">option</a> of the OCaml compiler, as well as any tool that requires control of parsing the file. For instance, <a href="https://ocaml.github.io/merlin/">Merlin</a> includes an OCaml parser that tries hard to recover from errors in order to generate a valid AST most of the time.</p><p>Several arguments can be passed to the driver when executing it. Those arguments can also be easily passed using Dune, as explained in its <a href="https://dune.readthedocs.io/en/stable/concepts.html#preprocessing-with-ppx-rewriters">manual</a>. PPX authors can add arguments to their generated drivers using <a href="ppxlib/Ppxlib/Driver/index.html#val-add_arg" title="Ppxlib.Driver.add_arg"><code>Driver.add_arg</code></a>. Here are the default arguments for respectively <a href="ppxlib/Ppxlib/Driver/index.html#val-standalone" title="Ppxlib.Driver.standalone"><code>standalone</code></a> and <a href="ppxlib/Ppxlib/Driver/index.html#val-run_as_ppx_rewriter" title="Ppxlib.Driver.run_as_ppx_rewriter"><code>run_as_ppx_rewriter</code></a> generated drivers:</p> <details><summary>Standalone driver</summary><pre>driver.exe [extra_args] [&lt;files&gt;]
  -as-ppx                     Run as a -ppx rewriter (must be the first argument)
  --as-ppx                    Same as -as-ppx
  -as-pp                      Shorthand for: -dump-ast -embed-errors
  --as-pp                     Same as -as-pp
  -o &lt;filename&gt;               Output file (use '-' for stdout)
  -                           Read input from stdin
  -dump-ast                   Dump the marshaled ast to the output file instead of pretty-printing it
  --dump-ast                  Same as -dump-ast
  -dparsetree                 Print the parsetree (same as ocamlc -dparsetree)
  -embed-errors               Embed errors in the output AST (default: true when -dump-ast, false otherwise)
  -null                       Produce no output, except for errors
  -impl &lt;file&gt;                Treat the input as a .ml file
  --impl &lt;file&gt;               Same as -impl
  -intf &lt;file&gt;                Treat the input as a .mli file
  --intf &lt;file&gt;               Same as -intf
  -debug-attribute-drop       Debug attribute dropping
  -print-transformations      Print linked-in code transformations, in the order they are applied
  -print-passes               Print the actual passes over the whole AST in the order they are applied
  -ite-check                  (no effect -- kept for compatibility)
  -pp &lt;command&gt;               Pipe sources through preprocessor &lt;command&gt; (incompatible with -as-ppx)
  -reconcile                  (WIP) Pretty print the output using a mix of the input source and the generated code
  -reconcile-with-comments    (WIP) same as -reconcile but uses comments to enclose the generated code
  -no-color                   Don't use colors when printing errors
  -diff-cmd                   Diff command when using code expectations (use - to disable diffing)
  -pretty                     Instruct code generators to improve the prettiness of the generated code
  -styler                     Code styler
  -output-metadata FILE       Where to store the output metadata
  -corrected-suffix SUFFIX    Suffix to append to corrected files
  -loc-filename &lt;string&gt;      File name to use in locations
  -reserve-namespace &lt;string&gt; Mark the given namespace as reserved
  -no-check                   Disable checks (unsafe)
  -check                      Enable checks
  -no-check-on-extensions     Disable checks on extension point only
  -check-on-extensions        Enable checks on extension point only
  -no-locations-check         Disable locations check only
  -locations-check            Enable locations check only
  -apply &lt;names&gt;              Apply these transformations in order (comma-separated list)
  -dont-apply &lt;names&gt;         Exclude these transformations
  -no-merge                   Do not merge context free transformations (better for debugging rewriters). As a result, the context-free transformations are not all applied before all impl and intf.
  -cookie NAME=EXPR           Set the cookie NAME to EXPR
  --cookie                    Same as -cookie
  -deriving-keep-w32 {impl|intf|both}
                               Do not try to disable warning 32 for the generated code
  -deriving-disable-w32-method {code|attribute}
                               How to disable warning 32 for the generated code
  -type-conv-keep-w32 {impl|intf|both}
                               Deprecated, use -deriving-keep-w32
  -type-conv-w32 {code|attribute}
                               Deprecated, use -deriving-disable-w32-method
  -deriving-keep-w60 {impl|intf|both}
                               Do not try to disable warning 60 for the generated code
  -unused-code-warnings {true|false|force}
                               Allow ppx derivers to enable unused code warnings (default: false)
  -unused-type-warnings {true|false|force}
                               Allow unused type warnings for types with [@@deriving ...] (default: false)
  -help                        Display this list of options
  --help                       Display this list of options</pre> </details><p>and</p> <details><summary>Ppx rewriter driver</summary><pre>driver.exe [extra_args] &lt;infile&gt; &lt;outfile&gt;
  -loc-filename &lt;string&gt;      File name to use in locations
  -reserve-namespace &lt;string&gt; Mark the given namespace as reserved
  -no-check                   Disable checks (unsafe)
  -check                      Enable checks
  -no-check-on-extensions     Disable checks on extension point only
  -check-on-extensions        Enable checks on extension point only
  -no-locations-check         Disable locations check only
  -locations-check            Enable locations check only
  -apply &lt;names&gt;              Apply these transformations in order (comma-separated list)
  -dont-apply &lt;names&gt;         Exclude these transformations
  -no-merge                   Do not merge context free transformations (better for debugging rewriters). As a result, the context-free transformations are not all applied before all impl and intf.
  -cookie NAME=EXPR           Set the cookie NAME to EXPR
  --cookie                    Same as -cookie
  -help                       Display this list of options
  --help                      Display this list of options</pre> </details><h4 id="exception_handling"><a href="#exception_handling" class="anchor"></a>Exception handling</h4><p>In general, raising an exception in a registered transformation will make the ppxlib driver crash with an uncaught exception error. However, when spawned with the <code>-embed-errors</code> or <code>-as-ppx</code> flags (that's the case when Merlin calls the driver) the ppxlib driver still handles a specific kind of exception: Located exceptions. They have type <a href="ppxlib/Ppxlib/Location/index.html#exception-Error" title="Ppxlib.Location.Error"><code>Location.Error</code></a> and contain enough information to display a located error message.</p><p>During its <a href="#driver_execution" title="driver_execution">execution</a>, the driver will run many different rewriters. In the case described above, it will catch any located exception thrown by a rewriter. When catching an exception, it will collect the error in a list, take the last valid AST (the one that was given to the raising rewriter) and continue its execution from there.</p><p>At the end of the rewriting process, the driver will prepend all collected errors to the beginning of the AST, in the order in which they appeared.</p><p>The same mechanism applies for the <a href="#derivers-and-extenders" title="derivers-and-extenders">context-free rewriters</a>: if any of them raises, the error is collected, the part of the AST that the rewriter was responsible to rewrite remains unmodified, and the <a href="#context-free-phase" title="context-free-phase">context-free phase</a> continues.</p><h3 id="cookies"><a href="#cookies" class="anchor"></a>Cookies</h3><p>Cookies are values that are passed to the driver via the command line, or set as side effects of transformations, which can be accessed by the transformations. They have a name to identify them and a value consisting of an OCaml expression. The module to access cookies is <a href="ppxlib/Ppxlib/Driver/Cookies/index.html" title="Ppxlib.Driver.Cookies"><code>Driver.Cookies</code></a>.</p><h3 id="integration-with-dune"><a href="#integration-with-dune" class="anchor"></a>Integration With Dune</h3><p>The <a href="https://dune.build">Dune</a> build system is well integrated with the <code>ppxlib</code> mechanism of registering transformations. In every <code>dune</code> file, Dune will read the set of PPXs that are to be used (i.e. the PPXs in `(preprocess (pps &lt;list of PPXs that are to be used&gt;))`). For a given set of rewriters, it will generate a driver using <a href="ppxlib/Ppxlib/Driver/index.html#val-run_as_ppx_rewriter" title="Ppxlib.Driver.run_as_ppx_rewriter"><code>Driver.run_as_ppx_rewriter</code></a> that contains all registered transformations. Using a single driver for multiple transformations from multiple PPXs ensures better composition semantics and improves the speed of the combined transformations. Moreover, <code>ppxlib</code> communicates with Dune through <code>.corrected</code> files to allow for promotion, for instance when using <a href="writing-ppxs.html#inlining-transformations" title="inlining-transformations"><code>[@@deriving_inline]</code></a>. A PPX author can also generate its own promotion suggestion using the <a href="ppxlib/Ppxlib/Driver/index.html#val-register_correction" title="Ppxlib.Driver.register_correction"><code>Driver.register_correction</code></a> function.</p><h2 id="compat_mult_ver"><a href="#compat_mult_ver" class="anchor"></a>Compatibility With Multiple OCaml Versions</h2><p>One of the important issues with working with the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> is that the API is not stable. For instance, in the <a href="https://ocaml.org/releases/4.13.0">OCaml 4.13 release</a>, the following <a href="https://github.com/ocaml/ocaml/pull/9584/files#diff-ebecf307cba2d756cc28f0ec614dfc57d3adc6946eb4faa9825eb25a92b2596d">two</a> <a href="https://github.com/ocaml/ocaml/pull/10133/files#diff-ebecf307cba2d756cc28f0ec614dfc57d3adc6946eb4faa9825eb25a92b2596d">changes</a> were made to the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> type. Although they are small changes, they may break any PPX that is written to directly manipulate the (evolving) type.</p><p>This instability causes an issue with maintenance. PPX authors wish to maintain a single version of their PPX, not one per OCaml version, and ideally not have to update their code when an irrelevant (for them) field is changed in the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a>.</p><p><code>ppxlib</code> helps to solve both issues. The first one, having to maintain a single PPX version working for every OCaml version, is done by migrating the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a>. The PPX author only maintains a version working with the latest version, and the <code>ppxlib</code> driver will convert the values from one version to another.</p><p>For example, say a deriver is applied in the context of OCaml 4.08. After the 4.08 <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> has been given to it, the <code>ppxlib</code> driver will migrate this value into the latest <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> version, using the <a href="ppxlib.astlib/Astlib/index.html"><code>Astlib</code></a> module. The &quot;latest&quot; here depends on the version of <code>ppxlib</code>, but at any given time, the latest released version of <code>ppxlib</code> will always use the latest released version of the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a>.</p><p>After the migration to the latest <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a>, the driver runs all transformations on it, which ends with a rewritten <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> of the latest version. However, since the context of rewriting is OCaml 4.08 (in this example), the driver needs to migrate back the rewritten <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a> to an OCaml 4.08 version. Again, <code>ppxlib</code> uses the <a href="ppxlib.astlib/Astlib/index.html"><code>Astlib</code></a> module for this migration. Once the driver has rewritten the AST for OCaml 4.08, the compilation can continue as usual.</p><h2 id="derivers-and-extenders"><a href="#derivers-and-extenders" class="anchor"></a>Context-Free Transformations</h2><p><code>ppxlib</code> defines several kinds of transformations whose core property is that they can only read and modify the code locally. The parts of the AST given to the transformation are only portions of the whole AST. In this regard, they are usually called <em>context-free</em> transformations. While being not as general-purpose as plain AST transformations, they are more than often sufficient and have many nice properties such as a well-defined semantics for composition. The two most important context-free transformations are <em>derivers</em> and <em>extenders</em>.</p><h3 id="def_derivers"><a href="#def_derivers" class="anchor"></a>Derivers</h3><p>A <em>deriver</em> is a context-free transformation that, given a certain structure or signature item, will generate code <em>to append after</em> this item. The given code is never modified. A deriver can be very useful to generate values depending on the structure of a user-defined type, for instance a converter for a type to and from a JSON value. A deriver is triggered by adding an <a href="https://v2.ocaml.org/manual/attributes.html">attribute</a> to a structure or signature item. For instance, the folowing code:</p><pre class="language-ocaml"><code>type t = Int of int | Float of float [@@deriving yojson]

let x = ...</code></pre><p>would be rewritten to:</p><pre class="language-ocaml"><code>type ty = Int of int | Float of float [@@deriving yojson]

let ty_of_yojson = ...
let ty_to_yojson = ...

let x = ...</code></pre><h3 id="def_extenders"><a href="#def_extenders" class="anchor"></a>Extenders</h3><p>An <em>extender</em> is a context-free transformation that is triggered on <a href="https://v2.ocaml.org/manual/extensionnodes.html">extension nodes</a>, and that will replace the extension node by some code generated from the extension node's payload. This can be very useful to generate values of a DSL using a more user-friendly syntax, e.g., to generate OCaml values from the JSON syntax.</p><p>For instance, the following code:</p><pre class="language-ocaml"><code>let json =
  [%yojson
    [ { name = &quot;Anne&quot;; grades = [&quot;A&quot;; &quot;B-&quot;; &quot;B+&quot;] }
    ; { name = &quot;Bernard&quot;; grades = [&quot;B+&quot;; &quot;A&quot;; &quot;B-&quot;] }
    ]
  ]</code></pre><p>could be rewritten into:</p><pre class="language-ocaml"><code>let json =
  `List
    [ `Assoc
        [ (&quot;name&quot;, `String &quot;Anne&quot;)
        ; (&quot;grades&quot;, `List [`String &quot;A&quot;; `String &quot;B-&quot;; `String &quot;B+&quot;])
        ]
    ; `Assoc
        [ (&quot;name&quot;, `String &quot;Bernard&quot;)
        ; (&quot;grades&quot;, `List [`String &quot;B+&quot;; `String &quot;A&quot;; `String &quot;B-&quot;])
        ]
    ]</code></pre><h3 id="advantages"><a href="#advantages" class="anchor"></a>Advantages</h3><p>There are multiple advantages of using context-free transformations. First, they provide the PPX user a much clearer understanding of the AST parts that will be rewritten, rather than a fully general AST rewriting. Secondly, they provide a much better composition semantic, which does not depend on the order. Finally, context-free transformations are applied in a single phase factorising the work for all transformations, resulting in a much faster driver than when combining multiple, whole AST transformations. More details on the execution of this phase are given in its <a href="#context-free-phase" title="context-free-phase">dedicated section.</a></p><p>See the <a href="writing-ppxs.html" title="writing-ppxs">Writing PPXs</a> section for how to define derivers and extenders.</p><h2 id="driver_execution"><a href="#driver_execution" class="anchor"></a>The Execution of the Driver</h2><p>The actual rewriting of the AST is done in multiple phases:</p><ol><li>The linting phase</li><li>The preprocessing phase</li><li>The first instrumentation phase</li><li>The context-free phase</li><li>The global transformation phase</li><li>The last instrumentation phase</li></ol><p>When registering a transformation through the <a href="ppxlib/Ppxlib/Driver/index.html#val-register_transformation" title="Ppxlib.Driver.register_transformation"><code>Driver.register_transformation</code></a> function, the phase in which the transformation has to be applied is specified. The multiplicity of phases is mostly to account for potential constraints on the execution order. However, most of the time there are no such constraints, and in this case, either the <a href="#context-free-phase" title="context-free-phase">context-free</a> or the <a href="#global-transfo-phase" title="global-transfo-phase">global transformation phase</a> should be used. (Note that whenever possible, which should be almost always, context-free transformations are possible and better.) If you register in another phase, be sure to know what you are doing.</p><h3 id="the-linter-phase"><a href="#the-linter-phase" class="anchor"></a>The Linter Phase</h3><p>Linters are preprocessors that take as input the whole AST and output a list of &quot;lint&quot; errors. Such an error is of type <a href="ppxlib/Ppxlib/Driver/Lint_error/index.html#type-t" title="Ppxlib.Driver.Lint_error.t"><code>Driver.Lint_error.t</code></a> and includes a string (the error message) and the location of the error. The errors will be reported as preprocessors warnings.</p><p>This is the first phase, so linting errors can only be reported for code handwritten by the user.</p><p>An example of a PPX registered in this phase is <a href="https://github.com/janestreet/ppx_js_style">ppx_js_style</a>.</p><h3 id="the-preprocessing-phase"><a href="#the-preprocessing-phase" class="anchor"></a>The Preprocessing Phase</h3><p>The preprocessing phase is the first transformation that actually alters the AST. In fact, the property of being the &quot;first transformation applied&quot; is what defines this phase, and <code>ppxlib</code> will thus ensure that only one transformation is registered in this phase; otherwise, it will generate an error.</p><p>You should only register a transformation in this phase if it is really strongly necessary, and you know what you are doing. Your PPX will not be usable at the same time as another one registering a transformation in this phase.</p><p>An example of a PPX registered in this phase is <a href="https://github.com/thierry-martinez/metapp">metapp</a>.</p><h3 id="the-first-instrumentation-phase"><a href="#the-first-instrumentation-phase" class="anchor"></a>The First Instrumentation Phase</h3><p>This phase is for transformations that <em>need</em> to be run before the context-free phase. Historically, it was meant for <a href="https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)">instrumentation</a>-related PPXs, hence the name. Unlike the <a href="#the-preprocessing-phase" title="the-preprocessing-phase">preprocessing phase</a>, registering to this phase provides no guarantee that the transformation is run early in the rewriting, as there is no limit in the number of transformations registered in this phase, which are then applied in the alphabetical order by their name.</p><p>If it is not crucial for a transformation to run before the context-free phase, it should be registered to the <a href="#global-transfo-phase" title="global-transfo-phase">global transformation phase</a>.</p><h3 id="context-free-phase"><a href="#context-free-phase" class="anchor"></a>The Context-Free Phase</h3><p>The execution of all registered context-free rules is done in a single top-down pass through the AST. Whenever the top-down pass encounters a situation that triggers rewriting, the corresponding transformation is called. For instance, when encountering an extension point corresponding to a rewriting rule, the extension point is replaced by the rule's execution, and the top-down pass continues inside the generated code. Similarly, when a deriving attribute is found attached to a structure or signature item, the result of the deriving rule‚Äôs application is appended to the AST, and the top-down pass continues in the generated code.</p><p>Note that the code generation for derivers is applied when &quot;leaving&quot; the AST node, that is when all rewriters have been run. Indeed, a deriver like this:</p><pre class="language-ocaml"><code>type t = [%my_type] [@@deriving deriver_from_type]</code></pre><p>would need the information generated by the <code>my_type</code> extender to match on the structure of <code>t</code>.</p><p>Also note that in this phase, the execution of the context-free rules are intertwined altogether, and it would not make sense to speak about the order of application, contrary to the next phase.</p><h3 id="global-transfo-phase"><a href="#global-transfo-phase" class="anchor"></a>The Global Transformation Phase</h3><p>The global transformation phase is the phase where registered transformations, seen as function from and to the <a href="ppxlib.astlib/Astlib/Ast_500/Parsetree/index.html" title="Ppxlib.Parsetree"><code>Parsetree</code></a>, are run. The applied order might matter and change the outcome, but since <code>ppxlib</code> knows nothing about the transformations, the order applied is alphabetical by the transformation's name.</p><h3 id="the-last-instrumentation-phase"><a href="#the-last-instrumentation-phase" class="anchor"></a>The Last Instrumentation Phase</h3><p>This phase is for global transformation to escape the alphabetical order and be executed as a last phase. For instance, <a href="https://github.com/aantron/bisect_ppx"><code>bisect_ppx</code></a> needs to be executed after all rewriting has occurred.</p><p>Note that only one global transformation can be executed last. If several transformations rely on being the last transformation, it will be true for only one of them. Thus, only register your transformation in this phase if it is absolutely vital to be the last transformation, as your PPX will become incompatible with any other that registers a transformation during this phase.</p><p> <div style="display: flex; justify-content:space-between"><div><a href="quick_intro.html" title="quick_intro">&lt; Introduction</a> </div><div><a href="writing-ppxs.html" title="writing-ppxs">Writing PPXs &gt;</a> </div></div></p></div></body></html>
